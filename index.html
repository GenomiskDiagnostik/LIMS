<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Augmented Pedigree Builder</title>
  <!--
    MIT License
    Copyright (c) 2024

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

    Augmented Pedigree Builder – Single-page vanilla JS + D3 v7 app for crafting
    interactive genetic pedigrees with autosave/autoload, File System Access API
    integration, weighted relationships, and export utilities.
  -->
  <style>
    :root {
      color-scheme: dark;
      --bg: #101217;
      --panel: #161a22;
      --border: #2a3140;
      --accent: #4ea0f5;
      --accent-weak: #2e6bba;
      --danger: #f06292;
      --success: #6dd17c;
      --text: #e4e7ee;
      --muted: #a4a9b7;
      --font: 'Segoe UI', system-ui, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background: radial-gradient(circle at top right, #182030, var(--bg) 45%);
      color: var(--text);
      display: grid;
      grid-template-columns: 320px 1fr;
      grid-template-rows: auto 1fr auto;
      grid-template-areas:
        "header header"
        "sidebar main"
        "footer footer";
      height: 100vh;
      overflow: hidden;
    }

    header {
      grid-area: header;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(16, 18, 23, 0.9);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      z-index: 5;
    }

    header h1 {
      margin: 0;
      font-size: 1.2rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .badges {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      font-size: 0.7rem;
      text-transform: uppercase;
    }

    .badge {
      padding: 0.15rem 0.45rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(40, 60, 90, 0.35);
      color: var(--muted);
    }

    .controls-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .controls-row button,
    .controls-row select,
    .controls-row input[type="range"] {
      margin: 0;
    }

    aside {
      grid-area: sidebar;
      overflow-y: auto;
      border-right: 1px solid var(--border);
      padding: 1rem;
      background: linear-gradient(180deg, rgba(20, 24, 32, 0.9), rgba(16, 18, 23, 0.95));
    }

    aside h2 {
      font-size: 0.95rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.6rem;
    }

    input,
    select,
    textarea,
    button {
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: rgba(22, 24, 32, 0.8);
      color: var(--text);
      padding: 0.45rem 0.6rem;
      font: inherit;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    input:focus,
    select:focus,
    textarea:focus,
    button:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(78, 160, 245, 0.3);
    }

    button {
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    button.primary {
      background: linear-gradient(120deg, var(--accent), #7ab8ff);
      color: #050608;
      border: none;
    }

    button.danger {
      background: linear-gradient(120deg, #ec4a78, #ff758f);
      border: none;
      color: #fff;
    }

    button.secondary {
      background: rgba(28, 32, 45, 0.9);
      border-color: var(--border);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    textarea {
      resize: vertical;
      min-height: 80px;
    }

    main {
      grid-area: main;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #graph-wrapper {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at center, rgba(32, 38, 52, 0.3), rgba(16, 18, 23, 0.9));
    }

    svg {
      width: 100%;
      height: 100%;
    }

    #legend {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      background: rgba(16, 18, 23, 0.85);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      line-height: 1.4;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }

    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.85);
      padding: 0.4rem 0.6rem;
      border-radius: 0.4rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 0.75rem;
      max-width: 260px;
      line-height: 1.4;
      opacity: 0;
      transform: translate(-50%, -120%);
      transition: opacity 0.15s ease;
      z-index: 10;
    }

    footer {
      grid-area: footer;
      padding: 0.6rem 1rem;
      border-top: 1px solid var(--border);
      background: rgba(16, 18, 23, 0.9);
      font-size: 0.75rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: rgba(78, 160, 245, 0.15);
      border: 1px solid rgba(78, 160, 245, 0.35);
      font-size: 0.75rem;
    }

    .status-pill.dirty {
      background: rgba(236, 74, 120, 0.15);
      border-color: rgba(236, 74, 120, 0.35);
    }

    .status-message {
      margin-top: 0.5rem;
      font-size: 0.75rem;
      color: var(--muted);
      min-height: 1.2rem;
    }

    .inline-inputs {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 0.5rem;
    }

    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }

    .hint {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .flex {
      display: flex;
      gap: 0.5rem;
    }

    .flex.column {
      flex-direction: column;
    }

    .nowrap {
      white-space: nowrap;
    }

    .status-ok {
      color: var(--success);
    }

    .status-warn {
      color: var(--danger);
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 1rem 0;
    }

    @media (max-width: 1080px) {
      body {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto;
        grid-template-areas:
          "header"
          "sidebar"
          "main"
          "footer";
        height: auto;
      }

      aside {
        max-height: 300px;
      }
    }
  </style>
  <!-- TODO: For offline deployments bundle d3.v7 locally and inline via <script> tag. -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>
<body>
  <header>
    <h1>Augmented Pedigree Builder</h1>
    <div class="controls-row">
      <div class="badges">
        <span class="badge">D3 Interactive</span>
        <span class="badge">Autosave</span>
        <span class="badge">Backup/Restore</span>
      </div>
      <div class="controls-row">
        <label class="hint nowrap">Zoom
          <input type="range" id="zoom-slider" min="0.2" max="2" step="0.05" value="1" />
        </label>
        <button class="secondary" id="fit-btn">Fit</button>
        <select id="layout-select">
          <option value="force">Force Layout</option>
          <option value="tree">Tree Layout</option>
        </select>
      </div>
    </div>
  </header>

  <aside>
    <section>
      <h2>File &amp; Database</h2>
      <div class="flex column">
        <button id="choose-file" class="primary">Choose/Recreate DB file</button>
        <button id="reset-local" class="danger">Reset local storage</button>
        <button id="backup" class="secondary">Backup → download .json</button>
        <label>Restore from .json
          <input type="file" id="restore" accept="application/json" />
        </label>
        <span id="file-status" class="hint">Idle</span>
      </div>
    </section>

    <section>
      <h2>Person</h2>
      <form id="person-form">
        <label>ID (auto if blank)
          <input id="person-id" list="person-ids" autocomplete="off" />
          <datalist id="person-ids"></datalist>
        </label>
        <label>Name
          <input id="person-name" required />
        </label>
        <div class="inline-inputs">
          <label>Sex
            <select id="person-sex">
              <option value="U">Unknown</option>
              <option value="F">Female</option>
              <option value="M">Male</option>
            </select>
          </label>
          <label>Birth
            <input id="person-birth" type="number" />
          </label>
          <label>Death
            <input id="person-death" type="number" />
          </label>
        </div>
        <label>Notes
          <textarea id="person-notes" placeholder="Observations, health notes, etc."></textarea>
        </label>
        <div class="flex">
          <button type="submit" class="primary">Add / Update</button>
          <button type="button" id="person-delete" class="danger">Delete</button>
        </div>
      </form>
    </section>

    <section>
      <h2>Parent → Child</h2>
      <div class="inline-inputs">
        <label>Parent ID
          <input id="parent-id" list="person-ids" />
        </label>
        <label>Child ID
          <input id="child-id" list="person-ids" />
        </label>
      </div>
      <div class="flex">
        <button id="add-parent" class="secondary">Add</button>
        <button id="del-parent" class="danger">Delete</button>
      </div>
    </section>

    <section>
      <h2>Partner A ↔ B</h2>
      <div class="inline-inputs">
        <label>Partner A ID
          <input id="partner-a" list="person-ids" />
        </label>
        <label>Partner B ID
          <input id="partner-b" list="person-ids" />
        </label>
      </div>
      <div class="flex">
        <button id="add-partner" class="secondary">Add</button>
        <button id="del-partner" class="danger">Delete</button>
      </div>
    </section>

    <section>
      <h2>Weighted Relations</h2>
      <div class="inline-inputs">
        <label>A ID
          <input id="weighted-a" list="person-ids" />
        </label>
        <label>B ID
          <input id="weighted-b" list="person-ids" />
        </label>
        <label>Weight
          <input id="weighted-value" type="number" min="0" max="100" value="50" />
        </label>
      </div>
      <label>Label
        <input id="weighted-label" />
      </label>
      <div class="flex">
        <button id="add-weighted" class="secondary">Add</button>
        <button id="del-weighted" class="danger">Delete</button>
      </div>
    </section>

    <section>
      <h2>View Options</h2>
      <label>Tree root ID
        <input id="root-id" list="person-ids" />
      </label>
      <div class="flex">
        <button id="apply-root" class="secondary">Apply</button>
        <button id="clear-root" class="secondary">Clear</button>
      </div>
      <label>
        <input type="checkbox" id="toggle-labels" checked /> Show labels
      </label>
      <label>
        <input type="checkbox" id="toggle-drag" checked /> Enable drag
      </label>
    </section>

    <section>
      <h2>Quick Actions</h2>
      <div class="flex column">
        <button id="seed-example" class="secondary">Seed Example</button>
        <button id="export-png" class="secondary">Export PNG</button>
      </div>
    </section>

    <section>
      <h2>Status</h2>
      <div id="status-pill" class="status-pill">Synced</div>
      <div class="status-message" id="status-message">Ready.</div>
    </section>
  </aside>

  <main>
    <div id="graph-wrapper">
      <svg id="graph" viewBox="0 0 1000 800"></svg>
      <div id="legend">
        <strong>Legend</strong>
        <div>■ Male &nbsp; ● Female &nbsp; ◆ Unknown</div>
        <div>— Parent → Child (arrow)</div>
        <div>⋯ Partner link</div>
        <div>══ Weighted (thickness ↔ strength)</div>
      </div>
      <div id="tooltip"></div>
    </div>
  </main>

  <footer>
    <div>Shortcuts: <strong>Ctrl/Cmd + S</strong> save · Scroll to zoom · Drag background to pan</div>
    <div id="footer-sync" class="hint">Dirty state: <span id="dirty-flag">clean</span></div>
  </footer>

  <script>
    /* global d3 */
    // ------------------------------
    // State management
    // ------------------------------
    const defaultState = () => ({
      persons: {},
      rel: {
        parent: [],
        partner: [],
        weighted: []
      },
      view: {
        layout: 'force',
        rootId: null,
        showLabels: true,
        drag: true,
        zoom: 1
      },
      meta: {
        lastSaved: null,
        fileHandle: null
      },
      _dirty: false
    });

    let state = defaultState();
    let idbHandle = null;
    let saveTimeout = null;
    let nodePositions = new Map();
    let zoomBehavior = null;
    let svgSelection = null;
    let tooltip = null;

    const DB_NAME = 'augPedDB';
    const DB_STORE = 'kv';
    const DB_KEY_STATE = 'data';
    const DB_KEY_FILE = 'fileHandle';

    function byId(id) {
      return document.getElementById(id);
    }

    function escapeHtml(str = '') {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function setDirty(flag = true) {
      state._dirty = flag;
      byId('dirty-flag').textContent = flag ? 'dirty' : 'clean';
      const pill = byId('status-pill');
      if (flag) {
        pill.textContent = 'Unsaved';
        pill.classList.add('dirty');
      } else {
        pill.textContent = 'Synced';
        pill.classList.remove('dirty');
      }
      if (typeof updateFooter === 'function') {
        updateFooter();
      }
    }

    function flashStatus(msg, type = 'info') {
      const el = byId('status-message');
      el.textContent = msg;
      el.classList.toggle('status-ok', type === 'success');
      el.classList.toggle('status-warn', type === 'warn');
    }

    function refreshPersonDatalist() {
      const datalist = byId('person-ids');
      datalist.innerHTML = '';
      Object.keys(state.persons).forEach((id) => {
        const opt = document.createElement('option');
        opt.value = id;
        opt.label = state.persons[id].name || id;
        datalist.appendChild(opt);
      });
    }

    function populatePersonForm(person) {
      if (!person) return;
      byId('person-id').value = person.id;
      byId('person-name').value = person.name || '';
      byId('person-sex').value = person.sex || 'U';
      byId('person-birth').value = person.birth ?? '';
      byId('person-death').value = person.death ?? '';
      byId('person-notes').value = person.notes || '';
    }

    function generatePersonId() {
      let idx = Object.keys(state.persons).length + 1;
      let candidate;
      do {
        candidate = `P${idx++}`;
      } while (state.persons[candidate]);
      return candidate;
    }

    function upsertPerson(evt) {
      evt.preventDefault();
      const id = (byId('person-id').value || '').trim() || generatePersonId();
      const person = {
        id,
        name: (byId('person-name').value || '').trim() || 'Unnamed',
        sex: byId('person-sex').value || 'U',
        birth: byId('person-birth').value ? Number(byId('person-birth').value) : undefined,
        death: byId('person-death').value ? Number(byId('person-death').value) : undefined,
        notes: (byId('person-notes').value || '').trim() || undefined
      };
      state.persons[id] = person;
      populatePersonForm(person);
      refreshPersonDatalist();
      setDirty(true);
      saveSoon();
      drawGraph();
      flashStatus(`Saved person ${person.name}`, 'success');
    }

    function deletePerson() {
      const id = (byId('person-id').value || '').trim();
      if (!id || !state.persons[id]) {
        flashStatus('Unknown person ID.', 'warn');
        return;
      }
      delete state.persons[id];
      state.rel.parent = state.rel.parent.filter((rel) => rel.parentId !== id && rel.childId !== id);
      state.rel.partner = state.rel.partner.filter((rel) => rel.aId !== id && rel.bId !== id);
      state.rel.weighted = state.rel.weighted.filter((rel) => rel.aId !== id && rel.bId !== id);
      refreshPersonDatalist();
      setDirty(true);
      saveSoon();
      drawGraph();
      flashStatus(`Deleted person ${id}`, 'warn');
    }

    function getPersons(ids) {
      return ids.every((id) => state.persons[id]);
    }

    function addParentRelation() {
      const parentId = (byId('parent-id').value || '').trim();
      const childId = (byId('child-id').value || '').trim();
      if (!parentId || !childId || parentId === childId) {
        flashStatus('Invalid parent/child IDs.', 'warn');
        return;
      }
      if (!getPersons([parentId, childId])) {
        flashStatus('Person not found.', 'warn');
        return;
      }
      if (state.rel.parent.some((r) => r.parentId === parentId && r.childId === childId)) {
        flashStatus('Relation already exists.', 'warn');
        return;
      }
      state.rel.parent.push({ parentId, childId });
      setDirty(true);
      saveSoon();
      drawGraph();
      flashStatus('Added parent relation.', 'success');
    }

    function deleteParentRelation() {
      const parentId = (byId('parent-id').value || '').trim();
      const childId = (byId('child-id').value || '').trim();
      const len = state.rel.parent.length;
      state.rel.parent = state.rel.parent.filter((r) => !(r.parentId === parentId && r.childId === childId));
      if (state.rel.parent.length !== len) {
        setDirty(true);
        saveSoon();
        drawGraph();
        flashStatus('Deleted parent relation.', 'warn');
      }
    }

    function addPartnerRelation() {
      const aId = (byId('partner-a').value || '').trim();
      const bId = (byId('partner-b').value || '').trim();
      if (!aId || !bId || aId === bId) {
        flashStatus('Invalid partner IDs.', 'warn');
        return;
      }
      if (!getPersons([aId, bId])) {
        flashStatus('Person not found.', 'warn');
        return;
      }
      const exists = state.rel.partner.some((r) => (r.aId === aId && r.bId === bId) || (r.aId === bId && r.bId === aId));
      if (exists) {
        flashStatus('Partner relation exists.', 'warn');
        return;
      }
      state.rel.partner.push({ aId, bId });
      setDirty(true);
      saveSoon();
      drawGraph();
      flashStatus('Added partner relation.', 'success');
    }

    function deletePartnerRelation() {
      const aId = (byId('partner-a').value || '').trim();
      const bId = (byId('partner-b').value || '').trim();
      const len = state.rel.partner.length;
      state.rel.partner = state.rel.partner.filter((r) => !((r.aId === aId && r.bId === bId) || (r.aId === bId && r.bId === aId)));
      if (len !== state.rel.partner.length) {
        setDirty(true);
        saveSoon();
        drawGraph();
        flashStatus('Deleted partner relation.', 'warn');
      }
    }

    function addWeightedRelation() {
      const aId = (byId('weighted-a').value || '').trim();
      const bId = (byId('weighted-b').value || '').trim();
      const weight = Number(byId('weighted-value').value);
      const label = (byId('weighted-label').value || '').trim() || undefined;
      if (!aId || !bId || aId === bId || Number.isNaN(weight) || weight < 0 || weight > 100) {
        flashStatus('Invalid weighted relation.', 'warn');
        return;
      }
      if (!getPersons([aId, bId])) {
        flashStatus('Person not found.', 'warn');
        return;
      }
      const exists = state.rel.weighted.some((r) => (r.aId === aId && r.bId === bId) || (r.aId === bId && r.bId === aId));
      if (exists) {
        flashStatus('Weighted relation exists.', 'warn');
        return;
      }
      state.rel.weighted.push({ aId, bId, weight, label });
      setDirty(true);
      saveSoon();
      drawGraph();
      flashStatus('Added weighted relation.', 'success');
    }

    function deleteWeightedRelation() {
      const aId = (byId('weighted-a').value || '').trim();
      const bId = (byId('weighted-b').value || '').trim();
      const len = state.rel.weighted.length;
      state.rel.weighted = state.rel.weighted.filter((r) => !((r.aId === aId && r.bId === bId) || (r.aId === bId && r.bId === aId)));
      if (len !== state.rel.weighted.length) {
        setDirty(true);
        saveSoon();
        drawGraph();
        flashStatus('Deleted weighted relation.', 'warn');
      }
    }

    function applyRootId() {
      const rootId = (byId('root-id').value || '').trim();
      state.view.rootId = rootId || null;
      setDirty(true);
      saveSoon();
      drawGraph();
      flashStatus(`Root set to ${rootId || 'auto'}.`, 'success');
    }

    function clearRootId() {
      byId('root-id').value = '';
      state.view.rootId = null;
      setDirty(true);
      saveSoon();
      drawGraph();
    }

    function toggleLabels(evt) {
      state.view.showLabels = evt.target.checked;
      setDirty(true);
      saveSoon();
      drawGraph();
    }

    function toggleDrag(evt) {
      state.view.drag = evt.target.checked;
      setDirty(true);
      saveSoon();
      drawGraph();
    }

    function setLayout(evt) {
      state.view.layout = evt.target.value;
      setDirty(true);
      saveSoon();
      drawGraph();
    }

    function updateZoom(value, silent = false) {
      state.view.zoom = value;
      if (!silent && zoomBehavior && svgSelection) {
        svgSelection.transition().duration(200).call(zoomBehavior.scaleTo, value);
      }
      setDirty(true);
      saveSoon();
    }

    function fitToScreen() {
      if (!svgSelection) return;
      const nodes = svgSelection.selectAll('.node');
      if (nodes.empty()) return;
      const bbox = svgSelection.select('g.scene').node().getBBox();
      const wrapper = byId('graph-wrapper');
      const width = wrapper.clientWidth;
      const height = wrapper.clientHeight;
      const scale = Math.min(width / bbox.width, height / bbox.height) * 0.9;
      const translate = [
        width / 2 - (bbox.x + bbox.width / 2) * scale,
        height / 2 - (bbox.y + bbox.height / 2) * scale
      ];
      svgSelection.transition().duration(400).call(zoomBehavior.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
      byId('zoom-slider').value = scale.toFixed(2);
      state.view.zoom = scale;
    }

    function seedExample() {
      state = defaultState();
      nodePositions = new Map();
      const sample = [
        { id: 'P1', name: 'Alex', sex: 'M', birth: 1950 },
        { id: 'P2', name: 'Beth', sex: 'F', birth: 1952 },
        { id: 'P3', name: 'Carla', sex: 'F', birth: 1975 },
        { id: 'P4', name: 'Dylan', sex: 'M', birth: 1973 },
        { id: 'P5', name: 'Eli', sex: 'M', birth: 1998 },
        { id: 'P6', name: 'Fern', sex: 'F', birth: 2001 }
      ];
      sample.forEach((p) => {
        state.persons[p.id] = p;
      });
      state.rel.parent.push({ parentId: 'P1', childId: 'P3' });
      state.rel.parent.push({ parentId: 'P2', childId: 'P3' });
      state.rel.parent.push({ parentId: 'P3', childId: 'P5' });
      state.rel.parent.push({ parentId: 'P4', childId: 'P5' });
      state.rel.parent.push({ parentId: 'P3', childId: 'P6' });
      state.rel.parent.push({ parentId: 'P4', childId: 'P6' });
      state.rel.partner.push({ aId: 'P1', bId: 'P2' });
      state.rel.partner.push({ aId: 'P3', bId: 'P4' });
      state.rel.weighted.push({ aId: 'P5', bId: 'P6', weight: 70, label: 'Shared Trait' });
      state.rel.weighted.push({ aId: 'P1', bId: 'P4', weight: 30, label: 'Gene Flow' });
      state.view.rootId = 'P1';
      setDirty(true);
      refreshPersonDatalist();
      saveSoon();
      drawGraph();
      flashStatus('Seed example loaded.', 'success');
    }
    // ------------------------------
    // Persistence (IndexedDB + File System Access API)
    // ------------------------------
    function openIndexedDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(DB_STORE)) {
            db.createObjectStore(DB_STORE);
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function initDB() {
      try {
        idbHandle = await openIndexedDB();
      } catch (err) {
        console.error('IndexedDB init failed', err);
        flashStatus('IndexedDB unavailable. Persistence disabled.', 'warn');
      }
    }

    function idbGet(key) {
      return new Promise((resolve, reject) => {
        if (!idbHandle) {
          resolve(undefined);
          return;
        }
        const tx = idbHandle.transaction(DB_STORE, 'readonly');
        const store = tx.objectStore(DB_STORE);
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    function idbSet(key, value) {
      return new Promise((resolve, reject) => {
        if (!idbHandle) {
          resolve();
          return;
        }
        const tx = idbHandle.transaction(DB_STORE, 'readwrite');
        const store = tx.objectStore(DB_STORE);
        const req = store.put(value, key);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function saveAll() {
      try {
        if (saveTimeout) {
          clearTimeout(saveTimeout);
          saveTimeout = null;
        }
        const payload = { ...state, meta: { ...state.meta, fileHandle: undefined } };
        await idbSet(DB_KEY_STATE, payload);
        await idbSet(DB_KEY_FILE, state.meta.fileHandle ? await state.meta.fileHandle.getFile().then(() => state.meta.fileHandle, () => null) : null);
        if (state.meta.fileHandle) {
          const permission = await verifyFilePermission(state.meta.fileHandle, true);
          if (permission) {
            const writable = await state.meta.fileHandle.createWritable();
            await writable.write(JSON.stringify(payload, null, 2));
            await writable.close();
          }
        }
        state.meta.lastSaved = new Date().toISOString();
        setDirty(false);
        flashStatus('State saved.', 'success');
      } catch (err) {
        console.error('Save failed', err);
        flashStatus('Failed to save state.', 'warn');
      }
    }

    async function loadAll() {
      try {
        const storedState = await idbGet(DB_KEY_STATE);
        if (storedState) {
          hydrateState(storedState);
        }
        const handle = await idbGet(DB_KEY_FILE);
        if (handle) {
          state.meta.fileHandle = handle;
          const permission = await verifyFilePermission(handle, false);
          if (permission) {
            try {
              const file = await handle.getFile();
              const text = await file.text();
              const parsed = JSON.parse(text);
              hydrateState(parsed);
              flashStatus('Loaded from file handle.', 'success');
            } catch (err) {
              console.warn('Could not read file handle', err);
            }
          } else {
            flashStatus('File permission denied; using IndexedDB copy.', 'warn');
          }
        }
        refreshPersonDatalist();
        drawGraph();
      } catch (err) {
        console.error('Load failed', err);
        flashStatus('Failed to load saved state.', 'warn');
      }
    }

    function hydrateState(obj) {
      try {
        const next = defaultState();
        if (obj && typeof obj === 'object') {
          if (obj.persons && typeof obj.persons === 'object') {
            for (const [id, person] of Object.entries(obj.persons)) {
              if (!person || typeof person !== 'object') continue;
              next.persons[id] = {
                id,
                name: typeof person.name === 'string' ? person.name : 'Unnamed',
                sex: ['M', 'F', 'U'].includes(person.sex) ? person.sex : 'U',
                birth: Number.isFinite(person.birth) ? Number(person.birth) : undefined,
                death: Number.isFinite(person.death) ? Number(person.death) : undefined,
                notes: typeof person.notes === 'string' ? person.notes : undefined
              };
            }
          }
          if (obj.rel && typeof obj.rel === 'object') {
            const seenParent = new Set();
            const seenPartner = new Set();
            const seenWeighted = new Set();
            if (Array.isArray(obj.rel.parent)) {
              obj.rel.parent.forEach((rel) => {
                if (!rel || typeof rel !== 'object') return;
                const key = `${rel.parentId}->${rel.childId}`;
                if (!rel.parentId || !rel.childId || seenParent.has(key)) return;
                if (!next.persons[rel.parentId] || !next.persons[rel.childId]) return;
                seenParent.add(key);
                next.rel.parent.push({ parentId: rel.parentId, childId: rel.childId });
              });
            }
            if (Array.isArray(obj.rel.partner)) {
              obj.rel.partner.forEach((rel) => {
                if (!rel || typeof rel !== 'object') return;
                const sorted = [rel.aId, rel.bId].sort().join('<>');
                if (!rel.aId || !rel.bId || rel.aId === rel.bId || seenPartner.has(sorted)) return;
                if (!next.persons[rel.aId] || !next.persons[rel.bId]) return;
                seenPartner.add(sorted);
                next.rel.partner.push({ aId: rel.aId, bId: rel.bId });
              });
            }
            if (Array.isArray(obj.rel.weighted)) {
              obj.rel.weighted.forEach((rel) => {
                if (!rel || typeof rel !== 'object') return;
                const sorted = [rel.aId, rel.bId].sort().join('<>');
                if (!rel.aId || !rel.bId || rel.aId === rel.bId || seenWeighted.has(sorted)) return;
                if (!next.persons[rel.aId] || !next.persons[rel.bId]) return;
                const weight = Number(rel.weight);
                if (!Number.isFinite(weight)) return;
                seenWeighted.add(sorted);
                next.rel.weighted.push({
                  aId: rel.aId,
                  bId: rel.bId,
                  weight: Math.min(100, Math.max(0, weight)),
                  label: typeof rel.label === 'string' ? rel.label : undefined
                });
              });
            }
          }
          if (obj.view && typeof obj.view === 'object') {
            next.view.layout = ['force', 'tree'].includes(obj.view.layout) ? obj.view.layout : 'force';
            next.view.rootId = typeof obj.view.rootId === 'string' ? obj.view.rootId : null;
            next.view.showLabels = Boolean(obj.view.showLabels);
            next.view.drag = obj.view.drag !== false;
            next.view.zoom = Number.isFinite(obj.view.zoom) ? Number(obj.view.zoom) : 1;
          }
          if (obj.meta && typeof obj.meta === 'object') {
            next.meta.lastSaved = typeof obj.meta.lastSaved === 'string' ? obj.meta.lastSaved : null;
          }
        }
        next._dirty = false;
        state = next;
        nodePositions = new Map();
        byId('layout-select').value = state.view.layout;
        byId('toggle-labels').checked = state.view.showLabels;
        byId('toggle-drag').checked = state.view.drag;
        byId('zoom-slider').value = state.view.zoom;
        byId('root-id').value = state.view.rootId || '';
        setDirty(false);
        flashStatus('State hydrated.', 'success');
      } catch (err) {
        console.error('Hydration failed', err);
        flashStatus('Failed to hydrate state.', 'warn');
      }
    }

    function saveSoon() {
      if (saveTimeout) {
        clearTimeout(saveTimeout);
      }
      saveTimeout = setTimeout(saveAll, 800);
    }

    async function verifyFilePermission(handle, write) {
      if (!handle) return false;
      if (!window.navigator || !('permissions' in navigator)) {
        try {
          await handle.requestPermission({ mode: write ? 'readwrite' : 'read' });
        } catch (err) {
          return false;
        }
      }
      const opts = { mode: write ? 'readwrite' : 'read' };
      if (typeof handle.queryPermission === 'function') {
        const perm = await handle.queryPermission(opts);
        if (perm === 'granted') return true;
        if (perm === 'prompt') {
          const req = await handle.requestPermission(opts);
          return req === 'granted';
        }
        return false;
      }
      if (typeof handle.requestPermission === 'function') {
        const req = await handle.requestPermission(opts);
        return req === 'granted';
      }
      return false;
    }

    async function chooseFile() {
      if (!window.showSaveFilePicker) {
        flashStatus('File System Access API unavailable.', 'warn');
        return;
      }
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: 'pedigree.json',
          types: [
            {
              description: 'Pedigree JSON',
              accept: { 'application/json': ['.json'] }
            }
          ]
        });
        const permission = await verifyFilePermission(handle, true);
        if (permission) {
          state.meta.fileHandle = handle;
          flashStatus('File handle stored. Autosave active.', 'success');
          await saveAll();
        } else {
          flashStatus('Write permission denied.', 'warn');
        }
      } catch (err) {
        if (err && err.name === 'AbortError') {
          flashStatus('File selection cancelled.', 'warn');
        } else {
          console.error('File handle selection failed', err);
          flashStatus('Could not select file.', 'warn');
        }
      }
    }

    async function resetLocal() {
      state = defaultState();
      nodePositions = new Map();
      refreshPersonDatalist();
      drawGraph();
      setDirty(true);
      await saveAll();
      flashStatus('Local state reset.', 'warn');
    }

    function backupDownload() {
      const payload = { ...state, meta: { ...state.meta, fileHandle: null }, _dirty: undefined };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'pedigree-backup.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      flashStatus('Backup downloaded.', 'success');
    }

    function restoreFromFile(evt) {
      const file = evt.target.files && evt.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const parsed = JSON.parse(e.target.result);
          hydrateState(parsed);
          refreshPersonDatalist();
          drawGraph();
          setDirty(true);
          saveSoon();
          flashStatus('State restored from backup.', 'success');
        } catch (err) {
          console.error('Restore failed', err);
          flashStatus('Invalid backup file.', 'warn');
        }
      };
      reader.readAsText(file);
    }

    function exportSVGtoPNG() {
      const svgNode = document.getElementById('graph');
      const serializer = new XMLSerializer();
      const svgText = serializer.serializeToString(svgNode);
      const svgBlob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = svgNode.clientWidth * 2;
        canvas.height = svgNode.clientHeight * 2;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#101217';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'pedigree.png';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
      };
      img.src = url;
    }
    // ------------------------------
    // Graph rendering
    // ------------------------------
    function initGraph() {
      const svg = d3.select('#graph');
      svgSelection = svg;
      svg.selectAll('*').remove();

      const defs = svg.append('defs');
      defs
        .append('marker')
        .attr('id', 'arrow-head')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 16)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#9eb6d7');

      const scene = svg.append('g').attr('class', 'scene');

      zoomBehavior = d3
        .zoom()
        .scaleExtent([0.2, 4])
        .on('zoom', (event) => {
          scene.attr('transform', event.transform);
          byId('zoom-slider').value = event.transform.k.toFixed(2);
        });

      svg.call(zoomBehavior);
      svg.on('dblclick.zoom', null);

      tooltip = d3.select('#tooltip');
    }

    function graphData() {
      const persons = Object.values(state.persons);
      const nodes = persons.map((p) => ({ ...p }));
      const links = [];
      state.rel.parent.forEach((rel) => {
        if (state.persons[rel.parentId] && state.persons[rel.childId]) {
          links.push({
            source: rel.parentId,
            target: rel.childId,
            type: 'parent'
          });
        }
      });
      state.rel.partner.forEach((rel) => {
        if (state.persons[rel.aId] && state.persons[rel.bId]) {
          links.push({
            source: rel.aId,
            target: rel.bId,
            type: 'partner'
          });
        }
      });
      state.rel.weighted.forEach((rel) => {
        if (state.persons[rel.aId] && state.persons[rel.bId]) {
          links.push({
            source: rel.aId,
            target: rel.bId,
            type: 'weighted',
            weight: rel.weight,
            label: rel.label
          });
        }
      });
      return { nodes, links };
    }

    function drawGraph() {
      if (!svgSelection) {
        initGraph();
      }
      const { nodes, links } = graphData();
      const scene = svgSelection.select('g.scene');
      scene.selectAll('*').remove();

      const linkGroup = scene.append('g').attr('class', 'links');
      const nodeGroup = scene.append('g').attr('class', 'nodes');
      const labelGroup = scene.append('g').attr('class', 'labels');

      if (state.view.layout === 'tree') {
        buildTreeLayout(nodes, links, nodeGroup, linkGroup, labelGroup);
      } else {
        buildForceGraph(nodes, links, nodeGroup, linkGroup, labelGroup);
      }
    }

    function buildForceGraph(nodes, links, nodeGroup, linkGroup, labelGroup) {
      const width = byId('graph-wrapper').clientWidth || 1000;
      const height = byId('graph-wrapper').clientHeight || 800;

      const weightedStrength = (link) => {
        if (link.type === 'weighted') {
          return Math.max(0.1, (link.weight || 50) / 150);
        }
        if (link.type === 'parent') return 0.8;
        return 0.4;
      };

      const weightedDistance = (link) => {
        if (link.type === 'weighted') {
          return 160 - (link.weight || 50);
        }
        if (link.type === 'parent') return 80;
        return 120;
      };

      const simulation = d3
        .forceSimulation(nodes)
        .force(
          'link',
          d3
            .forceLink(links)
            .id((d) => d.id)
            .distance(weightedDistance)
            .strength(weightedStrength)
        )
        .force('charge', d3.forceManyBody().strength(-200))
        .force('collide', d3.forceCollide().radius(40))
        .force('center', d3.forceCenter(width / 2, height / 2));

      nodes.forEach((node) => {
        const cached = nodePositions.get(node.id);
        if (cached) {
          node.x = cached.x;
          node.y = cached.y;
        }
      });

      const link = linkGroup
        .selectAll('path')
        .data(links)
        .enter()
        .append('path')
        .attr('class', (d) => `link ${d.type}`)
        .attr('stroke', (d) => {
          if (d.type === 'weighted') return '#e0b05c';
          if (d.type === 'partner') return '#8a9ab5';
          return '#9eb6d7';
        })
        .attr('stroke-width', (d) => (d.type === 'weighted' ? 2 + (d.weight || 0) / 30 : d.type === 'partner' ? 1.5 : 1.8))
        .attr('stroke-dasharray', (d) => (d.type === 'partner' ? '6 4' : ''))
        .attr('fill', 'none')
        .attr('opacity', (d) => (d.type === 'weighted' ? 0.3 + (d.weight || 0) / 120 : 0.7))
        .attr('marker-end', (d) => (d.type === 'parent' ? 'url(#arrow-head)' : null))
        .on('mouseover', (event, d) => {
          tooltip.style('opacity', 1);
          let label = '';
          if (d.type === 'parent') {
            label = `Parent → Child: ${escapeHtml(state.persons[d.source.id || d.source]?.name || d.source.id)} → ${escapeHtml(state.persons[d.target.id || d.target]?.name || d.target.id)}`;
          } else if (d.type === 'partner') {
            label = `Partners: ${escapeHtml(state.persons[d.source.id || d.source]?.name || d.source.id)} ↔ ${escapeHtml(state.persons[d.target.id || d.target]?.name || d.target.id)}`;
          } else if (d.type === 'weighted') {
            label = `Weighted (${d.weight || 0}): ${escapeHtml(state.persons[d.source.id || d.source]?.name || d.source.id)} ↔ ${escapeHtml(state.persons[d.target.id || d.target]?.name || d.target.id)}${d.label ? `<br/>Label: ${escapeHtml(d.label)}` : ''}`;
          }
          tooltip.html(label).style('left', event.offsetX + 'px').style('top', event.offsetY + 'px');
        })
        .on('mouseout', () => tooltip.style('opacity', 0));

      const node = nodeGroup
        .selectAll('g')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .on('click', (event, d) => {
          populatePersonForm(state.persons[d.id]);
        })
        .on('mouseover', (event, d) => {
          tooltip.style('opacity', 1);
          tooltip
            .html(
              `ID: ${escapeHtml(d.id)}<br/>${escapeHtml(d.name || '')}<br/>Sex: ${escapeHtml(d.sex || 'U')}${
                d.birth ? `<br/>Born: ${escapeHtml(d.birth)}` : ''
              }${d.death ? `<br/>Died: ${escapeHtml(d.death)}` : ''}${d.notes ? `<br/>Notes: ${escapeHtml(d.notes)}` : ''}`
            )
            .style('left', event.offsetX + 'px')
            .style('top', event.offsetY + 'px');
        })
        .on('mouseout', () => tooltip.style('opacity', 0));

      node.each(function (d) {
        const shape = d.sex === 'M' ? 'rect' : d.sex === 'F' ? 'circle' : 'path';
        const group = d3.select(this);
        if (shape === 'rect') {
          group
            .append('rect')
            .attr('x', -14)
            .attr('y', -14)
            .attr('width', 28)
            .attr('height', 28)
            .attr('rx', 4)
            .attr('ry', 4)
            .attr('fill', '#4e7ab9')
            .attr('stroke', '#b9c7de')
            .attr('stroke-width', 1.2);
        } else if (shape === 'circle') {
          group
            .append('circle')
            .attr('r', 14)
            .attr('fill', '#b95f9d')
            .attr('stroke', '#f1c3e1')
            .attr('stroke-width', 1.2);
        } else {
          group
            .append('path')
            .attr('d', 'M0,-18 L18,0 L0,18 L-18,0Z')
            .attr('fill', '#8a93a5')
            .attr('stroke', '#d0d5dd')
            .attr('stroke-width', 1.2);
        }
      });

      if (state.view.showLabels) {
        labelGroup
          .selectAll('text')
          .data(nodes)
          .enter()
          .append('text')
          .attr('text-anchor', 'middle')
          .attr('dy', 24)
          .attr('fill', '#d3d7e2')
          .attr('font-size', 12)
          .text((d) => d.name || d.id);
      }

      if (state.view.drag) {
        node.call(
          d3
            .drag()
            .on('start', (event, d) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            })
            .on('drag', (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
            })
            .on('end', (event, d) => {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            })
        );
      }

      simulation.on('tick', () => {
        link.attr('d', (d) => {
          const sx = d.source.x;
          const sy = d.source.y;
          const tx = d.target.x;
          const ty = d.target.y;
          return `M${sx},${sy} L${tx},${ty}`;
        });

        node.attr('transform', (d) => {
          nodePositions.set(d.id, { x: d.x, y: d.y });
          return `translate(${d.x},${d.y})`;
        });

        labelGroup.selectAll('text').attr('transform', (d) => `translate(${d.x},${d.y})`);
      });
    }

    function buildTreeLayout(nodes, links, nodeGroup, linkGroup, labelGroup) {
      if (!state.view.rootId || !state.persons[state.view.rootId]) {
        flashStatus('Tree layout requires a valid root ID.', 'warn');
        buildForceGraph(nodes, links, nodeGroup, linkGroup, labelGroup);
        return;
      }
      const rootId = state.view.rootId;
      const childMap = new Map();
      state.rel.parent.forEach((rel) => {
        if (!childMap.has(rel.parentId)) childMap.set(rel.parentId, new Set());
        childMap.get(rel.parentId).add(rel.childId);
      });

      function buildNode(id, visited = new Set()) {
        if (visited.has(id)) return null;
        visited.add(id);
        const children = Array.from(childMap.get(id) || [])
          .map((childId) => buildNode(childId, visited))
          .filter(Boolean);
        return { id, children };
      }

      const hierarchyData = buildNode(rootId);
      if (!hierarchyData) {
        flashStatus('Could not build tree from root.', 'warn');
        buildForceGraph(nodes, links, nodeGroup, linkGroup, labelGroup);
        return;
      }

      const root = d3.hierarchy(hierarchyData, (d) => d.children);
      const treeLayout = d3.tree().nodeSize([100, 150]);
      treeLayout(root);

      const positions = new Map();
      root.each((d) => {
        positions.set(d.data.id, { x: d.x, y: d.y });
      });

      nodes.forEach((node) => {
        const pos = positions.get(node.id);
        if (pos) {
          node.x = pos.x;
          node.y = pos.y;
        } else {
          node.x = Math.random() * 50;
          node.y = Math.random() * 50;
        }
        nodePositions.set(node.id, { x: node.x, y: node.y });
      });

      linkGroup
        .selectAll('path')
        .data(links)
        .enter()
        .append('path')
        .attr('class', (d) => `link ${d.type}`)
        .attr('stroke', (d) => {
          if (d.type === 'weighted') return '#e0b05c';
          if (d.type === 'partner') return '#8a9ab5';
          return '#9eb6d7';
        })
        .attr('stroke-width', (d) => (d.type === 'weighted' ? 2 + (d.weight || 0) / 30 : d.type === 'partner' ? 1.5 : 1.8))
        .attr('stroke-dasharray', (d) => (d.type === 'partner' ? '6 4' : ''))
        .attr('fill', 'none')
        .attr('opacity', (d) => (d.type === 'weighted' ? 0.3 + (d.weight || 0) / 120 : 0.7))
        .attr('marker-end', (d) => (d.type === 'parent' ? 'url(#arrow-head)' : null))
        .attr('d', (d) => {
          const source = nodes.find((n) => n.id === (d.source.id || d.source));
          const target = nodes.find((n) => n.id === (d.target.id || d.target));
          if (!source || !target) return '';
          return `M${source.x},${source.y} C${source.x},${(source.y + target.y) / 2} ${target.x},${(source.y + target.y) / 2} ${target.x},${target.y}`;
        })
        .on('mouseover', (event, d) => {
          tooltip.style('opacity', 1);
          let label = '';
          if (d.type === 'parent') {
            label = `Parent → Child: ${escapeHtml(state.persons[d.source.id || d.source]?.name || d.source.id)} → ${escapeHtml(state.persons[d.target.id || d.target]?.name || d.target.id)}`;
          } else if (d.type === 'partner') {
            label = `Partners: ${escapeHtml(state.persons[d.source.id || d.source]?.name || d.source.id)} ↔ ${escapeHtml(state.persons[d.target.id || d.target]?.name || d.target.id)}`;
          } else if (d.type === 'weighted') {
            label = `Weighted (${d.weight || 0}): ${escapeHtml(state.persons[d.source.id || d.source]?.name || d.source.id)} ↔ ${escapeHtml(state.persons[d.target.id || d.target]?.name || d.target.id)}${d.label ? `<br/>Label: ${escapeHtml(d.label)}` : ''}`;
          }
          tooltip.html(label).style('left', event.offsetX + 'px').style('top', event.offsetY + 'px');
        })
        .on('mouseout', () => tooltip.style('opacity', 0));

      const node = nodeGroup
        .selectAll('g')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', (d) => `translate(${d.x},${d.y})`)
        .on('click', (event, d) => {
          populatePersonForm(state.persons[d.id]);
        })
        .on('mouseover', (event, d) => {
          tooltip.style('opacity', 1);
          tooltip
            .html(
              `ID: ${escapeHtml(d.id)}<br/>${escapeHtml(d.name || '')}<br/>Sex: ${escapeHtml(d.sex || 'U')}${
                d.birth ? `<br/>Born: ${escapeHtml(d.birth)}` : ''
              }${d.death ? `<br/>Died: ${escapeHtml(d.death)}` : ''}${d.notes ? `<br/>Notes: ${escapeHtml(d.notes)}` : ''}`
            )
            .style('left', event.offsetX + 'px')
            .style('top', event.offsetY + 'px');
        })
        .on('mouseout', () => tooltip.style('opacity', 0));

      node.each(function (d) {
        const shape = d.sex === 'M' ? 'rect' : d.sex === 'F' ? 'circle' : 'path';
        const group = d3.select(this);
        if (shape === 'rect') {
          group
            .append('rect')
            .attr('x', -14)
            .attr('y', -14)
            .attr('width', 28)
            .attr('height', 28)
            .attr('rx', 4)
            .attr('ry', 4)
            .attr('fill', '#4e7ab9')
            .attr('stroke', '#b9c7de')
            .attr('stroke-width', 1.2);
        } else if (shape === 'circle') {
          group
            .append('circle')
            .attr('r', 14)
            .attr('fill', '#b95f9d')
            .attr('stroke', '#f1c3e1')
            .attr('stroke-width', 1.2);
        } else {
          group
            .append('path')
            .attr('d', 'M0,-18 L18,0 L0,18 L-18,0Z')
            .attr('fill', '#8a93a5')
            .attr('stroke', '#d0d5dd')
            .attr('stroke-width', 1.2);
        }
      });

      if (state.view.showLabels) {
        labelGroup
          .selectAll('text')
          .data(nodes)
          .enter()
          .append('text')
          .attr('text-anchor', 'middle')
          .attr('dy', 24)
          .attr('fill', '#d3d7e2')
          .attr('font-size', 12)
          .attr('transform', (d) => `translate(${d.x},${d.y})`)
          .text((d) => d.name || d.id);
      }
    }

    function updateFooter() {
      const savedInfo = state.meta.lastSaved ? ` · Last saved ${new Date(state.meta.lastSaved).toLocaleString()}` : '';
      byId('footer-sync').textContent = `Dirty state: ${state._dirty ? 'dirty' : 'clean'}${savedInfo}`;
      byId('file-status').textContent = state.meta.fileHandle ? 'File bound (autosave)' : 'IndexedDB only';
    }

    function handleResize() {
      drawGraph();
    }

    function registerEvents() {
      byId('person-form').addEventListener('submit', upsertPerson);
      byId('person-delete').addEventListener('click', deletePerson);
      byId('add-parent').addEventListener('click', addParentRelation);
      byId('del-parent').addEventListener('click', deleteParentRelation);
      byId('add-partner').addEventListener('click', addPartnerRelation);
      byId('del-partner').addEventListener('click', deletePartnerRelation);
      byId('add-weighted').addEventListener('click', addWeightedRelation);
      byId('del-weighted').addEventListener('click', deleteWeightedRelation);
      byId('apply-root').addEventListener('click', applyRootId);
      byId('clear-root').addEventListener('click', clearRootId);
      byId('toggle-labels').addEventListener('change', toggleLabels);
      byId('toggle-drag').addEventListener('change', toggleDrag);
      byId('layout-select').addEventListener('change', (evt) => {
        setLayout(evt);
        drawGraph();
      });
      byId('zoom-slider').addEventListener('input', (evt) => {
        updateZoom(Number(evt.target.value));
      });
      byId('fit-btn').addEventListener('click', fitToScreen);
      byId('seed-example').addEventListener('click', seedExample);
      byId('choose-file').addEventListener('click', chooseFile);
      byId('reset-local').addEventListener('click', resetLocal);
      byId('backup').addEventListener('click', backupDownload);
      byId('restore').addEventListener('change', (evt) => {
        restoreFromFile(evt);
        evt.target.value = '';
      });
      byId('export-png').addEventListener('click', exportSVGtoPNG);
      window.addEventListener('resize', handleResize);
      document.addEventListener('keydown', (evt) => {
        if ((evt.ctrlKey || evt.metaKey) && evt.key.toLowerCase() === 's') {
          evt.preventDefault();
          saveAll();
        }
      });
    }

    async function boot() {
      await initDB();
      await loadAll();
      initGraph();
      drawGraph();
      updateFooter();
      registerEvents();
      setInterval(updateFooter, 2000);
      if (state.view.zoom && svgSelection && zoomBehavior) {
        svgSelection.call(zoomBehavior.scaleTo, state.view.zoom);
        byId('zoom-slider').value = state.view.zoom;
      }
      flashStatus('Ready.', 'success');
    }

    boot();
  </script>
</body>
</html>
