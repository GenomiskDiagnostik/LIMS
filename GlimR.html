<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<title>GlimR – Genetic LIMS Reporter</title>
<style>
:root {
  font-family: "Segoe UI", Arial, sans-serif;
  color-scheme: light dark;
  --bg: #f5f7fb;
  --text: #162941;
  --muted-text: #41516b;
  --panel-bg: #ffffff;
  --panel-border: #c7d2e3;
  --shadow: 0 4px 14px rgba(18, 76, 135, 0.08);
  --accent: #186faf;
  --accent-strong: #124c87;
  --accent-shadow: rgba(24, 111, 175, 0.2);
  --danger: #c0392b;
  --priority-urgent: #f59e0b;
  --priority-acute: #c0392b;
  --nav-bg: #ffffff;
  --nav-border: #c7d2e3;
  --nav-button-bg: #e3ecf8;
  --nav-button-color: #124c87;
  --nav-button-active-bg: #124c87;
  --nav-button-active-color: #ffffff;
  --table-header-bg: #f0f4fb;
  --table-row-border: #dde4f1;
  --badge-bg: #dce6f7;
  --badge-color: #0f4173;
  --input-bg: #ffffff;
  --input-border: #c3cde0;
  --input-placeholder: #6b7d97;
  --input-focus: rgba(24, 111, 175, 0.35);
  --header-bg: linear-gradient(135deg, #124c87, #186faf);
  --header-text: #ffffff;
  --code-bg: #101927;
  --code-text: #e8f1ff;
}
[data-theme="dark"] {
  --bg: #0f172a;
  --text: #e2e8f0;
  --muted-text: #94a3b8;
  --panel-bg: #1e293b;
  --panel-border: #334155;
  --shadow: 0 6px 18px rgba(8, 47, 73, 0.55);
  --accent: #38bdf8;
  --accent-strong: #0ea5e9;
  --accent-shadow: rgba(56, 189, 248, 0.2);
  --danger: #ef4444;
  --priority-urgent: #fbbf24;
  --priority-acute: #ef4444;
  --nav-bg: #111c30;
  --nav-border: #1f2a3c;
  --nav-button-bg: #1f2a3c;
  --nav-button-color: #cbd5f5;
  --nav-button-active-bg: #0ea5e9;
  --nav-button-active-color: #0b1120;
  --table-header-bg: #233049;
  --table-row-border: #2f3e58;
  --badge-bg: #1d4ed8;
  --badge-color: #bfdbfe;
  --input-bg: #0f172a;
  --input-border: #334155;
  --input-placeholder: #64748b;
  --input-focus: rgba(56, 189, 248, 0.45);
  --header-bg: linear-gradient(135deg, #0b2a4a, #14395d);
  --header-text: #e2e8f0;
  --code-bg: #0b1120;
  --code-text: #e2e8f0;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  transition: background 0.2s ease, color 0.2s ease;
}
header {
  background: var(--header-bg);
  color: var(--header-text);
  padding: 1rem 2rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 1rem;
}
.brand {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex: 1 1 260px;
  min-width: 200px;
}
.icon-slot {
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.icon {
  width: 1.1em;
  height: 1.1em;
  display: block;
}
.with-icon {
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
}
.with-icon .icon-slot {
  flex: 0 0 auto;
}
.brand-mark {
  width: 64px;
  height: 64px;
  border-radius: 18px;
  background: rgba(255, 255, 255, 0.18);
  display: none;
  align-items: center;
  justify-content: center;
  color: var(--header-text);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
}
.brand-mark .icon-slot {
  width: 2.4rem;
  height: 2.4rem;
}
.brand-mark .icon {
  width: 100%;
  height: 100%;
}
.brand.logo-missing .brand-mark {
  display: flex;
}
[data-theme="dark"] .brand-mark {
  background: rgba(15, 23, 42, 0.55);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.45);
}
.brand img {
  width: 64px;
  height: 64px;
  object-fit: contain;
}
.brand.logo-missing::after {
  content: 'Logo mangler – placer logo.png ved siden af GlimR.html.';
  display: block;
  font-size: 0.75rem;
  color: var(--muted-text);
}
.with-icon .icon {
  width: 1.2em;
  height: 1.2em;
}
header h1 {
  margin: 0;
  font-size: 1.8rem;
}
#statusBar {
  font-size: 0.9rem;
  margin-top: 0.3rem;
  color: var(--header-text);
}
.header-actions {
  display: flex;
  gap: 1rem;
  align-items: stretch;
  flex-wrap: wrap;
  justify-content: flex-end;
}
.auth-block {
  background: rgba(255, 255, 255, 0.12);
  border-radius: 0.75rem;
  padding: 0.6rem 0.8rem;
  display: flex;
  align-items: center;
  gap: 0.6rem;
}
[data-theme="dark"] .auth-block {
  background: rgba(15, 23, 42, 0.45);
}
.auth-block form {
  display: flex;
  gap: 0.4rem;
  flex-wrap: wrap;
  align-items: center;
}
.auth-block select,
.auth-block input {
  min-width: 160px;
}
.auth-block .user-info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.auth-block .user-info span {
  font-weight: 600;
}
.quick-actions {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  flex-wrap: wrap;
  justify-content: flex-end;
}
nav {
  background: var(--nav-bg);
  border-bottom: 1px solid var(--nav-border);
  display: flex;
  flex-wrap: wrap;
  padding: 0.5rem 1rem;
  gap: 0.5rem;
}
nav button {
  border: none;
  background: var(--nav-button-bg);
  color: var(--nav-button-color);
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-size: 0.95rem;
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}
nav button.active {
  background: var(--nav-button-active-bg);
  color: var(--nav-button-active-color);
}
nav button .icon-slot {
  width: 1.2em;
  height: 1.2em;
}
nav button .icon {
  width: 100%;
  height: 100%;
}
main {
  padding: 1.5rem;
}
section[data-tab] {
  display: none;
}
section[data-tab].active {
  display: block;
}
.panel {
  background: var(--panel-bg);
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  padding: 1rem 1.2rem;
  margin-bottom: 1.2rem;
  border: 1px solid var(--panel-border);
}
.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
  flex-wrap: wrap;
}
.panel-header h2 {
  margin: 0;
}
.tool-panel {
  padding: 0;
  overflow: hidden;
}
.tool-panel summary {
  margin: 0;
  padding: 1rem 1.2rem;
  list-style: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
  background: transparent;
  color: inherit;
  transition: background 0.2s ease, color 0.2s ease;
}
.tool-panel summary:hover {
  background: rgba(24, 111, 175, 0.08);
}
.tool-panel[open] summary {
  color: var(--accent-strong);
  background: rgba(24, 111, 175, 0.08);
}
[data-theme="dark"] .tool-panel summary:hover {
  background: rgba(56, 189, 248, 0.12);
}
[data-theme="dark"] .tool-panel[open] summary {
  background: rgba(56, 189, 248, 0.12);
  color: var(--accent);
}
.tool-panel summary:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.tool-panel summary::-webkit-details-marker {
  display: none;
}
.tool-panel summary::marker {
  display: none;
}
.tool-panel summary::after {
  content: '\25B6';
  font-size: 0.95rem;
  color: var(--muted-text);
  transition: transform 0.2s ease;
}
.tool-panel[open] summary::after {
  transform: rotate(90deg);
  color: var(--accent-strong);
}
.tool-summary-text {
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
}
.tool-summary-text .tool-title {
  font-size: 1.05rem;
  font-weight: 600;
}
.tool-summary-text .tool-subtitle {
  font-size: 0.9rem;
  color: var(--muted-text);
}
.tool-panel .tool-body {
  padding: 0 1.2rem 1.2rem;
  border-top: 1px solid var(--panel-border);
}
.tool-panel .tool-body > h3 {
  margin-top: 1rem;
  margin-bottom: 0.5rem;
  font-size: 1.2rem;
}
.tool-panel .tool-body > p:first-of-type {
  margin-top: 0;
}
[data-theme="dark"] .tool-panel summary::after {
  color: var(--muted-text);
}
[data-theme="dark"] .tool-panel[open] summary::after {
  color: var(--accent);
}
.tool-panel[open] {
  padding-bottom: 0;
}
.tool-columns {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 0.75rem;
  margin-top: 0.75rem;
}
.tool-criteria-list {
  display: grid;
  gap: 0.4rem;
  justify-items: stretch;
}
.tool-criteria {
  display: grid;
  grid-template-columns: auto 1fr;
  align-items: flex-start;
  gap: 0.55rem;
  padding: 0.45rem 0.6rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.55rem;
  background: rgba(24, 111, 175, 0.08);
  text-align: left;
}
[data-theme="dark"] .tool-criteria {
  background: rgba(14, 165, 233, 0.12);
}
.tool-criteria input[type="checkbox"] {
  margin-top: 0.25rem;
}
.tool-criteria .criterion-text {
  display: block;
  line-height: 1.35;
}
.tool-criteria .criterion-strength-wrapper {
  display: block;
  margin-top: 0.4rem;
}
.tool-criteria .criterion-strength {
  width: 100%;
  font: inherit;
  font-size: 0.9rem;
  padding: 0.35rem 0.4rem;
  border-radius: 0.45rem;
  border: 1px solid var(--input-border);
  background: var(--input-bg);
  color: var(--text);
}
.tool-criteria .criterion-strength:disabled {
  opacity: 0.65;
}
.tool-result {
  margin-top: 0.9rem;
  padding: 0.7rem 0.9rem;
  border-radius: 0.55rem;
  background: rgba(24, 111, 175, 0.08);
  border: 1px solid var(--panel-border);
}
[data-theme="dark"] .tool-result {
  background: rgba(14, 165, 233, 0.15);
}
.tool-inline {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 0.75rem;
  align-items: end;
  margin-top: 0.75rem;
}
.tool-inline label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.consang-baseline {
  margin-top: 0.5rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 0.5rem 0.85rem;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  column-gap: 1.5rem;
  row-gap: 0.35rem;
  background: rgba(24, 111, 175, 0.06);
}
[data-theme="dark"] .consang-baseline {
  background: rgba(14, 165, 233, 0.12);
}
.consang-baseline legend {
  font-weight: 600;
  margin: 0;
  padding: 0 0.35rem 0 0;
  white-space: nowrap;
}
.consang-baseline .radio-option {
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
  font-size: 0.95rem;
  white-space: nowrap;
}
.consang-baseline .radio-option input[type="radio"] {
  margin: 0;
}
.consang-diagram {
  margin-top: 0.75rem;
  padding: 0.6rem 0.75rem;
  border-radius: 0.65rem;
  background: rgba(24, 111, 175, 0.05);
  border: 1px solid rgba(24, 111, 175, 0.15);
  max-width: 360px;
}
[data-theme="dark"] .consang-diagram {
  background: rgba(14, 165, 233, 0.12);
  border-color: rgba(56, 189, 248, 0.25);
}
.consang-diagram svg {
  display: block;
  width: 100%;
  height: auto;
}
.consang-diagram figcaption {
  margin-top: 0.5rem;
  font-size: 0.8rem;
  color: var(--muted-text);
}
.consang-diagram svg .pedigree-link {
  stroke: var(--accent);
  stroke-width: 1.8;
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.consang-diagram svg .pedigree-link.distant {
  stroke-dasharray: 4 3;
  opacity: 0.8;
}
.consang-diagram svg .pedigree-node {
  fill: var(--panel-bg);
  stroke: var(--accent-strong);
  stroke-width: 1.6;
}
[data-theme="dark"] .consang-diagram svg .pedigree-node {
  fill: rgba(15, 23, 42, 0.65);
}
.consang-diagram svg .pedigree-node.proband {
  fill: var(--accent);
  stroke: var(--accent-strong);
}
.consang-diagram svg .pedigree-label {
  font-size: 10px;
  font-family: 'Segoe UI', Arial, sans-serif;
  text-anchor: middle;
  fill: var(--muted-text);
}
[data-theme="dark"] .consang-diagram svg .pedigree-label {
  fill: var(--muted-text);
}
.consang-diagram svg .pedigree-label.name {
  fill: var(--text);
}
[data-theme="dark"] .consang-diagram svg .pedigree-label.name {
  fill: var(--text);
}
.consang-diagram svg .pedigree-label.proband {
  fill: var(--panel-bg);
  font-weight: 600;
}
.tool-note {
  color: var(--muted-text);
  font-size: 0.85rem;
  margin-top: 0.5rem;
}
.placeholder-guide {
  margin-top: 1rem;
  border-radius: 0.75rem;
  border: 1px solid var(--panel-border);
  background: rgba(24, 111, 175, 0.08);
  padding: 0;
  overflow: hidden;
}
[data-theme="dark"] .placeholder-guide {
  background: rgba(14, 165, 233, 0.12);
}
.placeholder-guide summary {
  padding: 1rem 1.25rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  list-style: none;
}
.placeholder-guide summary::-webkit-details-marker {
  display: none;
}
.placeholder-guide summary h3 {
  margin: 0;
  font-size: 1.05rem;
}
.placeholder-guide-subtitle {
  margin-left: auto;
  font-size: 0.85rem;
  font-weight: 500;
  color: var(--muted-text);
}
.placeholder-guide summary::after {
  content: '\25BC';
  font-size: 0.9rem;
  color: var(--muted-text);
  margin-left: 0.5rem;
  transition: transform 0.2s ease;
}
.placeholder-guide[open] summary::after {
  transform: rotate(180deg);
}
.placeholder-guide summary:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 3px;
  border-radius: 0.5rem;
}
.placeholder-guide summary:hover {
  background: rgba(24, 111, 175, 0.12);
}
[data-theme="dark"] .placeholder-guide summary:hover {
  background: rgba(14, 165, 233, 0.18);
}
.placeholder-guide-body {
  padding: 0 1.25rem 1.25rem;
}
.placeholder-guide[open] .placeholder-guide-body {
  border-top: 1px solid var(--panel-border);
  padding-top: 1rem;
}
.placeholder-guide p {
  margin: 0 0 0.75rem;
}
.placeholder-guide h4 {
  margin: 0.75rem 0 0.35rem;
  font-size: 0.95rem;
}
.placeholder-guide-columns {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 1rem;
}
.placeholder-guide ul {
  margin: 0;
  padding-left: 1.1rem;
  font-size: 0.92rem;
  color: var(--muted-text);
}
.placeholder-guide li + li {
  margin-top: 0.35rem;
}
.placeholder-guide code {
  font-family: 'Fira Code', 'Fira Mono', 'Consolas', monospace;
  background: rgba(24, 111, 175, 0.15);
  color: var(--accent-strong);
  border-radius: 0.45rem;
  padding: 0.05rem 0.35rem;
  font-size: 0.85rem;
}
[data-theme="dark"] .placeholder-guide code {
  background: rgba(14, 165, 233, 0.2);
  color: var(--code-text);
}
.placeholder-guide-footnote {
  margin-top: 0.75rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.variant-picker-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.45);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 1.5rem;
}
[data-theme="dark"] .variant-picker-overlay {
  background: rgba(8, 13, 23, 0.75);
}
.variant-picker {
  background: var(--panel-bg);
  color: var(--text);
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  border: 1px solid var(--panel-border);
  max-width: 960px;
  width: 100%;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
}
.variant-picker header {
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--panel-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}
.variant-picker header h3 {
  margin: 0;
  font-size: 1.25rem;
}
.variant-picker .picker-body {
  padding: 1rem 1.25rem 1.25rem;
  overflow: auto;
}
.variant-picker .picker-actions {
  display: flex;
  justify-content: flex-end;
  padding: 0 1.25rem 1rem;
}
.variant-picker table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 0.75rem;
}
.variant-picker table th,
.variant-picker table td {
  padding: 0.5rem 0.75rem;
  border-bottom: 1px solid var(--table-row-border);
  text-align: left;
}
.variant-picker table tbody tr {
  cursor: pointer;
  transition: background 0.15s ease;
}
.variant-picker table tbody tr:hover,
.variant-picker table tbody tr:focus-within {
  background: var(--table-header-bg);
}
.variant-picker table tbody tr:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
}
.variant-picker-empty {
  text-align: center;
  padding: 1.5rem 0.5rem;
  color: var(--muted-text);
}
.panel h2 {
  margin-top: 0;
}
.dashboard-metrics {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  align-items: stretch;
}
.dashboard-metric {
  display: flex;
  align-items: center;
  gap: 0.85rem;
  padding: 0.9rem 1rem;
  border-radius: 0.9rem;
  border: 1px solid var(--panel-border);
  background: rgba(24, 111, 175, 0.06);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
  transition: box-shadow 0.15s ease, background 0.15s ease;
}
.dashboard-metric:hover,
.dashboard-metric:focus-within {
  background: rgba(24, 111, 175, 0.1);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.45), var(--shadow);
}
[data-theme="dark"] .dashboard-metric {
  background: rgba(56, 189, 248, 0.14);
  box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.35);
}
[data-theme="dark"] .dashboard-metric:hover,
[data-theme="dark"] .dashboard-metric:focus-within {
  background: rgba(56, 189, 248, 0.18);
  box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.55), var(--shadow);
}
.dashboard-metric .icon-slot {
  width: 2.75rem;
  height: 2.75rem;
  border-radius: 0.85rem;
  background: rgba(24, 111, 175, 0.18);
  color: var(--accent-strong);
  flex: 0 0 auto;
}
[data-theme="dark"] .dashboard-metric .icon-slot {
  background: rgba(14, 165, 233, 0.25);
  color: var(--accent);
}
.dashboard-metric h3 {
  margin: 0;
  font-size: 2rem;
  line-height: 1.1;
}
.dashboard-metric .badge {
  margin-bottom: 0.25rem;
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.8rem;
}
.dashboard-stats {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}
.dashboard-stat {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.85rem 1rem;
  border-radius: 0.8rem;
  border: 1px solid var(--panel-border);
  background: rgba(24, 111, 175, 0.08);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
}
[data-theme="dark"] .dashboard-stat {
  background: rgba(56, 189, 248, 0.14);
  box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.25);
}
.dashboard-stat .icon-slot {
  width: 2.4rem;
  height: 2.4rem;
  border-radius: 0.75rem;
  background: rgba(24, 111, 175, 0.12);
  color: var(--accent-strong);
  flex: 0 0 auto;
}
[data-theme="dark"] .dashboard-stat .icon-slot {
  background: rgba(56, 189, 248, 0.18);
  color: var(--accent);
}
.dashboard-stat .stat-label {
  font-size: 0.85rem;
  color: var(--muted-text);
}
.dashboard-stat .stat-value {
  margin-top: 0.2rem;
  font-size: 1.6rem;
  font-weight: 700;
  color: var(--text);
}
.flex {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}
.flex > * {
  flex: 1 1 280px;
}
table {
  width: 100%;
  border-collapse: collapse;
  background: var(--panel-bg);
  color: inherit;
}
th, td {
  padding: 0.45rem 0.6rem;
  border-bottom: 1px solid var(--table-row-border);
  text-align: left;
  font-size: 0.9rem;
}
th {
  background: var(--table-header-bg);
}
tbody tr[data-selected="true"] {
  background: rgba(24, 111, 175, 0.12);
}
[data-theme="dark"] tbody tr[data-selected="true"] {
  background: rgba(56, 189, 248, 0.18);
}
tbody tr[data-order-id] {
  cursor: pointer;
}
tbody tr[data-order-id]:hover {
  background: rgba(24, 111, 175, 0.08);
}
[data-theme="dark"] tbody tr[data-order-id]:hover {
  background: rgba(56, 189, 248, 0.12);
}
.priority-indicator {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-right: 0.35rem;
}
.priority-indicator svg {
  width: 0.95em;
  height: 0.95em;
}
.urgent-indicator {
  color: var(--priority-urgent);
}
.acute-indicator {
  color: var(--priority-acute);
}
.inline-field-group {
  display: flex;
  gap: 1rem;
  align-items: flex-end;
  flex-wrap: wrap;
}
.inline-field-group > label {
  flex: 1 1 220px;
  margin-top: 0.4rem;
}
.inline-field-group > .checkbox-field {
  flex: 0 0 auto;
  margin-top: 0.4rem;
}
.order-id {
  display: inline-block;
}
.table-meta {
  display: inline-block;
  margin-left: 0.35rem;
  font-size: 0.75rem;
  color: var(--muted-text);
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
.table-shortcuts {
  width: 3.25rem;
}
.table-actions-cell {
  display: flex;
  align-items: center;
  gap: 0.3rem;
  padding-right: 0.4rem;
}
button.icon-button {
  border: none;
  background: transparent;
  color: var(--muted-text);
  padding: 0.35rem;
  border-radius: 0.45rem;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: background 0.2s ease, color 0.2s ease, opacity 0.2s ease;
}
button.icon-button .icon-slot {
  width: 1.1em;
  height: 1.1em;
}
button.icon-button:hover {
  background: rgba(24, 111, 175, 0.12);
  color: var(--accent-strong);
}
[data-theme="dark"] button.icon-button:hover {
  background: rgba(56, 189, 248, 0.18);
  color: var(--accent);
}
button.icon-button:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
  background: rgba(24, 111, 175, 0.12);
  color: var(--accent-strong);
}
[data-theme="dark"] button.icon-button:focus-visible {
  background: rgba(56, 189, 248, 0.18);
  color: var(--accent);
}
@media (hover: none) {
  button.icon-button:hover {
    background: transparent;
    color: var(--muted-text);
  }
  button.icon-button:focus-visible {
    background: rgba(24, 111, 175, 0.12);
    color: var(--accent-strong);
  }
  [data-theme="dark"] button.icon-button:focus-visible {
    background: rgba(56, 189, 248, 0.18);
    color: var(--accent);
  }
}
button.icon-button:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}
.table-actions-cell button.icon-button {
  flex: 0 0 auto;
}
label.checkbox-field {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--muted-text);
  margin-top: 0.6rem;
}
label.checkbox-field input[type="checkbox"] {
  transform: scale(1.05);
}
td.truncate-cell {
  vertical-align: top;
}
.truncate-text {
  display: block;
  width: 100%;
  max-width: clamp(12rem, 40vw, 28rem);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.truncate-text--narrow {
  max-width: clamp(10rem, 35vw, 22rem);
}
.truncate-text--wide {
  max-width: clamp(16rem, 55vw, 36rem);
}
form label {
  display: block;
  font-size: 0.8rem;
  font-weight: 600;
  margin-top: 0.4rem;
  color: var(--muted-text);
}
.label-note {
  display: inline-block;
  margin-left: 0.35rem;
  font-size: 0.75rem;
  font-weight: 400;
  color: var(--muted-text);
}
form input,
form select,
form textarea {
  width: 100%;
  padding: 0.4rem;
  border-radius: 0.4rem;
  border: 1px solid var(--input-border);
  font-size: 0.95rem;
  background: var(--input-bg);
  color: var(--text);
  transition: border 0.2s ease, box-shadow 0.2s ease;
}
form input::placeholder,
form textarea::placeholder {
  color: var(--input-placeholder);
}
form input:focus,
form select:focus,
form textarea:focus {
  outline: 2px solid var(--input-focus);
  border-color: var(--accent);
}
form textarea {
  min-height: 80px;
  resize: vertical;
}
.btn-row {
  margin-top: 0.8rem;
  display: flex;
  gap: 0.6rem;
  flex-wrap: wrap;
}
.panel-hint {
  margin-top: 0.4rem;
  color: var(--muted-text);
  font-size: 0.85rem;
}
.panel-hint.warning {
  color: var(--danger);
  font-weight: 600;
}
.case-form fieldset,
.panel fieldset[data-collapsible] {
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 1rem;
  margin: 0 0 1rem 0;
}
.case-form legend,
.panel fieldset[data-collapsible] > legend {
  font-weight: 600;
  padding: 0 0.4rem;
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  margin-bottom: 0.6rem;
}
.case-form legend .fieldset-title,
.panel fieldset[data-collapsible] > legend .fieldset-title {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
}
.case-form fieldset[data-collapsible],
.panel fieldset[data-collapsible] {
  position: relative;
}
.case-form fieldset[data-collapsible] .fieldset-toggle,
.panel fieldset[data-collapsible] .fieldset-toggle {
  border: none;
  background: transparent;
  color: var(--muted-text);
  font-size: 0.85rem;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  cursor: pointer;
  padding: 0.2rem 0.4rem;
  border-radius: 0.4rem;
  transition: color 0.2s ease, background 0.2s ease;
}
.case-form fieldset[data-collapsible] .fieldset-toggle::before,
.panel fieldset[data-collapsible] .fieldset-toggle::before {
  content: '−';
  font-size: 1rem;
  line-height: 1;
}
.case-form fieldset[data-collapsible].collapsed .fieldset-toggle::before,
.panel fieldset[data-collapsible].collapsed .fieldset-toggle::before {
  content: '+';
}
.case-form fieldset[data-collapsible] .fieldset-toggle:focus-visible,
.panel fieldset[data-collapsible] .fieldset-toggle:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.case-form fieldset[data-collapsible] .fieldset-toggle:hover,
.panel fieldset[data-collapsible] .fieldset-toggle:hover {
  color: var(--accent-strong);
  background: var(--accent-shadow);
}
.case-form fieldset[data-collapsible].collapsed,
.panel fieldset[data-collapsible].collapsed {
  padding-bottom: 0.6rem;
}
.case-form fieldset[data-collapsible].collapsed > legend,
.panel fieldset[data-collapsible].collapsed > legend {
  margin-bottom: 0;
}
.case-form fieldset[data-collapsible] .fieldset-body,
.panel fieldset[data-collapsible] .fieldset-body {
  display: block;
}
.case-form fieldset[data-collapsible][data-collapsed="true"] > .fieldset-body,
.case-form fieldset[data-collapsible].collapsed > .fieldset-body,
.panel fieldset[data-collapsible][data-collapsed="true"] > .fieldset-body,
.panel fieldset[data-collapsible].collapsed > .fieldset-body {
  display: none;
}
.case-form .inline-group {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 0.5rem;
}
.case-form .inline-group > label,
.case-form label.inline {
  flex: 1 1 220px;
}
.case-form label.inline {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.case-form .form-hint {
  margin: 0.2rem 0 0.6rem 0;
  color: var(--muted-text);
  font-size: 0.85rem;
}
.case-form .case-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  align-items: flex-end;
  margin-bottom: 0.75rem;
}
.case-form .case-row > label {
  flex: 1 1 180px;
}
.case-form .case-row > label.wide {
  flex: 1 1 100%;
}
.case-form .case-row textarea {
  min-height: 60px;
}
.case-form .case-row button {
  align-self: flex-start;
}
.variant-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 0.75rem;
  align-items: start;
}
.variant-row > label,
.variant-row > .variant-batch-group,
.variant-row > button {
  margin: 0;
}
.variant-row > label {
  min-width: 0;
}
.variant-row > label.wide,
.variant-row > .variant-batch-group > label.wide {
  grid-column: 1 / -1;
}
.variant-row > button {
  justify-self: flex-start;
  min-width: 160px;
}
.variant-row .variant-batch-group {
  display: contents;
}
.variant-row .variant-structure-grid {
  display: contents;
}
[data-variant-types][hidden],
[data-variant-types].variant-type-hidden {
  display: none !important;
}
.case-form .toggle {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.6rem 0;
  font-weight: 600;
  color: var(--muted-text);
}
.case-form .toggle input[type="checkbox"] {
  width: auto;
  accent-color: var(--accent);
}
.case-form textarea.small {
  min-height: 48px;
}
.table-actions {
  margin-top: 0.8rem;
  display: flex;
  justify-content: flex-end;
}
.table-actions button {
  min-width: 220px;
}
.list-toggle {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.6rem 0;
  font-weight: 600;
  color: var(--muted-text);
}
.list-toggle input[type="checkbox"] {
  width: auto;
  accent-color: var(--accent);
}
button.primary {
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 0.5rem;
  padding: 0.5rem 0.9rem;
  cursor: pointer;
}
button.danger {
  background: var(--danger);
  color: #fff;
}
button.secondary {
  background: var(--nav-button-bg);
  color: var(--nav-button-color);
  border: 1px solid transparent;
}
button.action-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.55rem;
  font-weight: 600;
  letter-spacing: 0.01em;
  border-radius: 0.75rem;
  padding: 0.55rem 1.1rem;
  border: 1px solid transparent;
  box-shadow: 0 6px 14px rgba(24, 111, 175, 0.12);
  transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease, color 0.18s ease;
}
button.action-button .icon-slot {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 1.9em;
  height: 1.9em;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.28);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
}
button.action-button svg {
  width: 1.35em;
  height: 1.35em;
  stroke: currentColor;
  stroke-width: 1.8;
  stroke-linecap: round;
  stroke-linejoin: round;
  fill: none;
}
button.action-button .label {
  display: inline-flex;
  align-items: center;
}
button.action-button:hover,
button.action-button:focus-visible {
  transform: translateY(-1px);
  box-shadow: 0 10px 18px rgba(24, 111, 175, 0.2);
}
button.action-button:focus-visible {
  outline: 3px solid var(--accent-shadow);
  outline-offset: 2px;
}
button.action-button.action-save,
button.action-button.action-save-new {
  background: linear-gradient(135deg, var(--accent), var(--accent-strong));
  color: #fff;
  box-shadow: 0 12px 20px var(--accent-shadow);
}
button.action-button.action-save-new {
  background: linear-gradient(135deg, #2a7fbe, var(--accent-strong));
}
button.action-button.action-save .icon-slot,
button.action-button.action-save-new .icon-slot {
  background: rgba(255, 255, 255, 0.32);
}
button.action-button.action-new {
  background: rgba(24, 111, 175, 0.1);
  color: var(--accent-strong);
  border-color: rgba(24, 111, 175, 0.35);
}
button.action-button.action-new .icon-slot {
  background: rgba(24, 111, 175, 0.18);
  box-shadow: inset 0 0 0 1px rgba(24, 111, 175, 0.35);
}
button.action-button.action-delete {
  background: linear-gradient(135deg, #d24b3c, var(--danger));
  color: #fff;
  box-shadow: 0 12px 20px rgba(192, 57, 43, 0.25);
}
button.action-button.action-delete .icon-slot {
  background: rgba(255, 255, 255, 0.26);
}
[data-theme="dark"] button.action-button.action-new {
  background: rgba(56, 189, 248, 0.16);
  color: #e0f2ff;
  border-color: rgba(56, 189, 248, 0.45);
  box-shadow: 0 8px 16px rgba(14, 165, 233, 0.25);
}
[data-theme="dark"] button.action-button .icon-slot {
  background: rgba(148, 163, 184, 0.24);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.38);
}
[data-theme="dark"] button.action-button.action-save .icon-slot,
[data-theme="dark"] button.action-button.action-save-new .icon-slot {
  background: rgba(226, 232, 240, 0.28);
}
[data-theme="dark"] button.action-button.action-new .icon-slot {
  background: rgba(56, 189, 248, 0.3);
}
[data-theme="dark"] button.action-button.action-delete .icon-slot {
  background: rgba(255, 255, 255, 0.24);
}
[data-theme="dark"] button.action-button.action-delete {
  box-shadow: 0 12px 20px rgba(239, 68, 68, 0.3);
}
button:disabled {
  opacity: 0.55;
  cursor: not-allowed;
}
.badge {
  display: inline-block;
  padding: 0.2rem 0.5rem;
  border-radius: 0.4rem;
  background: var(--badge-bg);
  color: var(--badge-color);
  font-size: 0.75rem;
}
.rsid-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  padding: 0.15rem 0.6rem;
  border-radius: 999px;
  background: var(--badge-bg);
  color: var(--accent-strong);
  font-weight: 600;
  text-decoration: none;
  border: 1px solid currentColor;
  transition: color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  line-height: 1.2;
}
.rsid-badge::after {
  content: '\2197';
  font-size: 0.75em;
  opacity: 0.8;
}
.rsid-badge:hover,
.rsid-badge:focus-visible {
  background: var(--accent-strong);
  color: #fff;
  box-shadow: 0 0 0 3px var(--accent-shadow);
}
input[type="search"] {
  border-radius: 1rem;
}
.filterable-select {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  margin-top: 0.3rem;
}
.filterable-select input[type="search"] {
  padding: 0.35rem 0.5rem;
}
.filterable-select select {
  max-height: 220px;
}
.report-variant-selector {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  align-items: flex-end;
  margin-top: 0.4rem;
}
.report-variant-selector .filterable-select {
  flex: 1 1 260px;
  margin-top: 0;
}
.conclusion-library-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  align-items: flex-end;
  margin-top: 0.4rem;
}
.conclusion-library-controls label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.conclusion-library-controls select {
  min-width: 220px;
}
.conclusion-library-buttons {
  display: flex;
  gap: 0.4rem;
  align-items: center;
}
.conclusion-library-buttons button {
  margin-top: 0.35rem;
}
.report-variant-list {
  margin-top: 0.6rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.report-variant-item {
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 0.6rem 0.75rem;
  box-shadow: inset 0 1px 0 rgba(15, 27, 45, 0.04);
}
[data-theme="dark"] .report-variant-item {
  background: rgba(15, 23, 42, 0.45);
}
.report-variant-item header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-weight: 600;
}
.report-variant-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem 0.8rem;
  margin-top: 0.35rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.report-variant-meta strong {
  font-weight: 600;
}
.report-variant-item p {
  margin: 0.35rem 0 0;
}
.report-variant-remove {
  background: none;
  border: none;
  color: var(--danger);
  cursor: pointer;
  padding: 0.15rem 0.35rem;
  border-radius: 0.4rem;
  font-size: 0.85rem;
}
.report-variant-remove:hover,
.report-variant-remove:focus {
  text-decoration: underline;
}
.report-variant-empty {
  color: var(--muted-text);
  font-style: italic;
  font-size: 0.9rem;
}
.report-variant-detail {
  margin-top: 0.75rem;
  padding: 0.6rem 0.8rem;
  border-left: 3px solid var(--accent);
  border-radius: 0.6rem;
  background: var(--panel-bg);
}
[data-theme="dark"] .report-variant-detail {
  background: rgba(15, 23, 42, 0.45);
}
.report-variant-detail h3 {
  margin: 0;
}
.report-variant-detail ul {
  margin: 0.4rem 0 0;
  padding-left: 1.2rem;
}
.report-variant-detail p {
  margin: 0.5rem 0 0;
}
.family-combo {
  display: flex;
  gap: 0.4rem;
  align-items: center;
  margin-top: 0.3rem;
}
.family-combo select {
  flex: 0 0 12rem;
}
.family-combo input {
  flex: 1 1 auto;
}
.advanced-filter {
  margin-top: 0.6rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.75rem;
  padding: 0.35rem 0.75rem;
  background: var(--panel-bg);
  box-shadow: inset 0 1px 2px rgba(15, 27, 45, 0.08);
}
.advanced-filter summary {
  cursor: pointer;
  font-weight: 600;
  color: var(--accent-strong);
  outline: none;
}
.advanced-filter summary::-webkit-details-marker {
  display: none;
}
.advanced-filter summary::after {
  content: '▾';
  float: right;
  transform: rotate(0deg);
  transition: transform 0.2s ease;
}
.advanced-filter[open] summary::after {
  transform: rotate(-180deg);
}
.advanced-filter .filter-grid {
  margin-top: 0.6rem;
  display: grid;
  gap: 0.6rem;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}
.advanced-filter label {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.advanced-filter input,
.advanced-filter select {
  font-size: 0.9rem;
}
.read-only-banner {
  background: rgba(192, 57, 43, 0.1);
  color: var(--danger);
  border: 1px dashed var(--danger);
  border-radius: 0.5rem;
  padding: 0.6rem 0.8rem;
  margin-bottom: 1rem;
  font-weight: 600;
}
pre {
  background: var(--code-bg);
  color: var(--code-text);
  padding: 0.8rem;
  border-radius: 0.6rem;
  overflow: auto;
}
@media (max-width: 900px) {
  header {
    flex-direction: column;
    align-items: stretch;
  }
  .header-actions {
    width: 100%;
    justify-content: space-between;
  }
  .auth-block,
  .quick-actions {
    width: 100%;
    justify-content: space-between;
  }
}
@media (max-width: 600px) {
  .auth-block form,
  .quick-actions {
    flex-direction: column;
    align-items: stretch;
  }
  .auth-block form > * {
    width: 100%;
  }
}
</style>
</head>
<body>
<header>
  <div class="brand">
    <span class="brand-mark" aria-hidden="true">
      <span class="icon-slot" data-icon="dna"></span>
    </span>
    <img id="glimrLogo" src="logo.png" alt="G" loading="lazy">
    <div>
      <h1>GlimR – Genetic LIMS Reporter</h1>
      <div id="statusBar">Initialiserer...</div>
    </div>
  </div>
  <div class="header-actions">
    <div class="auth-block" id="authBlock">
      <form id="loginForm">
        <select id="loginUser" required></select>
        <input id="loginPass" type="password" placeholder="Adgangskode (valgfri)">
        <button type="submit" class="primary with-icon">
          <span class="icon-slot" data-icon="arrow-right-on-rectangle"></span>
          <span>Log ind</span>
        </button>
      </form>
      <div class="user-info" id="userInfo" hidden>
        <span id="currentUserLabel"></span>
        <button type="button" class="secondary with-icon" id="logoutBtn">
          <span class="icon-slot" data-icon="arrow-left-on-rectangle"></span>
          <span>Log ud</span>
        </button>
      </div>
    </div>
    <div class="quick-actions">
      <button class="secondary with-icon" id="themeToggle">
        <span class="icon-slot" data-icon="moon"></span>
        <span>Skift til mørkt tema</span>
      </button>
    </div>
  </div>
</header>
<nav id="tabNav"></nav>
<main id="tabContent"></main>
<script>
(() => {
'use strict';
const DB_NAME = 'glims';
const DB_VER = 7;
const STORES = ['patients','samples','orders','patient_groups','panels','variants','qc','reports','users','audit','variant_library','responses','conclusion_library'];
const storage = (() => {
  try {
    const testKey = '__glimr_storage_test__';
    localStorage.setItem(testKey, '1');
    localStorage.removeItem(testKey);
    return localStorage;
  } catch (err) {
    console.warn('Local storage utilgængelig, bruger in-memory fallback.', err);
    const memory = new Map();
    return {
      getItem(key) {
        return memory.has(key) ? memory.get(key) : null;
      },
      setItem(key, value) {
        memory.set(key, String(value));
      },
      removeItem(key) {
        memory.delete(key);
      }
    };
  }
})();

const state = {
  db: null,
  cache: new Map(),
  creationLookup: new Map(),
  boundHandle: null,
  autosave: false,
  autosaveTimer: null,
  currentTab: 'dashboard',
  currentUser: null,
  theme: storage.getItem('glimr-theme') || 'light',
  testResults: [],
  lastStatus: '',
  usingMemoryDb: false,
  pendingOrderId: null,
  pendingOrderShowAll: false,
  pendingOrderFilterSampleId: null,
  pendingOrderFilterSampleExact: false,
  pendingOrderFilterId: null,
  pendingSampleId: null,
  pendingSampleShowAll: false,
  pendingReportFilterOrderId: null,
  pendingReportFilterSampleId: null,
  pendingReportFilterSampleExact: false,
  pendingReportShowAll: false,
  pendingReportSelectOrderId: null,
  pendingReportSelectReportId: null
};
const CREATED_BY_STORES = new Set(['patients','samples','orders','patient_groups','variants','qc','reports','conclusion_library']);
const UPDATED_BY_STORES = new Set(['panels']);
const ROLE_OPTIONS = [
  {value: 'Observatør', description: 'Kun læseadgang til data', canWrite: false},
  {value: 'Bioinformatiker', description: 'Kan registrere analyser og varianter', canWrite: true},
  {value: 'Skriver', description: 'Kan oprette og redigere alle laboratoriedata', canWrite: true},
  {value: 'Administrator', description: 'Fuld systemadgang inkl. brugeradministration', canWrite: true}
];
const WRITE_ROLE_KEYS = new Set(ROLE_OPTIONS.filter(opt => opt.canWrite).map(opt => opt.value.toLowerCase()));
function normaliseRoleValue(role) {
  return (role || '').toString().trim();
}
function findRoleOption(role) {
  const normalised = normaliseRoleValue(role).toLowerCase();
  return ROLE_OPTIONS.find(opt => opt.value.toLowerCase() === normalised) || null;
}
function roleLabel(role) {
  if (!role) return '';
  const match = findRoleOption(role);
  return match ? match.value : normaliseRoleValue(role);
}
function roleWithDescription(role) {
  if (!role) return '';
  const match = findRoleOption(role);
  if (!match) return normaliseRoleValue(role);
  return `${match.value} – ${match.description}`;
}
const classificationMap = {
  '1': {code:'LA6576-8', display:'Godartet'},
  '2': {code:'LA6577-6', display:'Sandsynligvis godartet'},
  '3': {code:'LA4489-6', display:'Variant af ukendt betydning (VUS)'},
  '4': {code:'LA6668-3', display:'Sandsynligvis patogen'},
  '5': {code:'LA6708-8', display:'Patogen'}
};
const tabs = [
  {id:'dashboard', label:'Overblik'},
  {id:'case_create', label:'Opret'},
  {id:'patients', label:'Patienter'},
  {id:'samples', label:'Prøver'},
  {id:'orders', label:'Ordinationer'},
  {id:'panels', label:'Analyser/Panels'},
  {id:'variants', label:'Varianter'},
  {id:'variant_library', label:'Variantbibliotek'},
  {id:'conclusion_library', label:'Standardtekster'},
  {id:'reports', label:'Rapporter'},
  {id:'qc', label:'Kvalitetskontrol'},
  {id:'responses', label:'Svar (MedCom)'},
  {id:'tools', label:'Værktøjskasse'},
  {id:'users', label:'Brugere'},
  {id:'audit', label:'Revision'},
  {id:'db', label:'Database & Backup'},
  {id:'admin', label:'Administration'},
  {id:'tests', label:'Selvtest'}
];
const tabIcons = {
  dashboard: 'chart-bar',
  case_create: 'folder-plus',
  patients: 'user-circle',
  samples: 'beaker',
  orders: 'document-text',
  panels: 'squares-2x2',
  variants: 'dna',
  variant_library: 'book-open',
  conclusion_library: 'clipboard-document',
  reports: 'document-chart-bar',
  qc: 'clipboard-document-check',
  responses: 'inbox',
  tools: 'wrench-screwdriver',
  users: 'user-group',
  audit: 'clock',
  db: 'circle-stack',
  admin: 'shield-check',
  tests: 'clipboard-document-list'
};
const ICON_NS = 'http://www.w3.org/2000/svg';
const iconLibrary = {
  'arrow-right-on-rectangle': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15m3 0 3-3m0 0-3-3m3 3H9'}
    ]
  },
  'arrow-left-on-rectangle': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15M12 9l-3 3m0 0 3 3m-3-3h12.75'}
    ]
  },
  'arrows-up-down': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M3 16.5l3 3m0 0 3-3m-3 3V4.5M21 7.5l-3-3m0 0-3 3m3-3v15'}
    ]
  },
  moon: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z'}
    ]
  },
  sun: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z'}
    ]
  },
  'chart-bar': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z'}
    ]
  },
  'folder-plus': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 10.5v6m3-3H9m4.06-7.19-2.12-2.12a1.5 1.5 0 0 0-1.061-.44H4.5A2.25 2.25 0 0 0 2.25 6v12a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9a2.25 2.25 0 0 0-2.25-2.25h-5.379a1.5 1.5 0 0 1-1.06-.44Z'}
    ]
  },
  'user-circle': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M17.982 18.725A7.488 7.488 0 0 0 12 15.75a7.488 7.488 0 0 0-5.982 2.975m11.963 0a9 9 0 1 0-11.963 0m11.963 0A8.966 8.966 0 0 1 12 21a8.966 8.966 0 0 1-5.982-2.275M15 9.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z'}
    ]
  },
  beaker: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M9.75 3.104v5.714a2.25 2.25 0 0 1-.659 1.591L5 14.5M9.75 3.104c-.251.023-.501.05-.75.082m.75-.082a24.301 24.301 0 0 1 4.5 0m0 0v5.714c0 .597.237 1.17.659 1.591L19.8 15.3M14.25 3.104c.251.023.501.05.75.082M19.8 15.3l-1.57.393A9.065 9.065 0 0 1 12 15a9.065 9.065 0 0 0-6.23-.693L5 14.5m14.8.8 1.402 1.402c1.232 1.232.65 3.318-1.067 3.611A48.309 48.309 0 0 1 12 21c-2.773 0-5.491-.235-8.135-.687-1.718-.293-2.3-2.379-1.067-3.61L5 14.5'}
    ]
  },
  'document-text': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z'}
    ]
  },
  'squares-2x2': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M3.75 6A2.25 2.25 0 0 1 6 3.75h2.25A2.25 2.25 0 0 1 10.5 6v2.25a2.25 2.25 0 0 1-2.25 2.25H6a2.25 2.25 0 0 1-2.25-2.25V6ZM3.75 15.75A2.25 2.25 0 0 1 6 13.5h2.25a2.25 2.25 0 0 1 2.25 2.25V18a2.25 2.25 0 0 1-2.25 2.25H6A2.25 2.25 0 0 1 3.75 18v-2.25ZM13.5 6a2.25 2.25 0 0 1 2.25-2.25H18A2.25 2.25 0 0 1 20.25 6v2.25A2.25 2.25 0 0 1 18 10.5h-2.25a2.25 2.25 0 0 1-2.25-2.25V6ZM13.5 15.75a2.25 2.25 0 0 1 2.25-2.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-2.25A2.25 2.25 0 0 1 13.5 18v-2.25Z'}
    ]
  },
  dna: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.6'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M8 3C11 5.2 11 9 8 11.5S5 17.8 8 21'},
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M16 3C13 5.2 13 9 16 11.5S19 17.8 16 21'},
      {'stroke-linecap': 'round', d: 'M6 5h4'},
      {'stroke-linecap': 'round', d: 'M14 5h4'},
      {'stroke-linecap': 'round', d: 'M6 11.5h4'},
      {'stroke-linecap': 'round', d: 'M14 11.5h4'},
      {'stroke-linecap': 'round', d: 'M6 18h4'},
      {'stroke-linecap': 'round', d: 'M14 18h4'}
    ]
  },
  'book-open': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25'}
    ]
  },
  'clipboard-document': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.057 1.123-.08M15.75 18H18a2.25 2.25 0 0 0 2.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 0 0-1.123-.08M15.75 18.75v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5A3.375 3.375 0 0 0 6.375 7.5H5.25m11.9-3.664A2.251 2.251 0 0 0 15 2.25h-1.5a2.251 2.251 0 0 0-2.15 1.586m5.8 0c.065.21.1.433.1.664v.75h-6V4.5c0-.231.035-.454.1-.664M6.75 7.5H4.875c-.621 0-1.125.504-1.125 1.125v12c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V16.5a9 9 0 0 0-9-9Z'}
    ]
  },
  'document-chart-bar': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25M9 16.5v.75m3-3v3M15 12v5.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z'}
    ]
  },
  'clipboard-document-check': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75 2.25 2.25 0 0 0-.1-.664m-5.8 0A2.251 2.251 0 0 1 13.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0 1 18 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3 1.5 1.5 3-3.75'}
    ]
  },
  inbox: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M2.25 13.5h3.86a2.25 2.25 0 0 1 2.012 1.244l.256.512a2.25 2.25 0 0 0 2.013 1.244h3.218a2.25 2.25 0 0 0 2.013-1.244l.256-.512a2.25 2.25 0 0 1 2.013-1.244h3.859m-19.5.338V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18v-4.162c0-.224-.034-.447-.1-.661L19.24 5.338a2.25 2.25 0 0 0-2.15-1.588H6.911a2.25 2.25 0 0 0-2.15 1.588L2.35 13.177a2.25 2.25 0 0 0-.1.661Z'}
    ]
  },
  'wrench-screwdriver': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M11.42 15.17 17.25 21A2.652 2.652 0 0 0 21 17.25l-5.877-5.877M11.42 15.17l2.496-3.03c.317-.384.74-.626 1.208-.766M11.42 15.17l-4.655 5.653a2.548 2.548 0 1 1-3.586-3.586l6.837-5.63m5.108-.233c.55-.164 1.163-.188 1.743-.14a4.5 4.5 0 0 0 4.486-6.336l-3.276 3.277a3.004 3.004 0 0 1-2.25-2.25l3.276-3.276a4.5 4.5 0 0 0-6.336 4.486c.091 1.076-.071 2.264-.904 2.95l-.102.085m-1.745 1.437L5.909 7.5H4.5L2.25 3.75l1.5-1.5L7.5 4.5v1.409l4.26 4.26m-1.745 1.437 1.745-1.437m6.615 8.206L15.75 15.75M4.867 19.125h.008v.008h-.008v-.008Z'}
    ]
  },
  'user-group': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M18 18.72a9.094 9.094 0 0 0 3.741-.479 3 3 0 0 0-4.682-2.72m.94 3.198.001.031c0 .225-.012.447-.037.666A11.944 11.944 0 0 1 12 21c-2.17 0-4.207-.576-5.963-1.584A6.062 6.062 0 0 1 6 18.719m12 0a5.971 5.971 0 0 0-.941-3.197m0 0A5.995 5.995 0 0 0 12 12.75a5.995 5.995 0 0 0-5.058 2.772m0 0a3 3 0 0 0-4.681 2.72 8.986 8.986 0 0 0 3.74.477m.94-3.197a5.971 5.971 0 0 0-.94 3.197M15 6.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm6 3a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Zm-13.5 0a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Z'}
    ]
  },
  clock: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z'}
    ]
  },
  'circle-stack': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M20.25 6.375c0 2.278-3.694 4.125-8.25 4.125S3.75 8.653 3.75 6.375m16.5 0c0-2.278-3.694-4.125-8.25-4.125S3.75 4.097 3.75 6.375m16.5 0v11.25c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125V6.375m16.5 0v3.75m-16.5-3.75v3.75m16.5 0v3.75C20.25 16.153 16.556 18 12 18s-8.25-1.847-8.25-4.125v-3.75m16.5 0c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125'}
    ]
  },
  'shield-check': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M9 12.75 11.25 15 15 9.75m-3-7.036A11.959 11.959 0 0 1 3.598 6 11.99 11.99 0 0 0 3 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285Z'}
    ]
  },
  'clipboard-document-list': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 0 0 2.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 0 0-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75 2.25 2.25 0 0 0-.1-.664m-5.8 0A2.251 2.251 0 0 1 13.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m0 0H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V9.375c0-.621-.504-1.125-1.125-1.125H8.25ZM6.75 12h.008v.008H6.75V12Zm0 3h.008v.008H6.75V15Zm0 3h.008v.008H6.75V18Z'}
    ]
  }
};
function createIconElement(name) {
  const def = iconLibrary[name];
  if (!def) return null;
  const svg = document.createElementNS(ICON_NS, 'svg');
  svg.classList.add('icon');
  svg.setAttribute('viewBox', def.viewBox || '0 0 24 24');
  svg.setAttribute('aria-hidden', 'true');
  const attrs = def.attrs || {};
  Object.entries(attrs).forEach(([key, value]) => svg.setAttribute(key, value));
  (def.paths || []).forEach(segment => {
    const node = document.createElementNS(ICON_NS, segment.type || 'path');
    Object.entries(segment).forEach(([key, value]) => {
      if (key === 'type') return;
      node.setAttribute(key, value);
    });
    svg.appendChild(node);
  });
  return svg;
}
function setIcon(slot, name) {
  if (!slot) return;
  slot.dataset.icon = name;
  const icon = createIconElement(name);
  slot.innerHTML = '';
  if (icon) {
    slot.appendChild(icon);
  }
}
function applyIconSlots(scope = document) {
  const root = scope instanceof Element || scope instanceof DocumentFragment ? scope : document;
  root.querySelectorAll('.icon-slot[data-icon]').forEach(slot => {
    setIcon(slot, slot.dataset.icon);
  });
}
applyIconSlots(document);
const SAMPLE_TYPES = ['Blod','Kindskrab','Biopsi','Kontrol'];
const SAMPLE_STATUSES = ['Modtaget','Afventer','QC','Analyse','Tolkning','Rapport','Svaret','Biobank','Annulleret'];
const INACTIVE_SAMPLE_STATUSES = new Set(['svaret','biobank','annulleret']);
function isActiveStatus(status) {
  return !INACTIVE_SAMPLE_STATUSES.has((status || '').toLowerCase());
}
const DEFAULT_PATIENT_GROUPS = [
  'Arvelige hjertesygdomme',
  'Arvelig hæmatologisk sygdom',
  'Arvelige kolestatiske og fibrotiske leversygdomme',
  'Audiogenetik',
  'Endokrinologiske patienter',
  'Føtal medicin',
  'Hæmatologisk kræft',
  'Kræft hos børn og unge (op til 18 år)',
  'Arvelig kræft hos voksne',
  'Neurogenetiske patienter',
  'Nyresvigt',
  'Oftalmologi',
  'Primær immundefekt',
  'Psykiatri børn og unge',
  'Sjældne sygdomme hos børn og voksne',
  'Svære arvelige hudsygdomme',
  'Udbredt og uhelbredelig kræft'
];
const schemaFields = {
  patients: ['id','mrn','extra_id','family_number','name','gender','birth_date','notes','created_by','created_at','updated_at'],
  samples: ['id','pmb_number','patient_id','sample_type','collected_at','status','notes','created_by','created_at','updated_at'],
  panels: ['id','name','description','version','gene_list','gene_count','created_at','updated_at','updated_by'],
  orders: ['id','patient_id','sample_id','panel_id','analysis_responsible_id','interpreter_id','approver_id','clinician','indication','patient_group_id','hpo_terms','status','acute','urgent','ordered_at','created_by','created_at','updated_at'],
  patient_groups: ['id','name','created_by','created_at','updated_at'],
  variants: ['id','order_id','variant_type','gene','transcript','hgvs_c','hgvs_p','rsid','zygosity','classification','criteria','af','annotations','interpretation','genome_build','chromosome','start','end','copy_number','sv_subtype','size_bp','iscn','description','affected_genes','created_by','created_at','updated_at'],
  qc: ['id','sample_id','metric','value','unit','notes','created_by','created_at','updated_at'],
  reports: ['id','order_id','findings','variant_ids','variant_details','summary','status','issued_at','created_by','created_at','updated_at'],
  users: ['id','name','email','role','pin','created_at','updated_at'],
  audit: ['id','ts','user','action','entity','entity_id','before','after','created_at','updated_at'],
  variant_library: ['id','variant_type','gene','transcript','hgvs_c','hgvs_p','rsid','classification','criteria','evidence','condition','inheritance','genome_build','chromosome','start','end','copy_number','sv_subtype','size_bp','iscn','description','affected_genes','curated_by','last_review','created_at','updated_at'],
  responses: ['id','ts','sender','patient','diagnostic_report_id','variant_count','variants','raw','created_at','updated_at'],
  conclusion_library: ['id','title','body','created_by','created_at','updated_at']
};
const tooltipCatalog = {
  tabs: {
    dashboard: 'Viser nøgletal, seneste ordinationer og seneste revisionshændelser.',
    case_create: 'Opret patient, prøve, ordination, QC og varianter i ét samlet flow.',
    patients: 'Administrer patientoplysninger og søg i patientlisten.',
    samples: 'Registrer og vedligehold prøver knyttet til patienter.',
    orders: 'Administrer analyseordinationer og deres status.',
    panels: 'Vedligehold assays og analysepaneler.',
    variants: 'Registrer genetiske varianter for ordinationer.',
    variant_library: 'Se og vedligehold det kuraterede variantbibliotek.',
    conclusion_library: 'Administrer standardtekster til rapportkonklusioner.',
    reports: 'Opret og redigér laboratoriesvar og rapporter.',
    qc: 'Registrer kvalitetskontrolmålinger for prøver.',
    responses: 'Importer og gennemse MedCom/FHIR-svar.',
    tools: 'Åbn værktøjskassen med beregnere og hjælpeværktøjer til variantfortolkning.',
    users: 'Administrer GlimR-brugere og roller.',
    audit: 'Gennemgå revisionsloggen for alle ændringer.',
    db: 'Håndter lokal databasefil, backup og autogem.',
    admin: 'Tilgå administrative værktøjer, SQL og ZIP-eksport.',
    tests: 'Kør indbyggede selvtests og se resultater.'
  },
  metrics: {
    'Patienter': 'Antal registrerede patienter i databasen.',
    'Prøver': 'Antal registrerede laboratorieprøver.',
    'Ordinationer': 'Samlet antal aktive og historiske ordinationer.',
    'Modtaget': 'Prøver registreret som modtaget i laboratoriet.',
    'Aktive': 'Prøver i aktiv behandling (QC, Analyse, Tolkning eller Rapport).',
    'Analyse': 'Prøver markeret som i analysefasen.',
    'Tolkning': 'Prøver under tolkning af resultater.',
    'Rapport': 'Prøver i rapporteringsfasen.',
    'Varianter': 'Antal registrerede genetiske varianter.',
    'Biobank': 'Prøver arkiveret i biobanken.'
  },
  headers: {
    'ID': 'Internt ID for posten eller patientens supplerende ID (valgfrit).',
    'MRN': 'Medicinsk journalnummer eller CPR-reference.',
    'Ekstra ID': 'Supplerende identifikator for patienten (valgfrit).',
    'Familienummer': 'Eksternt familienummer brugt til at gruppere beslægtede patienter.',
    'Navn': 'Navnet på patient, panel eller bruger.',
    'Rolle': 'Din registrerede funktion i relation til ordinationen (fx Analytiker eller Godkender).',
    'Køn': 'Patientens registrerede køn.',
    'Født': 'Patientens fødselsdato.',
    'Patient': 'Tilknyttet patient til posten.',
    'Prøve': 'Prøve-ID eller beskrivelse.',
    'Prøvetype': 'Type af biologisk materiale.',
    'Panel': 'Navn på det analyserede panel.',
    'Version': 'Versionsnummer for panelet. Øges automatisk ved ændringer men kan justeres manuelt.',
    'Opdateret af': 'Bruger der senest har gemt ændringer på panelet.',
    'Analyseansvarlig': 'Bruger der har det overordnede ansvar for analysen.',
    'Tolker': 'Bruger der tolker de genetiske fund.',
    'Godkender': 'Bruger der godkender ordinationen eller rapporten.',
    'Indikation': 'Klinisk indikation angivet for ordinationen.',
    'Indikationer': 'Kommasepareret liste over ordinationers indikationer for patienten.',
    'HPO-termer': 'Registrerede HPO-termer knyttet til ordinationen.',
    'Status': 'Aktuel status for posten.',
    'Opdateret': 'Seneste ændringstidspunkt.',
    'Antal gener': 'Optalt antal gener i panelets genliste.',
    'Genliste': 'Kommasepareret liste over gener inkluderet i panelet.',
    'Bestilt': 'Tidspunkt for oprettelse af ordinationen.',
    'Genveje': 'Genveje til relaterede visninger for ordinationen.',
    'Opsamlet': 'Dato og tidspunkt for prøveindsamling.',
    'Ordination': 'Reference til ordinationen.',
    'Gen': 'Genet hvor varianten er fundet.',
    'Transkript': 'Reference-transkript for varianten.',
    'HGVS c.': 'HGVS-beskrivelse på cDNA-niveau.',
    'HGVS p.': 'HGVS-beskrivelse på protein-niveau.',
    'rsID': 'dbSNP-referencenummer (rsID) for SNV/indel.',
    'Klasse': 'ACMG-klassifikation 1–5.',
    'Kriterier': 'Anvendte ACMG-kriterier.',
    'HGVS': 'HGVS-beskrivelse for varianten.',
    'Evidens': 'Kurateret evidens for varianten.',
    'Kurateret af': 'Navn på ansvarlig kurator.',
    'Sidst gennemgået': 'Dato for seneste kuratoriske gennemgang.',
    'Tilstand': 'Associeret sygdom eller klinisk tilstand.',
    'Nedarvning': 'Beskriver variantens nedarvningsmønster.',
    'Oprettet': 'Tidspunkt for hvornår posten blev oprettet.',
    'Opdateret': 'Tidspunkt for den seneste ændring.',
    'Beskrivelse': 'Uddybende beskrivelse.',
    'Måling': 'Navn på kvalitetskontrolmålingen.',
    'Værdi': 'Målt værdi.',
    'Enhed': 'Måleenhed for værdien.',
    'Tid': 'Tidsstempel for hændelsen.',
    'Handling': 'Registreret handlingstype.',
    'Entitet': 'Tabellen som blev ændret.',
    'Før': 'Data før ændringen.',
    'Efter': 'Data efter ændringen.',
    'Sender': 'Afsendende organisation eller system.',
    'Rapport': 'DiagnosticReport-identifikator.',
    'Varianter': 'Antal varianter i posten.',
    'Udstedt': 'Tidspunkt hvor rapporten blev udsendt.',
    'Test': 'Navn på selvtesten.',
    'Detaljer': 'Supplerende oplysninger til testen.'
  },
  search: {
    patientSearch: 'Filtrer patientlisten efter navn, MRN, ID, familienummer eller køn.',
    sampleSearch: 'Filtrer prøver efter ID, PMB-nummer, status eller type.',
      panelSearch: 'Find paneler efter navn, version, bruger eller gener.',
    orderSearch: 'Søg efter ordination ud fra status eller ID.',
    variantSearch: 'Søg efter varianter baseret på gen eller HGVS.',
    libSearch: 'Filtrer variantbiblioteket efter gen eller HGVS.',
    reportSearch: 'Find rapporter ved at søge på status.',
    qcSearch: 'Søg efter kvalitetsmålinger.',
    userSearch: 'Søg brugere på navn, e-mail eller rolle.'
  },
  forms: {
    patientForm: {
      mrn: 'Patientens MRN/CPR til entydig identifikation.',
      extra_id: 'Supplerende identifikator til intern brug (valgfrit).',
      family_number: 'Familienummer anvendt til at gruppere beslægtede patienter.',
      name: 'Patientens fulde navn som angivet i journalen.',
      gender: 'Registreret køn for patienten.',
      birth_date: 'Patientens fødselsdato (ÅÅÅÅ-MM-DD).',
      notes: 'Evt. kliniske noter om patienten.'
    },
    sampleForm: {
      patient_id: 'Vælg hvilken patient prøven tilhører.',
      pmb_number: 'Unikt PMB-nummer anvendt i andre systemer.',
      sample_type: 'Vælg prøvetype fra listen.',
      status: 'Prøvens aktuelle laboratoriestatus.',
      collected_at: 'Dato og tidspunkt for prøveindsamling.',
      notes: 'Evt. bemærkninger til prøven.'
    },
    panelForm: {
      name: 'Navn på analysepanelet eller assay.',
      description: 'Beskriv kort panelets indhold og formål.',
      gene_list: 'Kommasepareret liste over gener der indgår i panelet. Antallet beregnes automatisk.'
    },
    orderForm: {
      patient_id: 'Vælg patienten ordinationen vedrører.',
      sample_id: 'Vælg den prøve der analyseres.',
      panel_id: 'Vælg panel for analysen (valgfrit).',
      analysis_responsible_id: 'Vælg hvem der er analyseansvarlig.',
      interpreter_id: 'Vælg den bruger der tolker resultaterne.',
      approver_id: 'Vælg den bruger der godkender ordinationen.',
      clinician: 'Navn på rekvirerende kliniker eller afdeling.',
      indication: 'Klinisk indikation eller henvisningsårsag for ordinationen.',
      patient_group_id: 'Valgfrit – klassificér ordinationen efter patientgruppe.',
      hpo_terms: 'Valgfri liste over relevante HPO-termer (én per linje eller separeret af semikolon).',
      status: 'Ordinationens arbejdsgangstatus.',
      acute: 'Markér ordinationen som akut – vises med rødt advarselsikon i oversigten.',
      urgent: 'Markér ordinationen som haster – vises med gult advarselsikon i oversigten.',
      ordered_at: 'Tidspunkt for oprettelse af ordinationen.'
    },
    variantForm: {
      order_id: 'Ordination som varianten er registreret på.',
      variant_type: 'Vælg om fundet er en SNV/indel, CNV, strukturel variant eller cytogenetisk forandring.',
      gene: 'Gen-symbol eller primære gener for fundet.',
      transcript: 'Reference-transkript (fx NM_) for SNV/indel.',
      hgvs_c: 'HGVS-beskrivelse på cDNA-niveau (SNV/indel).',
      hgvs_p: 'HGVS-beskrivelse på protein-niveau (SNV/indel).',
      rsid: 'dbSNP-reference (rsID), fx rs80357713, for SNV/indel.',
      zygosity: 'Zygositetsstatus (fx heterozygot).',
      classification: 'ACMG-klassifikation 1 (godartet) – 5 (patogen).',
      criteria: 'Anfør anvendte ACMG- eller CNV-kriterier, adskilt af komma.',
      af: 'Allelfrekvens eller observationsfrekvens.',
      annotations: 'Supplerende annoteringer fra eksterne værktøjer såsom VarSeq.',
      interpretation: 'Klinisk tolkning og evidens for varianten.',
      genome_build: 'Angiv reference-genom (fx GRCh38) for CNV/SV.',
      chromosome: 'Kromosom eller kromosomarm for CNV/SV.',
      start: 'Genomisk startposition.',
      end: 'Genomisk slutposition.',
      copy_number: 'Angiv kopital (fx x1, x3) ved CNV/aneuploidi.',
      sv_subtype: 'Vælg strukturtype for CNV/SV/cytogenetiske fund.',
      size_bp: 'Variantens størrelse i baser eller Mb.',
      iscn: 'ISCN-beskrivelse af cytogenetisk fund.',
      description: 'Valgfri fri tekst til yderligere beskrivelse.',
      affected_genes: 'Liste over berørte gener ved CNV/SV.'
    },
    variantLibraryForm: {
      variant_type: 'Varianttype for biblioteksposten.',
      gene: 'Gen-symbol eller primære gener.',
      transcript: 'Reference-transkript brugt til kurateringen.',
      hgvs_c: 'HGVS cDNA-beskrivelse (SNV/indel).',
      hgvs_p: 'HGVS protein-beskrivelse (SNV/indel).',
      rsid: 'dbSNP-reference (rsID) knyttet til varianten.',
      classification: 'Kurateret ACMG-klassifikation eller tilsvarende vurdering.',
      criteria: 'De kriterier der understøtter klassifikationen.',
      evidence: 'Sammendrag af litteratur, observationer eller noter.',
      condition: 'Associeret sygdom eller klinisk tilstand.',
      inheritance: 'Beskriv nedarvningsmønstret, fx autosomal dominant.',
      genome_build: 'Reference-genom for CNV/SV.',
      chromosome: 'Kromosom/karyotypisk lokalisation.',
      start: 'Genomisk startposition.',
      end: 'Genomisk slutposition.',
      copy_number: 'Kopital for CNV eller aneuploidi.',
      sv_subtype: 'Vælg strukturtype fra listen for CNV/SV/cytogenetik.',
      size_bp: 'Størrelse i baser eller Mb.',
      iscn: 'ISCN-streng for cytogenetiske beskrivelser.',
      description: 'Supplerende fri tekst.',
      affected_genes: 'Berørte gener i varianten.',
      curated_by: 'Navn på kurator eller team der har ansvaret.',
      last_review: 'Dato for seneste gennemgang (ÅÅÅÅ-MM-DD).'
    },
    conclusionLibraryForm: {
      title: 'Sigende titel, fx formål eller patientgruppe.',
      body: 'Standardtekst der kan indsættes som rapportkonklusion.'
    },
    reportForm: {
      order_id: 'Ordinationen som rapporten beskriver.',
      status: 'Rapportstatus (udkast, endelig eller ændret).',
      issued_at: 'Dato og tidspunkt for rapportens udsendelse.',
      variant_ids: 'Tilføj de registrerede varianter, der skal indgå i rapporten.',
      summary: 'Kort konklusion til modtageren.'
    },
    qcForm: {
      sample_id: 'Vælg den prøve QC-målingen relaterer til.',
      metric: 'Navn på kvalitetskontrolparameteren.',
      value: 'Målt værdi for QC-parameteren.',
      unit: 'Måleenhed (fx %, ng/µl).',
      notes: 'Supplerende noter om målingen.'
    },
    primerTool: {
      sequence: 'Indsæt sekvensen som primere skal designes imod (tillader A/C/G/T/U/N).',
      start: '1-baseret startposition for det ønskede amplicon (valgfri).',
      end: '1-baseret slutposition for ampliconet (valgfri).',
      min_len: 'Mindste længde for foreslåede primere.',
      max_len: 'Største længde for foreslåede primere.',
      target_tm: 'Ønsket smeltetemperatur (Tm) for primerparret i °C.'
    },
    createCaseForm: {
      patient_mrn: 'Patientens MRN eller CPR til entydig identifikation.',
      patient_extra_id: 'Supplerende identifikator til lokal brug (valgfrit).',
      patient_family: 'Evt. familienummer der kobler patienten til andre sager.',
      patient_name: 'Patientens fulde navn.',
      patient_gender: 'Patientens registrerede køn.',
      patient_birth: 'Patientens fødselsdato.',
      patient_notes: 'Evt. kliniske noter om patienten.',
      sample_pmb: 'Unikt PMB-nummer for den primære prøve.',
      sample_type: 'Vælg prøvetype for hovedprøven.',
      sample_status: 'Status for prøven og den tilknyttede ordination.',
      sample_collected: 'Dato og tidspunkt for prøveindsamlingen.',
      sample_notes: 'Noter om hovedprøven.',
      control_pmb: 'PMB-nummer for kontrolprøven.',
      control_type: 'Prøvetype for kontrolprøven.',
      control_status: 'Status for kontrolprøven.',
      control_collected: 'Dato og tidspunkt for kontrolprøven.',
      control_notes: 'Noter om kontrolprøven.',
      order_panel_id: 'Vælg hvilket panel ordinationen omfatter.',
      order_analysis_responsible: 'Vælg analyseansvarlig bruger.',
      order_interpreter: 'Vælg den bruger der tolker fundene.',
      order_approver: 'Vælg den bruger der godkender ordinationen.',
      order_clinician: 'Rekvirerende kliniker eller afdeling.',
      order_indication: 'Klinisk indikation eller henvisningsårsag for ordinationen.',
      order_acute: 'Markér ordinationen som akut – vises med rødt advarselsikon i oversigten.',
      order_urgent: 'Markér ordinationen som haster – vises med gult advarselsikon i oversigten.',
      order_patient_group: 'Valgfrit – vælg patientgruppe for ordinationen.',
      order_hpo_terms: 'Valgfri liste over HPO-termer (én per linje eller separeret af semikolon).',
      order_ordered_at: 'Tidspunkt hvor ordinationen registreres.'
    },
    userForm: {
      name: 'Brugerens fulde navn.',
      email: 'Brugerens arbejds-e-mailadresse.',
      role: 'Vælg brugerrolle for at fastlægge læse- eller skriveadgang.',
      pin: 'Valgfri adgangskode, der kræves ved login for brugeren.'
    }
  },
  buttons: {
    demoDataBtn: 'Indlæser et demodatasæt til hurtig afprøvning (kræver skriveadgang).',
    runTestsBtn: 'Kører den indbyggede selvtest og viser resultater.',
    resetDataBtn: 'Downloader en fuld backup og rydder alle data undtagen brugerlisten.',
    patientClear: 'Ryd formularen for at registrere en ny patient.',
    patientDelete: 'Slet den valgte patient permanent.',
    sampleClear: 'Ryd formularen for at registrere en ny prøve.',
    sampleDelete: 'Slet den valgte prøve.',
    panelClear: 'Ryd formularen for at oprette et nyt panel.',
    panelDelete: 'Slet det valgte panel.',
    panelsExport: 'Eksportér den filtrerede panelliste som tekstfil.',
    orderClear: 'Ryd formularen for at oprette en ny ordination.',
    orderDelete: 'Slet den valgte ordination.',
    variantClear: 'Ryd formularen for at registrere en ny variant.',
    variantSaveNew: 'Gem varianten som en ny registrering uden at overskrive den valgte.',
    variantDelete: 'Slet den valgte variant.',
    variantToLibrary: 'Tilføj varianten til det kuraterede bibliotek.',
    variantFromLibrary: 'Hent variantoplysninger fra biblioteket.',
    variantLibraryClear: 'Ryd formularen for at oprette en ny bibliotekspost.',
    variantLibraryDelete: 'Slet den valgte bibliotekspost.',
    variantLibrarySaveNew: 'Gem biblioteksposten som en ny registrering.',
    variantLibrarySave: 'Gem ændringerne til den valgte bibliotekspost.',
    libraryExportCsv: 'Eksportér de viste biblioteksposter til en CSV-fil.',
    libraryImportCsv: 'Importer biblioteksposter fra en CSV-fil.',
    conclusionLibraryClear: 'Ryd formularen for at oprette en ny standardtekst.',
    conclusionLibraryDelete: 'Slet den valgte standardtekst.',
    conclusionLibraryInsert: 'Erstat konklusionsfeltet med den valgte standardtekst.',
    conclusionLibraryAppend: 'Tilføj den valgte tekst til eksisterende konklusion.',
    reportClear: 'Ryd formularen for at skrive en ny rapport.',
    reportDelete: 'Slet den valgte rapport.',
    reportPreview: 'Åbn rapporten i en ny fane til forhåndsvisning.',
    reportAddVariant: 'Tilføj den valgte variant til rapporten.',
    qcClear: 'Ryd formularen for at registrere en ny QC-måling.',
    qcDelete: 'Slet den valgte QC-måling.',
    userClear: 'Ryd formularen for at oprette en ny bruger.',
    userDelete: 'Slet den valgte bruger.',
    acmgReset: 'Ryd alle valgte ACMG-kriterier.',
    distanceSwap: 'Byt start- og slutposition for beregningen.',
    primerDesign: 'Analyser sekvensen og foreslå et primerpar baseret på indstillingerne.',
    primerClear: 'Ryd formularen for at starte et nyt primerdesign.',
    gcUpper: 'Fjern mellemrum og konverter sekvensen til store bogstaver.',
    gcReverse: 'Beregn og indsæt den omvendt komplementære sekvens.',
    blastSubmit: 'Sender sekvensen til NCBI BLAST i en ny fane.',
    blastClear: 'Rydder felterne for en ny BLAST-forespørgsel.',
    patientsExport: 'Eksportér den aktuelt filtrerede patientliste til en CSV-fil.',
    samplesExport: 'Eksportér de filtrerede prøver som CSV til deling eller videre analyse.',
    ordersExport: 'Eksportér ordinationerne der matcher filtrene som CSV.',
    variantsExport: 'Eksportér filtrerede varianter inklusive ACMG-data til CSV.',
    reportsExport: 'Eksportér rapportlisten med de valgte filtre som CSV.',
    themeToggle: 'Skifter mellem lyst og mørkt layout for GlimR.',
    logoutBtn: 'Log brugeren ud og lås GlimR for redigering.',
    generateFhir: 'Generér og download et FHIR-svar for ordinationen.',
    previewFhir: 'Vis FHIR-bundlen som JSON uden download.',
    downloadSql: 'Download komplet MySQL-dump af GlimR-data.',
    showSchema: 'Vis MySQL-skemaet direkte på siden.',
    downloadZip: 'Download ZIP med GlimR og aktuelle data.',
    bindFile: 'Vælg eller opret en lokal databasefil til autogem.',
    saveNow: 'Gem straks til den tilknyttede databasefil.',
    downloadBackup: 'Eksportér alle data som JSON-backup.',
    submit: 'Gemmer formularens indhold i databasen.',
    addQcRow: 'Tilføj en ekstra QC-måling til prøven.',
    addVariantRow: 'Tilføj endnu en variant til ordinationen.',
    caseImportVarSeq: 'Importer varianter fra en VarSeq-CSV direkte i oprettelsesflowet.',
    variantBatchAdd: 'Tilføj en tom række til masseoprettelse af varianter.',
    variantBatchImport: 'Importer en VarSeq-CSV og udfyld rækkerne automatisk.',
    variantBatchSave: 'Gem alle udfyldte rækker på den valgte ordination.',
    variantBatchClear: 'Ryd alle midlertidige rækker uden at gemme dem.',
    createCaseSubmit: 'Opretter patient, prøve, ordination, QC og varianter i ét trin.',
    createCaseReset: 'Ryd alle felter i oprettelsesformularen.',
    'Vælg fra bibliotek': 'Hent variantoplysninger fra biblioteket.'
  },
  controls: {
    autosaveToggle: 'Aktiver eller deaktiver automatisk gemning til fil.',
    fhirOrderSelect: 'Vælg hvilken ordination der skal bruges til FHIR-svar.',
    fhirImportLabel: 'Importer en modtaget FHIR JSON-fil.',
    fhirPreview: 'JSON-visning af den genererede FHIR-bundle.',
    reportVariantSelect: 'Vælg blandt ordinationens registrerede varianter.',
    reportVariantList: 'Varianter der er føjet til rapportens fund.',
    restoreLabel: 'Gendan databasen fra en tidligere JSON-backup.',
    schemaText: 'Viser MySQL-skema og INSERT-statements til reference.',
    patientsFilterPanel: 'Åbn avancerede filtre for at søge præcist i patientlisten.',
    samplesFilterPanel: 'Finfiltrér prøver efter patient, status og indsamlingstid.',
    ordersFilterPanel: 'Filtrer ordinationer på patient, panel, status og dato.',
    variantsFilterPanel: 'Indsnævr variantoversigten efter gen, ordination og ACMG-klasse.',
    reportsFilterPanel: 'Begræns rapportlisten efter status, ordination og udstedelsesdato.',
    loginUser: 'Vælg hvilken GlimR-bruger der skal logges ind.',
    loginPass: 'Indtast brugerens adgangskode hvis der er opsat en PIN.',
    includeControlSample: 'Aktiver for at registrere en ekstra kontrolprøve på samme patient.',
    orderStatusPreview: 'Viser hvilken status den nye ordination får. Status følger prøvens valg.',
    caseVariantHint: 'Information om tilknyttede varianter i den nye sag.',
    variantLibraryImportInput: 'Vælg en CSV-fil der indeholder biblioteksposter til import.',
    caseImportVarSeqInput: 'Vælg en VarSeq CSV-fil med fund, som skal tilføjes til sagen.',
    variantBatchOrder: 'Vælg den ordination som de importerede varianter skal knyttes til.',
    variantBatchMessage: 'Status og advarsler for masseoprettelse af varianter.',
    variantBatchFile: 'Vælg en VarSeq CSV-fil til masseimport.',
    acmgTool: 'Vælg de kriterier der er opfyldt, for at få et ACMG-forslag.',
    distanceTool: 'Indtast to koordinater for at udregne den genomiske afstand.',
    distanceStart: 'Genomisk startposition, fx 123456 eller chr7:123456.',
    distanceEnd: 'Genomisk slutposition. Bogstaver ignoreres automatisk.',
    distanceResult: 'Viser antal baser mellem positionerne (inkl./ekskl.).',
    primerTool: 'Design primere ud fra en målsekvens og ønskede parametre.',
    primerSequence: 'Indsæt målsekvensen for primerdesign (A/C/G/T/U/N tilladt).',
    primerStart: '1-baseret startposition for det ønskede amplicon (valgfri).',
    primerEnd: '1-baseret slutposition for ampliconet (valgfri).',
    primerMinLen: 'Mindste længde for foreslåede primere.',
    primerMaxLen: 'Største længde for foreslåede primere.',
    primerTargetTm: 'Ønsket smeltetemperatur (Tm) for primerparret.',
    primerResult: 'Opsummerer det foreslåede primerpar og relevante advarsler.',
    gcSequence: 'Indsæt DNA/RNA-sekvens for at beregne længde og GC%.',
    acmgResult: 'Opsummering af den foreslåede klassifikation baseret på kriterierne.',
    gcResult: 'Opsummerer længde, GC% og basefordeling for sekvensen.',
    blastForm: 'Send sekvensen til NCBI BLAST via en ny browserfane.',
    blastProgram: 'Vælg BLAST-program ud fra om sekvensen er nukleotid eller protein.',
    blastDatabase: 'Vælg hvilken NCBI-database der skal søges imod.',
    blastExpect: 'Valgfrit E-værditærskel (fx 1e-5) for resultaterne.',
    blastTitle: 'Valgfri titel der indsættes som FASTA-header hvis den mangler.',
    blastOrganism: 'Filtrér mod en organisme via Entrez-søgestreng (fx Homo sapiens [taxid:9606]).',
    blastQuery: 'Indsæt DNA- eller proteinsekvens (FASTA eller rå tekst).',
    blastMegablast: 'Brug MEGABLAST for hurtig søgning efter meget lignende DNA-sekvenser (kun blastn).',
    blastStatus: 'Statusbeskeder for BLAST-forespørgsler og eventuelle fejl.'
  }
};
function setTooltip(el, text) {
  if (!el || !text) return;
  el.title = text;
  el.dataset.tip = text;
  el.setAttribute('aria-label', text);
}
function annotateHeaders(root) {
  if (!root) return;
  root.querySelectorAll('th').forEach(th => {
    const key = th.textContent.trim();
    const tip = tooltipCatalog.headers[key] || `Kolonne: ${key}`;
    setTooltip(th, tip);
  });
}
function annotateTableCells(root) {
  if (!root) return;
  root.querySelectorAll('tbody td').forEach(td => {
    const nested = td.querySelector('[data-full-text]');
    const fullText = td.dataset.fullText || nested?.dataset.fullText || '';
    const text = fullText || td.textContent.trim();
    if (!text) return;
    setTooltip(td, text);
    td.querySelectorAll('.truncate-text').forEach(el => setTooltip(el, text));
  });
}
function annotateSearchInputs(root) {
  if (!root) return;
  root.querySelectorAll('input[type="search"]').forEach(input => {
    const tip = tooltipCatalog.search[input.id] || 'Filtrer tabellen ved at indtaste søgetekst.';
    setTooltip(input, tip);
  });
}
function applyMetricTooltips(root) {
  if (!root) return;
  root.querySelectorAll('.badge').forEach(badge => {
    const key = badge.textContent.trim();
    const tip = tooltipCatalog.metrics[key];
    if (tip) {
      setTooltip(badge, tip);
      const container = badge.parentElement;
      if (container) {
        setTooltip(container, tip);
        const value = container.querySelector('h3');
        if (value) setTooltip(value, tip);
      }
    }
  });
}
function applyFormTooltips(form) {
  if (!form) return;
  const map = tooltipCatalog.forms[form.id];
  if (map) {
    Object.entries(map).forEach(([name, tip]) => {
      const field = form.elements[name];
      if (!field) return;
      const isRadioList = typeof RadioNodeList !== 'undefined' && field instanceof RadioNodeList;
      const el = isRadioList ? field[0] : field;
      if (!el) return;
      setTooltip(el, tip);
      const label = el.closest('label');
      if (label) setTooltip(label, tip);
      const filterable = el.closest('.filterable-select');
      if (filterable) {
        setTooltip(filterable, tip);
        const filterInput = filterable.querySelector('input[data-select-filter]');
        if (filterInput) setTooltip(filterInput, tip);
      }
    });
  }
  const submit = form.querySelector('button[type="submit"]');
  if (submit) setTooltip(submit, tooltipCatalog.buttons.submit);
}
function applyButtonTooltips(root) {
  if (!root) return;
  root.querySelectorAll('button').forEach(btn => {
    const tip = tooltipCatalog.buttons[btn.id] || tooltipCatalog.buttons[btn.textContent.trim()];
    if (tip) setTooltip(btn, tip);
  });
}
function applyControlTooltips(root) {
  if (!root) return;
  Object.entries(tooltipCatalog.controls).forEach(([id, tip]) => {
    const el = root.querySelector(`#${id}`);
    if (el) {
      setTooltip(el, tip);
      if (el.tagName === 'INPUT' && el.type === 'checkbox' && el.parentElement) {
        setTooltip(el.parentElement, tip);
      }
    }
  });
}
function applySelectFilters(root) {
  if (!root) return;
  root.querySelectorAll('.filterable-select').forEach(wrapper => {
    const input = wrapper.querySelector('input[data-select-filter]');
    const select = wrapper.querySelector('select');
    if (!input || !select || wrapper.dataset.filterInit) return;
    const options = Array.from(select.options).map(option => ({
      option,
      text: option.textContent.toLowerCase()
    }));
    input.addEventListener('input', () => {
      const term = input.value.trim().toLowerCase();
      options.forEach(({option, text}) => {
        const matches = !term || text.includes(term) || option.selected;
        option.hidden = !matches;
      });
      if (term) {
        const firstMatch = options.find(({option}) => !option.hidden);
        if (firstMatch && !firstMatch.option.selected) {
          select.value = firstMatch.option.value;
        }
      }
    });
    input.addEventListener('keydown', evt => {
      if (evt.key === 'Escape') {
        input.value = '';
        input.dispatchEvent(new Event('input'));
      }
    });
    wrapper.dataset.filterInit = 'true';
  });
}

const VARIANT_TYPE_OPTIONS = [
  {value: 'snv', label: 'SNV/indel'},
  {value: 'cnv', label: 'Kopitalvariant (CNV)'},
  {value: 'sv', label: 'Strukturel variant'},
  {value: 'cyto', label: 'Cytogenetisk forandring'}
];

const STRUCTURE_TYPE_OPTION_GROUPS = [
  {
    label: 'CNV (kopital)',
    options: [
      {value: 'deletion', label: 'Deletion (tab)', synonyms: ['deletion','del','loss','tab','kopitaltab','copy loss']},
      {value: 'duplication', label: 'Duplikation', synonyms: ['duplication','dup','gain','kopitalgain']},
      {value: 'amplification', label: 'Amplifikation', synonyms: ['amplification','amp','forstærkning']},
      {value: 'copy_gain', label: 'Kopitalgain (x3/x4)', synonyms: ['copy gain','kopitalgain','x3','x4','copy-number gain']},
      {value: 'copy_loss', label: 'Kopitaltab (x1/x0)', synonyms: ['copy loss','kopitaltab','x1','x0']},
      {value: 'cnloh', label: 'Copy-neutral LOH', synonyms: ['cnloh','copy-neutral loh','copy neutral loh']},
      {value: 'loh', label: 'LOH', synonyms: ['loh','loss of heterozygosity']},
      {value: 'mosaic_gain', label: 'Mosaik gain', synonyms: ['mosaic gain','mosaik gain']},
      {value: 'mosaic_loss', label: 'Mosaik tab', synonyms: ['mosaic loss','mosaik tab']},
      {value: 'segmental_gain', label: 'Segmental gain', synonyms: ['segmental gain','segment gain','partial duplication','partial gain']},
      {value: 'segmental_loss', label: 'Segmental tab', synonyms: ['segmental loss','segment loss','partial deletion','partial loss']},
      {value: 'whole_arm_gain', label: 'Helarm gain', synonyms: ['whole arm gain','arm gain','p-arm gain','q-arm gain']},
      {value: 'whole_arm_loss', label: 'Helarm tab', synonyms: ['whole arm loss','arm loss','p-arm loss','q-arm loss']}
    ]
  },
  {
    label: 'Strukturel variant',
    options: [
      {value: 'translocation', label: 'Translokation (ikke specificeret)', synonyms: ['translocation','translokation']},
      {value: 'insertion', label: 'Insertion', synonyms: ['insertion','indsættelse']},
      {value: 'inversion', label: 'Inversion', synonyms: ['inversion','inversi','omvendt segment']},
      {value: 'balanced_translocation', label: 'Translokation (balanceret)', synonyms: ['balanced translocation','balanceret translokation']},
      {value: 'unbalanced_translocation', label: 'Translokation (ubalanceret)', synonyms: ['unbalanced translocation','ubalanceret translokation']},
      {value: 'fusion', label: 'Fusionsgen', synonyms: ['fusion','fusionsgen','gene fusion']},
      {value: 'breakend', label: 'Breakend (BND)', synonyms: ['breakend','bnd']},
      {value: 'tandem_duplication', label: 'Tandem duplikation', synonyms: ['tandem duplication','tandem duplikation']},
      {value: 'complex_rearrangement', label: 'Kompleks omlejring', synonyms: ['complex rearrangement','kompleks omlejring','complex']},
      {value: 'chromothripsis', label: 'Kromothripsis', synonyms: ['chromothripsis']},
      {value: 'transposition', label: 'Transposition', synonyms: ['transposition','transponering']},
      {value: 'duplication_inverted', label: 'Inverteret duplikation', synonyms: ['inverted duplication','duplication inverted','inv dup']},
      {value: 'gene_conversion', label: 'Genkonvertering', synonyms: ['gene conversion','genkonvertering']}
    ]
  },
  {
    label: 'Cytogenetisk forandring',
    options: [
      {value: 'monosomy', label: 'Monosomi', synonyms: ['monosomy','monosomi']},
      {value: 'trisomy', label: 'Trisomi', synonyms: ['trisomy','trisomi']},
      {value: 'tetrasomy', label: 'Tetrasomi', synonyms: ['tetrasomy','tetrasomi']},
      {value: 'aneuploidy', label: 'Aneuploidi (andet)', synonyms: ['aneuploidy','aneuploidi']},
      {value: 'polyploidy', label: 'Polyploidi', synonyms: ['polyploidy','polyploidi']},
      {value: 'ring_chromosome', label: 'Ringkromosom', synonyms: ['ring chromosome','ringkromosom']},
      {value: 'isochromosome', label: 'Isochromosom', synonyms: ['isochromosome','isochromosom']},
      {value: 'dicentric', label: 'Dicentrisk kromosom', synonyms: ['dicentric','dicentrisk']},
      {value: 'marker_chromosome', label: 'Marker-kromosom', synonyms: ['marker chromosome','marker-kromosom','marker kromosom']},
      {value: 'robertsonian', label: 'Robertsonsk translokation', synonyms: ['robertsonian','robertsonian translocation','robertsonsk translokation']},
      {value: 'partial_trisomy', label: 'Partiel trisomi', synonyms: ['partial trisomy','partiel trisomi']},
      {value: 'partial_monosomy', label: 'Partiel monosomi', synonyms: ['partial monosomy','partiel monosomi']},
      {value: 'whole_genome_duplication', label: 'Hel genom-duplikation', synonyms: ['whole genome duplication','genom duplikation','tetraploidi']}
    ]
  },
  {
    label: 'Andre',
    options: [
      {value: 'other', label: 'Anden/andet (specificer i beskrivelsen)', synonyms: ['other','andet','anden']}
    ]
  }
];

function renderStructureTypeOptions({includeBlank = true} = {}) {
  const parts = [];
  if (includeBlank) {
    parts.push('<option value="">Vælg strukturtype</option>');
  }
  STRUCTURE_TYPE_OPTION_GROUPS.forEach(group => {
    const options = group.options
      .map(option => `<option value="${option.value}">${option.label}</option>`)
      .join('');
    if (group.label) {
      parts.push(`<optgroup label="${group.label}">${options}</optgroup>`);
    } else {
      parts.push(options);
    }
  });
  return parts.join('');
}

function normalizeRsId(value) {
  if (value == null) return '';
  const trimmed = String(value).trim();
  if (!trimmed) return '';
  const match = trimmed.match(/^rs?(\d+)$/i);
  if (match) {
    return `rs${match[1]}`;
  }
  return trimmed;
}

function formatRsIdCell(rsid) {
  const normalized = normalizeRsId(rsid);
  if (!normalized) return '';
  if (/^rs\d+$/i.test(normalized)) {
    const canonical = normalized.replace(/^rs/i, 'rs');
    const url = `https://www.ncbi.nlm.nih.gov/snp/${encodeURIComponent(canonical)}`;
    const label = esc(canonical);
    return `<a class="rsid-badge" href="${url}" target="_blank" rel="noopener noreferrer" title="Åbn dbSNP-opslag for ${label}" aria-label="Åbn dbSNP-opslag for ${label}">${label}</a>`;
  }
  return esc(normalized);
}

function normalizeStructureTypeValue(value) {
  if (value == null) return '';
  const trimmed = String(value).trim();
  if (!trimmed) return '';
  const lower = trimmed.toLowerCase();
  for (const group of STRUCTURE_TYPE_OPTION_GROUPS) {
    for (const option of group.options) {
      const optionValue = option.value.toLowerCase();
      if (optionValue === lower) return option.value;
      const labelLower = option.label.toLowerCase();
      const labelBase = labelLower.split('(')[0].trim();
      if (labelLower === lower || (labelBase && labelBase === lower)) {
        return option.value;
      }
      if (labelBase && (labelBase.startsWith(lower) || lower.startsWith(labelBase))) {
        return option.value;
      }
      const synonyms = Array.isArray(option.synonyms) ? option.synonyms : option.synonyms ? [option.synonyms] : [];
      if (synonyms.some(syn => syn && syn.toLowerCase() === lower)) {
        return option.value;
      }
    }
  }
  return trimmed;
}

function getStructureTypeLabel(value) {
  if (value == null) return '';
  const normalized = normalizeStructureTypeValue(value);
  const lower = normalized.toLowerCase();
  for (const group of STRUCTURE_TYPE_OPTION_GROUPS) {
    for (const option of group.options) {
      if (option.value.toLowerCase() === lower) {
        return option.label;
      }
    }
  }
  return String(value).trim();
}

function normalizeVariantType(value) {
  if (!value) return 'snv';
  const normalized = String(value).trim().toLowerCase();
  return VARIANT_TYPE_OPTIONS.some(option => option.value === normalized) ? normalized : 'snv';
}

function getVariantTypeLabel(value) {
  const normalized = normalizeVariantType(value);
  const option = VARIANT_TYPE_OPTIONS.find(opt => opt.value === normalized);
  return option ? option.label : normalized;
}

function setupVariantTypeForm(form, {defaultType = 'snv', disableInactiveGroups = false} = {}) {
  if (!form) {
    return {
      updateVariantTypeFields: () => {},
      variantTypeSelect: null
    };
  }
  const select = form.elements?.variant_type
    || form.querySelector('[name="variant_type"]')
    || form.querySelector('[data-field="variant_type"]')
    || null;
  const groups = Array.from(form.querySelectorAll('[data-variant-types]'));
  const typeRequiredFields = Array.from(form.querySelectorAll('[data-type-required]'));
  const initialRequired = new Map(typeRequiredFields.map(field => [field, field.required]));
  const normalizedDefault = normalizeVariantType(defaultType);
  const update = () => {
    const type = normalizeVariantType(select?.value || normalizedDefault);
    if (select && select.value !== type) {
      select.value = type;
    }
    groups.forEach(group => {
      const types = (group.dataset.variantTypes || '')
        .split(/\s+/)
        .filter(Boolean)
        .map(normalizeVariantType);
      const active = types.length ? types.includes(type) : true;
      group.hidden = !active;
      group.classList.toggle('variant-type-hidden', !active);
      if (disableInactiveGroups) {
        const fields = group.querySelectorAll('input, select, textarea, button');
        fields.forEach(field => {
          if (field.matches('[name="variant_type"],[data-field="variant_type"]')) return;
          field.disabled = !active;
        });
      }
    });
    typeRequiredFields.forEach(field => {
      const requiredFor = (field.dataset.typeRequired || '')
        .split(/\s+/)
        .filter(Boolean)
        .map(normalizeVariantType);
      const defaultRequired = initialRequired.get(field) ?? field.required;
      const shouldRequire = requiredFor.length ? requiredFor.includes(type) : defaultRequired;
      field.required = shouldRequire;
      const label = field.closest('label');
      if (label) {
        label.classList.toggle('required', shouldRequire);
      }
    });
  };
  if (select) {
    select.addEventListener('change', update);
  }
  update();
  return {
    updateVariantTypeFields: update,
    variantTypeSelect: select
  };
}

function formatVariantGenomicRange(variant) {
  if (!variant) return '';
  const chromosome = variant.chromosome || variant.chrom;
  const start = variant.start || variant.position_start || variant.begin;
  const end = variant.end || variant.position_end || variant.finish;
  if (!chromosome) return '';
  if (start && end) return `${chromosome}:${start}-${end}`;
  if (start) return `${chromosome}:${start}`;
  return String(chromosome);
}

function formatVariantCopyNumber(variant) {
  if (!variant) return '';
  const copyNumber = variant.copy_number ?? variant.copynumber ?? variant.copies;
  if (copyNumber === '' || copyNumber === null || copyNumber === undefined) return '';
  return `Kopital: ${copyNumber}`;
}

function normalizeVariantKeyPart(value) {
  if (value == null) return '';
  return String(value).trim().toLowerCase();
}

function createVariantComparisonKey(variant) {
  if (!variant) return '';
  const type = normalizeVariantType(variant.variant_type);
  const parts = [`type:${type}`];
  const seen = new Set(parts);
  const addPart = (label, rawValue) => {
    const value = normalizeVariantKeyPart(rawValue);
    if (!value) return;
    const part = `${label}:${value}`;
    if (seen.has(part)) return;
    seen.add(part);
    parts.push(part);
  };
  const gene = variant.gene || variant.region;
  const transcript = variant.transcript;
  const hgvsC = variant.hgvs_c;
  const hgvsP = variant.hgvs_p;
  const rsid = normalizeRsId(variant.rsid || variant.rs_id);
  const iscn = variant.iscn || variant.cytogenetic;
  const chromosome = variant.chromosome || variant.chr;
  const start = variant.start || variant.begin || variant.position_start;
  const end = variant.end || variant.finish || variant.position_end;
  const copyNumber = variant.copy_number || variant.copynumber || variant.copies;
  const svSubtype = normalizeStructureTypeValue(variant.sv_subtype || variant.structural_type || variant.variant_subtype);
  const description = variant.description;
  const affectedGenes = variant.affected_genes || variant.genes;
  if (type === 'snv') {
    if (hgvsC || hgvsP || rsid) {
      addPart('hgvs_c', hgvsC);
      addPart('hgvs_p', hgvsP);
      addPart('rsid', rsid);
    } else {
      if (transcript) addPart('transcript', transcript);
      addPart('gene', gene);
    }
  } else {
    addPart('iscn', iscn);
    addPart('chromosome', chromosome);
    addPart('start', start);
    addPart('end', end);
    addPart('copy_number', copyNumber);
    addPart('sv_subtype', svSubtype);
    if (!iscn && !start && !end) {
      addPart('description', description);
    }
    if (!iscn && !description) {
      if (gene) {
        addPart('gene', gene);
      } else {
        addPart('affected_genes', affectedGenes);
      }
    }
  }
  if (parts.length <= 1) {
    addPart('gene', gene);
    addPart('description', description);
    addPart('affected_genes', affectedGenes);
  }
  return parts.length > 1 ? parts.join('|') : '';
}

function computeVariantFrequencyData() {
  const variants = getCached('variants') || [];
  const patients = getCached('patients') || [];
  const countMap = new Map();
  let maxCount = 0;
  variants.forEach(variant => {
    const key = createVariantComparisonKey(variant);
    if (!key) return;
    const updatedCount = (countMap.get(key) || 0) + 1;
    countMap.set(key, updatedCount);
    if (updatedCount > maxCount) {
      maxCount = updatedCount;
    }
  });
  return {countMap, patientCount: patients.length, maxCount};
}

function formatVariantFrequencyLabel(count, patientCount) {
  const registrations = Number(count) || 0;
  const patientsTotal = Number(patientCount) || 0;
  if (!patientsTotal) {
    return String(registrations);
  }
  const percent = (registrations / patientsTotal) * 100;
  const formattedPercent = percent.toLocaleString('da-DK', {
    minimumFractionDigits: percent > 0 && percent < 1 ? 2 : percent > 0 && percent < 10 ? 1 : 0,
    maximumFractionDigits: percent >= 10 ? 1 : 2
  });
  return `${registrations}/${patientsTotal} (${formattedPercent}%)`;
}

function formatVariantTitle(variant) {
  if (!variant) return '';
  const type = normalizeVariantType(variant.variant_type);
  if (type === 'snv') {
    const parts = [variant.gene, variant.hgvs_c, variant.hgvs_p, variant.rsid].filter(Boolean);
    if (parts.length) return parts.join(' · ');
  }
  const iscn = variant.iscn || variant.cytogenetic || '';
  const genomic = formatVariantGenomicRange(variant);
  const subtype = getStructureTypeLabel(variant.sv_subtype || variant.structural_type || variant.variant_subtype || '');
  const affectedGenes = variant.affected_genes || variant.genes || '';
  const gene = variant.gene || variant.region || '';
  const parts = [gene, iscn, genomic, subtype, affectedGenes, variant.rsid];
  const seen = new Set();
  const uniqueParts = parts
    .map(part => (part == null ? '' : String(part).trim()))
    .filter(part => {
      if (!part) return false;
      const key = part.toLowerCase();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  if (uniqueParts.length) return uniqueParts.join(' · ');
  if (variant.description) return variant.description;
  return variant.gene || subtype || getVariantTypeLabel(type);
}

function formatVariantDetailLines(variant) {
  if (!variant) return [];
  const type = normalizeVariantType(variant.variant_type);
  const details = [];
  if (type !== 'snv') {
    if (variant.gene) details.push(`Gen/region: ${variant.gene}`);
    const genomeBuild = variant.genome_build || '';
    const range = formatVariantGenomicRange(variant);
    if (genomeBuild || range) {
      const buildRange = [genomeBuild, range].filter(Boolean).join(' ');
      if (buildRange) details.push(`Genomisk position: ${buildRange}`);
    }
    const subtype = getStructureTypeLabel(variant.sv_subtype || variant.structural_type || variant.variant_subtype);
    if (subtype) details.push(`Type: ${subtype}`);
    const cn = formatVariantCopyNumber(variant);
    if (cn) details.push(cn);
    if (variant.size_bp) details.push(`Størrelse: ${variant.size_bp}`);
    if (variant.affected_genes) details.push(`Berørte gener: ${variant.affected_genes}`);
    if (variant.iscn) details.push(`ISCN: ${variant.iscn}`);
  }
  if (variant.hgvs_c) details.push(`HGVS c.: ${variant.hgvs_c}`);
  if (variant.hgvs_p) details.push(`HGVS p.: ${variant.hgvs_p}`);
  if (variant.rsid) details.push(`dbSNP: ${variant.rsid}`);
  if (variant.transcript) details.push(`Transkript: ${variant.transcript}`);
  if (variant.zygosity) details.push(`Zygositet: ${variant.zygosity}`);
  if (variant.classification) details.push(`ACMG-klasse: ${variant.classification}`);
  if (variant.criteria) details.push(`Kriterier: ${variant.criteria}`);
  if (variant.af !== undefined && variant.af !== null && variant.af !== '') details.push(`AF: ${variant.af}`);
  if (variant.description) details.push(`Beskrivelse: ${variant.description}`);
  return details;
}

function openVariantLibraryPicker(onSelect) {
  const library = (getCached('variant_library') || []).slice();
  if (!library.length) {
    alert('Variantbiblioteket er tomt.');
    return;
  }
  const existing = document.querySelector('.variant-picker-overlay');
  if (existing) existing.remove();
  const sorted = library.sort((a, b) => {
    const titleA = formatVariantTitle(a) || '';
    const titleB = formatVariantTitle(b) || '';
    const compareTitle = titleA.localeCompare(titleB, 'da');
    if (compareTitle) return compareTitle;
    const compareType = normalizeVariantType(a.variant_type).localeCompare(normalizeVariantType(b.variant_type));
    if (compareType) return compareType;
    return (a.id || 0) - (b.id || 0);
  });
  const overlay = document.createElement('div');
  overlay.className = 'variant-picker-overlay';
  overlay.innerHTML = `
    <div class="variant-picker" role="dialog" aria-modal="true" aria-label="Vælg variant fra bibliotek">
      <header>
        <h3>Vælg variant fra bibliotek</h3>
        <button type="button" class="secondary" data-action="close">Luk</button>
      </header>
      <div class="picker-body">
        <label class="inline">Søg
          <input type="search" placeholder="Filtrer på variant, gen, ISCN eller HGVS">
        </label>
        <p class="form-hint">Klik på en variant for at kopiere oplysningerne til formularen.</p>
        <table>
          <thead>
            <tr><th>ID</th><th>Variant</th><th>Type</th><th>Genomisk position</th><th>Gen</th><th>HGVS c.</th><th>rsID</th><th>ISCN</th><th>Klasse</th><th>Kriterier</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>`;
  const previousOverflow = document.body.style.overflow;
  document.body.style.overflow = 'hidden';
  document.body.appendChild(overlay);
  const dialog = overlay.querySelector('.variant-picker');
  const searchInput = overlay.querySelector('input[type="search"]');
  const tbody = overlay.querySelector('tbody');
  const closeBtn = overlay.querySelector('[data-action="close"]');
  const cleanup = () => {
    document.body.style.overflow = previousOverflow;
    overlay.remove();
    document.removeEventListener('keydown', onKeyDown, true);
  };
  const onKeyDown = evt => {
    if (evt.key === 'Escape') {
      evt.preventDefault();
      cleanup();
    }
  };
  document.addEventListener('keydown', onKeyDown, true);
  const handleSelect = id => {
    const variant = sorted.find(item => item.id === id);
    if (!variant) return;
    if (onSelect) onSelect({...variant, variant_type: normalizeVariantType(variant.variant_type)});
    cleanup();
  };
  const renderRows = () => {
    const term = (searchInput?.value || '').trim().toLowerCase();
    const filtered = sorted.filter(item => {
      if (!term) return true;
      return [
        item.gene,
        item.transcript,
        item.hgvs_c,
        item.hgvs_p,
        item.rsid,
        item.iscn,
        item.criteria,
        item.evidence,
        formatVariantTitle(item),
        formatVariantGenomicRange(item),
        getVariantTypeLabel(item.variant_type)
      ].some(value => (value || '').toLowerCase().includes(term));
    });
    if (!filtered.length) {
      tbody.innerHTML = '<tr><td colspan="10"><div class="variant-picker-empty">Ingen varianter matcher søgningen.</div></td></tr>';
      return;
    }
    tbody.innerHTML = filtered.map(item => {
      const title = formatVariantTitle(item);
      const typeLabel = getVariantTypeLabel(item.variant_type);
      const genomic = formatVariantGenomicRange(item);
      return `
      <tr tabindex="0" data-id="${item.id}">
        <td>${esc(item.id)}</td>
        <td>${esc(title)}</td>
        <td>${esc(typeLabel)}</td>
        <td>${esc(genomic)}</td>
        <td>${esc(item.gene || '')}</td>
        <td>${esc(item.hgvs_c || '')}</td>
        <td>${formatRsIdCell(item.rsid)}</td>
        <td>${esc(item.iscn || '')}</td>
        <td>${esc(item.classification || '')}</td>
        <td>${esc(item.criteria || '')}</td>
      </tr>`;
    }).join('');
    annotateTableCells(dialog);
  };
  renderRows();
  annotateHeaders(dialog);
  applyButtonTooltips(dialog);
  overlay.addEventListener('click', evt => {
    if (evt.target === overlay) cleanup();
  });
  closeBtn?.addEventListener('click', cleanup);
  searchInput?.addEventListener('input', renderRows);
  tbody.addEventListener('click', evt => {
    const tr = evt.target.closest('tr[data-id]');
    if (!tr) return;
    handleSelect(Number(tr.dataset.id));
  });
  tbody.addEventListener('keydown', evt => {
    if (evt.key === 'Enter' || evt.key === ' ') {
      evt.preventDefault();
      const tr = evt.target.closest('tr[data-id]');
      if (tr) handleSelect(Number(tr.dataset.id));
    }
  });
  setTimeout(() => searchInput?.focus(), 50);
}
function initCollapsibleFieldsets(root) {
  if (!root) return;
  const toggleState = (fieldset, toggle, body, collapsed) => {
    const labelOpen = toggle.dataset.labelOpen || 'Minimér';
    const labelClosed = toggle.dataset.labelClosed || 'Udvid';
    fieldset.classList.toggle('collapsed', collapsed);
    if (collapsed) {
      fieldset.dataset.collapsed = 'true';
    } else {
      delete fieldset.dataset.collapsed;
    }
    toggle.setAttribute('aria-expanded', String(!collapsed));
    toggle.textContent = collapsed ? labelClosed : labelOpen;
    const title = fieldset.querySelector('.fieldset-title');
    const sectionName = title?.textContent?.trim();
    if (typeof setTooltip === 'function') {
      const tip = collapsed
        ? sectionName ? `Udvid sektionen “${sectionName}”` : 'Udvid denne sektion'
        : sectionName ? `Minimér sektionen “${sectionName}”` : 'Minimér denne sektion';
      setTooltip(toggle, tip);
    }
    if (body) {
      body.hidden = collapsed;
    }
  };
  root.querySelectorAll('fieldset[data-collapsible]').forEach((fieldset, index) => {
    if (fieldset.dataset.collapsibleInit) return;
    const toggle = fieldset.querySelector('.fieldset-toggle');
    if (!toggle) return;
    if (!fieldset.id) {
      fieldset.id = `collapsible-${Date.now()}-${index}`;
    }
    const body = fieldset.querySelector('.fieldset-body');
    if (body && !body.id) {
      body.id = `${fieldset.id}-body`;
    }
    const controlsId = body?.id || fieldset.id;
    toggle.setAttribute('aria-controls', controlsId);
    toggle.addEventListener('click', () => {
      const collapsed = !fieldset.classList.contains('collapsed');
      toggleState(fieldset, toggle, body, collapsed);
    });
    const defaultCollapsed = fieldset.dataset.collapsed === 'true';
    toggleState(fieldset, toggle, body, defaultCollapsed);
    fieldset.dataset.collapsibleInit = 'true';
  });
}
function initFamilyCombos(root) {
  if (!root) return;
  root.querySelectorAll('.family-combo').forEach(combo => {
    if (combo.dataset.familyInit) return;
    const select = combo.querySelector('[data-family-select]');
    const input = combo.querySelector('[data-family-input]');
    if (!select || !input) return;
    const syncSelect = () => {
      const value = input.value.trim();
      if (!value) {
        select.value = '';
        return;
      }
      const match = Array.from(select.options).find(opt => opt.value === value);
      select.value = match ? value : '__custom__';
    };
    select.addEventListener('change', () => {
      if (!select.value) {
        input.value = '';
      } else if (select.value !== '__custom__') {
        input.value = select.value;
      }
      if (select.value === '__custom__') {
        input.focus();
      } else {
        input.dispatchEvent(new Event('input', {bubbles: false}));
      }
    });
    input.addEventListener('input', () => syncSelect());
    combo.dataset.familyInit = 'true';
    const form = combo.closest('form');
    if (form && !form.dataset.familyResetInit) {
      form.addEventListener('reset', () => {
        setTimeout(() => {
          form.querySelectorAll('[data-family-input]').forEach(field => {
            field.dispatchEvent(new Event('input', {bubbles: false}));
          });
        }, 0);
      });
      form.dataset.familyResetInit = 'true';
    }
    syncSelect();
  });
}
function hasWriteRole(user) {
  if (!user) return false;
  const role = normaliseRoleValue(user.role).toLowerCase();
  if (WRITE_ROLE_KEYS.has(role)) return true;
  return ['admin', 'skriver', 'redakt', 'editor', 'bio', 'write', 'leder'].some(key => role.includes(key));
}
function currentCanWrite() {
  if (state.currentUser?.internal) return true;
  return hasWriteRole(state.currentUser);
}
function ensureWrite(storeName) {
  if (state.currentUser?.internal) return true;
  if (storeName === 'users') {
    const existing = state.cache.get('users');
    if (!existing || existing.length === 0) {
      return true;
    }
  }
  if (currentCanWrite()) return true;
  alert('Handling kræver skriveadgang. Log ind med en bruger der har rollen "Administrator" eller "Skriver".');
  return false;
}
function updateWriteBanner() {
  const hasWrite = currentCanWrite();
  let banner = document.getElementById('writeLockBanner');
  if (!hasWrite) {
    if (!banner) {
      banner = document.createElement('div');
      banner.id = 'writeLockBanner';
      banner.className = 'read-only-banner';
      banner.textContent = 'Skriveadgang er låst. Log ind med skrivetilladelse for at redigere eller oprette data.';
      const main = document.getElementById('tabContent');
      if (main) {
        main.prepend(banner);
      }
    }
  } else if (banner) {
    banner.remove();
  }
}
function refreshLoginOptions() {
  const select = document.getElementById('loginUser');
  if (!select) return;
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const currentId = state.currentUser?.id ? String(state.currentUser.id) : '';
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = users.length ? 'Vælg bruger' : 'Opret en bruger for at logge ind';
  placeholder.disabled = true;
  select.appendChild(placeholder);
  users.forEach(user => {
    const opt = document.createElement('option');
    opt.value = String(user.id);
    opt.textContent = `${user.name} (${roleWithDescription(user.role) || 'rolle ukendt'})`;
    select.appendChild(opt);
  });
  if (currentId) {
    select.value = currentId;
    placeholder.selected = false;
  } else {
    placeholder.selected = true;
  }
}
function updateAuthUi() {
  const form = document.getElementById('loginForm');
  const info = document.getElementById('userInfo');
  const label = document.getElementById('currentUserLabel');
  const select = document.getElementById('loginUser');
  if (!form || !info || !label || !select) return;
  const user = state.currentUser;
  if (user) {
    form.style.display = 'none';
    info.hidden = false;
    label.textContent = `${user.name} – ${roleWithDescription(user.role) || 'rolle ukendt'}`;
  } else {
    info.hidden = true;
    form.style.display = '';
    form.reset();
    refreshLoginOptions();
  }
  updateWriteBanner();
}
function applyTheme() {
  if (!['light', 'dark'].includes(state.theme)) {
    state.theme = 'light';
  }
  document.documentElement.dataset.theme = state.theme;
  storage.setItem('glimr-theme', state.theme);
  const btn = document.getElementById('themeToggle');
  if (btn) {
    const toDark = state.theme !== 'dark';
    const label = btn.querySelector('span:not(.icon-slot)');
    if (label) {
      label.textContent = toDark ? 'Skift til mørkt tema' : 'Skift til lyst tema';
    } else {
      btn.textContent = toDark ? 'Skift til mørkt tema' : 'Skift til lyst tema';
    }
    const iconSlot = btn.querySelector('.icon-slot');
    if (iconSlot) {
      setIcon(iconSlot, toDark ? 'moon' : 'sun');
    }
    setTooltip(btn, tooltipCatalog.buttons.themeToggle);
  }
}
function toggleTheme() {
  state.theme = state.theme === 'dark' ? 'light' : 'dark';
  applyTheme();
}
function restoreUserSession() {
  const storedId = storage.getItem('glimr-user-id');
  if (storedId) {
    const user = findById('users', Number(storedId));
    if (user) {
      state.currentUser = {...user};
    } else {
      state.currentUser = null;
      storage.removeItem('glimr-user-id');
    }
  } else if (!state.currentUser || !state.currentUser.internal) {
    state.currentUser = null;
  }
  refreshLoginOptions();
  updateAuthUi();
}
function logoutUser() {
  state.currentUser = null;
  storage.removeItem('glimr-user-id');
  updateAuthUi();
  setStatus('Logget ud. Systemet er skrivebeskyttet.');
  const dashboardSection = document.querySelector('section[data-tab="dashboard"]');
  if (dashboardSection) renderDashboard(dashboardSection);
}
function handleLogin(event) {
  event.preventDefault();
  const select = document.getElementById('loginUser');
  const pass = document.getElementById('loginPass');
  if (!select || !pass) return;
  const id = Number(select.value);
  if (!id) {
    alert('Vælg en bruger for at logge ind.');
    return;
  }
  const user = findById('users', id);
  if (!user) {
    alert('Brugeren findes ikke længere.');
    refreshLoginOptions();
    return;
  }
  const pin = pass.value.trim();
  if (user.pin && user.pin !== pin) {
    alert('Forkert adgangskode.');
    return;
  }
  state.currentUser = {...user};
  storage.setItem('glimr-user-id', String(user.id));
  pass.value = '';
  updateAuthUi();
  setStatus(`Logget ind som ${user.name}.`);
  const dashboardSection = document.querySelector('section[data-tab="dashboard"]');
  if (dashboardSection) renderDashboard(dashboardSection);
}
function esc(str) {
  return String(str ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}

function collapseSpaces(value) {
  return String(value ?? '').replace(/\s+/g, ' ').trim();
}

function formatMultilineCell(value) {
  const text = String(value ?? '').trim();
  if (!text) return '';
  return esc(text).replace(/\n/g, '<br>');
}

function splitHpoInput(value) {
  const raw = String(value ?? '');
  if (!raw.trim()) return [];
  const hasPreferredDelimiter = /[\n;]/.test(raw);
  const parts = hasPreferredDelimiter ? raw.split(/[\n;]+/) : raw.split(/,+/);
  return parts.map(part => collapseSpaces(part)).filter(Boolean);
}

function normalizeHpoTerms(value) {
  const seen = new Set();
  const terms = [];
  for (const term of splitHpoInput(value)) {
    const key = term.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    terms.push(term);
  }
  return terms.join('\n');
}

function parseHpoTerms(value) {
  const normalized = normalizeHpoTerms(value);
  if (!normalized) return [];
  return normalized.split('\n');
}

function formatHpoList(value, separator = ', ') {
  return parseHpoTerms(value).join(separator);
}

function formatHpoHtml(value) {
  const terms = parseHpoTerms(value);
  if (!terms.length) return '';
  return terms.map(term => esc(term)).join('<br>');
}

function formatIndicationForList(value) {
  return collapseSpaces(value);
}

const PRIORITY_ICON_PATH = '<path fill="currentColor" d="M12 3.172 2.322 20.5h19.356L12 3.172zm1 13.828h-2v2h2v-2zm0-8h-2v6h2v-6z"></path>';

function renderOrderPriorityIcon(label, modifierClass) {
  return `<span class="priority-indicator ${modifierClass}" role="img" aria-label="${label}"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">${PRIORITY_ICON_PATH}</svg></span>`;
}

function renderOrderPriorityIcons(order) {
  if (!order) return '';
  const icons = [];
  if (order.acute) icons.push(renderOrderPriorityIcon('Akut', 'acute-indicator'));
  if (order.urgent) icons.push(renderOrderPriorityIcon('Haster', 'urgent-indicator'));
  return icons.join('');
}

function orderPriorityAttributes(order) {
  if (!order) return '';
  const attrs = [];
  if (order.acute) attrs.push('data-acute="true"');
  if (order.urgent) attrs.push('data-urgent="true"');
  return attrs.length ? ` ${attrs.join(' ')}` : '';
}

function truncateForListDisplay(value, maxLength = 120) {
  const text = collapseSpaces(value);
  if (!text) return '';
  if (text.length <= maxLength) return text;
  const ellipsis = '...';
  if (maxLength <= ellipsis.length) return ellipsis;
  const cut = maxLength - ellipsis.length;
  let truncated = text.slice(0, cut).trimEnd();
  truncated = truncated.replace(/[,;:.]$/, '');
  if (!truncated) return ellipsis;
  return truncated + ellipsis;
}
function setStatus(msg) {
  state.lastStatus = msg;
  const bar = document.getElementById('statusBar');
  if (!bar) return;
  bar.textContent = msg;
  setTooltip(bar, msg);
}
window.addEventListener('error', event => {
  if (!event) return;
  const hasDetails = Boolean(event.message) || Boolean(event.error && event.error.message);
  if (!hasDetails) return;
  const detail = event.message || (event.error && event.error.message) || 'Ukendt fejl';
  console.error('Ubehandlet fejl i GlimR:', event.error || detail, event);
  setStatus('Fejl: ' + detail);
});
window.addEventListener('unhandledrejection', event => {
  if (!event) return;
  const reason = event.reason;
  const detail = reason && (reason.message || String(reason)) || 'Ukendt asynkron fejl';
  console.error('Ubehandlet promise-fejl i GlimR:', reason || event);
  setStatus('Fejl: ' + detail);
});
function currentUserName() {
  return state.currentUser?.name || 'System';
}
function initTabs() {
  const nav = document.getElementById('tabNav');
  const main = document.getElementById('tabContent');
  nav.innerHTML = '';
  main.innerHTML = '';
  tabs.forEach(tab => {
    const btn = document.createElement('button');
    const iconName = tabIcons[tab.id];
    if (iconName) {
      btn.classList.add('with-icon');
      const iconSlot = document.createElement('span');
      iconSlot.className = 'icon-slot';
      iconSlot.dataset.icon = iconName;
      btn.appendChild(iconSlot);
      setIcon(iconSlot, iconName);
      const span = document.createElement('span');
      span.textContent = tab.label;
      btn.appendChild(span);
    } else {
      btn.textContent = tab.label;
    }
    btn.dataset.tab = tab.id;
    setTooltip(btn, tooltipCatalog.tabs[tab.id]);
    btn.addEventListener('click', () => activateTab(tab.id));
    nav.appendChild(btn);
    const section = document.createElement('section');
    section.dataset.tab = tab.id;
    main.appendChild(section);
  });
}
function activateTab(id) {
  state.currentTab = id;
  document.querySelectorAll('nav button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === id);
  });
  document.querySelectorAll('section[data-tab]').forEach(sec => {
    sec.classList.toggle('active', sec.dataset.tab === id);
  });
  renderTab(id);
}

function openOrderDetails(orderId, options = {}) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId)) return;
  state.pendingOrderId = numericId;
  state.pendingOrderShowAll = Boolean(options.showAll);
  activateTab('orders');
}
function openSamplesForOrder(orderId) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId)) return;
  const order = findById('orders', numericId);
  const sampleId = order?.sample_id != null ? Number(order.sample_id) : null;
  state.pendingSampleId = Number.isFinite(sampleId) ? sampleId : null;
  state.pendingSampleShowAll = true;
  activateTab('samples');
}
function openReportsForOrder(orderId) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId)) return;
  state.pendingReportFilterOrderId = numericId;
  state.pendingReportFilterSampleId = null;
  state.pendingReportFilterSampleExact = false;
  state.pendingReportSelectOrderId = numericId;
  state.pendingReportSelectReportId = null;
  state.pendingReportShowAll = true;
  activateTab('reports');
}

function openOrdersForSample(sampleId) {
  const numericId = Number(sampleId);
  if (!Number.isFinite(numericId)) return;
  const orders = getCached('orders') || [];
  const matching = orders.filter(o => Number(o.sample_id) === numericId);
  matching.sort((a, b) => {
    const timeA = (a.ordered_at || a.updated_at || a.created_at || '');
    const timeB = (b.ordered_at || b.updated_at || b.created_at || '');
    return timeB.localeCompare(timeA);
  });
  const first = matching[0] || null;
  const selectedId = first ? Number(first.id) : null;
  state.pendingOrderFilterSampleId = numericId;
  state.pendingOrderFilterSampleExact = true;
  state.pendingOrderFilterId = null;
  state.pendingOrderId = Number.isFinite(selectedId) ? selectedId : null;
  state.pendingOrderShowAll = true;
  activateTab('orders');
}

function openReportsForSample(sampleId) {
  const numericId = Number(sampleId);
  if (!Number.isFinite(numericId)) return;
  const orders = getCached('orders') || [];
  const reports = getCached('reports') || [];
  const orderIds = new Set(orders.filter(o => Number(o.sample_id) === numericId).map(o => Number(o.id)));
  const matchingReports = reports.filter(r => orderIds.has(Number(r.order_id)));
  matchingReports.sort((a, b) => {
    const timeA = (a.issued_at || a.updated_at || a.created_at || '');
    const timeB = (b.issued_at || b.updated_at || b.created_at || '');
    return timeB.localeCompare(timeA);
  });
  const firstReport = matchingReports[0] || null;
  const firstReportId = firstReport ? Number(firstReport.id) : null;
  const firstOrderId = firstReport ? Number(firstReport.order_id) : (orderIds.size === 1 ? Array.from(orderIds)[0] : null);
  state.pendingReportFilterSampleId = numericId;
  state.pendingReportFilterSampleExact = true;
  state.pendingReportFilterOrderId = null;
  state.pendingReportSelectOrderId = Number.isFinite(firstOrderId) ? firstOrderId : null;
  state.pendingReportSelectReportId = Number.isFinite(firstReportId) ? firstReportId : null;
  state.pendingReportShowAll = true;
  activateTab('reports');
}

function openOrdersForReport(reportId) {
  const numericId = Number(reportId);
  if (!Number.isFinite(numericId)) return;
  const report = findById('reports', numericId);
  const orderId = report?.order_id != null ? Number(report.order_id) : null;
  if (!Number.isFinite(orderId)) return;
  state.pendingOrderFilterId = orderId;
  state.pendingOrderFilterSampleId = null;
  state.pendingOrderId = orderId;
  state.pendingOrderShowAll = true;
  activateTab('orders');
}

function openSamplesForReport(reportId) {
  const numericId = Number(reportId);
  if (!Number.isFinite(numericId)) return;
  const report = findById('reports', numericId);
  if (!report) return;
  const orderId = report.order_id != null ? Number(report.order_id) : null;
  const order = Number.isFinite(orderId) ? findById('orders', orderId) : null;
  const sampleId = order?.sample_id != null ? Number(order.sample_id) : null;
  if (!Number.isFinite(sampleId)) return;
  state.pendingSampleId = sampleId;
  state.pendingSampleShowAll = true;
  activateTab('samples');
}
function openDb() {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) {
      reject(new Error('Browseren understøtter ikke IndexedDB. GlimR kræver lokal databaseadgang.'));
      return;
    }
    const req = indexedDB.open(DB_NAME, DB_VER);
    let settled = false;
    const finish = (action) => {
      if (settled) return;
      settled = true;
      if (action) action();
    };
    req.onupgradeneeded = event => {
      setStatus('Opgraderer lokal database...');
      const db = event.target.result;
      const ensureStore = (name, options) => {
        if (!db.objectStoreNames.contains(name)) {
          const store = db.createObjectStore(name, options);
          return store;
        }
        return event.target.transaction.objectStore(name);
      };
      const withTimestamps = store => {
        ['created_at','updated_at'].forEach(field => {
          if (!store.indexNames.contains(field)) {
            try { store.createIndex(field, field); } catch (e) {}
          }
        });
        return store;
      };
      withTimestamps(ensureStore('patients', {keyPath:'id', autoIncrement:true}));
      const samplesStore = withTimestamps(ensureStore('samples',{keyPath:'id',autoIncrement:true}));
      if (!samplesStore.indexNames.contains('pmb_number')) {
        try { samplesStore.createIndex('pmb_number','pmb_number',{unique:true}); } catch (e) {}
      }
      if (!samplesStore.indexNames.contains('patient_id')) samplesStore.createIndex('patient_id','patient_id');
      const ordersStore = withTimestamps(ensureStore('orders',{keyPath:'id',autoIncrement:true}));
      ['patient_id','sample_id','panel_id','analysis_responsible_id','interpreter_id','approver_id','patient_group_id'].forEach(idx => {
        if (!ordersStore.indexNames.contains(idx)) ordersStore.createIndex(idx, idx);
      });
      withTimestamps(ensureStore('patient_groups',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('panels',{keyPath:'id',autoIncrement:true}));
      const variantsStore = withTimestamps(ensureStore('variants',{keyPath:'id',autoIncrement:true}));
      if (!variantsStore.indexNames.contains('order_id')) variantsStore.createIndex('order_id','order_id');
      const qcStore = withTimestamps(ensureStore('qc',{keyPath:'id',autoIncrement:true}));
      if (!qcStore.indexNames.contains('sample_id')) qcStore.createIndex('sample_id','sample_id');
      const reportsStore = withTimestamps(ensureStore('reports',{keyPath:'id',autoIncrement:true}));
      if (!reportsStore.indexNames.contains('order_id')) reportsStore.createIndex('order_id','order_id');
      withTimestamps(ensureStore('users',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('audit',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('variant_library',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('responses',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('conclusion_library',{keyPath:'id',autoIncrement:true}));
    };
    req.onblocked = () => {
      finish(() => {
        console.warn('Databaseopgradering blokeret af en anden åben GlimR-fane.');
        reject(new Error('Kan ikke opgradere databasen fordi en anden GlimR-fane stadig er åben. Luk andre faner og prøv igen.'));
      });
    };
    req.onerror = () => {
      finish(() => reject(req.error || new Error('Ukendt IndexedDB-fejl.')));
    };
    req.onsuccess = () => {
      if (settled) {
        try { req.result?.close(); } catch (err) { console.warn('Kunne ikke lukke overflødig databaseforbindelse:', err); }
        return;
      }
      finish(() => {
        const db = req.result;
        if (db) {
          db.onversionchange = () => {
            console.warn('Databaseversion ændres, lukker eksisterende forbindelse.');
            try { db.close(); } catch (err) { console.warn('Kunne ikke lukke database:', err); }
            setStatus('Databaseversion ændret. Genindlæs GlimR for at fortsætte.');
          };
        }
        resolve(db);
      });
    };
  });
}
function requestToPromise(req) {
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function loadStore(name) {
  const tx = state.db.transaction(name, 'readonly');
  const store = tx.objectStore(name);
  const req = store.getAll();
  const rows = await requestToPromise(req);
  state.cache.set(name, rows);
  if (name === 'orders') {
    clearOrderDisplayNameCache();
  }
  if (name === 'audit') {
    rebuildCreationLookup();
  }
  return rows;
}
async function loadAllStores() {
  for (const name of STORES) {
    await loadStore(name);
  }
  rebuildCreationLookup();
}
function getCached(name) {
  return state.cache.get(name) ?? [];
}
function findById(store, id) {
  return getCached(store).find(item => item.id === id);
}

const orderDisplayNameCache = new Map();
function clearOrderDisplayNameCache() {
  orderDisplayNameCache.clear();
}
function getOrderDisplayName(orderId) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId) || numericId === 0) return '';
  if (orderDisplayNameCache.has(numericId)) {
    return orderDisplayNameCache.get(numericId);
  }
  const order = findById('orders', numericId);
  let display = '';
  if (order) {
    for (const key of ['name', 'title', 'display_name', 'displayName', 'label']) {
      const value = order?.[key];
      if (typeof value === 'string' && value.trim()) {
        display = value.trim();
        break;
      }
    }
    if (!display) {
      const patientId = Number(order.patient_id);
      const panelId = Number(order.panel_id);
      const sampleId = Number(order.sample_id);
      const patientName = Number.isFinite(patientId) && patientId > 0 ? getName('patients', patientId) : '';
      const panel = Number.isFinite(panelId) && panelId > 0 ? findById('panels', panelId) : null;
      const sample = Number.isFinite(sampleId) && sampleId > 0 ? findById('samples', sampleId) : null;
      const sampleLabel = sample?.pmb_number || '';
      const parts = [patientName, sampleLabel, panel?.name].filter(part => part && String(part).trim());
      if (parts.length) {
        display = parts.join(' • ');
      } else if (order.id != null) {
        display = `Ordination #${order.id}`;
      }
    }
  }
  if (!display && Number.isFinite(numericId)) {
    display = `Ordination #${numericId}`;
  }
  orderDisplayNameCache.set(numericId, display);
  return display;
}
async function addRecord(store, record) {
  const now = new Date().toISOString();
  if (CREATED_BY_STORES.has(store) && !record.created_by) {
    record.created_by = currentUserName();
  }
  if (UPDATED_BY_STORES.has(store)) {
    record.updated_by = currentUserName();
  }
  record.created_at = now;
  record.updated_at = now;
  const tx = state.db.transaction(store, 'readwrite');
  const req = tx.objectStore(store).add(record);
  const id = await requestToPromise(req);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('CREATE', store, id, null, record);
  scheduleAutosave();
  return id;
}
async function updateRecord(store, record, before) {
  record.updated_at = new Date().toISOString();
  if (UPDATED_BY_STORES.has(store)) {
    record.updated_by = currentUserName();
  }
  const tx = state.db.transaction(store, 'readwrite');
  tx.objectStore(store).put(record);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('UPDATE', store, record.id, before, record);
  scheduleAutosave();
}
async function deleteRecord(store, id) {
  const existing = findById(store, id);
  if (!existing) return;
  const tx = state.db.transaction(store, 'readwrite');
  tx.objectStore(store).delete(id);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('DELETE', store, id, existing, null);
  scheduleAutosave();
}
async function logAudit(action, entity, entityId, before, after) {
  const entry = {
    ts: new Date().toISOString(),
    user: currentUserName(),
    action,
    entity,
    entity_id: entityId ?? null,
    before: before ? JSON.stringify(before) : null,
    after: after ? JSON.stringify(after) : null
  };
  const tx = state.db.transaction('audit','readwrite');
  tx.objectStore('audit').add({...entry, created_at:new Date().toISOString(), updated_at:new Date().toISOString()});
  await tx.done?.catch(() => {});
  await loadStore('audit');
}
function scheduleAutosave() {
  if (!state.autosave || !state.boundHandle) return;
  if (state.autosaveTimer) clearTimeout(state.autosaveTimer);
  state.autosaveTimer = setTimeout(() => {
    saveBoundFile().catch(err => console.error(err));
  }, 1200);
}
async function exportData() {
  const data = {};
  for (const store of STORES) {
    data[store] = cloneWithCreatedBy(store, getCached(store));
  }
  return data;
}
async function saveBoundFile() {
  if (!state.boundHandle) {
    setStatus('Ingen fil tilknyttet.');
    return;
  }
  const writable = await state.boundHandle.createWritable();
  const data = await exportData();
  await writable.write(JSON.stringify(data, null, 2));
  await writable.close();
  setStatus('Autogemt kl. ' + new Date().toLocaleTimeString());
}
async function manualSave() {
  try {
    await saveBoundFile();
  } catch (err) {
    console.error(err);
    alert('Kunne ikke gemme: ' + err.message);
  }
}
async function bindDbFile() {
  try {
    const [handle] = await window.showOpenFilePicker({multiple:false, types:[{description:'GlimR-data', accept:{'application/json':['.json']}}]});
    state.boundHandle = handle;
    setStatus('Fil tilknyttet: ' + handle.name);
    const file = await handle.getFile();
    if (file.size > 0) {
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        await importData(data, true);
      } catch (err) {
        console.error(err);
        alert('Kunne ikke læse filen: ' + err.message);
      }
    }
  } catch (err) {
    if (err && err.name !== 'AbortError') {
      console.error(err);
      alert('Filtilknytning fejlede: ' + err.message);
    }
  }
  renderDbTab();
}
async function replaceAllData(data) {
  const timestamp = new Date().toISOString();
  for (const store of STORES) {
    const tx = state.db.transaction(store, 'readwrite');
    const objectStore = tx.objectStore(store);
    const clearReq = objectStore.clear();
    await requestToPromise(clearReq);
    const rows = data[store] ?? [];
    for (const row of rows) {
      if (!row.created_at) row.created_at = timestamp;
      if (!row.updated_at) row.updated_at = timestamp;
      objectStore.add(row);
    }
    await tx.done?.catch(() => {});
  }
  await loadAllStores();
}
async function importData(data, skipConfirm=false) {
  if (!currentCanWrite()) {
    alert('Import kræver login med skrivetilladelse.');
    return;
  }
  const proceed = skipConfirm || confirm('Dette vil overskrive eksisterende data. Fortsæt?');
  if (!proceed) return;
  await replaceAllData(data);
  setStatus('Data indlæst.');
  renderAll();
}
async function downloadBackup() {
  const data = await exportData();
  const filename = downloadJsonFile(data, 'glimr-backup.json');
  setStatus(`Fuld backup downloadet som ${filename}.`);
}
async function backupAndResetData() {
  if (!ensureWrite('patients')) return;
  const confirmReset = confirm('Dette vil hente en fuld backup og derefter slette alle data undtagen brugere. Fortsæt?');
  if (!confirmReset) return;
  const data = await exportData();
  const filename = downloadJsonFile(data, 'glimr-backup-pre-reset.json');
  const storesToClear = STORES.filter(store => store !== 'users');
  const preservedUsers = JSON.parse(JSON.stringify(getCached('users') || []));
  try {
    if (state.db) {
      state.db.close();
      state.db = null;
    }
    if (IDB) {
      await new Promise((resolve, reject) => {
        const req = IDB.deleteDatabase(DB_NAME);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
        req.onblocked = () => {
          alert('Databasen kunne ikke nulstilles, fordi den er åben i en anden fane. Luk andre GlimR-vinduer og prøv igen.');
        };
      });
    } else {
      writeMemoryDbSnapshot({});
    }
    state.cache.clear();
    state.db = await openDb();
    await loadAllStores();
    if (preservedUsers.length) {
      const tx = state.db.transaction('users', 'readwrite');
      const store = tx.objectStore('users');
      const now = new Date().toISOString();
      for (const user of preservedUsers) {
        if (!user.created_at) user.created_at = now;
        if (!user.updated_at) user.updated_at = now;
        store.put(user);
      }
      await tx.done?.catch(() => {});
    }
    await loadAllStores();
    await logAudit('RESET', 'system', null, null, {clearedStores: storesToClear});
    renderAll();
    restoreUserSession();
    scheduleAutosave();
    setStatus(`Data ryddet (undtagen brugere). Backup: ${filename}.`);
    alert(`Alle data undtagen brugere er nu ryddet. Backup er downloadet som ${filename}.`);
  } catch (err) {
    console.error(err);
    setStatus('Kunne ikke nulstille databasen: ' + err.message);
    alert('Kunne ikke nulstille databasen: ' + err.message);
    if (!state.db) {
      try {
        state.db = await openDb();
        await loadAllStores();
        restoreUserSession();
      } catch (reopenErr) {
        console.error(reopenErr);
      }
    }
  }
}
const CSV_LABEL_OVERRIDES = {
  id: 'ID',
  mrn: 'MRN',
  extra_id: 'Ekstra ID',
  family_number: 'Familienummer',
  name: 'Navn',
  gender: 'Køn (kode)',
  birth_date: 'Fødselsdato',
  notes: 'Noter',
  created_by: 'Oprettet af',
  created_at: 'Oprettet (ISO)',
  updated_at: 'Opdateret (ISO)',
  patient_id: 'Patient-ID',
  sample_id: 'Prøve-ID',
  panel_id: 'Panel-ID',
  pmb_number: 'PMB-nummer',
  sample_type: 'Prøvetype',
  collected_at: 'Opsamlet (ISO)',
  status: 'Status (kode)',
  ordered_at: 'Bestilt (ISO)',
  variant_type: 'Varianttype (kode)',
  hgvs_c: 'HGVS c.',
  hgvs_p: 'HGVS p.',
  rsid: 'rsID',
  af: 'Allelfrekvens',
  genome_build: 'Genom reference',
  sv_subtype: 'Strukturtype (kode)',
  size_bp: 'Størrelse (bp)',
  copy_number: 'Kopital',
  affected_genes: 'Berørte gener',
  order_id: 'Ordination-ID',
  summary: 'Konklusion',
  issued_at: 'Udstedt (ISO)',
  findings: 'Fund',
  variant_ids: 'Variant-ID\'er',
  variant_details: 'Variantdetaljer',
  annotations: 'Annoteringer',
  interpretation: 'Tolkning',
  clinician: 'Rekvirent',
  analysis_responsible_id: 'Analyseansvarlig-ID',
  interpreter_id: 'Tolker-ID',
  approver_id: 'Godkender-ID',
  gene: 'Gen/Region',
  transcript: 'Transkript',
  zygosity: 'Zygositet',
  chromosome: 'Kromosom',
  start: 'Start',
  end: 'Slut',
  description: 'Beskrivelse'
};
function getCsvLabel(key) {
  if (!key) return '';
  if (CSV_LABEL_OVERRIDES[key]) return CSV_LABEL_OVERRIDES[key];
  const parts = key.split('_').map(part => {
    if (!part) return '';
    if (part.length <= 3) return part.toUpperCase();
    return part.charAt(0).toUpperCase() + part.slice(1);
  });
  return parts.join(' ');
}
function inferCsvColumns(rows) {
  const keys = Array.from(new Set(rows.flatMap(row => row ? Object.keys(row) : [])));
  if (!keys.length) {
    return [{
      key: '__serialized__',
      label: 'Data',
      value: row => {
        try {
          return JSON.stringify(row ?? {});
        } catch (err) {
          return '';
        }
      }
    }];
  }
  return keys.map(key => ({key, label: getCsvLabel(key)}));
}
function formatJsonCell(value) {
  if (value == null || value === '') return '';
  if (typeof value === 'string') return value;
  try {
    return JSON.stringify(value);
  } catch (err) {
    return String(value);
  }
}
function exportFilteredCsv(baseName, rows, columns, meta = {}) {
  const data = Array.isArray(rows) ? rows : [];
  const cols = Array.isArray(columns) && columns.length ? columns : inferCsvColumns(data);
  const filename = downloadCsvFile(data, cols, baseName, meta.delimiter || ';');
  const plural = meta.plural || meta.entity || 'poster';
  setStatus(`Eksporterede ${data.length} ${plural} til ${filename}.`);
}
function triggerDownload(url, filename) {
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
function downloadJsonFile(data, baseName) {
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  return filename;
}
const WINDOWS_1252_EXTENDED = {
  0x20ac: 0x80,
  0x201a: 0x82,
  0x0192: 0x83,
  0x201e: 0x84,
  0x2026: 0x85,
  0x2020: 0x86,
  0x2021: 0x87,
  0x02c6: 0x88,
  0x2030: 0x89,
  0x0160: 0x8a,
  0x2039: 0x8b,
  0x0152: 0x8c,
  0x017d: 0x8e,
  0x2018: 0x91,
  0x2019: 0x92,
  0x201c: 0x93,
  0x201d: 0x94,
  0x2022: 0x95,
  0x2013: 0x96,
  0x2014: 0x97,
  0x02dc: 0x98,
  0x2122: 0x99,
  0x0161: 0x9a,
  0x203a: 0x9b,
  0x0153: 0x9c,
  0x017e: 0x9e,
  0x0178: 0x9f
};
function encodeWindows1252(str) {
  const bytes = [];
  for (let i = 0; i < str.length; i++) {
    let codePoint = str.codePointAt(i);
    if (codePoint > 0xffff) {
      i++;
    }
    if (codePoint <= 0xff) {
      bytes.push(codePoint);
      continue;
    }
    const mapped = WINDOWS_1252_EXTENDED[codePoint];
    if (mapped != null) {
      bytes.push(mapped);
    } else {
      bytes.push(0x3f);
    }
  }
  return new Uint8Array(bytes);
}
function sanitizeFirstCsvHeaderLabel(label) {
  if (label == null) return '';
  const text = String(label);
  const trimmedUpper = text.trim().toUpperCase();
  if (trimmedUpper === 'ID') {
    return 'Id';
  }
  return text;
}
function downloadCsvFile(rows, columns, baseName, delimiter = ';') {
  if (!Array.isArray(rows)) rows = [];
  const cols = columns.map(col => typeof col === 'string' ? {key: col, label: col} : col);
  const header = cols.map((col, index) => {
    const label = index === 0
      ? sanitizeFirstCsvHeaderLabel(col.label ?? col.key)
      : (col.label ?? col.key);
    return escapeCsvValue(label, delimiter);
  }).join(delimiter);
  const lines = rows.map(row => cols.map(col => {
    const raw = typeof col.value === 'function' ? col.value(row) : row?.[col.key];
    return escapeCsvValue(raw, delimiter);
  }).join(delimiter));
  const csv = [header, ...lines].join('\r\n');
  const encoded = encodeWindows1252(csv);
  const blob = new Blob([encoded], {type: 'text/csv;charset=windows-1252;'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  return filename;
}
function downloadTextFile(text, baseName) {
  if (typeof text !== 'string') text = '';
  const normalised = text.replace(/\r?\n|\r/g, '\r\n');
  const encoded = encodeWindows1252(normalised);
  const blob = new Blob([encoded], {type: 'text/plain;charset=windows-1252;'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  return filename;
}
function escapeCsvValue(value, delimiter) {
  if (value == null) value = '';
  if (value instanceof Date) value = value.toISOString();
  let str = String(value);
  if (!str) return '';
  str = str.replace(/\r?\n|\r/g, ' ');
  const needsQuotes = str.includes(delimiter) || str.includes('"') || /[\t]/.test(str) || /^\s|\s$/.test(str);
  let escaped = str.replace(/"/g, '""');
  if (needsQuotes) {
    escaped = `"${escaped}"`;
  }
  return escaped;
}
function withDateStamp(filename) {
  const stamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0].replace('T', '-');
  const dot = filename.lastIndexOf('.');
  if (dot === -1) return `${filename}-${stamp}`;
  return `${filename.slice(0, dot)}-${stamp}${filename.slice(dot)}`;
}
function detectCsvDelimiter(text) {
  const sample = (text || '').slice(0, 1024);
  const counts = {',': 0, ';': 0, '\t': 0};
  let inQuotes = false;
  for (let i = 0; i < sample.length; i++) {
    const char = sample[i];
    if (char === '"') {
      if (inQuotes && sample[i + 1] === '"') {
        i++;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }
    if (!inQuotes && (char === ',' || char === ';' || char === '\t')) {
      counts[char]++;
    }
    if (char === '\n' && !inQuotes) {
      break;
    }
  }
  if (counts[';'] >= counts[','] && counts[';'] >= counts['\t'] && counts[';'] > 0) return ';';
  if (counts[','] >= counts['\t'] && counts[','] > 0) return ',';
  if (counts['\t'] > 0) return '\t';
  return ';';
}
function parseCsv(text) {
  if (!text) return {headers: [], rows: [], delimiter: ';'};
  const cleaned = text.replace(/^\ufeff/, '');
  const delimiter = detectCsvDelimiter(cleaned);
  const rows = [];
  let field = '';
  let row = [];
  let inQuotes = false;
  for (let i = 0; i < cleaned.length; i++) {
    const char = cleaned[i];
    if (inQuotes) {
      if (char === '"') {
        if (cleaned[i + 1] === '"') {
          field += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        field += char;
      }
      continue;
    }
    if (char === '"') {
      inQuotes = true;
      continue;
    }
    if (char === '\r') {
      continue;
    }
    if (char === '\n') {
      row.push(field);
      rows.push(row);
      row = [];
      field = '';
      continue;
    }
    if (char === delimiter) {
      row.push(field);
      field = '';
      continue;
    }
    field += char;
  }
  if (inQuotes) {
    row.push(field);
  } else if (field !== '' || row.length) {
    row.push(field);
  }
  if (row.length) {
    rows.push(row);
  }
  while (rows.length && rows[rows.length - 1].every(cell => cell.trim() === '')) {
    rows.pop();
  }
  const headers = rows.shift() || [];
  return {headers: headers.map(h => h.trim()), rows, delimiter};
}
function normaliseHeader(header) {
  if (header == null) return '';
  let value = String(header).trim().toLowerCase();
  if (typeof value.normalize === 'function') {
    value = value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }
  return value.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
}
function mapVarSeqClassification(value) {
  if (value == null) return '';
  const raw = String(value).trim();
  if (!raw) return '';
  if (/^[1-5]$/.test(raw)) return raw;
  const digit = raw.match(/[1-5]/);
  if (digit) return digit[0];
  const lower = raw.toLowerCase();
  if (lower.includes('pathogenic')) {
    return lower.includes('likely') ? '4' : '5';
  }
  if (lower.includes('benign')) {
    return lower.includes('likely') ? '2' : '1';
  }
  if (lower.includes('vus') || lower.includes('uncertain') || lower.includes('ukendt')) {
    return '3';
  }
  if (lower.includes('risk')) return '3';
  return '';
}
function parseVarSeqVariants(text) {
  const {headers, rows} = parseCsv(text);
  if (!headers.length) throw new Error('CSV-filen mangler kolonneoverskrifter.');
  const headerMap = {
    gene: 'gene',
    gen: 'gene',
    gene_name: 'gene',
    gene_symbol: 'gene',
    transcript: 'transcript',
    transcript_id: 'transcript',
    transcript_accession: 'transcript',
    refseq_transcript: 'transcript',
    refseq: 'transcript',
    ensembl_transcript: 'transcript',
    cdna_change: 'hgvs_c',
    cdna_change_hgvs: 'hgvs_c',
    cdna: 'hgvs_c',
    c_hgvs: 'hgvs_c',
    hgvs_c: 'hgvs_c',
    coding_hgvs: 'hgvs_c',
    coding_dna_change: 'hgvs_c',
    protein_change: 'hgvs_p',
    protein_change_hgvs: 'hgvs_p',
    protein: 'hgvs_p',
    hgvs_p: 'hgvs_p',
    rsid: 'rsid',
    dbsnp: 'rsid',
    dbsnp_id: 'rsid',
    dbsnpid: 'rsid',
    dbsnp_rs: 'rsid',
    rs_id: 'rsid',
    amino_acid_change: 'hgvs_p',
    effect: 'hgvs_p',
    protein_effect: 'hgvs_p',
    zygosity: 'zygosity',
    genotype: 'zygosity',
    sample_zygosity: 'zygosity',
    classification: 'classification',
    classification_short: 'classification',
    acmg_classification: 'classification',
    acmg_class: 'classification',
    acmg_score: 'classification',
    acmg: 'criteria',
    acmg_evidence: 'criteria',
    acmg_criteria: 'criteria',
    acmg_codes: 'criteria',
    acmg_rule: 'criteria',
    allele_fraction: 'af',
    allele_frequency: 'af',
    allele_balance: 'af',
    allele_ratio: 'af',
    af: 'af',
    af_percent: 'af',
    variant_af: 'af',
    allel_frekvens: 'af',
    allelfrekvens: 'af',
    variant_type: 'variant_type',
    varianttype: 'variant_type',
    variant_class: 'variant_type',
    variant_category: 'variant_type',
    genome_build: 'genome_build',
    genome: 'genome_build',
    assembly: 'genome_build',
    chrom: 'chromosome',
    chromosome: 'chromosome',
    chr: 'chromosome',
    locus: 'chromosome',
    start: 'start',
    begin: 'start',
    position_start: 'start',
    end: 'end',
    stop: 'end',
    finish: 'end',
    position_end: 'end',
    copy_number: 'copy_number',
    copynumber: 'copy_number',
    cn: 'copy_number',
    copies: 'copy_number',
    cn_state: 'copy_number',
    sv_type: 'sv_subtype',
    sv_subtype: 'sv_subtype',
    structural_type: 'sv_subtype',
    cnv_type: 'sv_subtype',
    event_type: 'sv_subtype',
    size: 'size_bp',
    size_bp: 'size_bp',
    length: 'size_bp',
    span: 'size_bp',
    iscn: 'iscn',
    cytogenetic: 'iscn',
    cytogenetic_location: 'iscn',
    cytogenetic_band: 'iscn',
    description: 'description',
    notes: 'description',
    comment: 'description',
    comments: 'description',
    affected_genes: 'affected_genes',
    genes: 'affected_genes',
    gene_list: 'affected_genes'
  };
  const columnKeys = headers.map(header => headerMap[normaliseHeader(header)] || null);
  if (!columnKeys.some(key => key === 'gene' || key === 'hgvs_c' || key === 'hgvs_p' || key === 'iscn' || key === 'description')) {
    throw new Error('CSV-filen skal indeholde mindst én kolonne for gen eller HGVS.');
  }
  const variants = [];
  let skipped = 0;
  const warnings = [];
  const seenAnnotations = new Set();
  const toNumber = value => {
    if (value == null) return null;
    const trimmed = String(value).trim();
    if (!trimmed) return null;
    const hasPercent = /%/.test(trimmed);
    const normalised = trimmed.replace(/%/g, '').replace(/\s+/g, '').replace(',', '.');
    const parsed = Number(normalised);
    if (!Number.isFinite(parsed)) return null;
    const result = hasPercent ? parsed / 100 : parsed;
    return result;
  };
  rows.forEach((rowValues, index) => {
    if (!rowValues || rowValues.every(cell => !cell || !cell.trim())) {
      skipped++;
      return;
    }
    const entry = {};
    const annotations = [];
    columnKeys.forEach((key, idx) => {
      const rawValue = rowValues[idx];
      if (rawValue == null) return;
      const value = String(rawValue).trim();
      if (!value) return;
      if (!key) {
        const header = headers[idx] ?? `Kolonne ${idx + 1}`;
        const label = String(header).trim() || `Kolonne ${idx + 1}`;
        annotations.push(`${label}: ${value}`);
        seenAnnotations.add(label);
        return;
      }
      switch (key) {
        case 'gene':
          entry.gene = value;
          break;
        case 'transcript':
          entry.transcript = value;
          break;
        case 'hgvs_c':
          entry.hgvs_c = value;
          break;
        case 'hgvs_p':
          entry.hgvs_p = value;
          break;
        case 'rsid':
          entry.rsid = normalizeRsId(value);
          break;
        case 'zygosity':
          entry.zygosity = value;
          break;
        case 'classification':
          entry.classification = mapVarSeqClassification(value);
          if (!entry.classification && value) {
            warnings.push(`Række ${index + 2}: Ukendt klassifikation "${value}".`);
          }
          break;
        case 'criteria':
          entry.criteria = entry.criteria ? `${entry.criteria}; ${value}` : value;
          break;
        case 'af':
          const afValue = toNumber(value);
          if (afValue != null) {
            entry.af = afValue;
          } else {
            warnings.push(`Række ${index + 2}: Kunne ikke tolke allelfrekvens "${value}".`);
          }
          break;
        case 'variant_type':
          entry.variant_type = normalizeVariantType(value);
          break;
        case 'genome_build':
          entry.genome_build = value;
          break;
        case 'chromosome':
          entry.chromosome = value;
          break;
        case 'start':
          entry.start = value;
          break;
        case 'end':
          entry.end = value;
          break;
        case 'copy_number':
          entry.copy_number = value;
          break;
        case 'sv_subtype':
          entry.sv_subtype = normalizeStructureTypeValue(value);
          break;
        case 'size_bp':
          entry.size_bp = value;
          break;
        case 'iscn':
          entry.iscn = value;
          break;
        case 'description':
          entry.description = entry.description ? `${entry.description}; ${value}` : value;
          break;
        case 'affected_genes':
          entry.affected_genes = entry.affected_genes ? `${entry.affected_genes}; ${value}` : value;
          break;
        default:
          break;
      }
    });
    if (!entry.gene && !entry.hgvs_c && !entry.hgvs_p && !entry.iscn && !entry.description && !(entry.chromosome && (entry.start || entry.end))) {
      skipped++;
      return;
    }
    if (!entry.variant_type) {
      const hasStructuralMarkers = entry.iscn || entry.description || entry.copy_number || entry.sv_subtype || (entry.chromosome && (entry.start || entry.end));
      entry.variant_type = normalizeVariantType(hasStructuralMarkers ? 'cnv' : 'snv');
    }
    if (annotations.length) {
      entry.annotations = annotations.join(' | ');
    }
    variants.push(entry);
  });
  return {
    variants,
    warnings,
    summary: {
      total: rows.length,
      imported: variants.length,
      skipped,
      annotationColumns: Array.from(seenAnnotations)
    }
  };
}
async function parseVarSeqFile(file) {
  if (!file) throw new Error('Ingen fil valgt.');
  const text = await file.text();
  return parseVarSeqVariants(text);
}
async function restoreFromFile(file) {
  const text = await file.text();
  const data = JSON.parse(text);
  await importData(data);
}
function renderAll() {
  tabs.forEach(tab => renderTab(tab.id));
}
function renderTab(id) {
  const section = document.querySelector(`section[data-tab="${id}"]`);
  if (!section) return;
  switch(id) {
    case 'dashboard': return renderDashboard(section);
    case 'case_create': return renderCreateCase(section);
    case 'patients': return renderPatients(section);
    case 'samples': return renderSamples(section);
    case 'orders': return renderOrders(section);
    case 'panels': return renderPanels(section);
    case 'variants': return renderVariants(section);
    case 'variant_library': return renderVariantLibrary(section);
    case 'conclusion_library': return renderConclusionLibrary(section);
    case 'reports': return renderReports(section);
    case 'qc': return renderQC(section);
    case 'responses': return renderResponses(section);
    case 'tools': return renderTools(section);
    case 'users': return renderUsers(section);
    case 'audit': return renderAudit(section);
    case 'db': return renderDbTab(section);
    case 'admin': return renderAdmin(section);
    case 'tests': return renderTestsTab(section);
    default:
      section.innerHTML = '<p>Ingen data.</p>';
  }
}
function renderDashboard(section) {
  const patients = getCached('patients').length;
  const samples = getCached('samples');
  const sampleCount = samples.length;
  const orders = getCached('orders');
  const reports = getCached('reports');
  const variants = getCached('variants');
  const statusCounts = samples.reduce((acc, sample) => {
    const status = (sample.status || '').toLowerCase();
    if (status === 'modtaget') acc.received += 1;
    else if (status === 'qc') acc.qc += 1;
    else if (status === 'analyse') acc.analysis += 1;
    else if (status === 'tolkning') acc.interpretation += 1;
    else if (status === 'rapport') acc.report += 1;
    else if (status === 'biobank') acc.biobank += 1;
    return acc;
  }, {received: 0, qc: 0, analysis: 0, interpretation: 0, report: 0, biobank: 0});
  const activeCount = statusCounts.qc + statusCounts.analysis + statusCounts.interpretation + statusCounts.report;
  const recentOrders = orders.slice().sort((a,b)=> (b.updated_at||'').localeCompare(a.updated_at||'' )).slice(0,5);
  const inactiveSampleStatuses = new Set(['svaret','biobank','annulleret']);
  const activeOrders = orders.filter(order => {
    const sample = findById('samples', Number(order.sample_id));
    const status = (sample?.status || order.status || '').toLowerCase();
    return !inactiveSampleStatuses.has(status);
  });
  const MS_PER_DAY = 86400000;
  const MS_PER_WEEK = MS_PER_DAY * 7;
  const now = new Date();
  const weekAgo = new Date(now.getTime() - MS_PER_WEEK);
  const monthAgo = new Date(now.getTime() - MS_PER_DAY * 30);
  const responseDurations = [];
  reports.forEach(report => {
    const order = findById('orders', Number(report.order_id));
    if (!order) return;
    const sample = order.sample_id ? findById('samples', Number(order.sample_id)) : null;
    const receivedAt = parseDateTimeValue(sample?.created_at || sample?.collected_at || sample?.updated_at);
    const answeredAt = parseDateTimeValue(report.issued_at || report.updated_at || report.created_at);
    if (!receivedAt || !answeredAt) return;
    const diffDays = (answeredAt.getTime() - receivedAt.getTime()) / MS_PER_DAY;
    if (Number.isFinite(diffDays) && diffDays >= 0) {
      responseDurations.push(diffDays);
    }
  });
  const responseTimeP90 = calculatePercentile(responseDurations, 0.9);
  const samplesLastWeek = samples.filter(sample => {
    const receivedAt = parseDateTimeValue(sample.created_at || sample.collected_at || sample.updated_at);
    return receivedAt && receivedAt >= weekAgo;
  }).length;
  const samplesLastMonth = samples.filter(sample => {
    const receivedAt = parseDateTimeValue(sample.created_at || sample.collected_at || sample.updated_at);
    return receivedAt && receivedAt >= monthAgo;
  }).length;
  const ordersLastMonth = orders.filter(order => {
    const orderedAt = parseDateTimeValue(order.ordered_at || order.created_at || order.updated_at);
    return orderedAt && orderedAt >= monthAgo;
  });
  const ordersLastMonthCount = ordersLastMonth.length;
  const weeksCovered = Math.max((now.getTime() - monthAgo.getTime()) / MS_PER_WEEK, 1 / 52);
  const avgOrdersPerWeek = ordersLastMonthCount ? ordersLastMonthCount / weeksCovered : 0;
  const reportsLastMonth = reports.filter(report => {
    const issuedAt = parseDateTimeValue(report.issued_at || report.updated_at || report.created_at);
    return issuedAt && issuedAt >= monthAgo;
  });
  const reportsLastMonthCount = reportsLastMonth.length;
  const avgReportsPerWeek = reportsLastMonthCount ? reportsLastMonthCount / weeksCovered : 0;
  const avgOrdersPerWeekRounded = Math.round(avgOrdersPerWeek);
  const avgOrdersPerWeekDisplay = `${formatNumberDa(avgOrdersPerWeekRounded)} pr. uge`;
  const netOrdersPerWeek = avgOrdersPerWeek - avgReportsPerWeek;
  const netOrdersPerWeekRounded = Math.round(netOrdersPerWeek);
  const netOrdersPerWeekSign = netOrdersPerWeekRounded > 0 ? '+' : netOrdersPerWeekRounded < 0 ? '-' : '';
  const netOrdersDisplay = `${netOrdersPerWeekSign}${formatNumberDa(Math.abs(netOrdersPerWeekRounded))} pr. uge`;
  const metrics = [
    {icon: 'user-group', badge: 'Patienter', value: formatNumberDa(patients)},
    {icon: 'beaker', badge: 'Prøver', value: formatNumberDa(sampleCount)},
    {icon: 'clipboard-document-list', badge: 'Ordinationer', value: formatNumberDa(orders.length)},
    {icon: 'inbox', badge: 'Modtaget', value: formatNumberDa(statusCounts.received)},
    {icon: 'chart-bar', badge: 'Aktive', value: formatNumberDa(activeCount)},
    {icon: 'wrench-screwdriver', badge: 'Analyse', value: formatNumberDa(statusCounts.analysis)},
    {icon: 'book-open', badge: 'Tolkning', value: formatNumberDa(statusCounts.interpretation)},
    {icon: 'document-text', badge: 'Rapport', value: formatNumberDa(statusCounts.report)},
    {icon: 'dna', badge: 'Varianter', value: formatNumberDa(variants.length)},
    {icon: 'circle-stack', badge: 'Biobank', value: formatNumberDa(statusCounts.biobank)}
  ];
  const metricsHtml = metrics.map(metric => `
      <div class="dashboard-metric">
        <span class="icon-slot" data-icon="${metric.icon}"></span>
        <div><div class="badge">${esc(metric.badge)}</div><h3>${esc(metric.value)}</h3></div>
      </div>
    `).join('');
  const statsCards = [
    {icon: 'clock', label: "Svarstid (90%-fraktil)", value: formatDurationDays(responseTimeP90)},
    {icon: 'arrows-up-down', label: 'Nettoflow (30 dage)', value: netOrdersDisplay},
    {icon: 'inbox', label: 'Prøver modtaget (7 dage)', value: formatNumberDa(samplesLastWeek)},
    {icon: 'beaker', label: 'Prøver modtaget (30 dage)', value: formatNumberDa(samplesLastMonth)},
    {icon: 'document-chart-bar', label: 'Gns. ordinationer (30 dage)', value: avgOrdersPerWeekDisplay},
    {icon: 'clipboard-document-check', label: 'Rapporter udstedt (30 dage)', value: formatNumberDa(reportsLastMonthCount)}
  ];
  const statsCardsHtml = statsCards.map(stat => `
      <div class="dashboard-stat">
        <span class="icon-slot" data-icon="${stat.icon}"></span>
        <div>
          <div class="stat-label">${esc(stat.label)}</div>
          <div class="stat-value">${esc(stat.value)}</div>
        </div>
      </div>
    `).join('');
  const oldestActiveOrders = activeOrders
    .slice()
    .sort((a, b) => (a.updated_at || '').localeCompare(b.updated_at || ''))
    .slice(0, 5);
  const currentUserId = state.currentUser?.id ? String(state.currentUser.id) : '';
  let myActiveOrdersHtml = '';
  if (currentUserId) {
    const myActiveOrders = activeOrders.filter(order => {
      const analysisMatch = order.analysis_responsible_id !== undefined && order.analysis_responsible_id !== null && String(order.analysis_responsible_id) === currentUserId;
      const interpreterMatch = order.interpreter_id !== undefined && order.interpreter_id !== null && String(order.interpreter_id) === currentUserId;
      const approverMatch = order.approver_id !== undefined && order.approver_id !== null && String(order.approver_id) === currentUserId;
      return analysisMatch || interpreterMatch || approverMatch;
    });
    const sortedMyActiveOrders = myActiveOrders.slice().sort((a, b) => {
      const acuteA = a.acute ? 1 : 0;
      const acuteB = b.acute ? 1 : 0;
      if (acuteA !== acuteB) return acuteB - acuteA;
      const urgentA = a.urgent ? 1 : 0;
      const urgentB = b.urgent ? 1 : 0;
      if (urgentA !== urgentB) return urgentB - urgentA;
      const sampleA = findById('samples', Number(a.sample_id));
      const sampleB = findById('samples', Number(b.sample_id));
      const dateA = parseDateTimeValue(sampleA?.collected_at || sampleA?.created_at || a.created_at || a.ordered_at);
      const dateB = parseDateTimeValue(sampleB?.collected_at || sampleB?.created_at || b.created_at || b.ordered_at);
      const timeA = dateA ? dateA.getTime() : Number.POSITIVE_INFINITY;
      const timeB = dateB ? dateB.getTime() : Number.POSITIVE_INFINITY;
      if (timeA !== timeB) return timeA - timeB;
      const idA = Number(a.id);
      const idB = Number(b.id);
      if (Number.isFinite(idA) && Number.isFinite(idB)) return idA - idB;
      return String(a.id || '').localeCompare(String(b.id || ''));
    });
    myActiveOrdersHtml = sortedMyActiveOrders.map(o => {
      const sample = findById('samples', Number(o.sample_id));
      const roleLabels = [];
      if (o.analysis_responsible_id !== undefined && o.analysis_responsible_id !== null && String(o.analysis_responsible_id) === currentUserId) {
        roleLabels.push('Analyseansvarlig');
      }
      if (o.interpreter_id !== undefined && o.interpreter_id !== null && String(o.interpreter_id) === currentUserId) {
        roleLabels.push('Tolker');
      }
      if (o.approver_id !== undefined && o.approver_id !== null && String(o.approver_id) === currentUserId) {
        roleLabels.push('Godkender');
      }
      const statusDisplay = sample?.status || o.status || '';
      const collectedValue = sample?.collected_at || sample?.created_at || o.ordered_at || o.created_at;
      const collectedAt = formatDanishDate(collectedValue);
      const priorityIcons = renderOrderPriorityIcons(o);
      const priorityAttr = orderPriorityAttributes(o);
      const sampleDisplay = sample?.pmb_number || sample?.id || o.sample_id || '';
      const rolesDisplay = roleLabels.length ? roleLabels.join(', ') : '—';
      return `<tr data-order-id="${esc(o.id)}"${priorityAttr}><td>${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td>${esc(rolesDisplay)}</td><td>${esc(getName('patients', o.patient_id))}</td><td>${esc(sampleDisplay)}</td><td>${getName('panels', o.panel_id)}</td><td>${esc(statusDisplay)}</td><td>${esc(collectedAt)}</td></tr>`;
    }).join('') || '<tr><td colspan="7">Ingen aktive ordrer</td></tr>';
  }
  const audit = getCached('audit').slice(-5).reverse();
  const recentOrdersHtml = recentOrders.map(o => {
    const sample = findById('samples', Number(o.sample_id));
    const statusDisplay = sample?.status || o.status || '';
    const updatedAt = formatDanishDate(o.updated_at);
    const priorityIcons = renderOrderPriorityIcons(o);
    const priorityAttr = orderPriorityAttributes(o);
    return `<tr data-order-id="${esc(o.id)}"${priorityAttr}><td>${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td>${esc(getName('patients', o.patient_id))}</td><td>${esc(o.sample_id || '')}</td><td>${getName('panels', o.panel_id)}</td><td>${esc(statusDisplay)}</td><td>${esc(updatedAt)}</td></tr>`;
  }).join('') || '<tr><td colspan="6">Ingen</td></tr>';
  const oldestOrdersHtml = oldestActiveOrders.map(o => {
    const sample = findById('samples', Number(o.sample_id));
    const statusDisplay = sample?.status || o.status || '';
    const updatedAt = formatDanishDate(o.updated_at);
    const priorityIcons = renderOrderPriorityIcons(o);
    const priorityAttr = orderPriorityAttributes(o);
    return `<tr data-order-id="${esc(o.id)}"${priorityAttr}><td>${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td>${esc(getName('patients', o.patient_id))}</td><td>${esc(o.sample_id || '')}</td><td>${getName('panels', o.panel_id)}</td><td>${esc(statusDisplay)}</td><td>${esc(updatedAt)}</td></tr>`;
  }).join('') || '<tr><td colspan="6">Ingen aktive ordrer</td></tr>';
  const printableMetrics = metrics.map(item => ({badge: item.badge, value: item.value}));
  const printableStats = statsCards.map(item => ({label: item.label, value: item.value}));
  section.innerHTML = `
  <div class="panel">
    <div class="panel-header">
      <h2>KPI'er</h2>
      <button class="secondary with-icon" id="dashboardPrintButton" type="button">
        <span class="icon-slot" data-icon="document-chart-bar"></span>
        <span>Udskriv KPI'er og statistik</span>
      </button>
    </div>
    <div class="dashboard-metrics">
      ${metricsHtml}
    </div>
  </div>
  <div class="panel">
    <h2>Statistik</h2>
    <div class="dashboard-stats">
      ${statsCardsHtml}
    </div>
  </div>
  <div class="panel">
    <h2>Seneste ordrer</h2>
    <table>
      <thead><tr><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Status</th><th>Opdateret</th></tr></thead>
      <tbody>
        ${recentOrdersHtml}
      </tbody>
    </table>
  </div>
  <div class="panel">
    <h2>Ældste aktive ordrer</h2>
    <table>
      <thead><tr><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Status</th><th>Opdateret</th></tr></thead>
      <tbody>
        ${oldestOrdersHtml}
      </tbody>
    </table>
  </div>
  ${currentUserId ? `
  <div class="panel">
    <h2>Mine aktive ordrer</h2>
    <table>
      <thead><tr><th>ID</th><th>Rolle</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Status</th><th>Opsamlet</th></tr></thead>
      <tbody>
        ${myActiveOrdersHtml}
      </tbody>
    </table>
  </div>` : ''}
  <div class="panel">
    <h2>Revision</h2>
    <table>
      <thead><tr><th>Tid</th><th>Bruger</th><th>Handling</th><th>Entitet</th><th>ID</th></tr></thead>
      <tbody>
        ${audit.map(a => `<tr><td>${esc(a.ts)}</td><td>${esc(a.user)}</td><td>${esc(a.action)}</td><td>${esc(a.entity)}</td><td>${esc(a.entity_id??'')}</td></tr>`).join('') || '<tr><td colspan="5">Ingen</td></tr>'}
      </tbody>
    </table>
  </div>`;
  const printButton = section.querySelector('#dashboardPrintButton');
  if (printButton) {
    printButton.addEventListener('click', () => {
      openDashboardPrintView(printableMetrics, printableStats);
    });
  }
  applyIconSlots(section);
  applyMetricTooltips(section);
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  if (section._orderClickHandler) {
    section.removeEventListener('click', section._orderClickHandler);
  }
  const handleOrderClick = event => {
    const row = event.target.closest('tr[data-order-id]');
    if (!row || !section.contains(row)) return;
    const orderId = row.dataset.orderId;
    if (!orderId) return;
    openOrderDetails(orderId, {showAll: true});
  };
  section._orderClickHandler = handleOrderClick;
  section.addEventListener('click', handleOrderClick);
}

function openDashboardPrintView(metrics, stats) {
  if (!Array.isArray(metrics) || !Array.isArray(stats)) return;
  const metricsRows = metrics.length
    ? metrics.map(item => `<tr><th scope="row">${esc(item.badge)}</th><td>${esc(String(item.value ?? ''))}</td></tr>`).join('')
    : '<tr><td colspan="2">Ingen data</td></tr>';
  const statsRows = stats.length
    ? stats.map(item => `<tr><th scope="row">${esc(item.label)}</th><td>${esc(String(item.value ?? ''))}</td></tr>`).join('')
    : '<tr><td colspan="2">Ingen data</td></tr>';
  const generatedAt = new Date().toLocaleString('da-DK', {dateStyle: 'long', timeStyle: 'short'});
  const safeGeneratedAt = esc(generatedAt);
  const html = `<!DOCTYPE html>
  <html lang="da">
  <head>
    <meta charset="utf-8">
    <title>GlimR – KPI'er og statistik</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: "Segoe UI", Arial, sans-serif; margin: 2rem; color: #0f172a; background: #ffffff; }
      h1 { margin-top: 0; font-size: 1.75rem; }
      h2 { margin-top: 2rem; font-size: 1.2rem; }
      table { width: 100%; border-collapse: collapse; margin-top: 0.75rem; }
      th, td { text-align: left; padding: 0.6rem 0.75rem; border-bottom: 1px solid #d0d7e1; font-size: 1rem; }
      th { width: 55%; font-weight: 600; }
      .print-meta { color: #475569; margin-top: 0.5rem; font-size: 0.95rem; }
      @media print {
        body { margin: 1.5cm; }
        .print-meta { font-size: 0.85rem; }
      }
    </style>
  </head>
  <body>
    <h1>GlimR – KPI'er og statistik</h1>
    <p class="print-meta">Genereret ${safeGeneratedAt}</p>
    <section>
      <h2>KPI'er</h2>
      <table>
        <tbody>
          ${metricsRows}
        </tbody>
      </table>
    </section>
    <section>
      <h2>Statistik</h2>
      <table>
        <tbody>
          ${statsRows}
        </tbody>
      </table>
    </section>
  </body>
  </html>`;
  let printWindow = null;
  try {
    printWindow = window.open('about:blank', 'glimr-dashboard-print', 'popup=yes,width=900,height=700');
  } catch (error) {
    printWindow = null;
  }
  if (printWindow && !printWindow.closed) {
    const doc = printWindow.document;
    doc.open('text/html');
    doc.write(html);
    doc.close();
    printWindow.focus();
    setTimeout(() => {
      try {
        printWindow.print();
      } catch (err) {
        console.error('Udskrivning mislykkedes', err);
      }
    }, 50);
    return;
  }
  const iframe = document.createElement('iframe');
  iframe.setAttribute('title', 'Udskriftsvisning af KPI\'er og statistik');
  iframe.setAttribute('aria-hidden', 'true');
  iframe.style.position = 'fixed';
  iframe.style.width = '0';
  iframe.style.height = '0';
  iframe.style.border = '0';
  iframe.style.visibility = 'hidden';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument;
  if (!iframeDoc) {
    iframe.remove();
    return;
  }
  iframeDoc.open('text/html');
  iframeDoc.write(html);
  iframeDoc.close();
  const iframeWindow = iframe.contentWindow;
  if (!iframeWindow) {
    iframe.remove();
    return;
  }
  setTimeout(() => {
    try {
      iframeWindow.focus();
      iframeWindow.print();
    } catch (err) {
      console.error('Udskrivning mislykkedes', err);
    } finally {
      setTimeout(() => {
        iframe.remove();
      }, 400);
    }
  }, 50);
}

function renderCreateCase(section) {
  const panels = getCached('panels').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const patientGroups = getCached('patient_groups').slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'da'));
  const families = Array.from(new Set(getCached('patients').map(p => (p.family_number || '').trim()).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const familySelectOptions = ['<option value="">Vælg familienummer</option>']
    .concat(families.map(num => `<option value="${esc(num)}">${esc(num)}</option>`))
    .concat('<option value="__custom__">Tilføj nyt familienummer…</option>')
    .join('');
  const panelOptions = panels.length
    ? panels.map(p => `<option value="${p.id}">${esc(p.name || `Panel #${p.id}`)}</option>`).join('')
    : '<option value="" disabled>Ingen paneler tilgængelige</option>';
  const userOptions = users.map(u => `<option value="${u.id}">${esc(u.name || `Bruger #${u.id}`)}</option>`).join('');
  const patientGroupOptions = patientGroups.map(group => `<option value="${group.id}">${esc(group.name || `Patientgruppe #${group.id}`)}</option>`).join('');
  const typeOptions = SAMPLE_TYPES.map(type => `<option value="${type}">${type}</option>`).join('');
  const controlTypeOptions = SAMPLE_TYPES.map(type => {
    const selected = type.toLowerCase() === 'kontrol' ? ' selected' : '';
    return `<option value="${type}"${selected}>${type}</option>`;
  }).join('');
  const statusOptions = SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <h2>Opret komplet sag</h2>
    <form id="createCaseForm" class="case-form">
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Patient</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <div class="inline-group">
            <label class="inline">MRN<input name="patient_mrn" required placeholder="Fx 010170-1234"></label>
            <label class="inline">ID<input name="patient_extra_id" placeholder="Fx intern ID"></label>
            <label class="inline">Navn<input name="patient_name" required placeholder="Patientnavn"></label>
            <label class="inline">Familienummer
              <div class="family-combo">
                <select data-family-select>
                  ${familySelectOptions}
                </select>
                <input name="patient_family" data-family-input placeholder="Fx FAM-001">
              </div>
            </label>
          </div>
          <div class="inline-group">
            <label class="inline">Køn<select name="patient_gender"><option value="">-</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
            <label class="inline">Fødselsdato<input type="date" name="patient_birth"></label>
          </div>
          <label class="inline">Noter<textarea name="patient_notes" class="small" placeholder="Valgfrit"></textarea></label>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Prøve</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <div class="inline-group">
            <label class="inline">PMB-nummer<input name="sample_pmb" required placeholder="PMB-12345"></label>
            <label class="inline">Prøvetype<select name="sample_type" required><option value="" selected>Vælg type</option>${typeOptions}</select></label>
          </div>
          <div class="inline-group">
            <label class="inline">Status<select name="sample_status" required><option value="" selected>Vælg status</option>${statusOptions}</select></label>
            <label class="inline">Opsamlet<input type="datetime-local" name="sample_collected"></label>
          </div>
          <label class="inline">Noter<textarea name="sample_notes" class="small" placeholder="Valgfrit"></textarea></label>
          <label class="toggle"><input type="checkbox" id="includeControlSample"> Tilføj kontrolprøve</label>
          <div id="controlSampleFields" hidden>
            <div class="inline-group">
              <label class="inline">PMB-nummer<input name="control_pmb" placeholder="PMB-KONTROL"></label>
              <label class="inline">Prøvetype<select name="control_type">${controlTypeOptions}</select></label>
            </div>
            <div class="inline-group">
              <label class="inline">Status<select name="control_status"><option value="" selected>Vælg status</option>${statusOptions}</select></label>
              <label class="inline">Opsamlet<input type="datetime-local" name="control_collected"></label>
            </div>
            <label class="inline">Noter<textarea name="control_notes" class="small" placeholder="Valgfrit"></textarea></label>
          </div>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Ordination</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <div class="inline-group">
            <label class="inline">Panel
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer paneler">
                <select name="order_panel_id" ${panels.length ? 'required' : ''}>
                  <option value="" selected>Vælg panel</option>
                  ${panelOptions}
                </select>
              </div>
            </label>
            <label class="inline">Rekvirent<input name="order_clinician" placeholder="Afdeling/Læge"></label>
          </div>
          <div class="inline-group">
            <label class="inline">Patientgruppe
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer patientgrupper">
                <select name="order_patient_group">
                  <option value="" selected>Ingen</option>
                  ${patientGroupOptions}
                </select>
              </div>
            </label>
          </div>
          <div class="inline-group">
            <label class="inline">Analyseansvarlig
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="order_analysis_responsible">
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label class="inline">Tolker
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="order_interpreter">
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
          </div>
          <label>Indikation<textarea name="order_indication" rows="3" placeholder="Beskriv klinisk indikation"></textarea></label>
          <label>HPO-termer<textarea name="order_hpo_terms" class="small" placeholder="HP:0001250; HP:0004321"></textarea></label>
          <label class="toggle"><input type="checkbox" name="order_acute"> Markér ordinationen som akut</label>
          <label class="toggle"><input type="checkbox" name="order_urgent"> Markér ordinationen som haster</label>
          <div class="inline-group">
            <label class="inline">Godkender
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="order_approver">
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label class="inline">Bestilt<input type="datetime-local" name="order_ordered_at"></label>
          </div>
          <p class="form-hint" id="orderStatusPreview">Ordinationsstatus følger prøven: <strong id="orderStatusValue">–</strong></p>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Kvalitetskontrol</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <p class="form-hint">Tilføj QC-målinger for prøven (valgfrit).</p>
          <div id="qcList" class="repeater"></div>
          <button type="button" class="secondary" id="addQcRow">Tilføj måling</button>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Varianter</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <p class="form-hint" id="caseVariantHint">Registrer varianter fundet ved analysen. Tomme rækker ignoreres.</p>
          <div id="variantList" class="repeater"></div>
          <div class="btn-row">
            <button type="button" class="secondary" id="addVariantRow">Tilføj variant</button>
            <button type="button" class="secondary" id="caseImportVarSeq">Importér VarSeq CSV</button>
            <input type="file" id="caseImportVarSeqInput" accept=".csv,text/csv" hidden>
          </div>
        </div>
      </fieldset>
      <div class="btn-row">
        <button type="submit" class="primary" id="createCaseSubmit">Opret sag</button>
        <button type="reset" class="secondary" id="createCaseReset">Ryd formular</button>
      </div>
    </form>
    <div id="createCaseMessage" class="form-hint" role="status" aria-live="polite"></div>
  </div>`;
  const form = section.querySelector('#createCaseForm');
  const message = section.querySelector('#createCaseMessage');
  if (!form) return;
  const controlToggle = form.querySelector('#includeControlSample');
  const controlFields = form.querySelector('#controlSampleFields');
  const controlTypeSelect = form.elements.control_type;
  const controlStatusSelect = form.elements.control_status;
  const sampleStatusSelect = form.elements.sample_status;
  const orderedAtInput = form.elements.order_ordered_at;
  const addQcBtn = section.querySelector('#addQcRow');
  const qcList = section.querySelector('#qcList');
  const addVariantBtn = section.querySelector('#addVariantRow');
  const importVariantBtn = section.querySelector('#caseImportVarSeq');
  const importVariantInput = section.querySelector('#caseImportVarSeqInput');
  const variantList = section.querySelector('#variantList');
  const submitBtn = section.querySelector('#createCaseSubmit');
  const resetBtn = section.querySelector('#createCaseReset');
  const statusPreviewValue = section.querySelector('#orderStatusValue');
  const setMessage = (text, tone = 'info') => {
    if (!message) return;
    message.textContent = text;
    const color = tone === 'success' ? 'var(--accent-strong)' : tone === 'error' ? 'var(--danger)' : 'var(--muted-text)';
    message.style.color = color;
  };
  const toLocalDateTimeValue = (date = new Date()) => {
    const pad = value => String(value).padStart(2, '0');
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
  };
  const disableButtons = disabled => {
    if (submitBtn) submitBtn.disabled = disabled;
    if (resetBtn) resetBtn.disabled = disabled;
  };
  const updateControlVisibility = () => {
    if (!controlFields) return;
    const enabled = Boolean(controlToggle?.checked);
    controlFields.hidden = !enabled;
    controlFields.querySelectorAll('input, select, textarea').forEach(el => {
      el.disabled = !enabled;
    });
    if (enabled) {
      if (controlTypeSelect && !controlTypeSelect.value) {
        const defaultType = SAMPLE_TYPES.find(type => type.toLowerCase() === 'kontrol') || SAMPLE_TYPES[0] || '';
        if (defaultType) controlTypeSelect.value = defaultType;
      }
      if (controlStatusSelect && !controlStatusSelect.value && sampleStatusSelect) {
        controlStatusSelect.value = sampleStatusSelect.value;
      }
    }
  };
  const updateStatusPreview = () => {
    const value = sampleStatusSelect?.value || '';
    if (statusPreviewValue) statusPreviewValue.textContent = value || '–';
    if (controlStatusSelect && controlToggle?.checked && !controlStatusSelect.value) {
      controlStatusSelect.value = value;
    }
  };
  controlToggle?.addEventListener('change', updateControlVisibility);
  sampleStatusSelect?.addEventListener('change', updateStatusPreview);
  const addQcRow = (values = {}) => {
    if (!qcList) return;
    const row = document.createElement('div');
    row.className = 'case-row qc-row';
    row.innerHTML = `
      <label class="inline">Måling<input type="text" data-field="metric" placeholder="DNA-koncentration"></label>
      <label class="inline">Værdi<input type="number" step="0.0001" data-field="value" placeholder="42.0"></label>
      <label class="inline">Enhed<input type="text" data-field="unit" placeholder="ng/µl"></label>
      <label class="inline wide">Noter<input type="text" data-field="notes" placeholder="Valgfrit"></label>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const metricInput = row.querySelector('[data-field="metric"]');
    const valueInput = row.querySelector('[data-field="value"]');
    const unitInput = row.querySelector('[data-field="unit"]');
    const notesInput = row.querySelector('[data-field="notes"]');
    if (metricInput) metricInput.value = values.metric || '';
    if (valueInput) valueInput.value = values.value != null ? values.value : '';
    if (unitInput) unitInput.value = values.unit || '';
    if (notesInput) notesInput.value = values.notes || '';
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern denne måling');
    qcList.appendChild(row);
    applyButtonTooltips(row);
  };
  const addVariantRow = (values = {}) => {
    if (!variantList) return;
    const defaultClass = values.classification != null ? String(values.classification) : '3';
    const classificationOptions = ['1','2','3','4','5'].map(v => `<option value="${v}"${defaultClass === String(v) ? ' selected' : ''}>${v}</option>`).join('');
    const row = document.createElement('div');
    row.className = 'case-row variant-row';
    row.innerHTML = `
      <label class="inline">Varianttype<select data-field="variant_type">${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}</select></label>
      <label class="inline">Gen / region<input type="text" data-field="gene" data-type-required="snv" placeholder="BRCA1"></label>
      <div class="variant-batch-group variant-field-group" data-variant-types="snv">
        <label class="inline">Transkript<input type="text" data-field="transcript" data-type-required="snv" placeholder="NM_007294.3"></label>
        <label class="inline">HGVS c.<input type="text" data-field="hgvs_c" data-type-required="snv" placeholder="c.5266dupC"></label>
        <label class="inline">HGVS p.<input type="text" data-field="hgvs_p" placeholder="p.(Gln1756Profs*74)"></label>
        <label class="inline">dbSNP rsID<input type="text" data-field="rsid" placeholder="rs123456"></label>
        <label class="inline">Zygositet<input type="text" data-field="zygosity" placeholder="Heterozygot"></label>
      </div>
      <div class="variant-batch-group variant-field-group" data-variant-types="cnv sv cyto">
        <div class="variant-structure-grid">
          <label class="inline">Genom ref.<input type="text" data-field="genome_build" placeholder="GRCh38"></label>
          <label class="inline">Kromosom<input type="text" data-field="chromosome" placeholder="17p"></label>
          <label class="inline">Start<input type="text" data-field="start" placeholder="16287000"></label>
          <label class="inline">Slut<input type="text" data-field="end" placeholder="21100000"></label>
          <label class="inline">Kopital<input type="text" data-field="copy_number" placeholder="x1"></label>
          <label class="inline">Strukturtype<select data-field="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
          <label class="inline">Størrelse<input type="text" data-field="size_bp" placeholder="4.8 Mb"></label>
        </div>
        <label class="inline wide">ISCN<textarea class="small" data-field="iscn" placeholder="arr[GRCh38] 17p11.2p12(16287000_21100000)x1"></textarea></label>
        <label class="inline wide">Berørte gener<textarea class="small" data-field="affected_genes" placeholder="RAI1; PMP22"></textarea></label>
      </div>
      <label class="inline wide">Beskrivelse<textarea class="small" data-field="description" placeholder="Fri tekst"></textarea></label>
      <label class="inline">ACMG<select data-field="classification">${classificationOptions}</select></label>
      <label class="inline">Kriterier<input type="text" data-field="criteria" placeholder="PM1,PP3"></label>
      <label class="inline">Allelfrekvens<input type="number" step="0.0001" data-field="af" placeholder="0.125"></label>
      <label class="inline wide">Annoteringer<textarea class="small" data-field="annotations" placeholder="VarSeq-annoteringer og noter"></textarea></label>
      <label class="inline wide">Tolkning<textarea class="small" data-field="interpretation" placeholder="Kort tolkning"></textarea></label>
      <button type="button" class="secondary case-choose-library">Vælg fra bibliotek</button>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const setValue = (selector, value) => {
      const el = row.querySelector(selector);
      if (!el) return;
      if (selector.includes('sv_subtype') && el.tagName === 'SELECT') {
        const normalized = normalizeStructureTypeValue(value);
        const asString = normalized ? String(normalized) : '';
        if (el.dataset.allowLegacyOption !== undefined && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
          const opt = document.createElement('option');
          opt.value = asString;
          opt.textContent = getStructureTypeLabel(asString);
          opt.dataset.legacy = 'true';
          el.appendChild(opt);
        }
        el.value = asString;
        return;
      }
      if (selector.includes('rsid')) {
        el.value = normalizeRsId(value);
        return;
      }
      el.value = value || '';
    };
    setValue('[data-field="variant_type"]', normalizeVariantType(values.variant_type));
    setValue('[data-field="gene"]', values.gene);
    setValue('[data-field="transcript"]', values.transcript);
    setValue('[data-field="hgvs_c"]', values.hgvs_c);
    setValue('[data-field="hgvs_p"]', values.hgvs_p);
    setValue('[data-field="rsid"]', values.rsid);
    setValue('[data-field="zygosity"]', values.zygosity);
    setValue('[data-field="criteria"]', values.criteria);
    setValue('[data-field="genome_build"]', values.genome_build);
    setValue('[data-field="chromosome"]', values.chromosome);
    setValue('[data-field="start"]', values.start);
    setValue('[data-field="end"]', values.end);
    setValue('[data-field="copy_number"]', values.copy_number);
    setValue('[data-field="sv_subtype"]', values.sv_subtype);
    setValue('[data-field="size_bp"]', values.size_bp);
    setValue('[data-field="iscn"]', values.iscn);
    setValue('[data-field="affected_genes"]', values.affected_genes);
    setValue('[data-field="description"]', values.description);
    const afField = row.querySelector('[data-field="af"]');
    if (afField) {
      if (values.af !== undefined && values.af !== null && values.af !== '') {
        afField.value = values.af;
      } else {
        afField.value = '';
      }
    }
    const interpretationField = row.querySelector('[data-field="interpretation"]');
    if (interpretationField) interpretationField.value = values.interpretation || '';
    const annotationsField = row.querySelector('[data-field="annotations"]');
    if (annotationsField) annotationsField.value = values.annotations || '';
    const {updateVariantTypeFields} = setupVariantTypeForm(row, {
      defaultType: row.querySelector('[data-field="variant_type"]')?.value || 'snv',
      disableInactiveGroups: true
    });
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern varianten fra oprettelsen.');
    const libraryBtn = row.querySelector('.case-choose-library');
    libraryBtn?.addEventListener('click', () => {
      openVariantLibraryPicker(variant => {
        setValue('[data-field="variant_type"]', normalizeVariantType(variant.variant_type));
        setValue('[data-field="gene"]', variant.gene);
        setValue('[data-field="transcript"]', variant.transcript);
        setValue('[data-field="hgvs_c"]', variant.hgvs_c);
        setValue('[data-field="hgvs_p"]', variant.hgvs_p);
        setValue('[data-field="rsid"]', variant.rsid);
        setValue('[data-field="zygosity"]', variant.zygosity);
        setValue('[data-field="criteria"]', variant.criteria);
        setValue('[data-field="genome_build"]', variant.genome_build);
        setValue('[data-field="chromosome"]', variant.chromosome);
        setValue('[data-field="start"]', variant.start);
        setValue('[data-field="end"]', variant.end);
        setValue('[data-field="copy_number"]', variant.copy_number);
        setValue('[data-field="sv_subtype"]', variant.sv_subtype);
        setValue('[data-field="size_bp"]', variant.size_bp);
        setValue('[data-field="iscn"]', variant.iscn);
        setValue('[data-field="affected_genes"]', variant.affected_genes);
        setValue('[data-field="description"]', variant.description);
        const classField = row.querySelector('[data-field="classification"]');
        if (classField && variant.classification != null && variant.classification !== '') {
          classField.value = String(variant.classification);
        }
        const interpretationField = row.querySelector('[data-field="interpretation"]');
        if (interpretationField) interpretationField.value = variant.evidence || variant.interpretation || '';
        const annotationsField = row.querySelector('[data-field="annotations"]');
        if (annotationsField) annotationsField.value = variant.annotations || variant.annotation_summary || '';
        updateVariantTypeFields();
      });
    });
    if (libraryBtn) setTooltip(libraryBtn, 'Vælg en variant fra biblioteket.');
    variantList.appendChild(row);
    applyButtonTooltips(row);
    const rsidField = row.querySelector('[data-field="rsid"]');
    if (rsidField) setTooltip(rsidField, tooltipCatalog.forms.variantForm.rsid);
    const subtypeSelect = row.querySelector('[data-field="sv_subtype"]');
    if (subtypeSelect) setTooltip(subtypeSelect, tooltipCatalog.forms.variantForm.sv_subtype);
  };
  const isVariantRowEmpty = row => {
    if (!row) return true;
    const get = field => {
      const el = row.querySelector(`[data-field="${field}"]`);
      if (!el) return '';
      if (el.disabled) return '';
      const group = el.closest('[data-variant-types]');
      if (group && (group.hidden || group.classList.contains('variant-type-hidden'))) {
        return '';
      }
      if (el.type === 'number') return el.value.trim();
      return (el.value || '').trim();
    };
    const gene = get('gene');
    const transcript = get('transcript');
    const hgvsC = get('hgvs_c');
    const hgvsP = get('hgvs_p');
    const rsid = get('rsid');
    const zygosity = get('zygosity');
    const criteria = get('criteria');
    const af = get('af');
    const interpretation = get('interpretation');
    const annotations = get('annotations');
    const genomeBuild = get('genome_build');
    const chromosome = get('chromosome');
    const start = get('start');
    const end = get('end');
    const copyNumber = get('copy_number');
    const svSubtype = get('sv_subtype');
    const sizeBp = get('size_bp');
    const iscn = get('iscn');
    const description = get('description');
    const affectedGenes = get('affected_genes');
    return !gene && !transcript && !hgvsC && !hgvsP && !rsid && !zygosity && !criteria && !af && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
  };
  const removeEmptyVariantRows = () => {
    if (!variantList) return;
    const rows = Array.from(variantList.querySelectorAll('.variant-row'));
    if (!rows.length) return;
    const filled = rows.filter(row => !isVariantRowEmpty(row));
    if (!filled.length) {
      variantList.innerHTML = '';
      return;
    }
    rows.forEach(row => {
      if (isVariantRowEmpty(row)) row.remove();
    });
  };
  addQcBtn?.addEventListener('click', () => addQcRow());
  addVariantBtn?.addEventListener('click', () => addVariantRow());
  importVariantBtn?.addEventListener('click', () => importVariantInput?.click());
  importVariantInput?.addEventListener('change', async () => {
    const file = importVariantInput?.files?.[0];
    if (!file) return;
    try {
      const {variants: importedVariants, warnings, summary} = await parseVarSeqFile(file);
      if (!importedVariants.length) {
        setMessage('Ingen varianter blev fundet i filen.', 'error');
        return;
      }
      removeEmptyVariantRows();
      importedVariants.forEach(variant => addVariantRow(variant));
      const parts = [`Tilføjede ${importedVariants.length} varianter fra ${file.name}.`];
      if (summary.skipped) parts.push(`${summary.skipped} rækker blev ignoreret.`);
      if (warnings.length) parts.push(`${warnings.length} advarsler blev logget i konsollen.`);
      const messageText = parts.join(' ');
      setMessage(messageText, 'success');
      setStatus(`VarSeq import til oprettelse: ${importedVariants.length} varianter klar.`);
      if (warnings.length) console.warn('VarSeq import advarsler', warnings);
    } catch (err) {
      console.error(err);
      setMessage('Kunne ikke importere VarSeq CSV: ' + (err?.message || err), 'error');
    } finally {
      if (importVariantInput) importVariantInput.value = '';
    }
  });
  addQcRow();
  addVariantRow();
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  initCollapsibleFieldsets(form);
  initFamilyCombos(form);
  applySelectFilters(section);
  updateControlVisibility();
  updateStatusPreview();
  if (orderedAtInput && !orderedAtInput.value) {
    orderedAtInput.value = toLocalDateTimeValue();
  }
  form.addEventListener('reset', () => {
    setTimeout(() => {
      setMessage('');
      updateControlVisibility();
      updateStatusPreview();
      if (qcList) {
        qcList.innerHTML = '';
        addQcRow();
      }
      if (variantList) {
        variantList.innerHTML = '';
        addVariantRow();
      }
      if (orderedAtInput) orderedAtInput.value = toLocalDateTimeValue();
    }, 0);
  });
  let submitting = false;
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (submitting) return;
    submitting = true;
    disableButtons(true);
    setMessage('');
    const patientMrn = form.elements.patient_mrn.value.trim();
    if (!patientMrn) {
      setMessage('Angiv patientens MRN.', 'error');
      form.elements.patient_mrn.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const patientName = form.elements.patient_name.value.trim();
    if (!patientName) {
      setMessage('Angiv patientens navn.', 'error');
      form.elements.patient_name.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const patient = {
      mrn: patientMrn,
      extra_id: form.elements.patient_extra_id?.value.trim() || '',
      family_number: form.elements.patient_family?.value.trim() || '',
      name: patientName,
      gender: form.elements.patient_gender.value || '',
      birth_date: form.elements.patient_birth.value || '',
      notes: form.elements.patient_notes.value.trim()
    };
    const samplePmb = form.elements.sample_pmb.value.trim();
    if (!samplePmb) {
      setMessage('Angiv et PMB-nummer for prøven.', 'error');
      form.elements.sample_pmb.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sampleTypeValue = form.elements.sample_type.value.trim();
    if (!sampleTypeValue) {
      setMessage('Vælg prøvetype.', 'error');
      form.elements.sample_type.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sampleStatusValue = form.elements.sample_status.value.trim();
    if (!sampleStatusValue) {
      setMessage('Vælg prøvens status.', 'error');
      form.elements.sample_status.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sample = {
      pmb_number: samplePmb,
      sample_type: sampleTypeValue,
      status: sampleStatusValue,
      collected_at: form.elements.sample_collected.value || '',
      notes: form.elements.sample_notes.value.trim()
    };
    let controlSample = null;
    if (controlToggle?.checked) {
      const controlPmb = form.elements.control_pmb.value.trim();
      if (!controlPmb) {
        setMessage('Angiv PMB-nummer for kontrolprøven.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
      const controlTypeValue = (form.elements.control_type?.value || '').trim();
      const controlStatusValue = (form.elements.control_status?.value || '').trim();
      controlSample = {
        pmb_number: controlPmb,
        sample_type: controlTypeValue || (SAMPLE_TYPES.find(type => type.toLowerCase() === 'kontrol') || sample.sample_type),
        status: controlStatusValue || sample.status,
        collected_at: form.elements.control_collected.value || '',
        notes: form.elements.control_notes.value.trim()
      };
    }
    const panelIdValue = form.elements.order_panel_id.value;
    if (!panelIdValue) {
      setMessage('Vælg panel til ordinationen.', 'error');
      form.elements.order_panel_id.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    let orderedAt = form.elements.order_ordered_at.value;
    if (!orderedAt) orderedAt = toLocalDateTimeValue();
    const orderIndication = form.elements.order_indication.value.trim();
    const orderHpoTerms = normalizeHpoTerms(form.elements.order_hpo_terms.value);
    const order = {
      panel_id: Number(panelIdValue),
      analysis_responsible_id: form.elements.order_analysis_responsible.value ? Number(form.elements.order_analysis_responsible.value) : null,
      interpreter_id: form.elements.order_interpreter.value ? Number(form.elements.order_interpreter.value) : null,
      approver_id: form.elements.order_approver.value ? Number(form.elements.order_approver.value) : null,
      clinician: form.elements.order_clinician.value.trim(),
      indication: orderIndication,
      patient_group_id: form.elements.order_patient_group.value ? Number(form.elements.order_patient_group.value) : null,
      hpo_terms: orderHpoTerms,
      status: sample.status,
      acute: form.elements.order_acute.checked,
      urgent: form.elements.order_urgent.checked,
      ordered_at: orderedAt
    };
    const qcEntries = [];
    if (qcList) {
      for (const row of qcList.querySelectorAll('.qc-row')) {
        const metric = row.querySelector('[data-field="metric"]')?.value.trim() || '';
        const value = row.querySelector('[data-field="value"]')?.value.trim() || '';
        const unit = row.querySelector('[data-field="unit"]')?.value.trim() || '';
        const notes = row.querySelector('[data-field="notes"]')?.value.trim() || '';
        if (!metric && !value && !unit && !notes) continue;
        if (!metric || !value) {
          setMessage('Angiv både måling og værdi for QC-poster.', 'error');
          row.querySelector('[data-field="metric"]')?.focus();
          disableButtons(false);
          submitting = false;
          return;
        }
        qcEntries.push({metric, value, unit, notes});
      }
    }
    const variantEntries = [];
    if (variantList) {
      for (const row of variantList.querySelectorAll('.variant-row')) {
        const variantType = normalizeVariantType(row.querySelector('[data-field="variant_type"]')?.value || 'snv');
        const getFieldValue = fieldName => {
          const el = row.querySelector(`[data-field="${fieldName}"]`);
          if (!el) return '';
          if (el.disabled) return '';
          const group = el.closest('[data-variant-types]');
          if (group && (group.hidden || group.classList.contains('variant-type-hidden'))) {
            return '';
          }
          if (el.type === 'number') {
            return el.value.trim();
          }
          return (el.value || '').trim();
        };
        const gene = getFieldValue('gene');
        const transcript = getFieldValue('transcript');
        const hgvsC = getFieldValue('hgvs_c');
        const hgvsP = getFieldValue('hgvs_p');
        const rsid = getFieldValue('rsid');
        const zygosity = getFieldValue('zygosity');
        const classification = row.querySelector('[data-field="classification"]')?.value || '3';
        const criteria = getFieldValue('criteria');
        const afRaw = getFieldValue('af');
        const interpretation = getFieldValue('interpretation');
        const annotations = getFieldValue('annotations');
        const genomeBuild = getFieldValue('genome_build');
        const chromosome = getFieldValue('chromosome');
        const start = getFieldValue('start');
        const end = getFieldValue('end');
        const copyNumber = getFieldValue('copy_number');
        const svSubtype = normalizeStructureTypeValue(getFieldValue('sv_subtype'));
        const sizeBp = getFieldValue('size_bp');
        const iscn = getFieldValue('iscn');
        const description = getFieldValue('description');
        const affectedGenes = getFieldValue('affected_genes');
        const isEmpty = !gene && !transcript && !hgvsC && !hgvsP && !rsid && !zygosity && !criteria && !afRaw && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
        if (isEmpty) continue;
        if (variantType === 'snv') {
          if (!gene) {
            setMessage('Angiv gen for hver SNV/indel.', 'error');
            row.querySelector('[data-field="gene"]')?.focus();
            disableButtons(false);
            submitting = false;
            return;
          }
        } else {
          if (!iscn && !description && !chromosome) {
            setMessage('Angiv ISCN, kromosom eller beskrivelse for strukturelle varianter.', 'error');
            (row.querySelector('[data-field="iscn"]') || row.querySelector('[data-field="description"]') || row.querySelector('[data-field="chromosome"]'))?.focus();
            disableButtons(false);
            submitting = false;
            return;
          }
        }
        const variant = {
          variant_type: variantType,
          gene,
          transcript,
          hgvs_c: hgvsC,
          hgvs_p: hgvsP,
          rsid: normalizeRsId(rsid),
          zygosity,
          classification: String(classification || '3'),
          criteria,
          interpretation,
          genome_build: genomeBuild,
          chromosome,
          start,
          end,
          copy_number: copyNumber,
          sv_subtype: svSubtype,
          size_bp: sizeBp,
          iscn,
          description,
          affected_genes: affectedGenes
        };
        if (afRaw) {
          const afNumber = Number(afRaw);
          if (!Number.isFinite(afNumber)) {
            setMessage('Allelfrekvens skal være et tal.', 'error');
            row.querySelector('[data-field="af"]')?.focus();
            disableButtons(false);
            submitting = false;
            return;
          }
          variant.af = afNumber;
        }
        if (annotations) {
          variant.annotations = annotations;
        }
        variantEntries.push(variant);
      }
    }
    const requiredStores = new Set(['patients','samples','orders']);
    if (qcEntries.length) requiredStores.add('qc');
    if (variantEntries.length) requiredStores.add('variants');
    for (const store of requiredStores) {
      if (!ensureWrite(store)) {
        setMessage('Handling kræver skriveadgang. Kontakt en administrator.', 'error');
        disableButtons(false);
        submitting = false;
        return;
      }
    }
    const existingSamples = getCached('samples');
    const primaryPmbLower = sample.pmb_number.toLowerCase();
    if (existingSamples.some(s => (s.pmb_number || '').toLowerCase() === primaryPmbLower)) {
      setMessage('PMB-nummeret for hovedprøven er allerede i brug.', 'error');
      form.elements.sample_pmb.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    if (controlSample) {
      const controlPmbLower = controlSample.pmb_number.toLowerCase();
      if (controlPmbLower === primaryPmbLower) {
        setMessage('Kontrolprøven skal have et andet PMB-nummer end hovedprøven.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
      if (existingSamples.some(s => (s.pmb_number || '').toLowerCase() === controlPmbLower)) {
        setMessage('Kontrolprøvens PMB-nummer er allerede i brug.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
    }
    try {
      setMessage('Opretter sag...', 'info');
      const patientId = await addRecord('patients', patient);
      const sampleId = await addRecord('samples', {...sample, patient_id: patientId});
      if (controlSample) {
        await addRecord('samples', {...controlSample, patient_id: patientId});
      }
      const orderId = await addRecord('orders', {...order, patient_id: patientId, sample_id: sampleId});
      for (const qc of qcEntries) {
        await addRecord('qc', {...qc, sample_id: sampleId});
      }
      for (const variant of variantEntries) {
        await addRecord('variants', {...variant, order_id: orderId});
      }
      form.reset();
      setMessage(`Sag ${orderId} oprettet for ${patient.name} med PMB ${sample.pmb_number}.`, 'success');
      setStatus(`Sag ${orderId} oprettet for ${patient.name}.`);
      const dashboardSection = document.querySelector('section[data-tab="dashboard"]');
      if (dashboardSection) renderDashboard(dashboardSection);
      ['patients','samples','orders','qc','variants'].forEach(id => {
        const target = document.querySelector(`section[data-tab="${id}"]`);
        if (target && target.classList.contains('active')) {
          renderTab(id);
        }
      });
    } catch (err) {
      console.error(err);
      setMessage('Kunne ikke oprette sag: ' + (err?.message || err), 'error');
      setStatus('Fejl under oprettelse: ' + (err?.message || err));
    } finally {
      disableButtons(false);
      submitting = false;
    }
  });
  if (!panels.length) {
    setMessage('Opret først et panel under "Analyser/Panels" for at kunne oprette en sag.', 'error');
    disableButtons(true);
  } else {
    setMessage('');
    disableButtons(false);
  }
}
function getName(store, id) {
  if (!id) return '';
  const row = findById(store, typeof id === 'string' ? Number(id) : id);
  if (!row) return '';
  if (store === 'patients') {
    const name = row.name || '';
    const details = [row.mrn, row.extra_id, row.family_number].filter(Boolean).join(' • ');
    if (name && details) return `${name} (${details})`;
    if (name) return name;
    if (details) return details;
  }
  return row.pmb_number || row.name || row.mrn || row.extra_id || `#${id}`;
}

function getPatientGroupName(id) {
  if (!id) return '';
  const numericId = typeof id === 'string' ? Number(id) : id;
  if (!Number.isFinite(numericId) || numericId <= 0) return '';
  const group = findById('patient_groups', numericId);
  return group?.name || '';
}

async function ensureDefaultPatientGroups() {
  const existing = getCached('patient_groups');
  if (existing && existing.length) return;
  for (const name of DEFAULT_PATIENT_GROUPS) {
    await addRecord('patient_groups', {name});
  }
  await loadStore('patient_groups');
}
function creationKey(entity, id) {
  if (!entity || id === undefined || id === null) return null;
  return `${entity}:${id}`;
}
function rebuildCreationLookup() {
  const auditEntries = getCached('audit') || [];
  const map = new Map();
  for (const entry of auditEntries) {
    if (!entry || entry.action !== 'CREATE') continue;
    const key = creationKey(entry.entity, entry.entity_id);
    if (!key || map.has(key)) continue;
    let creator = entry.user || '';
    if ((!creator || creator === 'System') && entry.after) {
      try {
        const after = JSON.parse(entry.after);
        if (after?.created_by) creator = after.created_by;
      } catch (err) {
        /* ignore parse errors */
      }
    }
    if (creator) {
      map.set(key, creator);
    }
  }
  state.creationLookup = map;
}
function determineCreatedBy(store, record) {
  if (!record) return 'Ukendt';
  if (record.created_by) return record.created_by;
  const key = creationKey(store, record.id);
  if (key && state.creationLookup?.has(key)) {
    return state.creationLookup.get(key) || 'Ukendt';
  }
  return 'Ukendt';
}
function cloneWithCreatedBy(store, rows) {
  if (!Array.isArray(rows)) return [];
  if (!CREATED_BY_STORES.has(store)) {
    return rows.map(row => ({...row}));
  }
  return rows.map(row => {
    const clone = {...row};
    const creator = determineCreatedBy(store, row);
    if (creator && creator !== clone.created_by) {
      clone.created_by = creator;
    }
    return clone;
  });
}
async function ensureCreationMetadata() {
  if (!state.db) return;
  const stores = Array.from(CREATED_BY_STORES);
  const toReload = [];
  for (const store of stores) {
    const list = getCached(store) || [];
    const pending = [];
    for (const row of list) {
      if (!row) continue;
      const creator = determineCreatedBy(store, row);
      if (creator && creator !== 'Ukendt' && creator !== row.created_by) {
        pending.push({...row, created_by: creator});
      }
    }
    if (!pending.length) continue;
    const tx = state.db.transaction(store, 'readwrite');
    const objectStore = tx.objectStore(store);
    for (const record of pending) {
      objectStore.put(record);
    }
    await tx.done?.catch(() => {});
    toReload.push(store);
  }
  if (toReload.length) {
    for (const store of toReload) {
      await loadStore(store);
    }
  }
}
function fillForm(form, record) {
  if (!form || !record) return;
  Array.from(form.elements).forEach(el => {
    if (!el.name) return;
    if (!(el.name in record)) {
      return;
    }
    let value = record[el.name];
    if (el.name === 'sv_subtype') {
      value = normalizeStructureTypeValue(value);
    }
    if (el.type === 'checkbox') {
      el.checked = Boolean(value);
      return;
    }
    if (el.type === 'password') {
      el.value = '';
      return;
    }
    if (el.tagName === 'SELECT') {
      const asString = value == null ? '' : String(value);
      if (el.name === 'role' && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
        const opt = document.createElement('option');
        opt.value = asString;
        opt.textContent = roleWithDescription(asString);
        opt.dataset.legacy = 'true';
        el.appendChild(opt);
      }
      if (el.dataset.allowLegacyOption !== undefined && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
        const opt = document.createElement('option');
        opt.value = asString;
        opt.textContent = el.name === 'sv_subtype' ? getStructureTypeLabel(asString) : asString;
        opt.dataset.legacy = 'true';
        el.appendChild(opt);
      }
      el.value = asString;
      return;
    }
    el.value = value ?? '';
    if (el.dataset.familyInput !== undefined) {
      el.dispatchEvent(new Event('input', {bubbles: false}));
    }
  });
}

function clearFormIdentifier(form, fieldName = 'id') {
  if (!form) return;
  const field = form.elements[fieldName];
  if (!field) return;
  field.value = '';
  if ('defaultValue' in field) {
    field.defaultValue = '';
  }
}
function renderPatients(section) {
  const list = getCached('patients');
  const orders = getCached('orders');
  const patientIndicationSets = new Map();
  for (const order of orders) {
    if (!order) continue;
    const patientId = Number(order.patient_id);
    if (!Number.isFinite(patientId) || patientId <= 0) continue;
    const indication = formatIndicationForList(order.indication);
    if (!indication) continue;
    if (!patientIndicationSets.has(patientId)) {
      patientIndicationSets.set(patientId, new Set());
    }
    patientIndicationSets.get(patientId).add(indication);
  }
  const getPatientIndications = id => {
    const set = patientIndicationSets.get(Number(id));
    if (!set || !set.size) return '';
    return Array.from(set).join(', ');
  };
  const existingFamilyNumbers = Array.from(new Set(list.map(p => (p.family_number || '').trim()).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const familySelectOptions = ['<option value="">Vælg familienummer</option>']
    .concat(existingFamilyNumbers.map(num => `<option value="${esc(num)}">${esc(num)}</option>`))
    .concat('<option value="__custom__">Tilføj nyt familienummer…</option>')
    .join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="patientSearch">Søg</label>
        <input id="patientSearch" type="search" placeholder="Navn/MRN/ID/familie...">
        <details class="advanced-filter" id="patientsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-patients="id" placeholder="Fx 152"></label>
            <label>MRN<input type="search" data-filter-patients="mrn" placeholder="MRN eller CPR"></label>
            <label>ID<input type="search" data-filter-patients="extra" placeholder="Fx lokalt ID"></label>
            <label>Familienummer<input type="search" data-filter-patients="family" placeholder="Fx FAM-001"></label>
            <label>Navn<input type="search" data-filter-patients="name" placeholder="Patientnavn"></label>
            <label>Køn<select data-filter-patients="gender"><option value="">Alle</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
            <label>Fødselsår<input type="search" data-filter-patients="birth" placeholder="ÅÅÅÅ"></label>
            <label>Indikation<input type="search" data-filter-patients="indication" placeholder="Indikation"></label>
          </div>
        </details>
        <table id="patientsTable"><thead><tr><th>ID</th><th>MRN</th><th>ID</th><th>Familienummer</th><th>Navn</th><th>Køn</th><th>Født</th><th>Indikationer</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="patientsExport">Eksportér filtrerede patienter</button>
        </div>
      </div>
      <div>
        <h2>Patient</h2>
        <form id="patientForm">
          <input type="hidden" name="id">
          <label>MRN<input name="mrn" required></label>
          <label>ID<input name="extra_id" placeholder="Fx lokalt ID"></label>
          <label>Familienummer
            <div class="family-combo">
              <select data-family-select>
                ${familySelectOptions}
              </select>
              <input name="family_number" data-family-input placeholder="Fx FAM-001">
            </div>
          </label>
          <label>Navn<input name="name" required></label>
          <label>Køn<select name="gender"><option value="">-</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
          <label>Fødselsdato<span class="label-note" data-patient-age hidden></span><input type="date" name="birth_date"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button type="submit" class="primary action-button action-save with-icon">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button type="button" id="patientClear" class="secondary action-button action-new with-icon">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button type="button" id="patientDelete" class="danger action-button action-delete with-icon">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('#patientsTable tbody');
  const form = section.querySelector('#patientForm');
  const searchInput = section.querySelector('#patientSearch');
  const deleteBtn = section.querySelector('#patientDelete');
  const clearBtn = section.querySelector('#patientClear');
  const filterInputs = {
    id: section.querySelector('[data-filter-patients="id"]'),
    mrn: section.querySelector('[data-filter-patients="mrn"]'),
    extra: section.querySelector('[data-filter-patients="extra"]'),
    family: section.querySelector('[data-filter-patients="family"]'),
    name: section.querySelector('[data-filter-patients="name"]'),
    gender: section.querySelector('[data-filter-patients="gender"]'),
    birth: section.querySelector('[data-filter-patients="birth"]'),
    indication: section.querySelector('[data-filter-patients="indication"]')
  };
  const birthDateInput = form?.elements.birth_date;
  const ageNote = form?.querySelector('[data-patient-age]');
  const updateAgeNote = () => {
    if (!ageNote) return;
    const ageText = birthDateInput ? formatAgeFromBirthDate(birthDateInput.value) : '';
    if (ageText) {
      ageNote.textContent = `(${ageText})`;
      ageNote.hidden = false;
    } else {
      ageNote.textContent = '';
      ageNote.hidden = true;
    }
  };
  birthDateInput?.addEventListener('input', updateAgeNote);
  let filteredPatients = list.slice();
  let activeFilters = {};
  let selectedPatientId = null;
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  initFamilyCombos(form);
  const genderMap = {male:'Mand', female:'Kvinde', other:'Andet'};
  const renderRows = () => {
    const term = searchInput.value.trim().toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      mrn: filterInputs.mrn?.value.trim().toLowerCase() || '',
      extra: filterInputs.extra?.value.trim().toLowerCase() || '',
      family: filterInputs.family?.value.trim().toLowerCase() || '',
      name: filterInputs.name?.value.trim().toLowerCase() || '',
      gender: filterInputs.gender?.value || '',
      birth: filterInputs.birth?.value.trim().toLowerCase() || '',
      indication: filterInputs.indication?.value.trim().toLowerCase() || ''
    };
    const filterSummary = {...filters};
    if (filters.indication) filterSummary.indikation = filters.indication;
    delete filterSummary.indication;
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredPatients = list.filter(p => {
      if (!term) return true;
      const displayGender = genderMap[p.gender];
      const creator = determineCreatedBy('patients', p);
      const indications = getPatientIndications(p.id);
      return [p.name, p.mrn, p.extra_id, p.family_number, p.gender, displayGender, creator, indications].some(v => (v||'').toLowerCase().includes(term));
    }).filter(p => {
      const indicationText = getPatientIndications(p.id).toLowerCase();
      if (filters.id && !String(p.id).includes(filters.id)) return false;
      if (filters.mrn && !(p.mrn||'').toLowerCase().includes(filters.mrn)) return false;
      if (filters.extra && !(p.extra_id||'').toLowerCase().includes(filters.extra)) return false;
      if (filters.family && !(p.family_number||'').toLowerCase().includes(filters.family)) return false;
      if (filters.name && !(p.name||'').toLowerCase().includes(filters.name)) return false;
      if (filters.gender && (p.gender||'') !== filters.gender) return false;
      if (filters.birth && !(p.birth_date||'').toLowerCase().startsWith(filters.birth)) return false;
      if (filters.indication && !indicationText.includes(filters.indication)) return false;
      return true;
    });
    if (selectedPatientId != null && !filteredPatients.some(p => p.id === selectedPatientId)) {
      selectedPatientId = null;
    }
    tbody.innerHTML = filteredPatients.map(p => {
      const gender = genderMap[p.gender] || p.gender || '';
      const createdBy = determineCreatedBy('patients', p);
      const rawBirth = p.birth_date;
      const formattedBirth = formatDanishDate(rawBirth) || (rawBirth || '');
      const ageDisplay = formatAgeFromBirthDate(rawBirth);
      const birthDisplay = formattedBirth && ageDisplay ? `${formattedBirth} (${ageDisplay})` : formattedBirth;
      const indicationsList = getPatientIndications(p.id);
      const indicationDisplay = truncateForListDisplay(indicationsList, 140);
      const indicationAttr = indicationsList
        ? ` class="truncate-cell" data-full-text="${esc(indicationsList)}"`
        : ' class="truncate-cell"';
      const indicationContent = indicationDisplay ? `<span class="truncate-text truncate-text--wide">${esc(indicationDisplay)}</span>` : '';
      const selectedAttr = p.id === selectedPatientId ? ' data-selected="true"' : '';
      return `<tr data-id="${p.id}"${selectedAttr}><td>${p.id}</td><td>${esc(p.mrn)}</td><td>${esc(p.extra_id||'')}</td><td>${esc(p.family_number||'')}</td><td>${esc(p.name)}</td><td>${esc(gender)}</td><td>${esc(birthDisplay)}</td><td${indicationAttr}>${indicationContent}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  searchInput.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  const patientExportColumns = [
    {key:'id', label:'ID'},
    {key:'mrn', label:'MRN'},
    {key:'extra_id', label:'Ekstra ID'},
    {key:'family_number', label:'Familienummer'},
    {key:'name', label:'Navn'},
    {key:'gender', label:'Køn (kode)'},
    {key:'gender_label', label:'Køn', value: row => genderMap[row.gender] || row.gender || ''},
    {key:'birth_date', label:'Fødselsdato'},
    {key:'birth_date_formatted', label:'Fødselsdato (formateret)', value: row => formatDanishDate(row.birth_date)},
    {key:'notes', label:'Noter'},
    {key:'indications', label:'Indikationer', value: row => getPatientIndications(row.id)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#patientsExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('patients', filteredPatients);
    exportFilteredCsv('glimr-patienter-filtreret.csv', rows, patientExportColumns, {
      entity: 'patienter',
      plural: 'patienter'
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const patient = list.find(p => p.id === id);
    if (!patient) return;
    selectedPatientId = id;
    fillForm(form, patient);
    updateAgeNote();
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('patients')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.variant_type = normalizeVariantType(data.variant_type);
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('patients', id)};
      const updated = {...before, ...data, id};
      await updateRecord('patients', updated, before);
    } else {
      delete data.id;
      await addRecord('patients', data);
    }
    await loadStore('patients');
    renderTab('patients');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
  });
  deleteBtn.addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg en patient');
    if (!ensureWrite('patients')) return;
    if (confirm('Slet patient?')) {
      await deleteRecord('patients', id);
      form.reset();
      renderTab('patients');
      renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedPatientId = null;
    updateAgeNote();
    renderRows();
  });
  clearBtn.addEventListener('click', () => form.reset());
  updateAgeNote();
}
function renderSamples(section) {
  const list = getCached('samples');
  const patients = getCached('patients');
  const orders = getCached('orders') || [];
  const reports = getCached('reports') || [];
  const patientMap = new Map(patients.map(p => [p.id, p]));
  const ordersBySample = new Map();
  orders.forEach(order => {
    const sampleId = Number(order.sample_id);
    if (!Number.isFinite(sampleId)) return;
    ordersBySample.set(sampleId, (ordersBySample.get(sampleId) || 0) + 1);
  });
  const orderLookup = new Map(orders.map(order => [Number(order.id), order]));
  const reportsBySample = new Map();
  reports.forEach(report => {
    const order = orderLookup.get(Number(report.order_id));
    if (!order) return;
    const sampleId = Number(order.sample_id);
    if (!Number.isFinite(sampleId)) return;
    reportsBySample.set(sampleId, (reportsBySample.get(sampleId) || 0) + 1);
  });
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="sampleSearch">Søg</label>
        <input id="sampleSearch" type="search" placeholder="ID/PMB/status...">
        <label class="list-toggle"><input type="checkbox" id="samplesActiveOnly" checked> Vis kun aktive</label>
        <details class="advanced-filter" id="samplesFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-samples="id" placeholder="Sample-ID"></label>
            <label>PMB-nummer<input type="search" data-filter-samples="pmb" placeholder="PMB"></label>
            <label>Patient<input type="search" data-filter-samples="patient" placeholder="Patientnavn/MRN/ID/familie"></label>
            <label>Prøvetype<input type="search" data-filter-samples="type" placeholder="Type"></label>
            <label>Status<input type="search" data-filter-samples="status" placeholder="Status"></label>
            <label>Opsamlet fra<input type="date" data-filter-samples="collected_from"></label>
            <label>Opsamlet til<input type="date" data-filter-samples="collected_to"></label>
          </div>
        </details>
        <table><thead><tr><th class="table-shortcuts"><span class="sr-only">Genveje</span></th><th>ID</th><th>PMB-nummer</th><th>Patient</th><th>Prøvetype</th><th>Status</th><th>Opsamlet</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="samplesExport">Eksportér filtrerede prøver</button>
        </div>
      </div>
      <div>
        <h2>Prøve</h2>
        <form id="sampleForm">
          <input type="hidden" name="id">
          <label>Patient
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer patienter">
              <select name="patient_id" required>
                <option value="" selected>Vælg patient</option>
                ${patients.map(p => {
                  const details = [p.mrn, p.extra_id, p.family_number].filter(Boolean).map(esc).join(' • ');
                  return `<option value="${p.id}">${esc(p.name)}${details ? ` (${details})` : ''}</option>`;
                }).join('')}
              </select>
            </div>
          </label>
          <label>PMB-nummer<input name="pmb_number" required></label>
          <label>Prøvetype
            <select name="sample_type" required data-allow-legacy-option>
              <option value="">Vælg prøvetype</option>
              ${SAMPLE_TYPES.map(type => `<option value="${type}">${type}</option>`).join('')}
            </select>
          </label>
          <label>Status
            <select name="status" data-allow-legacy-option>
              <option value="">Vælg status</option>
              ${SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('')}
            </select>
          </label>
          <label>Opsamlet<input type="datetime-local" name="collected_at"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="sampleClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="sampleDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#sampleSearch');
  const form = section.querySelector('#sampleForm');
  const filterInputs = {
    id: section.querySelector('[data-filter-samples="id"]'),
    pmb: section.querySelector('[data-filter-samples="pmb"]'),
    patient: section.querySelector('[data-filter-samples="patient"]'),
    type: section.querySelector('[data-filter-samples="type"]'),
    status: section.querySelector('[data-filter-samples="status"]'),
    collected_from: section.querySelector('[data-filter-samples="collected_from"]'),
    collected_to: section.querySelector('[data-filter-samples="collected_to"]')
  };
  const activeToggle = section.querySelector('#samplesActiveOnly');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  let filteredSamples = list.slice();
  let activeFilters = {};
  let selectedSampleId = state.pendingSampleId != null ? Number(state.pendingSampleId) : null;
  if (!Number.isFinite(selectedSampleId)) selectedSampleId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  if (selectedSampleId != null) {
    if (filterInputs.id) filterInputs.id.value = String(selectedSampleId);
    if (search) search.value = '';
    if (state.pendingSampleShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
  }
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      pmb: filterInputs.pmb?.value.trim().toLowerCase() || '',
      patient: filterInputs.patient?.value.trim().toLowerCase() || '',
      type: filterInputs.type?.value.trim().toLowerCase() || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      collected_from: filterInputs.collected_from?.value || '',
      collected_to: filterInputs.collected_to?.value || ''
    };
    const fromDate = filters.collected_from ? new Date(filters.collected_from) : null;
    const toDate = filters.collected_to ? new Date(filters.collected_to) : null;
    if (toDate) {
      toDate.setHours(23, 59, 59, 999);
    }
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    filterSummary.visning = showActiveOnly ? 'Kun aktive' : 'Alle';
    activeFilters = filterSummary;
    filteredSamples = list.filter(s => {
      if (!term) return true;
      const creator = determineCreatedBy('samples', s);
      return [s.id, s.pmb_number, s.status, s.sample_type, creator].some(v => (v ?? '').toString().toLowerCase().includes(term));
    }).filter(s => {
      const patient = patientMap.get(Number(s.patient_id));
      const patientString = [patient?.name, patient?.mrn, patient?.extra_id, patient?.family_number].filter(Boolean).join(' ').toLowerCase();
      if (filters.id && !String(s.id).includes(filters.id)) return false;
      if (filters.pmb && !(s.pmb_number || '').toLowerCase().includes(filters.pmb)) return false;
      if (filters.patient && !patientString.includes(filters.patient)) return false;
      if (filters.type && !(s.sample_type || '').toLowerCase().includes(filters.type)) return false;
      if (filters.status && !(s.status || '').toLowerCase().includes(filters.status)) return false;
      if (showActiveOnly && !isActiveStatus(s.status)) return false;
      if (fromDate || toDate) {
        if (!s.collected_at) return false;
        const collectedAt = new Date(s.collected_at);
        if (Number.isNaN(collectedAt.getTime())) return false;
        if (fromDate && collectedAt < fromDate) return false;
        if (toDate && collectedAt > toDate) return false;
      }
      return true;
    });
    if (selectedSampleId != null && !filteredSamples.some(s => s.id === selectedSampleId)) {
      selectedSampleId = null;
    }
    tbody.innerHTML = filteredSamples.map(s => {
      const createdBy = determineCreatedBy('samples', s);
      const collectedAt = formatDanishDate(s.collected_at);
      const collectedMeta = formatDaysSince(s.collected_at);
      const collectedCell = collectedAt
        ? `${esc(collectedAt)}${collectedMeta ? ` <span class="table-meta">(${esc(collectedMeta)})</span>` : ''}`
        : '';
      const selectedAttr = s.id === selectedSampleId ? ' data-selected="true"' : '';
      const orderCount = ordersBySample.get(Number(s.id)) || 0;
      const reportCount = reportsBySample.get(Number(s.id)) || 0;
      const hasOrders = orderCount > 0;
      const hasReports = reportCount > 0;
      const orderTip = hasOrders
        ? 'Åbn Ordinationer-fanen med filter for denne prøve.'
        : 'Ingen ordinationer er knyttet til denne prøve endnu.';
      const reportTip = hasReports
        ? 'Åbn Rapporter-fanen med filter for denne prøve.'
        : 'Ingen rapporter er knyttet til denne prøve endnu.';
      const orderDisabledAttr = hasOrders ? '' : ' disabled';
      const reportDisabledAttr = hasReports ? '' : ' disabled';
      const shortcutsCell = `<td class="table-actions-cell"><button type="button" class="icon-button" data-sample-action="orders" data-sample-id="${s.id}" data-tooltip="${esc(orderTip)}"${orderDisabledAttr}><span class="icon-slot" data-icon="clipboard-document-list"></span></button><button type="button" class="icon-button" data-sample-action="reports" data-sample-id="${s.id}" data-tooltip="${esc(reportTip)}"${reportDisabledAttr}><span class="icon-slot" data-icon="document-chart-bar"></span></button></td>`;
      return `<tr data-id="${s.id}"${selectedAttr}>${shortcutsCell}<td>${s.id}</td><td>${esc(s.pmb_number||'')}</td><td>${esc(getName('patients', Number(s.patient_id)))}</td><td>${esc(s.sample_type)}</td><td>${esc(s.status||'')}</td><td>${collectedCell}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    applyIconSlots(tbody);
    tbody.querySelectorAll('button[data-sample-action]').forEach(btn => {
      const tip = btn.dataset.tooltip || btn.getAttribute('title') || '';
      if (tip) setTooltip(btn, tip);
    });
    annotateTableCells(section);
  };
  renderRows();
  if (selectedSampleId != null) {
    const pendingSample = list.find(s => s.id === selectedSampleId);
    if (pendingSample) {
      fillForm(form, pendingSample);
      const pendingRow = tbody?.querySelector(`tr[data-id="${pendingSample.id}"]`);
      if (pendingRow) {
        pendingRow.scrollIntoView({block: 'nearest'});
      }
    }
  }
  state.pendingSampleId = null;
  state.pendingSampleShowAll = false;
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  const sampleExportColumns = [
    {key:'id', label:'ID'},
    {key:'pmb_number', label:'PMB-nummer'},
    {key:'patient_id', label:'Patient-ID'},
    {key:'patient_name', label:'Patient', value: row => getName('patients', Number(row.patient_id))},
    {key:'sample_type', label:'Prøvetype'},
    {key:'status', label:'Status (kode)'},
    {key:'status_display', label:'Status', value: row => row.status || ''},
    {key:'collected_at', label:'Opsamlet (ISO)'},
    {key:'collected_at_formatted', label:'Opsamlet', value: row => formatDanishDate(row.collected_at, true)},
    {key:'notes', label:'Noter'},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#samplesExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('samples', filteredSamples);
    exportFilteredCsv('glimr-proever-filtreret.csv', rows, sampleExportColumns, {
      entity: 'prøver',
      plural: 'prøver'
    });
  });
  tbody.addEventListener('click', e => {
    const actionButton = e.target.closest('button[data-sample-action]');
    if (actionButton) {
      if (actionButton.disabled) return;
      const {sampleId, sampleAction} = actionButton.dataset;
      if (sampleAction === 'orders') {
        openOrdersForSample(sampleId);
      } else if (sampleAction === 'reports') {
        openReportsForSample(sampleId);
      }
      return;
    }
    const tr = e.target.closest('tr');
    if (!tr) return;
    const sample = list.find(s => s.id === Number(tr.dataset.id));
    if (!sample) return;
    selectedSampleId = sample.id;
    fillForm(form, sample);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('samples')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    const currentId = data.id ? Number(data.id) : null;
    data.patient_id = Number(data.patient_id);
    data.pmb_number = (data.pmb_number || '').trim();
    if (!data.pmb_number) {
      alert('Angiv et PMB-nummer.');
      return;
    }
    const existingSamples = getCached('samples');
    const conflict = existingSamples.find(s => (s.pmb_number || '').toLowerCase() === data.pmb_number.toLowerCase() && s.id !== currentId);
    if (conflict) {
      alert('PMB-nummeret er allerede i brug.');
      return;
    }
    if (data.sample_type) data.sample_type = data.sample_type.trim();
    if (data.status) data.status = data.status.trim();
    if (data.notes) data.notes = data.notes.trim();
    let sampleId;
    if (currentId) {
      const id = currentId;
      const before = {...findById('samples', id)};
      const updated = {...before, ...data, id};
      await updateRecord('samples', updated, before);
      sampleId = id;
    } else {
      delete data.id;
      sampleId = await addRecord('samples', data);
    }
    const sampleStatus = data.status || '';
    if (sampleId) {
      const relatedOrders = getCached('orders').filter(o => Number(o.sample_id) === sampleId);
      let ordersUpdated = false;
      for (const order of relatedOrders) {
        if ((order.status || '') !== sampleStatus) {
          const beforeOrder = {...order};
          const updatedOrder = {...order, status: sampleStatus};
          await updateRecord('orders', updatedOrder, beforeOrder);
          ordersUpdated = true;
        }
      }
      if (ordersUpdated && state.currentTab === 'orders') {
        renderTab('orders');
      }
    }
    await loadStore('samples');
    renderTab('samples');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
  });
  section.querySelector('#sampleDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg sample');
    if (!ensureWrite('samples')) return;
    if (confirm('Slet sample?')) {
      await deleteRecord('samples', id);
      renderTab('samples');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedSampleId = null;
    renderRows();
  });
  section.querySelector('#sampleClear').addEventListener('click', () => form.reset());
}
function renderPanels(section) {
  const list = getCached('panels');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="panelSearch">Søg</label>
        <input id="panelSearch" type="search" placeholder="Navn, version, dato, bruger eller gener...">
        <table><thead><tr><th>ID</th><th>Navn</th><th>Version</th><th>Oprettet</th><th>Opdateret</th><th>Opdateret af</th><th>Beskrivelse</th><th>Antal gener</th><th>Genliste</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="panelsExport">Eksportér filtrerede paneler</button>
        </div>
      </div>
      <div>
        <h2>Panel</h2>
        <form id="panelForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <label>Version<input name="version" type="number" min="1" step="1" inputmode="numeric"></label>
          <label>Beskrivelse<textarea name="description"></textarea></label>
          <label>Genliste<textarea name="gene_list" placeholder="GEN1, GEN2, GEN3"></textarea></label>
          <div class="form-meta">
            <p class="form-hint">Oprettet: <span data-panel-created>–</span></p>
            <p class="form-hint">Senest ændret: <span data-panel-updated>–</span></p>
            <p class="form-hint">Opdateret af: <span data-panel-updated-by>–</span></p>
            <p class="form-hint">Antal gener: <span data-panel-gene-count>0</span></p>
          </div>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="panelClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="panelDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#panelSearch');
  const form = section.querySelector('#panelForm');
  const exportButton = section.querySelector('#panelsExport');
  const versionInput = form?.elements?.version || null;
  const geneListInput = form?.elements?.gene_list || null;
  const createdMeta = section.querySelector('[data-panel-created]');
  const updatedMeta = section.querySelector('[data-panel-updated]');
  const updatedByMeta = section.querySelector('[data-panel-updated-by]');
  const geneCountMeta = section.querySelector('[data-panel-gene-count]');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  const normaliseVersionNumber = value => {
    if (value == null) return null;
    const numeric = Number.parseInt(String(value).trim(), 10);
    return Number.isFinite(numeric) && numeric > 0 ? numeric : null;
  };
  const formatPanelDate = value => formatDanishDate(value, true) || '';
  const displayPanelDate = value => {
    const formatted = formatPanelDate(value);
    return formatted || '–';
  };
  const parseGeneList = value => {
    if (value == null) return [];
    return String(value)
      .split(/[\n;,]/)
      .map(token => token.trim())
      .filter(Boolean);
  };
  const normaliseGeneList = value => parseGeneList(value).join(', ');
  const geneListPreviewLimit = 80;
  const formatGeneListPreview = (value, limit = geneListPreviewLimit) => {
    const text = (value ?? '').toString().trim();
    if (!text) return '';
    if (text.length <= limit) return text;
    const truncated = text.slice(0, Math.max(0, limit - 1)).trimEnd();
    return `${truncated}…`;
  };
  const geneCountFromValue = value => parseGeneList(value).length;
  const setVersionTouched = touched => {
    if (!form) return;
    form.dataset.versionTouched = touched ? 'true' : 'false';
  };
  const isVersionTouched = () => form?.dataset?.versionTouched === 'true';
  const updatePanelMetaDisplay = panel => {
    if (createdMeta) createdMeta.textContent = panel ? displayPanelDate(panel.created_at) : '–';
    if (updatedMeta) updatedMeta.textContent = panel ? displayPanelDate(panel.updated_at) : '–';
    if (updatedByMeta) updatedByMeta.textContent = panel?.updated_by ? panel.updated_by : '–';
    if (geneCountMeta) {
      const count = panel ? (Number.isFinite(Number(panel.gene_count)) ? Number(panel.gene_count) : geneCountFromValue(panel.gene_list)) : 0;
      geneCountMeta.textContent = count ? String(count) : '0';
    }
  };
  const prepareFormForPanel = panel => {
    const baseVersion = normaliseVersionNumber(panel?.version);
    setVersionTouched(false);
    if (versionInput) {
      versionInput.value = baseVersion ?? 1;
    }
    if (geneListInput) {
      geneListInput.value = panel?.gene_list ?? '';
    }
    updatePanelMetaDisplay(panel || null);
  };
  const resetPanelFormState = () => {
    setVersionTouched(false);
    if (versionInput) {
      versionInput.value = 1;
    }
    if (geneListInput) {
      geneListInput.value = '';
    }
    updatePanelMetaDisplay(null);
  };
  resetPanelFormState();
  versionInput?.addEventListener('input', () => setVersionTouched(true));
  geneListInput?.addEventListener('input', () => {
    if (geneCountMeta) {
      const count = geneCountFromValue(geneListInput.value);
      geneCountMeta.textContent = count ? String(count) : '0';
    }
  });
  let selectedPanelId = null;
  let filteredPanels = list.slice();
  const renderRows = () => {
    const term = search.value.trim().toLowerCase();
    filteredPanels = list.filter(p => {
      if (!term) return true;
      const values = [
        p.name,
        p.description,
        normaliseVersionNumber(p.version)?.toString() || '',
        formatPanelDate(p.created_at),
        formatPanelDate(p.updated_at),
        p.updated_by,
        geneCountFromValue(p.gene_list).toString(),
        p.gene_list
      ];
      return values.some(value => (value || '').toString().toLowerCase().includes(term));
    });
    if (selectedPanelId != null && !filteredPanels.some(p => p.id === selectedPanelId)) {
      selectedPanelId = null;
    }
    tbody.innerHTML = filteredPanels.map(p => {
      const selectedAttr = p.id === selectedPanelId ? ' data-selected="true"' : '';
      const versionValue = normaliseVersionNumber(p.version);
      const versionDisplay = versionValue != null ? esc(versionValue) : '–';
      const createdDisplay = esc(displayPanelDate(p.created_at));
      const updatedDisplay = esc(displayPanelDate(p.updated_at));
      const updatedByDisplay = esc(p.updated_by || '–');
      const geneCountValue = Number.isFinite(Number(p.gene_count)) ? Number(p.gene_count) : geneCountFromValue(p.gene_list);
      const geneCountDisplay = geneCountValue ? esc(geneCountValue) : '0';
      const geneListFull = (p.gene_list ?? '').toString();
      const geneListPreview = formatGeneListPreview(geneListFull);
      const geneListDisplay = geneListPreview ? esc(geneListPreview) : '–';
      const geneListTitle = geneListFull ? ` title="${esc(geneListFull)}"` : '';
      return `<tr data-id="${p.id}"${selectedAttr}><td>${p.id}</td><td>${esc(p.name)}</td><td>${versionDisplay}</td><td>${createdDisplay}</td><td>${updatedDisplay}</td><td>${updatedByDisplay}</td><td>${esc(p.description||'')}</td><td>${geneCountDisplay}</td><td${geneListTitle}>${geneListDisplay}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  exportButton?.addEventListener('click', () => {
    if (!filteredPanels.length) {
      alert('Ingen paneler matcher filtreringen.');
      return;
    }
    const entries = filteredPanels.map(p => {
      const name = (p.name ?? '').toString().trim() || '(uden navn)';
      const desc = (p.description ?? '').toString().replace(/\r?\n|\r/g, ' ').trim();
      const versionValue = normaliseVersionNumber(p.version);
      const label = versionValue != null ? `${name}_v${versionValue}` : name;
      const genes = parseGeneList(p.gene_list);
      const geneList = genes.join(', ');
      const geneCount = genes.length;
      const geneLine = `${label} (${geneCount}): ${geneList || '(ingen gener)'}.`;
      let descriptionLine = desc;
      if (descriptionLine) {
        if (!/[.!?]$/.test(descriptionLine)) {
          descriptionLine = `${descriptionLine}.`;
        }
      } else {
        descriptionLine = '.';
      }
      return `${geneLine}\r\n${descriptionLine}`;
    });
    const text = entries.join('\r\n\r\n');
    const filename = downloadTextFile(text, 'glimr-paneler.txt');
    setStatus(`Eksporterede ${filteredPanels.length} paneler til ${filename}.`);
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const panel = list.find(p => p.id === Number(tr.dataset.id));
    if (!panel) return;
    selectedPanelId = panel.id;
    fillForm(form, panel);
    prepareFormForPanel(panel);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('panels')) return;
    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());
    const hasId = Boolean(data.id);
    const id = hasId ? Number(data.id) : null;
    const existingRecord = hasId && Number.isFinite(id) ? findById('panels', id) : null;
    const existing = existingRecord ? {...existingRecord} : null;
    if (hasId && (!Number.isFinite(id) || !existing)) {
      alert('Panelet blev ikke fundet.');
      return;
    }
    const existingVersion = existing ? normaliseVersionNumber(existing.version) : null;
    let versionNumber = normaliseVersionNumber(formData.get('version'));
    if (hasId) {
      if (!isVersionTouched()) {
        versionNumber = (existingVersion ?? 0) + 1;
      } else if (versionNumber == null) {
        versionNumber = existingVersion ?? 1;
      }
    } else if (!isVersionTouched() || versionNumber == null) {
      versionNumber = 1;
    }
    const rawGeneList = formData.get('gene_list');
    const normalisedGeneListValue = normaliseGeneList(rawGeneList);
    const geneCountValue = geneCountFromValue(normalisedGeneListValue);
    if (geneListInput) {
      geneListInput.value = normalisedGeneListValue;
    }
    if (geneCountMeta) {
      geneCountMeta.textContent = geneCountValue ? String(geneCountValue) : '0';
    }
    const payload = {
      ...data,
      version: versionNumber,
      gene_list: normalisedGeneListValue,
      gene_count: geneCountValue
    };
    if (hasId) {
      payload.id = id;
      const before = existing || {};
      const updated = {...before, ...payload, id};
      await updateRecord('panels', updated, before);
    } else {
      delete payload.id;
      await addRecord('panels', payload);
    }
    if (versionInput) {
      versionInput.value = versionNumber;
    }
    setVersionTouched(false);
    await loadStore('panels');
    renderTab('panels');
  });
  section.querySelector('#panelDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg panel');
    if (!ensureWrite('panels')) return;
    if (confirm('Slet panel?')) {
      await deleteRecord('panels', id);
      renderTab('panels');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedPanelId = null;
    resetPanelFormState();
    renderRows();
  });
  section.querySelector('#panelClear').addEventListener('click', () => form.reset());
}
function renderOrders(section) {
  const list = getCached('orders');
  const patients = getCached('patients');
  const samples = getCached('samples');
  const panels = getCached('panels');
  const reports = getCached('reports') || [];
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const patientGroups = getCached('patient_groups').slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'da'));
  const patientMap = new Map(patients.map(p => [p.id, p]));
  const sampleMap = new Map(samples.map(s => [s.id, s]));
  const panelMap = new Map(panels.map(p => [p.id, p]));
  const userMap = new Map(users.map(u => [u.id, u]));
  const reportsByOrder = new Map();
  reports.forEach(report => {
    const orderId = Number(report.order_id);
    if (!Number.isFinite(orderId)) return;
    reportsByOrder.set(orderId, (reportsByOrder.get(orderId) || 0) + 1);
  });
  const resolveUserName = id => userMap.get(Number(id))?.name || '';
  const userOptions = users.map(u => `<option value="${u.id}">${esc(u.name || `Bruger #${u.id}`)}</option>`).join('');
  const patientGroupOptions = patientGroups.map(group => `<option value="${group.id}">${esc(group.name || `Patientgruppe #${group.id}`)}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="orderSearch">Søg</label>
        <input id="orderSearch" type="search" placeholder="Status/ID/PMB...">
        <label class="list-toggle"><input type="checkbox" id="ordersActiveOnly" checked> Vis kun aktive</label>
        <details class="advanced-filter" id="ordersFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-orders="id" placeholder="Ordination-ID"></label>
            <label>Patient<input type="search" data-filter-orders="patient" placeholder="Patientnavn/MRN/ID/familie"></label>
            <label>Prøve<input type="search" data-filter-orders="sample" placeholder="Prøve-ID eller PMB"></label>
            <label>Panel<input type="search" data-filter-orders="panel" placeholder="Panelnavn"></label>
            <label>Indikation<input type="search" data-filter-orders="indication" placeholder="Indikation"></label>
            <label>HPO-termer<input type="search" data-filter-orders="hpo" placeholder="HP:0001250"></label>
            <label>Patientgruppe
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer patientgrupper">
                <select data-filter-orders="patient_group">
                  <option value="" selected>Alle</option>
                  ${patientGroupOptions}
                </select>
              </div>
            </label>
            <label>Analyseansvarlig
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="analysis_responsible">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Tolker
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="interpreter">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Godkender
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="approver">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Status<input type="search" data-filter-orders="status" placeholder="Status"></label>
            <label>Bestilt fra<input type="date" data-filter-orders="ordered_from"></label>
            <label>Bestilt til<input type="date" data-filter-orders="ordered_to"></label>
          </div>
        </details>
        <table><thead><tr><th class="table-shortcuts"><span class="sr-only">Genveje</span></th><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Analyseansvarlig</th><th>Tolker</th><th>Godkender</th><th>Patientgruppe</th><th>Indikation</th><th>HPO-termer</th><th>Status</th><th>Oprettet af</th><th>Bestilt</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="ordersExport">Eksportér filtrerede ordinationer</button>
        </div>
      </div>
      <div>
        <h2>Ordination</h2>
        <form id="orderForm">
          <input type="hidden" name="id">
          <label>Patient
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer patienter">
              <select name="patient_id" required>
                <option value="" selected>Vælg patient</option>
                ${patients.map(p => {
                  const details = [p.mrn, p.extra_id, p.family_number].filter(Boolean).map(esc).join(' • ');
                  return `<option value="${p.id}">${esc(p.name)}${details ? ` (${details})` : ''}</option>`;
                }).join('')}
              </select>
            </div>
          </label>
          <label>Prøve
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer prøver">
              <select name="sample_id" required>
                <option value="" selected>Vælg prøve</option>
                ${samples.map(s => `<option value="${s.id}">${s.id} (${esc(s.pmb_number||'–')}) – ${esc(getName('patients', s.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Panel
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer paneler">
              <select name="panel_id"><option value="">-</option>${panels.map(p => `<option value="${p.id}">${esc(p.name)}</option>`).join('')}</select>
            </div>
          </label>
          <label>Analyseansvarlig
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="analysis_responsible_id" data-allow-legacy-option>
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
          <label>Tolker
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="interpreter_id" data-allow-legacy-option>
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
            <label>Godkender
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="approver_id" data-allow-legacy-option>
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Patientgruppe
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer patientgrupper">
                <select name="patient_group_id" data-allow-legacy-option>
                  <option value="">-</option>
                  ${patientGroupOptions}
                </select>
              </div>
            </label>
            <label>Rekvirent<input name="clinician"></label>
            <label>Indikation<textarea name="indication" rows="3" placeholder="Beskriv klinisk indikation"></textarea></label>
          <label>HPO-termer<textarea name="hpo_terms" class="small" placeholder="HP:0001250; HP:0004321"></textarea></label>
          <div class="inline-field-group">
            <label>Status
              <select name="status" required data-allow-legacy-option>
                <option value="" selected>Vælg status</option>
                ${SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('')}
              </select>
            </label>
            <label class="checkbox-field"><input type="checkbox" name="acute"> Markér ordinationen som akut</label>
            <label class="checkbox-field"><input type="checkbox" name="urgent"> Markér ordinationen som haster</label>
          </div>
          <label>Bestillingstidspunkt<input type="datetime-local" name="ordered_at"></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="orderClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="orderDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#orderSearch');
  const form = section.querySelector('#orderForm');
  const filterInputs = {
    id: section.querySelector('[data-filter-orders="id"]'),
    patient: section.querySelector('[data-filter-orders="patient"]'),
    sample: section.querySelector('[data-filter-orders="sample"]'),
    panel: section.querySelector('[data-filter-orders="panel"]'),
    indication: section.querySelector('[data-filter-orders="indication"]'),
    hpo: section.querySelector('[data-filter-orders="hpo"]'),
    patient_group: section.querySelector('[data-filter-orders="patient_group"]'),
    analysis_responsible: section.querySelector('[data-filter-orders="analysis_responsible"]'),
    interpreter: section.querySelector('[data-filter-orders="interpreter"]'),
    approver: section.querySelector('[data-filter-orders="approver"]'),
    status: section.querySelector('[data-filter-orders="status"]'),
    ordered_from: section.querySelector('[data-filter-orders="ordered_from"]'),
    ordered_to: section.querySelector('[data-filter-orders="ordered_to"]')
  };
  const activeToggle = section.querySelector('#ordersActiveOnly');
  applyIconSlots(section);
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  const statusSelect = form?.elements?.status;
  const sampleSelect = form?.elements?.sample_id;
  const ensureStatusOption = value => {
    if (!statusSelect || !value) return;
    if (!Array.from(statusSelect.options).some(opt => opt.value === value)) {
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = value;
      statusSelect.appendChild(opt);
    }
  };
  const syncStatusFromSample = sampleId => {
    if (!statusSelect) return;
    if (!sampleId) {
      statusSelect.value = '';
      return;
    }
    const sample = sampleMap.get(Number(sampleId));
    if (sample?.status) {
      ensureStatusOption(sample.status);
      statusSelect.value = sample.status;
    }
  };
  sampleSelect?.addEventListener('change', () => {
    const sampleId = Number(sampleSelect.value);
    if (sampleId) {
      syncStatusFromSample(sampleId);
    } else if (statusSelect) {
      statusSelect.value = '';
    }
  });
  let filteredOrders = list.slice();
  let activeFilters = {};
  let selectedOrderId = state.pendingOrderId != null ? Number(state.pendingOrderId) : null;
  if (!Number.isFinite(selectedOrderId)) selectedOrderId = null;
  let pendingFilterSampleId = state.pendingOrderFilterSampleId != null ? Number(state.pendingOrderFilterSampleId) : null;
  if (!Number.isFinite(pendingFilterSampleId)) pendingFilterSampleId = null;
  let requireExactSample = Boolean(state.pendingOrderFilterSampleExact && pendingFilterSampleId != null);
  let pendingFilterOrderId = state.pendingOrderFilterId != null ? Number(state.pendingOrderFilterId) : null;
  if (!Number.isFinite(pendingFilterOrderId)) pendingFilterOrderId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  if (selectedOrderId != null && state.pendingOrderShowAll && activeToggle) {
    showActiveOnly = false;
    activeToggle.checked = false;
  }
  if (pendingFilterSampleId != null) {
    if (filterInputs.sample) filterInputs.sample.value = String(pendingFilterSampleId);
    if (search) search.value = '';
    if (state.pendingOrderShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    const sampleOrders = list.filter(o => Number(o.sample_id) === pendingFilterSampleId);
    if (sampleOrders.length && selectedOrderId == null) {
      sampleOrders.sort((a, b) => {
        const timeA = (a.ordered_at || a.updated_at || a.created_at || '');
        const timeB = (b.ordered_at || b.updated_at || b.created_at || '');
        return timeB.localeCompare(timeA);
      });
      selectedOrderId = sampleOrders[0].id;
    }
  }
  if (pendingFilterOrderId != null) {
    if (filterInputs.id) filterInputs.id.value = String(pendingFilterOrderId);
    if (search) search.value = '';
    if (state.pendingOrderShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    selectedOrderId = pendingFilterOrderId;
  }
  const renderRows = () => {
    const term = (search?.value || '').trim().toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      patient: filterInputs.patient?.value.trim().toLowerCase() || '',
      sample: filterInputs.sample?.value.trim().toLowerCase() || '',
      panel: filterInputs.panel?.value.trim().toLowerCase() || '',
      indication: filterInputs.indication?.value.trim().toLowerCase() || '',
      hpo: filterInputs.hpo?.value.trim().toLowerCase() || '',
      patient_group: filterInputs.patient_group?.value || '',
      analysis_responsible: filterInputs.analysis_responsible?.value || '',
      interpreter: filterInputs.interpreter?.value || '',
      approver: filterInputs.approver?.value || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      ordered_from: filterInputs.ordered_from?.value || '',
      ordered_to: filterInputs.ordered_to?.value || ''
    };
    const fromDate = filters.ordered_from ? new Date(filters.ordered_from) : null;
    const toDate = filters.ordered_to ? new Date(filters.ordered_to) : null;
    if (toDate) toDate.setHours(23, 59, 59, 999);
    const filterSummary = {...filters};
    const numericFilterSample = Number(filters.sample || '');
    const matchExactSample = requireExactSample && filters.sample !== '' && Number.isFinite(numericFilterSample) && numericFilterSample === pendingFilterSampleId;
      if (filters.indication) filterSummary.indikation = filters.indication;
      if (filters.hpo) filterSummary['hpo-termer'] = filters.hpo;
      if (filters.sample) {
        const sample = sampleMap.get(Number(filters.sample));
        filterSummary.prøve = sample ? `${sample.id} (${sample.pmb_number || '–'})` : filters.sample;
      }
      if (filters.patient_group) {
        const groupLabel = getPatientGroupName(filters.patient_group);
        filterSummary.patient_group = groupLabel || filters.patient_group;
      }
      delete filterSummary.indication;
      delete filterSummary.hpo;
      delete filterSummary.sample;
    if (filters.analysis_responsible) filterSummary.analysis_responsible = getName('users', Number(filters.analysis_responsible));
    if (filters.interpreter) filterSummary.interpreter = getName('users', Number(filters.interpreter));
    if (filters.approver) filterSummary.approver = getName('users', Number(filters.approver));
    if (term) filterSummary.fritekst = term;
    filterSummary.visning = showActiveOnly ? 'Kun aktive' : 'Alle';
    activeFilters = filterSummary;
    filteredOrders = list.filter(o => {
      if (!term) return true;
      const sample = sampleMap.get(Number(o.sample_id));
      const analysisUser = userMap.get(Number(o.analysis_responsible_id));
      const interpreterUser = userMap.get(Number(o.interpreter_id));
      const approverUser = userMap.get(Number(o.approver_id));
      const creator = determineCreatedBy('orders', o);
      const indicationText = formatIndicationForList(o.indication);
      const hpoText = formatHpoList(o.hpo_terms);
      const patientGroupName = getPatientGroupName(o.patient_group_id);
      return [
        o.status,
        o.id,
        o.patient_id,
        o.sample_id,
        o.panel_id,
        sample?.pmb_number,
        sample?.status,
        analysisUser?.name,
        interpreterUser?.name,
        approverUser?.name,
        creator,
        indicationText,
        hpoText,
        patientGroupName,
        o.acute ? 'akut' : '',
        o.urgent ? 'haster' : ''
      ].some(v => (v ?? '').toString().toLowerCase().includes(term));
    }).filter(o => {
      const patient = patientMap.get(Number(o.patient_id));
      const sample = sampleMap.get(Number(o.sample_id));
      const panel = panelMap.get(Number(o.panel_id));
      const patientString = [patient?.name, patient?.mrn, patient?.extra_id, patient?.family_number].filter(Boolean).join(' ').toLowerCase();
      const sampleString = [o.sample_id, sample?.pmb_number, sample?.sample_type, getName('patients', sample?.patient_id)].filter(Boolean).join(' ').toLowerCase();
      const indicationString = formatIndicationForList(o.indication).toLowerCase();
      const hpoString = formatHpoList(o.hpo_terms).toLowerCase();
      if (filters.id && !String(o.id).includes(filters.id)) return false;
      if (filters.patient && !patientString.includes(filters.patient)) return false;
      if (filters.sample) {
        if (matchExactSample) {
          if (Number(o.sample_id) !== pendingFilterSampleId) return false;
        } else if (!sampleString.includes(filters.sample)) {
          return false;
        }
      }
      if (filters.panel) {
        const panelString = (panel?.name || String(o.panel_id || '')).toLowerCase();
        if (!panelString.includes(filters.panel)) return false;
      }
      if (filters.indication && !indicationString.includes(filters.indication)) return false;
      if (filters.hpo && !hpoString.includes(filters.hpo)) return false;
      if (filters.patient_group && String(o.patient_group_id || '') !== filters.patient_group) return false;
      if (filters.analysis_responsible && String(o.analysis_responsible_id || '') !== filters.analysis_responsible) return false;
      if (filters.interpreter && String(o.interpreter_id || '') !== filters.interpreter) return false;
      if (filters.approver && String(o.approver_id || '') !== filters.approver) return false;
      const statusValue = (sample?.status || o.status || '').toLowerCase();
      if (filters.status && !statusValue.includes(filters.status)) return false;
      if (showActiveOnly && !isActiveStatus(statusValue)) return false;
      if (fromDate || toDate) {
        if (!o.ordered_at) return false;
        const ordered = new Date(o.ordered_at);
        if (Number.isNaN(ordered.getTime())) return false;
        if (fromDate && ordered < fromDate) return false;
        if (toDate && ordered > toDate) return false;
      }
      return true;
    });
    const userName = id => resolveUserName(id);
    if (selectedOrderId != null && !filteredOrders.some(o => o.id === selectedOrderId)) {
      selectedOrderId = null;
    }
    tbody.innerHTML = filteredOrders.map(o => {
      const sample = sampleMap.get(Number(o.sample_id));
      const statusDisplay = sample?.status || o.status || '';
      const createdBy = determineCreatedBy('orders', o);
      const orderedAt = formatDanishDate(o.ordered_at);
      const orderedMeta = formatDaysSince(o.ordered_at);
      const orderedCell = orderedAt
        ? `${esc(orderedAt)}${orderedMeta ? ` <span class="table-meta">(${esc(orderedMeta)})</span>` : ''}`
        : '';
      const indicationFull = formatIndicationForList(o.indication);
      const indicationDisplay = truncateForListDisplay(indicationFull, 160);
      const indicationAttr = indicationFull ? ` class="truncate-cell" data-full-text="${esc(indicationFull)}"` : ' class="truncate-cell"';
      const indicationCell = indicationDisplay ? `<span class="truncate-text truncate-text--wide">${esc(indicationDisplay)}</span>` : '';
      const patientGroupName = getPatientGroupName(o.patient_group_id);
      const patientGroupDisplay = truncateForListDisplay(patientGroupName, 120);
      const patientGroupAttr = patientGroupName ? ` class="truncate-cell" data-full-text="${esc(patientGroupName)}"` : ' class="truncate-cell"';
      const patientGroupCell = patientGroupDisplay ? `<span class="truncate-text truncate-text--narrow">${esc(patientGroupDisplay)}</span>` : '';
      const hpoFull = formatHpoList(o.hpo_terms);
      const hpoDisplay = truncateForListDisplay(hpoFull, 120);
      const hpoAttr = hpoFull ? ` class="truncate-cell" data-full-text="${esc(hpoFull)}"` : ' class="truncate-cell"';
      const hpoCell = hpoDisplay ? `<span class="truncate-text truncate-text--narrow">${esc(hpoDisplay)}</span>` : '';
      const selectedAttr = o.id === selectedOrderId ? ' data-selected="true"' : '';
      const priorityAttr = orderPriorityAttributes(o);
      const priorityIcons = renderOrderPriorityIcons(o);
      const sampleId = Number(o.sample_id);
      const hasSample = Number.isFinite(sampleId);
      const reportCount = reportsByOrder.get(Number(o.id)) || 0;
      const hasReports = reportCount > 0;
      const sampleTip = hasSample
        ? 'Åbn Prøver-fanen med filter for denne ordination.'
        : 'Ordinationen er ikke knyttet til en prøve.';
      const reportTip = hasReports
        ? 'Åbn Rapporter-fanen med filter for denne ordination.'
        : 'Ingen rapporter er knyttet til denne ordination endnu.';
      const sampleButtonDisabledAttr = hasSample ? '' : ' disabled';
      const reportButtonDisabledAttr = hasReports ? '' : ' disabled';
      const shortcutsCell = `<td class="table-actions-cell"><button type="button" class="icon-button" data-order-action="samples" data-order-id="${o.id}" data-tooltip="${esc(sampleTip)}"${sampleButtonDisabledAttr}><span class="icon-slot" data-icon="beaker"></span></button><button type="button" class="icon-button" data-order-action="reports" data-order-id="${o.id}" data-tooltip="${esc(reportTip)}"${reportButtonDisabledAttr}><span class="icon-slot" data-icon="document-chart-bar"></span></button></td>`;
      return `<tr data-id="${o.id}"${selectedAttr}${priorityAttr}>${shortcutsCell}<td>${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td>${esc(getName('patients', Number(o.patient_id)))}</td><td>${esc(getName('samples', Number(o.sample_id)))}</td><td>${esc(getName('panels', Number(o.panel_id)))}</td><td>${esc(userName(o.analysis_responsible_id))}</td><td>${esc(userName(o.interpreter_id))}</td><td>${esc(userName(o.approver_id))}</td><td${patientGroupAttr}>${patientGroupCell}</td><td${indicationAttr}>${indicationCell}</td><td${hpoAttr}>${hpoCell}</td><td>${esc(statusDisplay)}</td><td>${esc(createdBy)}</td><td>${orderedCell}</td></tr>`;
    }).join('');
    applyIconSlots(tbody);
    tbody.querySelectorAll('button[data-order-action]').forEach(btn => {
      const tip = btn.dataset.tooltip || btn.getAttribute('title') || '';
      if (tip) setTooltip(btn, tip);
    });
    annotateTableCells(section);
  };
  renderRows();
  if (selectedOrderId != null) {
    const pendingOrder = list.find(o => o.id === selectedOrderId);
    if (pendingOrder) {
      fillForm(form, pendingOrder);
      syncStatusFromSample(pendingOrder.sample_id);
      const pendingRow = tbody?.querySelector(`tr[data-id="${pendingOrder.id}"]`);
      if (pendingRow) {
        pendingRow.scrollIntoView({block: 'nearest'});
      }
    }
  }
  state.pendingOrderId = null;
  state.pendingOrderShowAll = false;
  state.pendingOrderFilterSampleId = null;
  state.pendingOrderFilterSampleExact = false;
  state.pendingOrderFilterId = null;
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  search.addEventListener('input', renderRows);
  const handleFilterChange = event => {
    if (event?.currentTarget === filterInputs.sample) {
      requireExactSample = false;
    }
    renderRows();
  };
  Object.values(filterInputs).forEach(input => {
    if (!input) return;
    const isSelect = input.tagName === 'SELECT';
    input.addEventListener(isSelect ? 'change' : 'input', handleFilterChange);
    if (isSelect) {
      input.addEventListener('input', handleFilterChange);
    }
  });
  const orderExportColumns = [
    {key:'id', label:'ID'},
    {key:'patient_id', label:'Patient-ID'},
    {key:'patient_name', label:'Patient', value: row => getName('patients', Number(row.patient_id))},
    {key:'sample_id', label:'Prøve-ID'},
    {key:'sample_label', label:'Prøve', value: row => getName('samples', Number(row.sample_id))},
    {key:'panel_id', label:'Panel-ID'},
    {key:'panel_name', label:'Panel', value: row => getName('panels', Number(row.panel_id))},
    {key:'status', label:'Status (kode)'},
    {key:'status_display', label:'Status', value: row => {
      const sample = sampleMap.get(Number(row.sample_id));
      return sample?.status || row.status || '';
    }},
    {key:'acute', label:'Akut', value: row => row.acute ? 'Ja' : 'Nej'},
    {key:'urgent', label:'Haster', value: row => row.urgent ? 'Ja' : 'Nej'},
    {key:'analysis_responsible_id', label:'Analyseansvarlig-ID'},
    {key:'analysis_responsible', label:'Analyseansvarlig', value: row => resolveUserName(row.analysis_responsible_id)},
    {key:'interpreter_id', label:'Tolker-ID'},
    {key:'interpreter', label:'Tolker', value: row => resolveUserName(row.interpreter_id)},
    {key:'approver_id', label:'Godkender-ID'},
    {key:'approver', label:'Godkender', value: row => resolveUserName(row.approver_id)},
    {key:'clinician', label:'Rekvirent'},
    {key:'patient_group_id', label:'Patientgruppe-ID'},
    {key:'patient_group', label:'Patientgruppe', value: row => getPatientGroupName(row.patient_group_id)},
    {key:'indication', label:'Indikation'},
    {key:'hpo_terms', label:'HPO-termer', value: row => formatHpoList(row.hpo_terms)},
    {key:'ordered_at', label:'Bestilt (ISO)'},
    {key:'ordered_at_formatted', label:'Bestilt', value: row => formatDanishDate(row.ordered_at, true)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#ordersExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('orders', filteredOrders);
    exportFilteredCsv('glimr-ordinationer-filtreret.csv', rows, orderExportColumns, {
      entity: 'ordinationer',
      plural: 'ordinationer'
    });
  });
  tbody.addEventListener('click', e => {
    const actionButton = e.target.closest('button[data-order-action]');
    if (actionButton) {
      if (actionButton.disabled) return;
      const {orderId, orderAction} = actionButton.dataset;
      if (orderAction === 'samples') {
        openSamplesForOrder(orderId);
      } else if (orderAction === 'reports') {
        openReportsForOrder(orderId);
      }
      return;
    }
    const tr = e.target.closest('tr');
    if (!tr) return;
    const order = list.find(o => o.id === Number(tr.dataset.id));
    if (!order) return;
    selectedOrderId = order.id;
    fillForm(form, order);
    syncStatusFromSample(order.sample_id);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('orders')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.acute = form.elements.acute?.checked || false;
    data.urgent = form.elements.urgent?.checked || false;
    data.patient_id = Number(data.patient_id);
    data.sample_id = Number(data.sample_id);
    data.panel_id = data.panel_id ? Number(data.panel_id) : null;
    data.analysis_responsible_id = data.analysis_responsible_id ? Number(data.analysis_responsible_id) : null;
    data.interpreter_id = data.interpreter_id ? Number(data.interpreter_id) : null;
    data.approver_id = data.approver_id ? Number(data.approver_id) : null;
    data.patient_group_id = data.patient_group_id ? Number(data.patient_group_id) : null;
    if (data.clinician) data.clinician = data.clinician.trim();
    if (data.indication) {
      data.indication = data.indication.trim();
    } else {
      data.indication = '';
    }
    data.hpo_terms = normalizeHpoTerms(data.hpo_terms);
    if (data.status) data.status = data.status.trim();
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('orders', id)};
      const updated = {...before, ...data, id};
      await updateRecord('orders', updated, before);
    } else {
      delete data.id;
      await addRecord('orders', data);
    }
    const sampleBefore = findById('samples', data.sample_id);
    if (sampleBefore && (sampleBefore.status || '') !== (data.status || '')) {
      const updatedSample = {...sampleBefore, status: data.status || ''};
      await updateRecord('samples', updatedSample, sampleBefore);
      if (state.currentTab === 'samples') {
        renderTab('samples');
      }
    }
    await loadStore('orders');
    renderTab('orders');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    const patientsSection = document.querySelector('section[data-tab="patients"]');
    if (patientsSection && patientsSection.classList.contains('active')) {
      renderTab('patients');
    }
  });
  section.querySelector('#orderDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg ordre');
    if (!ensureWrite('orders')) return;
    if (confirm('Slet ordre?')) {
      await deleteRecord('orders', id);
      renderTab('orders');
      renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedOrderId = null;
    renderRows();
  });
  section.querySelector('#orderClear').addEventListener('click', () => form.reset());
}
function renderVariants(section) {
  let list = getCached('variants');
  const orders = getCached('orders');
  const orderMap = new Map(orders.map(order => [Number(order.id), order]));
  const orderNameCache = new Map();
  const getOrderDisplayName = orderId => {
    const numericId = Number(orderId);
    if (!Number.isFinite(numericId) || numericId === 0) return '';
    if (orderNameCache.has(numericId)) {
      return orderNameCache.get(numericId);
    }
    const order = orderMap.get(numericId);
    let display = '';
    if (order) {
      for (const key of ['name', 'title', 'display_name', 'displayName', 'label']) {
        const value = order?.[key];
        if (typeof value === 'string' && value.trim()) {
          display = value.trim();
          break;
        }
      }
      if (!display) {
        const patientId = Number(order.patient_id);
        const panelId = Number(order.panel_id);
        const sampleId = Number(order.sample_id);
        const patientName = Number.isFinite(patientId) && patientId > 0 ? getName('patients', patientId) : '';
        const panel = Number.isFinite(panelId) && panelId > 0 ? findById('panels', panelId) : null;
        const sample = Number.isFinite(sampleId) && sampleId > 0 ? findById('samples', sampleId) : null;
        const sampleLabel = sample?.pmb_number || '';
        const parts = [patientName, sampleLabel, panel?.name].filter(part => part && String(part).trim());
        if (parts.length) {
          display = parts.join(' • ');
        } else if (order.id != null) {
          display = `Ordination #${order.id}`;
        }
      }
    }
    if (!display && Number.isFinite(numericId)) {
      display = `Ordination #${numericId}`;
    }
    orderNameCache.set(numericId, display);
    return display;
  };
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="variantSearch">Søg</label>
        <input id="variantSearch" type="search" placeholder="Gen/HGVS...">
        <details class="advanced-filter" id="variantsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-variants="id" placeholder="Variant-ID"></label>
            <label>Ordination<input type="search" data-filter-variants="order" placeholder="Ordinations-ID"></label>
            <label>Gen<input type="search" data-filter-variants="gene" placeholder="Gen"></label>
            <label>Transkript<input type="search" data-filter-variants="transcript" placeholder="RefSeq/ENST"></label>
            <label>rsID<input type="search" data-filter-variants="rsid" placeholder="rs123456"></label>
            <label>ACMG<input type="search" data-filter-variants="classification" placeholder="1-5"></label>
            <label>Kriterier<input type="search" data-filter-variants="criteria" placeholder="PM1,PP3..."></label>
            <label>Varianttype
              <select data-filter-variants="variant_type">
                <option value="">Alle</option>
                ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
              </select>
            </label>
            <label>ISCN<input type="search" data-filter-variants="iscn" placeholder="arr[GRCh38]..."></label>
            <label>Kromosom<input type="search" data-filter-variants="chromosome" placeholder="Chr/arm"></label>
          </div>
        </details>
        <table><thead><tr><th>ID</th><th>Ordination</th><th>Variant</th><th>rsID</th><th>Type</th><th>Klasse</th><th>Kriterier</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="variantsExport">Eksportér filtrerede varianter</button>
        </div>
      </div>
      <div>
        <h2>Variant</h2>
        <form id="variantForm">
          <input type="hidden" name="id">
          <label>Ordination
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer ordinationer">
              <select name="order_id" required>
                <option value="" selected>Vælg ordination</option>
                ${orders.map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Varianttype
            <select name="variant_type">
              ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
            </select>
          </label>
          <label>Gen / region<input name="gene" data-type-required="snv"></label>
          <div class="variant-field-group" data-variant-types="snv">
            <label>Transkript<input name="transcript" data-type-required="snv"></label>
            <label>HGVS c.<input name="hgvs_c" data-type-required="snv"></label>
            <label>HGVS p.<input name="hgvs_p"></label>
            <label>dbSNP rsID<input name="rsid" placeholder="rs123456"></label>
            <label>Zygositet<input name="zygosity"></label>
          </div>
          <div class="variant-field-group" data-variant-types="cnv sv cyto">
            <div class="variant-structure-grid">
              <label>Genom reference<input name="genome_build"></label>
              <label>Kromosom<input name="chromosome"></label>
              <label>Start<input name="start"></label>
              <label>Slut<input name="end"></label>
              <label>Kopital<input name="copy_number"></label>
              <label>Strukturtype<select name="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
              <label>Størrelse<input name="size_bp"></label>
            </div>
            <label>ISCN<input name="iscn"></label>
            <label>Berørte gener<textarea name="affected_genes" class="small"></textarea></label>
            <label>Beskrivelse<textarea name="description" class="small"></textarea></label>
          </div>
          <label>ACMG-klasse<select name="classification" required><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option></select></label>
          <label>Kriterier<input name="criteria" placeholder="PM1,PP3..."></label>
          <label>Allelfrekvens<input name="af" type="number" step="0.0001"></label>
          <label>Annoteringer<textarea name="annotations" placeholder="Importerede annoteringer fra VarSeq og andre værktøjer."></textarea></label>
          <label>Tolkning<textarea name="interpretation"></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit" id="variantSave" data-action="save">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-save-new with-icon" type="submit" id="variantSaveNew" data-action="create" hidden>
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                  <path d="M15 14h6" />
                  <path d="M18 11v6" />
                </svg>
              </span>
              <span class="label">Gem som ny</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="variantClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="variantDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
            <button class="secondary" type="button" id="variantFromLibrary">Fra bibliotek</button>
            <button class="secondary" type="button" id="variantToLibrary">Til bibliotek</button>
          </div>
        </form>
      </div>
    </div>
  </div>
  <div class="panel">
    <fieldset data-collapsible data-collapsed="true" class="panel-fieldset">
      <legend>
        <span class="fieldset-title">Massetilføj varianter</span>
        <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
      </legend>
      <div class="fieldset-body" hidden>
        <p class="panel-hint">Tilføj flere varianter til en eksisterende ordination via import eller manuel indtastning.</p>
        <label>Ordination
          <div class="filterable-select">
            <input type="search" data-select-filter placeholder="Filtrer ordinationer">
            <select id="variantBatchOrder">
              <option value="" selected>Vælg ordination</option>
              ${orders.map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}
            </select>
          </div>
        </label>
        <div id="variantBatchList" class="repeater"></div>
        <div class="btn-row">
          <button type="button" class="secondary" id="variantBatchAdd">Tilføj variant</button>
          <button type="button" class="secondary" id="variantBatchImport">Importér VarSeq CSV</button>
          <input type="file" id="variantBatchFile" accept=".csv,text/csv" hidden>
          <button type="button" class="primary" id="variantBatchSave">Gem varianter</button>
          <button type="button" class="secondary" id="variantBatchClear">Ryd rækker</button>
        </div>
        <div class="form-hint" id="variantBatchMessage" role="status" aria-live="polite"></div>
      </div>
    </fieldset>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#variantSearch');
  const form = section.querySelector('#variantForm');
  const saveButton = form.querySelector('#variantSave');
  const saveButtonLabel = saveButton?.querySelector('.label');
  const saveNewButton = form.querySelector('#variantSaveNew');
  const defaultSaveLabel = saveButtonLabel?.textContent?.trim() || saveButton?.textContent?.trim() || 'Gem';
  const {updateVariantTypeFields, variantTypeSelect} = setupVariantTypeForm(form);
  const batchList = section.querySelector('#variantBatchList');
  const batchAddBtn = section.querySelector('#variantBatchAdd');
  const batchImportBtn = section.querySelector('#variantBatchImport');
  const batchFileInput = section.querySelector('#variantBatchFile');
  const batchSaveBtn = section.querySelector('#variantBatchSave');
  const batchClearBtn = section.querySelector('#variantBatchClear');
  const batchMessage = section.querySelector('#variantBatchMessage');
  const batchOrderSelect = section.querySelector('#variantBatchOrder');
  const setBatchMessage = (text, tone = 'info') => {
    if (!batchMessage) return;
    batchMessage.textContent = text ?? '';
    const color = tone === 'success' ? 'var(--accent-strong)' : tone === 'error' ? 'var(--danger)' : 'var(--muted-text)';
    batchMessage.style.color = color;
  };
  const addBatchVariantRow = (values = {}) => {
    if (!batchList) return;
    const defaultClass = values.classification != null ? String(values.classification) : '3';
    const classificationOptions = ['1','2','3','4','5'].map(v => `<option value="${v}"${defaultClass === String(v) ? ' selected' : ''}>${v}</option>`).join('');
    const row = document.createElement('div');
    row.className = 'case-row variant-row';
    row.innerHTML = `
      <label class="inline">Varianttype<select data-field="variant_type">${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}</select></label>
      <label class="inline">Gen / region<input type="text" data-field="gene" placeholder="BRCA1"></label>
      <div class="variant-batch-group" data-variant-types="snv">
        <label class="inline">Transkript<input type="text" data-field="transcript" placeholder="NM_007294.3"></label>
        <label class="inline">HGVS c.<input type="text" data-field="hgvs_c" placeholder="c.5266dupC"></label>
        <label class="inline">HGVS p.<input type="text" data-field="hgvs_p" placeholder="p.(Gln1756Profs*74)"></label>
        <label class="inline">dbSNP rsID<input type="text" data-field="rsid" placeholder="rs123456"></label>
        <label class="inline">Zygositet<input type="text" data-field="zygosity" placeholder="Heterozygot"></label>
      </div>
      <div class="variant-batch-group" data-variant-types="cnv sv cyto">
        <label class="inline">Genom ref.<input type="text" data-field="genome_build" placeholder="GRCh38"></label>
        <label class="inline">Kromosom<input type="text" data-field="chromosome" placeholder="17p"></label>
        <label class="inline">Start<input type="text" data-field="start" placeholder="16287000"></label>
        <label class="inline">Slut<input type="text" data-field="end" placeholder="21100000"></label>
        <label class="inline">Kopital<input type="text" data-field="copy_number" placeholder="x1"></label>
        <label class="inline">Strukturtype<select data-field="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
        <label class="inline">Størrelse<input type="text" data-field="size_bp" placeholder="4.8 Mb"></label>
        <label class="inline wide">ISCN<textarea class="small" data-field="iscn" placeholder="arr[GRCh38] 17p11.2p12(16287000_21100000)x1"></textarea></label>
        <label class="inline wide">Berørte gener<textarea class="small" data-field="affected_genes" placeholder="RAI1; PMP22"></textarea></label>
      </div>
      <label class="inline wide">Beskrivelse<textarea class="small" data-field="description" placeholder="Fri tekst"></textarea></label>
      <label class="inline">ACMG<select data-field="classification">${classificationOptions}</select></label>
      <label class="inline">Kriterier<input type="text" data-field="criteria" placeholder="PM1,PP3"></label>
      <label class="inline">Allelfrekvens<input type="number" step="0.0001" data-field="af" placeholder="0.125"></label>
      <label class="inline wide">Annoteringer<textarea class="small" data-field="annotations" placeholder="VarSeq-annoteringer og noter"></textarea></label>
      <label class="inline wide">Tolkning<textarea class="small" data-field="interpretation" placeholder="Valgfrit"></textarea></label>
      <button type="button" class="secondary case-choose-library">Vælg fra bibliotek</button>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const setValue = (selector, value) => {
      const el = row.querySelector(selector);
      if (!el) return;
      if (selector.includes('sv_subtype') && el.tagName === 'SELECT') {
        const normalized = normalizeStructureTypeValue(value);
        const asString = normalized ? String(normalized) : '';
        if (el.dataset.allowLegacyOption !== undefined && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
          const opt = document.createElement('option');
          opt.value = asString;
          opt.textContent = getStructureTypeLabel(asString);
          opt.dataset.legacy = 'true';
          el.appendChild(opt);
        }
        el.value = asString;
        return;
      }
      el.value = value || '';
    };
    setValue('[data-field="variant_type"]', normalizeVariantType(values.variant_type));
    setValue('[data-field="gene"]', values.gene);
    setValue('[data-field="transcript"]', values.transcript);
    setValue('[data-field="hgvs_c"]', values.hgvs_c);
    setValue('[data-field="hgvs_p"]', values.hgvs_p);
    setValue('[data-field="zygosity"]', values.zygosity);
    setValue('[data-field="criteria"]', values.criteria);
    setValue('[data-field="genome_build"]', values.genome_build);
    setValue('[data-field="chromosome"]', values.chromosome);
    setValue('[data-field="start"]', values.start);
    setValue('[data-field="end"]', values.end);
    setValue('[data-field="copy_number"]', values.copy_number);
    setValue('[data-field="sv_subtype"]', values.sv_subtype);
    setValue('[data-field="size_bp"]', values.size_bp);
    setValue('[data-field="iscn"]', values.iscn);
    setValue('[data-field="affected_genes"]', values.affected_genes);
    setValue('[data-field="description"]', values.description);
    const afField = row.querySelector('[data-field="af"]');
    if (afField) {
      if (values.af !== undefined && values.af !== null && values.af !== '') {
        afField.value = values.af;
      } else {
        afField.value = '';
      }
    }
    const interpretationField = row.querySelector('[data-field="interpretation"]');
    if (interpretationField) interpretationField.value = values.interpretation || '';
    const annotationsField = row.querySelector('[data-field="annotations"]');
    if (annotationsField) annotationsField.value = values.annotations || '';
    const typeSelect = row.querySelector('[data-field="variant_type"]');
    const typeGroups = row.querySelectorAll('[data-variant-types]');
    const updateRowVariantType = () => {
      const type = normalizeVariantType(typeSelect?.value || 'snv');
      if (typeSelect && typeSelect.value !== type) typeSelect.value = type;
      typeGroups.forEach(group => {
        const allowed = (group.dataset.variantTypes || '').split(/\s+/).filter(Boolean).map(normalizeVariantType);
        group.hidden = allowed.length ? !allowed.includes(type) : false;
      });
    };
    updateRowVariantType();
    typeSelect?.addEventListener('change', updateRowVariantType);
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern varianten fra batch-listen.');
    const libraryBtn = row.querySelector('.case-choose-library');
    libraryBtn?.addEventListener('click', () => {
      openVariantLibraryPicker(variant => {
        setValue('[data-field="variant_type"]', normalizeVariantType(variant.variant_type));
        setValue('[data-field="gene"]', variant.gene);
        setValue('[data-field="transcript"]', variant.transcript);
        setValue('[data-field="hgvs_c"]', variant.hgvs_c);
        setValue('[data-field="hgvs_p"]', variant.hgvs_p);
        setValue('[data-field="criteria"]', variant.criteria);
        setValue('[data-field="genome_build"]', variant.genome_build);
        setValue('[data-field="chromosome"]', variant.chromosome);
        setValue('[data-field="start"]', variant.start);
        setValue('[data-field="end"]', variant.end);
        setValue('[data-field="copy_number"]', variant.copy_number);
        setValue('[data-field="sv_subtype"]', variant.sv_subtype);
        setValue('[data-field="size_bp"]', variant.size_bp);
        setValue('[data-field="iscn"]', variant.iscn);
        setValue('[data-field="affected_genes"]', variant.affected_genes);
        setValue('[data-field="description"]', variant.description);
        const classField = row.querySelector('[data-field="classification"]');
        if (classField && variant.classification != null && variant.classification !== '') {
          classField.value = String(variant.classification);
        }
        const interpretationField = row.querySelector('[data-field="interpretation"]');
        if (interpretationField) interpretationField.value = variant.evidence || variant.interpretation || '';
        const annotationsField = row.querySelector('[data-field="annotations"]');
        if (annotationsField) annotationsField.value = variant.annotations || variant.annotation_summary || '';
        updateRowVariantType();
      });
    });
    if (libraryBtn) setTooltip(libraryBtn, 'Vælg en variant fra biblioteket.');
    batchList.appendChild(row);
    applyButtonTooltips(row);
    const rsidField = row.querySelector('[data-field="rsid"]');
    if (rsidField) setTooltip(rsidField, tooltipCatalog.forms.variantForm.rsid);
    const subtypeSelect = row.querySelector('[data-field="sv_subtype"]');
    if (subtypeSelect) setTooltip(subtypeSelect, tooltipCatalog.forms.variantForm.sv_subtype);
  };
  const getBatchValue = (row, field) => {
    const el = row?.querySelector(`[data-field="${field}"]`);
    if (!el) return '';
    return (el.value || '').trim();
  };
  const isBatchVariantRowEmpty = row => {
    if (!row) return true;
    const gene = getBatchValue(row, 'gene');
    const transcript = getBatchValue(row, 'transcript');
    const hgvsC = getBatchValue(row, 'hgvs_c');
    const hgvsP = getBatchValue(row, 'hgvs_p');
    const rsid = getBatchValue(row, 'rsid');
    const zygosity = getBatchValue(row, 'zygosity');
    const criteria = getBatchValue(row, 'criteria');
    const af = getBatchValue(row, 'af');
    const interpretation = getBatchValue(row, 'interpretation');
    const annotations = getBatchValue(row, 'annotations');
    const genomeBuild = getBatchValue(row, 'genome_build');
    const chromosome = getBatchValue(row, 'chromosome');
    const start = getBatchValue(row, 'start');
    const end = getBatchValue(row, 'end');
    const copyNumber = getBatchValue(row, 'copy_number');
    const svSubtype = getBatchValue(row, 'sv_subtype');
    const sizeBp = getBatchValue(row, 'size_bp');
    const iscn = getBatchValue(row, 'iscn');
    const description = getBatchValue(row, 'description');
    const affectedGenes = getBatchValue(row, 'affected_genes');
    return !gene && !transcript && !hgvsC && !hgvsP && !rsid && !zygosity && !criteria && !af && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
  };
  const collectBatchVariants = () => {
    if (!batchList) return [];
    const rows = Array.from(batchList.querySelectorAll('.variant-row'));
    const variants = [];
    rows.forEach((row, idx) => {
      const variantType = normalizeVariantType(getBatchValue(row, 'variant_type') || 'snv');
      const gene = getBatchValue(row, 'gene');
      const transcript = getBatchValue(row, 'transcript');
      const hgvsC = getBatchValue(row, 'hgvs_c');
      const hgvsP = getBatchValue(row, 'hgvs_p');
      const rsid = getBatchValue(row, 'rsid');
      const zygosity = getBatchValue(row, 'zygosity');
      const criteria = getBatchValue(row, 'criteria');
      const afRaw = getBatchValue(row, 'af');
      const interpretation = getBatchValue(row, 'interpretation');
      const annotations = getBatchValue(row, 'annotations');
      const genomeBuild = getBatchValue(row, 'genome_build');
      const chromosome = getBatchValue(row, 'chromosome');
      const start = getBatchValue(row, 'start');
      const end = getBatchValue(row, 'end');
      const copyNumber = getBatchValue(row, 'copy_number');
      const svSubtype = normalizeStructureTypeValue(getBatchValue(row, 'sv_subtype'));
      const sizeBp = getBatchValue(row, 'size_bp');
      const iscn = getBatchValue(row, 'iscn');
      const description = getBatchValue(row, 'description');
      const affectedGenes = getBatchValue(row, 'affected_genes');
      const classification = row.querySelector('[data-field="classification"]')?.value || '3';
      const isEmpty = !gene && !transcript && !hgvsC && !hgvsP && !rsid && !zygosity && !criteria && !afRaw && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
      if (isEmpty) return;
      if (variantType === 'snv') {
        if (!gene) {
          const err = new Error(`Angiv gen for række ${idx + 1}.`);
          err.focus = row.querySelector('[data-field="gene"]');
          throw err;
        }
      } else {
        if (!iscn && !description && !chromosome) {
          const err = new Error(`Angiv ISCN, kromosom eller beskrivelse for række ${idx + 1}.`);
          err.focus = row.querySelector('[data-field="iscn"]') || row.querySelector('[data-field="description"]');
          throw err;
        }
      }
      const variant = {
        variant_type: variantType,
        gene,
        transcript,
        hgvs_c: hgvsC,
        hgvs_p: hgvsP,
        rsid: normalizeRsId(rsid),
        zygosity,
        classification: String(classification || '3'),
        criteria,
        interpretation,
        genome_build: genomeBuild,
        chromosome,
        start,
        end,
        copy_number: copyNumber,
        sv_subtype: svSubtype,
        size_bp: sizeBp,
        iscn,
        description,
        affected_genes: affectedGenes
      };
      if (afRaw) {
        const afNumber = Number(afRaw);
        if (!Number.isFinite(afNumber)) {
          const err = new Error(`Allelfrekvens skal være et tal i række ${idx + 1}.`);
          err.focus = row.querySelector('[data-field="af"]');
          throw err;
        }
        variant.af = afNumber;
      }
      if (annotations) {
        variant.annotations = annotations;
      }
      variants.push(variant);
    });
    return variants;
  };
  const removeEmptyBatchRows = () => {
    if (!batchList) return;
    const rows = Array.from(batchList.querySelectorAll('.variant-row'));
    if (!rows.length) return;
    const filled = rows.filter(row => !isBatchVariantRowEmpty(row));
    if (!filled.length) {
      batchList.innerHTML = '';
      return;
    }
    rows.forEach(row => {
      if (isBatchVariantRowEmpty(row)) row.remove();
    });
  };
  const enterEditMode = id => {
    if (!form) return;
    form.dataset.mode = 'edit';
    form.dataset.editingId = id != null ? String(id) : '';
    if (saveButtonLabel) {
      saveButtonLabel.textContent = 'Opdater variant';
    } else if (saveButton) {
      saveButton.textContent = 'Opdater variant';
    }
    if (saveNewButton) saveNewButton.hidden = false;
  };
  const exitEditMode = () => {
    if (!form) return;
    form.dataset.mode = 'create';
    form.dataset.editingId = '';
    clearFormIdentifier(form);
    if (saveButtonLabel) {
      saveButtonLabel.textContent = defaultSaveLabel;
    } else if (saveButton) {
      saveButton.textContent = defaultSaveLabel;
    }
    if (saveNewButton) saveNewButton.hidden = true;
  };
  exitEditMode();
  const filterInputs = {
    id: section.querySelector('[data-filter-variants="id"]'),
    order: section.querySelector('[data-filter-variants="order"]'),
    gene: section.querySelector('[data-filter-variants="gene"]'),
    transcript: section.querySelector('[data-filter-variants="transcript"]'),
    rsid: section.querySelector('[data-filter-variants="rsid"]'),
    classification: section.querySelector('[data-filter-variants="classification"]'),
    criteria: section.querySelector('[data-filter-variants="criteria"]'),
    variant_type: section.querySelector('[data-filter-variants="variant_type"]'),
    iscn: section.querySelector('[data-filter-variants="iscn"]'),
    chromosome: section.querySelector('[data-filter-variants="chromosome"]')
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  initCollapsibleFieldsets(section);
  let filteredVariants = list.slice();
  let activeFilters = {};
  let selectedVariantId = null;
  const renderRows = () => {
    const term = (search.value || '').trim().toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      order: filterInputs.order?.value.trim().toLowerCase() || '',
      gene: filterInputs.gene?.value.trim().toLowerCase() || '',
      transcript: filterInputs.transcript?.value.trim().toLowerCase() || '',
      rsid: filterInputs.rsid?.value.trim().toLowerCase() || '',
      classification: filterInputs.classification?.value.trim().toLowerCase() || '',
      criteria: filterInputs.criteria?.value.trim().toLowerCase() || '',
      variant_type: filterInputs.variant_type?.value.trim().toLowerCase() || '',
      iscn: filterInputs.iscn?.value.trim().toLowerCase() || '',
      chromosome: filterInputs.chromosome?.value.trim().toLowerCase() || ''
    };
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredVariants = list.filter(v => {
      if (!term) return true;
      const creator = determineCreatedBy('variants', v);
      const orderName = getOrderDisplayName(v.order_id);
      const searchValues = [
        v.gene,
        v.transcript,
        v.hgvs_c,
        v.hgvs_p,
        v.rsid,
        v.criteria,
        v.zygosity,
        v.iscn,
        v.chromosome,
        getStructureTypeLabel(v.sv_subtype),
        v.description,
        v.affected_genes,
        formatVariantGenomicRange(v),
        formatVariantTitle(v),
        getVariantTypeLabel(v.variant_type),
        creator,
        orderName,
        String(v.order_id || '')
      ];
      return searchValues.some(val => (val || '').toString().toLowerCase().includes(term));
    }).filter(v => {
      if (filters.id && !String(v.id).includes(filters.id)) return false;
      if (filters.order) {
        const orderIdString = (String(v.order_id || '')).toLowerCase();
        const orderName = getOrderDisplayName(v.order_id).toLowerCase();
        if (!orderIdString.includes(filters.order) && !orderName.includes(filters.order)) return false;
      }
      if (filters.gene && !(v.gene || '').toLowerCase().includes(filters.gene)) return false;
      if (filters.transcript && !(v.transcript || '').toLowerCase().includes(filters.transcript)) return false;
      if (filters.rsid && !(v.rsid || '').toLowerCase().includes(filters.rsid)) return false;
      if (filters.classification && !(String(v.classification || '')).toLowerCase().includes(filters.classification)) return false;
      if (filters.criteria && !(v.criteria || '').toLowerCase().includes(filters.criteria)) return false;
      if (filters.variant_type && normalizeVariantType(v.variant_type) !== normalizeVariantType(filters.variant_type)) return false;
      if (filters.iscn && !(v.iscn || '').toLowerCase().includes(filters.iscn)) return false;
      if (filters.chromosome) {
        const chromo = (v.chromosome || '').toLowerCase();
        if (!chromo.includes(filters.chromosome)) return false;
      }
      return true;
    });
    if (selectedVariantId != null && !filteredVariants.some(v => v.id === selectedVariantId)) {
      selectedVariantId = null;
    }
    tbody.innerHTML = filteredVariants.map(v => {
      const createdBy = determineCreatedBy('variants', v);
      const selectedAttr = v.id === selectedVariantId ? ' data-selected="true"' : '';
      const title = formatVariantTitle(v);
      const typeLabel = getVariantTypeLabel(v.variant_type);
      const orderName = getOrderDisplayName(v.order_id);
      const orderTitle = v.order_id != null ? ` title="Ordination #${v.order_id}"` : '';
      return `<tr data-id="${v.id}"${selectedAttr}><td>${v.id}</td><td${orderTitle}>${esc(orderName)}</td><td>${esc(title)}</td><td>${formatRsIdCell(v.rsid)}</td><td>${esc(typeLabel)}</td><td>${esc(v.classification||'')}</td><td>${esc(v.criteria||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  const variantExportColumns = [
    {key:'id', label:'ID'},
    {key:'order_id', label:'Ordination-ID'},
    {key:'order_name', label:'Ordination', value: row => getOrderDisplayName(row.order_id)},
    {key:'variant_type', label:'Varianttype (kode)'},
    {key:'variant_type_label', label:'Varianttype', value: row => getVariantTypeLabel(row.variant_type)},
    {key:'gene', label:'Gen/Region'},
    {key:'transcript', label:'Transkript'},
    {key:'hgvs_c', label:'HGVS c.'},
    {key:'hgvs_p', label:'HGVS p.'},
    {key:'rsid', label:'rsID'},
    {key:'zygosity', label:'Zygositet'},
    {key:'classification', label:'Klasse'},
    {key:'classification_label', label:'Klasse (tekst)', value: row => {
      const key = String(row.classification ?? '');
      return classificationMap?.[key]?.display || '';
    }},
    {key:'criteria', label:'Kriterier'},
    {key:'af', label:'Allelfrekvens'},
    {key:'genome_build', label:'Genom reference'},
    {key:'chromosome', label:'Kromosom'},
    {key:'start', label:'Start'},
    {key:'end', label:'Slut'},
    {key:'copy_number', label:'Kopital'},
    {key:'sv_subtype', label:'Strukturtype (kode)'},
    {key:'sv_subtype_label', label:'Strukturtype', value: row => getStructureTypeLabel(row.sv_subtype)},
    {key:'size_bp', label:'Størrelse (bp)'},
    {key:'iscn', label:'ISCN'},
    {key:'description', label:'Beskrivelse'},
    {key:'affected_genes', label:'Berørte gener'},
    {key:'annotations', label:'Annoteringer'},
    {key:'interpretation', label:'Tolkning'},
    {key:'variant_title', label:'Varianttitel', value: row => formatVariantTitle(row)},
    {key:'variant_range', label:'Genomisk interval', value: row => formatVariantGenomicRange(row)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#variantsExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('variants', filteredVariants);
    exportFilteredCsv('glimr-varianter-filtreret.csv', rows, variantExportColumns, {
      entity: 'varianter',
      plural: 'varianter'
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const variant = list.find(v => v.id === Number(tr.dataset.id));
    if (!variant) return;
    selectedVariantId = variant.id;
    fillForm(form, variant);
    updateVariantTypeFields();
    enterEditMode(variant.id);
    if (batchOrderSelect && variant.order_id) {
      batchOrderSelect.value = String(variant.order_id);
    }
    renderRows();
  });
  batchAddBtn?.addEventListener('click', () => addBatchVariantRow());
  batchClearBtn?.addEventListener('click', () => {
    if (batchList) {
      batchList.innerHTML = '';
      addBatchVariantRow();
    }
    setBatchMessage('Batch-liste ryddet.', 'info');
  });
  batchImportBtn?.addEventListener('click', () => batchFileInput?.click());
  batchFileInput?.addEventListener('change', async () => {
    const file = batchFileInput?.files?.[0];
    if (!file) return;
    try {
      const {variants: importedVariants, warnings, summary} = await parseVarSeqFile(file);
      if (!importedVariants.length) {
        setBatchMessage('Ingen varianter blev fundet i filen.', 'error');
        return;
      }
      removeEmptyBatchRows();
      importedVariants.forEach(variant => addBatchVariantRow(variant));
      const parts = [`Tilføjede ${importedVariants.length} varianter fra ${file.name}.`];
      if (summary.skipped) parts.push(`${summary.skipped} rækker ignoreret.`);
      if (warnings.length) parts.push(`${warnings.length} advarsler logget i konsollen.`);
      setBatchMessage(parts.join(' '), 'success');
      setStatus(`VarSeq import til masseoprettelse: ${importedVariants.length} varianter klar.`);
      if (warnings.length) console.warn('VarSeq import advarsler', warnings);
    } catch (err) {
      console.error(err);
      setBatchMessage('Kunne ikke importere VarSeq CSV: ' + (err?.message || err), 'error');
    } finally {
      if (batchFileInput) batchFileInput.value = '';
    }
  });
  batchSaveBtn?.addEventListener('click', async () => {
    if (!ensureWrite('variants')) {
      setBatchMessage('Handling kræver skriveadgang. Log ind med en bruger der kan redigere varianter.', 'error');
      return;
    }
    const orderId = Number(batchOrderSelect?.value || 0);
    if (!orderId) {
      setBatchMessage('Vælg en ordination for at gemme varianterne.', 'error');
      batchOrderSelect?.focus();
      return;
    }
    let variants;
    try {
      variants = collectBatchVariants();
    } catch (err) {
      setBatchMessage(err.message || 'Kunne ikke fortolke batch-rækkerne.', 'error');
      if (err.focus) err.focus.focus();
      return;
    }
    if (!variants.length) {
      setBatchMessage('Udfyld mindst én variant før du gemmer.', 'error');
      return;
    }
    batchSaveBtn.disabled = true;
    if (batchAddBtn) batchAddBtn.disabled = true;
    if (batchImportBtn) batchImportBtn.disabled = true;
    if (batchClearBtn) batchClearBtn.disabled = true;
    try {
      setBatchMessage('Gemmer varianter...', 'info');
      const createdIds = [];
      for (const variant of variants) {
        const id = await addRecord('variants', {...variant, order_id: orderId});
        createdIds.push(id);
      }
      list = getCached('variants');
      filteredVariants = list.slice();
      renderRows();
      if (batchList) {
        batchList.innerHTML = '';
        addBatchVariantRow();
      }
      setBatchMessage(`Tilføjede ${createdIds.length} varianter til ordination ${orderId}.`, 'success');
      setStatus(`Tilføjede ${createdIds.length} varianter til ordination ${orderId}.`);
    } catch (err) {
      console.error(err);
      setBatchMessage('Kunne ikke gemme varianter: ' + (err?.message || err), 'error');
    } finally {
      batchSaveBtn.disabled = false;
      if (batchAddBtn) batchAddBtn.disabled = false;
      if (batchImportBtn) batchImportBtn.disabled = false;
      if (batchClearBtn) batchClearBtn.disabled = false;
    }
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('variants')) return;
    const action = e.submitter?.dataset.action || 'save';
    const data = Object.fromEntries(new FormData(form).entries());
    Object.keys(data).forEach(key => {
      if (typeof data[key] === 'string') {
        data[key] = data[key].trim();
      }
    });
    data.variant_type = normalizeVariantType(data.variant_type);
    data.rsid = normalizeRsId(data.rsid);
    data.sv_subtype = normalizeStructureTypeValue(data.sv_subtype);
    data.order_id = Number(data.order_id);
    data.classification = String(data.classification);
    if (data.af) data.af = Number(data.af);
    const editingId = Number(form.dataset.editingId || data.id || 0);
    const creatingNew = action === 'create' || !editingId;
    if (!creatingNew) {
      const id = editingId;
      const before = {...findById('variants', id)};
      const updated = {...before, ...data, id};
      await updateRecord('variants', updated, before);
    } else {
      delete data.id;
      await addRecord('variants', data);
    }
    await loadStore('variants');
    renderTab('variants');
  });
  section.querySelector('#variantDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg variant');
    if (!ensureWrite('variants')) return;
    if (confirm('Slet variant?')) {
      await deleteRecord('variants', id);
      renderTab('variants');
    }
  });
  section.querySelector('#variantFromLibrary').addEventListener('click', () => {
    openVariantLibraryPicker(variant => {
      if (!form) return;
      if (form.elements.variant_type) form.elements.variant_type.value = normalizeVariantType(variant.variant_type);
      if (form.elements.gene) form.elements.gene.value = variant.gene || '';
      if (form.elements.transcript) form.elements.transcript.value = variant.transcript || '';
      if (form.elements.hgvs_c) form.elements.hgvs_c.value = variant.hgvs_c || '';
      if (form.elements.hgvs_p) form.elements.hgvs_p.value = variant.hgvs_p || '';
      if (form.elements.rsid) form.elements.rsid.value = variant.rsid || '';
      if (form.elements.criteria) form.elements.criteria.value = variant.criteria || '';
      if (form.elements.genome_build) form.elements.genome_build.value = variant.genome_build || '';
      if (form.elements.chromosome) form.elements.chromosome.value = variant.chromosome || '';
      if (form.elements.start) form.elements.start.value = variant.start || '';
      if (form.elements.end) form.elements.end.value = variant.end || '';
      if (form.elements.copy_number) form.elements.copy_number.value = variant.copy_number || '';
      if (form.elements.sv_subtype) form.elements.sv_subtype.value = variant.sv_subtype || '';
      if (form.elements.size_bp) form.elements.size_bp.value = variant.size_bp || '';
      if (form.elements.iscn) form.elements.iscn.value = variant.iscn || '';
      if (form.elements.affected_genes) form.elements.affected_genes.value = variant.affected_genes || '';
      if (form.elements.description) form.elements.description.value = variant.description || '';
      if (form.elements.annotations) form.elements.annotations.value = variant.annotations || variant.annotation_summary || '';
      if (form.elements.interpretation) form.elements.interpretation.value = variant.evidence || variant.interpretation || '';
      if (form.elements.classification && variant.classification != null && variant.classification !== '') {
        form.elements.classification.value = String(variant.classification);
      }
      updateVariantTypeFields();
    });
  });
  if (batchList && !batchList.children.length) {
    addBatchVariantRow();
    setBatchMessage('Importer eller udfyld varianter for at gemme dem på den valgte ordination.', 'info');
  }
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedVariantId = null;
    updateVariantTypeFields();
    exitEditMode();
    renderRows();
  });
  section.querySelector('#variantClear').addEventListener('click', () => {
    const orderValue = form.elements.order_id.value;
    const classificationValue = form.elements.classification.value;
    form.reset();
    if (orderValue) form.elements.order_id.value = orderValue;
    if (classificationValue) form.elements.classification.value = classificationValue;
    updateVariantTypeFields();
    exitEditMode();
  });
  section.querySelector('#variantToLibrary').addEventListener('click', async () => {
    if (!ensureWrite('variant_library')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    Object.keys(data).forEach(key => {
      if (typeof data[key] === 'string') {
        data[key] = data[key].trim();
      }
    });
    data.variant_type = normalizeVariantType(data.variant_type);
    data.rsid = normalizeRsId(data.rsid);
    if (!data.gene && !data.hgvs_c && !data.hgvs_p && !data.iscn && !data.description) {
      return alert('Udfyld mindst ét kendetegn (gen, HGVS eller ISCN).');
    }
    const evidenceParts = [];
    if (data.interpretation) evidenceParts.push(data.interpretation);
    if (data.annotations) evidenceParts.push(data.annotations);
    const libraryEntry = {
      variant_type: data.variant_type,
      gene: data.gene,
      transcript: data.transcript,
      hgvs_c: data.hgvs_c,
      hgvs_p: data.hgvs_p,
      rsid: data.rsid,
      classification: String(data.classification || ''),
      criteria: data.criteria,
      evidence: evidenceParts.join('\n').trim(),
      condition: '',
      inheritance: '',
      genome_build: data.genome_build,
      chromosome: data.chromosome,
      start: data.start,
      end: data.end,
      copy_number: data.copy_number,
      sv_subtype: data.sv_subtype,
      size_bp: data.size_bp,
      iscn: data.iscn,
      description: data.description,
      affected_genes: data.affected_genes,
      curated_by: currentUserName(),
      last_review: new Date().toISOString().split('T')[0]
    };
    await addRecord('variant_library', libraryEntry);
    await loadStore('variant_library');
    renderTab('variant_library');
    alert('Variant tilføjet til biblioteket');
  });
}
function renderVariantLibrary(section) {
  const list = getCached('variant_library').slice().sort((a, b) => {
    const titleA = formatVariantTitle(a) || '';
    const titleB = formatVariantTitle(b) || '';
    const titleCompare = titleA.localeCompare(titleB, 'da');
    if (titleCompare) return titleCompare;
    const typeCompare = normalizeVariantType(a.variant_type).localeCompare(normalizeVariantType(b.variant_type));
    if (typeCompare) return typeCompare;
    return (a.id || 0) - (b.id || 0);
  });
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="libSearch">Søg</label>
        <input id="libSearch" type="search" placeholder="Gen/HGVS/ISCN...">
        <details class="advanced-filter" id="variantLibraryFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>Gen<input type="search" data-filter-library="gene" placeholder="Gen"></label>
            <label>Transkript<input type="search" data-filter-library="transcript" placeholder="RefSeq/ENST"></label>
            <label>HGVS c.<input type="search" data-filter-library="hgvs_c" placeholder="c."></label>
            <label>HGVS p.<input type="search" data-filter-library="hgvs_p" placeholder="p."></label>
            <label>rsID<input type="search" data-filter-library="rsid" placeholder="rs123456"></label>
            <label>Klasse<input type="search" data-filter-library="classification" placeholder="1-5/VUS"></label>
            <label>Kriterier<input type="search" data-filter-library="criteria" placeholder="PM1,PP3..."></label>
            <label>Varianttype
              <select data-filter-library="variant_type">
                <option value="">Alle</option>
                ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
              </select>
            </label>
            <label>ISCN<input type="search" data-filter-library="iscn" placeholder="arr[GRCh38]..."></label>
            <label>Kromosom<input type="search" data-filter-library="chromosome" placeholder="Chr"></label>
            <label>Genom<input type="search" data-filter-library="genome_build" placeholder="GRCh38"></label>
            <label>Genomisk start<input type="search" data-filter-library="start" placeholder="Start"></label>
            <label>Genomisk slut<input type="search" data-filter-library="end" placeholder="Slut"></label>
            <label>SV-type<input type="search" data-filter-library="sv_subtype" placeholder="Deletion, duplication..."></label>
            <label>Kopital<input type="search" data-filter-library="copy_number" placeholder="x1/x3..."></label>
            <label>Størrelse<input type="search" data-filter-library="size_bp" placeholder="Mb/kb"></label>
            <label>Tilstand<input type="search" data-filter-library="condition" placeholder="Tilstand"></label>
            <label>Nedarvning<input type="search" data-filter-library="inheritance" placeholder="Arvegang"></label>
            <label>Kurateret af<input type="search" data-filter-library="curated_by" placeholder="Kurator"></label>
            <label>Berørte gener<input type="search" data-filter-library="affected_genes" placeholder="GEN1;GEN2"></label>
            <label>Beskrivelse<input type="search" data-filter-library="description" placeholder="Kort beskrivelse"></label>
            <label>Sidst gennemgået fra<input type="date" data-filter-library="last_review_from"></label>
            <label>Sidst gennemgået til<input type="date" data-filter-library="last_review_to"></label>
          </div>
        </details>
        <table>
          <thead>
            <tr><th>ID</th><th>Variant</th><th>Type</th><th>Genomisk position</th><th>HGVS c.</th><th>HGVS p.</th><th>rsID</th><th>Klasse</th><th>Frekvens</th><th>Forekomst</th><th>Kriterier</th><th>ISCN</th><th>Tilstand</th><th>Nedarvning</th><th>Kurateret af</th><th>Sidst gennemgået</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="table-actions">
          <button type="button" class="secondary" id="libraryExportCsv">Eksportér CSV</button>
          <button type="button" class="secondary" id="libraryImportCsv">Importér CSV</button>
          <input type="file" id="variantLibraryImportInput" accept=".csv,text/csv" hidden>
        </div>
      </div>
      <div>
        <h2>Bibliotekspost</h2>
        <form id="variantLibraryForm">
          <input type="hidden" name="id">
          <label>Varianttype
            <select name="variant_type">
              ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
            </select>
          </label>
          <label>Gen / region<input name="gene"></label>
          <div class="variant-field-group" data-variant-types="snv">
            <label>Transkript<input name="transcript"></label>
            <label>HGVS c.<input name="hgvs_c"></label>
            <label>HGVS p.<input name="hgvs_p"></label>
            <label>dbSNP rsID<input name="rsid" placeholder="rs123456"></label>
          </div>
          <div class="variant-field-group" data-variant-types="cnv sv cyto">
            <div class="variant-structure-grid">
              <label>Genom reference<input name="genome_build"></label>
              <label>Kromosom<input name="chromosome"></label>
              <label>Start<input name="start"></label>
              <label>Slut<input name="end"></label>
              <label>Kopital<input name="copy_number"></label>
              <label>Strukturtype<select name="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
              <label>Størrelse<input name="size_bp"></label>
            </div>
            <label>ISCN<input name="iscn"></label>
            <label>Berørte gener<textarea class="small" name="affected_genes"></textarea></label>
            <label>Beskrivelse<textarea class="small" name="description"></textarea></label>
          </div>
          <label>Klasse<input name="classification" placeholder="1-5/VUS"></label>
          <label>Kriterier<input name="criteria"></label>
          <label>Tilstand<input name="condition"></label>
          <label>Nedarvning<input name="inheritance"></label>
          <label>Evidens<textarea name="evidence" rows="4"></textarea></label>
          <label>Kurateret af<input name="curated_by"></label>
          <label>Sidst gennemgået<input type="date" name="last_review"></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit" data-action="save" id="variantLibrarySave">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-save-new with-icon" type="submit" data-action="create" id="variantLibrarySaveNew" hidden>
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                  <path d="M15 14h6" />
                  <path d="M18 11v6" />
                </svg>
              </span>
              <span class="label">Gem som ny</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="variantLibraryClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="variantLibraryDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#libSearch');
  const form = section.querySelector('#variantLibraryForm');
  const saveButton = section.querySelector('#variantLibrarySave');
  const saveButtonLabel = saveButton?.querySelector('.label');
  const saveNewButton = section.querySelector('#variantLibrarySaveNew');
  const clearButton = section.querySelector('#variantLibraryClear');
  const deleteButton = section.querySelector('#variantLibraryDelete');
  const exportButton = section.querySelector('#libraryExportCsv');
  const importButton = section.querySelector('#libraryImportCsv');
  const importInput = section.querySelector('#variantLibraryImportInput');
  const defaultSaveLabel = saveButtonLabel?.textContent?.trim() || saveButton?.textContent?.trim() || 'Gem';
  const {updateVariantTypeFields, variantTypeSelect} = setupVariantTypeForm(form);
  const {
    countMap: variantFrequencyMap,
    patientCount: variantFrequencyPatientCount,
    maxCount: variantFrequencyMaxCount
  } = computeVariantFrequencyData();
  const getVariantFrequencyCount = entry => {
    const key = createVariantComparisonKey(entry);
    if (!key) return 0;
    return variantFrequencyMap.get(key) || 0;
  };
  const getVariantFrequencyLabel = entry => {
    const count = getVariantFrequencyCount(entry);
    if (!count && !variantFrequencyPatientCount) return '0';
    return formatVariantFrequencyLabel(count, variantFrequencyPatientCount);
  };
  const getVariantFrequencyCategory = entry => {
    if (!variantFrequencyMaxCount || variantFrequencyMaxCount <= 1) return 'Ukendt';
    const count = getVariantFrequencyCount(entry);
    if (!count) return 'Ukendt';
    const ratio = count / variantFrequencyMaxCount;
    if (!Number.isFinite(ratio) || ratio <= 0) return 'Ukendt';
    if (ratio >= 0.95) return 'Polymorf';
    if (ratio >= 0.65) return 'Hyppig';
    if (ratio >= 0.35) return 'Mellemfrekvent';
    if (ratio >= 0.2) return 'Lavfrekvent';
    if (ratio >= 0.1) return 'Sjælden';
    if (ratio >= 0.05) return 'Meget sjælden';
    return 'Ultra sjælden';
  };
  const csvColumns = [
    {key: 'id', label: 'ID'},
    {label: 'Varianttitel', value: entry => formatVariantTitle(entry) || ''},
    {key: 'gene', label: 'Gen'},
    {key: 'transcript', label: 'Transkript'},
    {key: 'hgvs_c', label: 'HGVS c.'},
    {key: 'hgvs_p', label: 'HGVS p.'},
    {key: 'rsid', label: 'rsID'},
    {key: 'variant_type', label: 'Varianttype (kode)'},
    {label: 'Varianttype', value: entry => getVariantTypeLabel(entry.variant_type) || ''},
    {key: 'classification', label: 'Klasse'},
    {key: 'criteria', label: 'Kriterier'},
    {key: 'evidence', label: 'Evidens'},
    {key: 'condition', label: 'Tilstand'},
    {key: 'inheritance', label: 'Nedarvning'},
    {label: 'Genomisk position', value: entry => formatVariantGenomicRange(entry) || ''},
    {key: 'genome_build', label: 'Genom'},
    {key: 'chromosome', label: 'Kromosom'},
    {key: 'start', label: 'Start'},
    {key: 'end', label: 'Slut'},
    {key: 'copy_number', label: 'Kopital'},
    {key: 'sv_subtype', label: 'Strukturtype (kode)'},
    {label: 'Strukturtype', value: entry => getStructureTypeLabel(entry.sv_subtype) || ''},
    {key: 'size_bp', label: 'Størrelse'},
    {key: 'iscn', label: 'ISCN'},
    {key: 'description', label: 'Beskrivelse'},
    {key: 'affected_genes', label: 'Berørte gener'},
    {key: 'curated_by', label: 'Kurateret af'},
    {key: 'last_review', label: 'Sidst gennemgået'},
    {key: 'created_at', label: 'Oprettet'},
    {key: 'updated_at', label: 'Opdateret'}
  ];
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  let filteredLibrary = list.slice();
  let selectedId = null;
  const filterInputs = {
    gene: section.querySelector('[data-filter-library="gene"]'),
    transcript: section.querySelector('[data-filter-library="transcript"]'),
    hgvs_c: section.querySelector('[data-filter-library="hgvs_c"]'),
    hgvs_p: section.querySelector('[data-filter-library="hgvs_p"]'),
    rsid: section.querySelector('[data-filter-library="rsid"]'),
    classification: section.querySelector('[data-filter-library="classification"]'),
    criteria: section.querySelector('[data-filter-library="criteria"]'),
    variant_type: section.querySelector('[data-filter-library="variant_type"]'),
    iscn: section.querySelector('[data-filter-library="iscn"]'),
    chromosome: section.querySelector('[data-filter-library="chromosome"]'),
    genome_build: section.querySelector('[data-filter-library="genome_build"]'),
    start: section.querySelector('[data-filter-library="start"]'),
    end: section.querySelector('[data-filter-library="end"]'),
    sv_subtype: section.querySelector('[data-filter-library="sv_subtype"]'),
    copy_number: section.querySelector('[data-filter-library="copy_number"]'),
    size_bp: section.querySelector('[data-filter-library="size_bp"]'),
    condition: section.querySelector('[data-filter-library="condition"]'),
    inheritance: section.querySelector('[data-filter-library="inheritance"]'),
    curated_by: section.querySelector('[data-filter-library="curated_by"]'),
    affected_genes: section.querySelector('[data-filter-library="affected_genes"]'),
    description: section.querySelector('[data-filter-library="description"]'),
    last_review_from: section.querySelector('[data-filter-library="last_review_from"]'),
    last_review_to: section.querySelector('[data-filter-library="last_review_to"]')
  };
  const enterEditMode = id => {
    if (!form) return;
    form.dataset.mode = 'edit';
    form.dataset.editingId = id != null ? String(id) : '';
    if (saveButtonLabel) {
      saveButtonLabel.textContent = 'Opdater bibliotekspost';
    } else if (saveButton) {
      saveButton.textContent = 'Opdater bibliotekspost';
    }
    if (saveNewButton) saveNewButton.hidden = false;
  };
  const exitEditMode = () => {
    if (!form) return;
    form.dataset.mode = 'create';
    form.dataset.editingId = '';
    clearFormIdentifier(form);
    if (saveButtonLabel) {
      saveButtonLabel.textContent = defaultSaveLabel;
    } else if (saveButton) {
      saveButton.textContent = defaultSaveLabel;
    }
    if (saveNewButton) saveNewButton.hidden = true;
  };
  exitEditMode();
  const renderRows = () => {
    const term = (search?.value || '').trim().toLowerCase();
    const filters = {
      gene: filterInputs.gene?.value.trim().toLowerCase() || '',
      transcript: filterInputs.transcript?.value.trim().toLowerCase() || '',
      hgvs_c: filterInputs.hgvs_c?.value.trim().toLowerCase() || '',
      hgvs_p: filterInputs.hgvs_p?.value.trim().toLowerCase() || '',
      rsid: filterInputs.rsid?.value.trim().toLowerCase() || '',
      classification: filterInputs.classification?.value.trim().toLowerCase() || '',
      criteria: filterInputs.criteria?.value.trim().toLowerCase() || '',
      variant_type: filterInputs.variant_type?.value.trim().toLowerCase() || '',
      iscn: filterInputs.iscn?.value.trim().toLowerCase() || '',
      chromosome: filterInputs.chromosome?.value.trim().toLowerCase() || '',
      genome_build: filterInputs.genome_build?.value.trim().toLowerCase() || '',
      start: filterInputs.start?.value.trim().toLowerCase() || '',
      end: filterInputs.end?.value.trim().toLowerCase() || '',
      sv_subtype: filterInputs.sv_subtype?.value.trim().toLowerCase() || '',
      copy_number: filterInputs.copy_number?.value.trim().toLowerCase() || '',
      size_bp: filterInputs.size_bp?.value.trim().toLowerCase() || '',
      condition: filterInputs.condition?.value.trim().toLowerCase() || '',
      inheritance: filterInputs.inheritance?.value.trim().toLowerCase() || '',
      curated_by: filterInputs.curated_by?.value.trim().toLowerCase() || '',
      affected_genes: filterInputs.affected_genes?.value.trim().toLowerCase() || '',
      description: filterInputs.description?.value.trim().toLowerCase() || '',
      last_review_from: filterInputs.last_review_from?.value || '',
      last_review_to: filterInputs.last_review_to?.value || ''
    };
    const fromDate = filters.last_review_from ? new Date(filters.last_review_from) : null;
    const toDate = filters.last_review_to ? new Date(filters.last_review_to) : null;
    const validFrom = fromDate && !Number.isNaN(fromDate.getTime()) ? fromDate : null;
    const validTo = toDate && !Number.isNaN(toDate.getTime()) ? toDate : null;
    filteredLibrary = list.filter(v => {
      if (!term) return true;
      return [
        v.gene,
        v.transcript,
        v.hgvs_c,
        v.hgvs_p,
        v.rsid,
        v.classification,
        v.criteria,
        v.condition,
        v.inheritance,
        v.evidence,
        v.curated_by,
        v.iscn,
        v.chromosome,
        v.genome_build,
        v.start,
        v.end,
        v.copy_number,
        v.sv_subtype,
        getStructureTypeLabel(v.sv_subtype),
        v.size_bp,
        v.description,
        v.affected_genes,
        formatVariantGenomicRange(v),
        getVariantTypeLabel(v.variant_type),
        formatVariantTitle(v),
        getVariantFrequencyLabel(v),
        getVariantFrequencyCategory(v)
      ].some(val => (val || '').toString().toLowerCase().includes(term));
    }).filter(v => {
      if (filters.gene && !(v.gene || '').toLowerCase().includes(filters.gene)) return false;
      if (filters.transcript && !(v.transcript || '').toLowerCase().includes(filters.transcript)) return false;
      if (filters.hgvs_c && !(v.hgvs_c || '').toLowerCase().includes(filters.hgvs_c)) return false;
      if (filters.hgvs_p && !(v.hgvs_p || '').toLowerCase().includes(filters.hgvs_p)) return false;
      if (filters.rsid && !(v.rsid || '').toLowerCase().includes(filters.rsid)) return false;
      if (filters.classification && !(String(v.classification || '')).toLowerCase().includes(filters.classification)) return false;
      if (filters.criteria && !(v.criteria || '').toLowerCase().includes(filters.criteria)) return false;
      if (filters.variant_type && normalizeVariantType(v.variant_type) !== normalizeVariantType(filters.variant_type)) return false;
      if (filters.iscn && !(v.iscn || '').toLowerCase().includes(filters.iscn)) return false;
      if (filters.chromosome && !(v.chromosome || '').toLowerCase().includes(filters.chromosome)) return false;
      if (filters.genome_build && !(v.genome_build || '').toLowerCase().includes(filters.genome_build)) return false;
      if (filters.start && !(v.start || '').toLowerCase().includes(filters.start)) return false;
      if (filters.end && !(v.end || '').toLowerCase().includes(filters.end)) return false;
      if (filters.sv_subtype) {
        const subtypeValue = (v.sv_subtype || '').toLowerCase();
        const subtypeLabel = getStructureTypeLabel(v.sv_subtype || '').toLowerCase();
        if (!subtypeValue.includes(filters.sv_subtype) && !subtypeLabel.includes(filters.sv_subtype)) return false;
      }
      if (filters.copy_number && !(v.copy_number || '').toLowerCase().includes(filters.copy_number)) return false;
      if (filters.size_bp && !(v.size_bp || '').toLowerCase().includes(filters.size_bp)) return false;
      if (filters.condition && !(v.condition || '').toLowerCase().includes(filters.condition)) return false;
      if (filters.inheritance && !(v.inheritance || '').toLowerCase().includes(filters.inheritance)) return false;
      if (filters.curated_by && !(v.curated_by || '').toLowerCase().includes(filters.curated_by)) return false;
      if (filters.affected_genes && !(v.affected_genes || '').toLowerCase().includes(filters.affected_genes)) return false;
      if (filters.description && !(v.description || '').toLowerCase().includes(filters.description)) return false;
      if ((validFrom || validTo) && v.last_review) {
        const reviewDate = new Date(v.last_review);
        if (!Number.isNaN(reviewDate.getTime())) {
          if (validFrom && reviewDate < validFrom) return false;
          if (validTo && reviewDate > validTo) return false;
        } else if (validFrom || validTo) {
          return false;
        }
      } else if ((validFrom || validTo) && !v.last_review) {
        return false;
      }
      return true;
    });
    if (selectedId && !filteredLibrary.some(v => v.id === selectedId)) {
      selectedId = null;
    }
    if (!filteredLibrary.length) {
      tbody.innerHTML = `<tr><td colspan="16">Ingen poster matcher filtreringen.</td></tr>`;
      annotateTableCells(section);
      return;
    }
    tbody.innerHTML = filteredLibrary.map(v => {
      const selectedAttr = v.id === selectedId ? ' data-selected="true"' : '';
      const lastReview = formatDanishDate(v.last_review);
      const title = formatVariantTitle(v);
      const typeLabel = getVariantTypeLabel(v.variant_type);
      const genomic = formatVariantGenomicRange(v);
      const frequencyCount = getVariantFrequencyCount(v);
      const frequencyLabel = getVariantFrequencyLabel(v);
      const frequencyTitle = variantFrequencyPatientCount
        ? `${frequencyCount} registrering${frequencyCount === 1 ? '' : 'er'} blandt ${variantFrequencyPatientCount} patient${variantFrequencyPatientCount === 1 ? '' : 'er'}`
        : `${frequencyCount} registrering${frequencyCount === 1 ? '' : 'er'}`;
      const frequencyCategory = getVariantFrequencyCategory(v);
      const frequencyCategoryTitle = (() => {
        if (frequencyCategory === 'Ukendt') {
          if (!variantFrequencyMaxCount || variantFrequencyMaxCount <= 1) {
            return 'Forekomst kan ikke vurderes før der er flere registreringer i variantbiblioteket.';
          }
          return 'Forekomst er ikke tilgængelig.';
        }
        const topSuffix = variantFrequencyMaxCount
          ? ` sammenlignet med topposten på ${variantFrequencyMaxCount} registrering${variantFrequencyMaxCount === 1 ? '' : 'er'}`
          : '';
        return `${frequencyCategory} forekomst baseret på ${frequencyLabel}${topSuffix}.`;
      })();
      return `<tr data-id="${v.id}"${selectedAttr}><td>${v.id}</td><td>${esc(title)}</td><td>${esc(typeLabel)}</td><td>${esc(genomic)}</td><td>${esc(v.hgvs_c || '')}</td><td>${esc(v.hgvs_p || '')}</td><td>${formatRsIdCell(v.rsid)}</td><td>${esc(v.classification || '')}</td><td title="${esc(frequencyTitle)}">${esc(frequencyLabel)}</td><td title="${esc(frequencyCategoryTitle)}">${esc(frequencyCategory)}</td><td>${esc(v.criteria || '')}</td><td>${esc(v.iscn || '')}</td><td>${esc(v.condition || '')}</td><td>${esc(v.inheritance || '')}</td><td>${esc(v.curated_by || '')}</td><td>${esc(lastReview)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search?.addEventListener('input', renderRows);
  Object.entries(filterInputs).forEach(([, input]) => {
    if (!input) return;
    const eventName = input.type === 'date' ? 'change' : 'input';
    input.addEventListener(eventName, renderRows);
    if (eventName === 'change') {
      input.addEventListener('input', renderRows);
    }
  });
  tbody?.addEventListener('click', e => {
    const tr = e.target.closest('tr[data-id]');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const entry = list.find(v => v.id === id);
    if (!entry) return;
    selectedId = id;
    fillForm(form, {...entry, variant_type: normalizeVariantType(entry.variant_type)});
    updateVariantTypeFields();
    enterEditMode(id);
    renderRows();
  });
  const clearForm = () => {
    if (!form) return;
    form.reset();
    if (variantTypeSelect) {
      variantTypeSelect.value = normalizeVariantType('snv');
    }
    updateVariantTypeFields();
  };
  clearButton?.addEventListener('click', clearForm);
  form?.addEventListener('reset', () => {
    clearFormIdentifier(form);
    exitEditMode();
    selectedId = null;
    updateVariantTypeFields();
    renderRows();
  });
  form?.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('variant_library')) return;
    const submitterAction = e.submitter?.dataset.action || 'save';
    const data = Object.fromEntries(new FormData(form).entries());
    Object.keys(data).forEach(key => {
      if (typeof data[key] === 'string') {
        data[key] = data[key].trim();
      }
    });
    data.rsid = normalizeRsId(data.rsid);
    data.variant_type = normalizeVariantType(data.variant_type);
    data.sv_subtype = normalizeStructureTypeValue(data.sv_subtype);
    const editingId = Number(form.dataset.editingId || data.id || 0);
    const creatingNew = submitterAction === 'create' || !editingId;
    const payload = {
      variant_type: data.variant_type,
      gene: data.gene || '',
      transcript: data.transcript || '',
      hgvs_c: data.hgvs_c || '',
      hgvs_p: data.hgvs_p || '',
      rsid: data.rsid || '',
      classification: data.classification || '',
      criteria: data.criteria || '',
      genome_build: data.genome_build || '',
      chromosome: data.chromosome || '',
      start: data.start || '',
      end: data.end || '',
      copy_number: data.copy_number || '',
      sv_subtype: data.sv_subtype || '',
      size_bp: data.size_bp || '',
      iscn: data.iscn || '',
      description: data.description || '',
      affected_genes: data.affected_genes || '',
      condition: data.condition || '',
      inheritance: data.inheritance || '',
      evidence: data.evidence || '',
      curated_by: data.curated_by || '',
      last_review: data.last_review || ''
    };
    if (payload.last_review && !/^\d{4}-\d{2}-\d{2}$/.test(payload.last_review)) {
      const date = new Date(payload.last_review);
      if (!Number.isNaN(date.getTime())) {
        payload.last_review = date.toISOString().split('T')[0];
      }
    }
    if (!creatingNew) {
      const id = editingId;
      const beforeRecord = findById('variant_library', id);
      if (!beforeRecord) {
        alert('Kunne ikke finde biblioteksposten.');
        return;
      }
      const before = {...beforeRecord};
      const updated = {...before, ...payload, id};
      await updateRecord('variant_library', updated, before);
      setStatus(`Bibliotekspost ${id} opdateret.`);
    } else {
      if (!payload.curated_by) payload.curated_by = currentUserName() || '';
      if (!payload.last_review) payload.last_review = new Date().toISOString().split('T')[0];
      const record = {...payload};
      await addRecord('variant_library', record);
      setStatus('Bibliotekspost oprettet.');
    }
    renderTab('variant_library');
  });
  deleteButton?.addEventListener('click', async () => {
    const id = Number(form?.elements?.id?.value || 0);
    if (!id) {
      alert('Vælg en bibliotekspost der skal slettes.');
      return;
    }
    if (!ensureWrite('variant_library')) return;
    if (!confirm('Slet bibliotekspost?')) return;
    await deleteRecord('variant_library', id);
    setStatus(`Bibliotekspost ${id} slettet.`);
    renderTab('variant_library');
  });
  exportButton?.addEventListener('click', () => {
    const exportRows = filteredLibrary.map(entry => ({
      ...entry,
      variant_type: normalizeVariantType(entry.variant_type),
      sv_subtype: normalizeStructureTypeValue(entry.sv_subtype)
    }));
    const filename = downloadCsvFile(exportRows, csvColumns, 'glimr-variantbibliotek.csv');
    setStatus(`Eksporterede ${filteredLibrary.length} biblioteksposter til ${filename}.`);
  });
  importButton?.addEventListener('click', () => importInput?.click());
  importInput?.addEventListener('change', async () => {
    const file = importInput.files?.[0];
    if (!file) return;
    if (!ensureWrite('variant_library')) {
      importInput.value = '';
      return;
    }
    try {
      const text = await file.text();
      const {headers, rows} = parseCsv(text);
      if (!headers.length) throw new Error('CSV-filen mangler kolonneoverskrifter.');
      const headerMap = {
        id: 'id',
        gene: 'gene',
        gen: 'gene',
        transcript: 'transcript',
        transkript: 'transcript',
        hgvs_c: 'hgvs_c',
        hgvs_c_: 'hgvs_c',
        hgvs: 'hgvs_c',
        hgvs_p: 'hgvs_p',
        rsid: 'rsid',
        dbsnp: 'rsid',
        dbsnp_id: 'rsid',
        dbsnpid: 'rsid',
        dbsnp_rs: 'rsid',
        rs_id: 'rsid',
        variant_type: 'variant_type',
        varianttype: 'variant_type',
        varianttypekode: 'variant_type',
        varianttype_kode: 'variant_type',
        type: 'variant_type',
        klassifikation: 'classification',
        classification: 'classification',
        class: 'classification',
        klasse: 'classification',
        criteria: 'criteria',
        kriterier: 'criteria',
        acmg: 'criteria',
        evidence: 'evidence',
        evidens: 'evidence',
        notes: 'evidence',
        condition: 'condition',
        tilstand: 'condition',
        phenotype: 'condition',
        inheritance: 'inheritance',
        nedarvning: 'inheritance',
        genome_build: 'genome_build',
        genome: 'genome_build',
        reference: 'genome_build',
        kromosom: 'chromosome',
        chromosome: 'chromosome',
        chr: 'chromosome',
        start: 'start',
        begin: 'start',
        begynd: 'start',
        position_start: 'start',
        end: 'end',
        stop: 'end',
        slut: 'end',
        position_end: 'end',
        copy_number: 'copy_number',
        copynumber: 'copy_number',
        kopital: 'copy_number',
        kopitaler: 'copy_number',
        cn: 'copy_number',
        sv_subtype: 'sv_subtype',
        svtype: 'sv_subtype',
        strukturtype: 'sv_subtype',
        strukturtypekode: 'sv_subtype',
        strukturtype_kode: 'sv_subtype',
        variant_subtype: 'sv_subtype',
        structuraltype: 'sv_subtype',
        size: 'size_bp',
        size_bp: 'size_bp',
        stoerrelse: 'size_bp',
        length: 'size_bp',
        iscn: 'iscn',
        cytogenetic: 'iscn',
        affected_genes: 'affected_genes',
        genes: 'affected_genes',
        gener: 'affected_genes',
        description: 'description',
        beskrivelse: 'description',
        curated_by: 'curated_by',
        kurator: 'curated_by',
        kurateret_af: 'curated_by',
        last_review: 'last_review',
        sidst_gennemgaaet: 'last_review',
        lastreview: 'last_review'
      };
      const computedColumnNames = new Set(['frekvens', 'frequency', 'forekomst', 'occurrence']);
      const ignoredComputedColumns = new Set();
      const columnKeys = headers.map(header => {
        const normalized = normaliseHeader(header);
        if (computedColumnNames.has(normalized)) {
          const trimmed = (header || '').trim();
          if (trimmed) ignoredComputedColumns.add(trimmed);
          return null;
        }
        return headerMap[normalized] || null;
      });
      if (!columnKeys.some(key => ['gene', 'hgvs_c', 'hgvs_p', 'iscn', 'chromosome', 'description'].includes(key))) {
        throw new Error('CSV-filen skal mindst indeholde et identificerende felt (Gen, HGVS, ISCN, kromosom eller beskrivelse).');
      }
      const summary = {created: 0, updated: 0, skipped: 0};
      const existingCache = new Map(getCached('variant_library').map(entry => [entry.id, {...entry}]));
      for (const rowValues of rows) {
        if (!rowValues || rowValues.every(cell => !cell || !cell.trim())) {
          summary.skipped++;
          continue;
        }
        const entry = {};
        columnKeys.forEach((key, idx) => {
          if (!key) return;
          const raw = (rowValues[idx] || '').trim();
          if (key === 'rsid') {
            entry.rsid = normalizeRsId(raw);
            return;
          }
          if (key === 'sv_subtype') {
            entry.sv_subtype = normalizeStructureTypeValue(raw);
            return;
          }
          entry[key] = raw;
        });
        entry.variant_type = normalizeVariantType(entry.variant_type);
        let id = null;
        if (entry.id) {
          const parsedId = Number(entry.id);
          if (Number.isFinite(parsedId) && parsedId > 0) {
            id = parsedId;
            entry.id = parsedId;
          } else {
            delete entry.id;
          }
        }
        const ensureIsoDate = value => {
          if (!value) return '';
          if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
          const parsed = new Date(value);
          if (!Number.isNaN(parsed.getTime())) {
            return parsed.toISOString().split('T')[0];
          }
          return value;
        };
        entry.last_review = ensureIsoDate(entry.last_review || '');
        if (!entry.gene && !entry.hgvs_c && !entry.hgvs_p && !entry.iscn && !entry.chromosome && !entry.description) {
          summary.skipped++;
          continue;
        }
        if (id && existingCache.has(id)) {
          const before = existingCache.get(id);
          const updated = {...before, ...entry, id};
          await updateRecord('variant_library', updated, before);
          existingCache.set(id, updated);
          summary.updated++;
        } else {
          const record = {...entry};
          delete record.id;
          if (!record.curated_by) record.curated_by = currentUserName() || '';
          if (!record.last_review) record.last_review = new Date().toISOString().split('T')[0];
          await addRecord('variant_library', record);
          summary.created++;
        }
      }
      const summaryParts = [];
      if (summary.updated) summaryParts.push(`${summary.updated} opdateret`);
      if (summary.created) summaryParts.push(`${summary.created} tilføjet`);
      if (summary.skipped) summaryParts.push(`${summary.skipped} uændret`);
      const message = summaryParts.length ? summaryParts.join(', ') : 'Ingen poster ændret';
      const ignoredMessage = ignoredComputedColumns.size
        ? ` Beregnede kolonner ignoreret: ${Array.from(ignoredComputedColumns).join(', ')}.`
        : '';
      setStatus(`Import fuldført: ${message}.${ignoredMessage}`);
      alert(`Import fuldført: ${message}.${ignoredMessage ? `\n${ignoredMessage}` : ''}`);
      renderTab('variant_library');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke importere CSV: ' + err.message);
      setStatus('Fejl under import: ' + err.message);
    } finally {
      importInput.value = '';
    }
  });
}
function snapshotVariant(variant) {
  if (!variant) {
    return {id: null, order_id: null, variant_type: 'snv', gene: '', transcript: '', hgvs_c: '', hgvs_p: '', zygosity: '', classification: '', criteria: '', af: '', annotations: '', interpretation: '', genome_build: '', chromosome: '', start: '', end: '', copy_number: '', sv_subtype: '', size_bp: '', iscn: '', description: '', affected_genes: ''};
  }
  return {
    id: variant.id ?? null,
    order_id: variant.order_id ?? null,
    variant_type: normalizeVariantType(variant.variant_type),
    gene: variant.gene || '',
    transcript: variant.transcript || '',
    hgvs_c: variant.hgvs_c || '',
    hgvs_p: variant.hgvs_p || '',
    rsid: normalizeRsId(variant.rsid || variant.rs_id || ''),
    zygosity: variant.zygosity || '',
    classification: variant.classification || '',
    criteria: variant.criteria || '',
    af: variant.af ?? '',
    annotations: variant.annotations || variant.annotation_summary || '',
    interpretation: variant.interpretation || '',
    genome_build: variant.genome_build || '',
    chromosome: variant.chromosome || '',
    start: variant.start || '',
    end: variant.end || '',
    copy_number: variant.copy_number || '',
    sv_subtype: normalizeStructureTypeValue(variant.sv_subtype || variant.structural_type || ''),
    size_bp: variant.size_bp || '',
    iscn: variant.iscn || variant.cytogenetic || '',
    description: variant.description || '',
    affected_genes: variant.affected_genes || variant.genes || ''
  };
}
function parseReportVariantIds(value) {
  if (Array.isArray(value)) {
    return value.map(Number).filter(id => Number.isFinite(id));
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return [];
    try {
      const parsed = JSON.parse(trimmed);
      return parseReportVariantIds(parsed);
    } catch (err) {
      return trimmed.split(/[^0-9]+/).map(Number).filter(id => Number.isFinite(id));
    }
  }
  return [];
}
function getReportVariantSnapshots(report, orderId) {
  if (!report) return [];
  const detailsRaw = report.variant_details;
  if (Array.isArray(detailsRaw) && detailsRaw.length) {
    return detailsRaw.map(snapshotVariant);
  }
  if (typeof detailsRaw === 'string' && detailsRaw.trim()) {
    try {
      const parsed = JSON.parse(detailsRaw);
      if (Array.isArray(parsed) && parsed.length) {
        return parsed.map(snapshotVariant);
      }
    } catch (err) {
      console.warn('Kunne ikke parse variant_details', err);
    }
  }
  const ids = parseReportVariantIds(report.variant_ids);
  if (!ids.length) return [];
  const orderVariants = getCached('variants').filter(v => !orderId || v.order_id === orderId);
  return ids.map(id => {
    const found = orderVariants.find(v => v.id === id) || getCached('variants').find(v => v.id === id);
    if (!found) return null;
    return snapshotVariant(found);
  }).filter(Boolean);
}
function describeVariantNarrative(variant) {
  if (!variant) return '';
  const summaryParts = [];
  const typeLabel = getVariantTypeLabel(variant.variant_type);
  if (variant.classification) summaryParts.push(`Klasse ${variant.classification}`);
  if (variant.criteria) summaryParts.push(`ACMG: ${variant.criteria}`);
  if (variant.af !== undefined && variant.af !== null && variant.af !== '') summaryParts.push(`AF: ${variant.af}`);
  if (variant.zygosity) summaryParts.push(`Zygositet: ${variant.zygosity}`);
  const subtypeLabel = getStructureTypeLabel(variant.sv_subtype || variant.structural_type || '');
  if (subtypeLabel) summaryParts.push(`Type: ${subtypeLabel}`);
  if (variant.copy_number) summaryParts.push(`Kopital: ${variant.copy_number}`);
  if (variant.size_bp) summaryParts.push(`Størrelse: ${variant.size_bp}`);
  if (variant.affected_genes) summaryParts.push(`Berørte gener: ${variant.affected_genes}`);
  if (variant.iscn) summaryParts.push(`ISCN: ${variant.iscn}`);
  const genomic = formatVariantGenomicRange(variant);
  if (genomic) summaryParts.push(`Position: ${genomic}`);
  if (variant.interpretation) summaryParts.push(variant.interpretation);
  const title = formatVariantTitle(variant);
  const summary = summaryParts.join(' – ');
  const headingParts = [title || '', typeLabel && title !== typeLabel ? typeLabel : '', summary].filter(Boolean);
  return headingParts.join(' – ');
}
function buildConclusionPlaceholderGuide(context = 'report') {
  const intro = context === 'library'
    ? 'Indsæt pladsholdere i standardteksten for at få felter udfyldt automatisk, når teksten bruges i en rapport.'
    : 'Når du indsætter en standardtekst i rapporten, erstattes pladsholdere automatisk med data fra den valgte ordination.';
  return `
    <details class="placeholder-guide">
      <summary>
        <h3>Pladsholdere til konklusioner</h3>
        <span class="placeholder-guide-subtitle">Klik for at se tilgængelige felter fra ordination, prøve og varianter.</span>
      </summary>
      <div class="placeholder-guide-body">
        <p>${intro} Skriv pladsholderen i firkantede parenteser, fx <code>[Patient]</code>.</p>
        <div class="placeholder-guide-columns">
          <div>
            <h4>Patient &amp; ordination</h4>
            <ul>
              <li><code>[Patient]</code> – patientens navn</li>
              <li><code>[PatientMRN]</code> – patientens MRN/CPR</li>
              <li><code>[PatientID]</code> – ID</li>
              <li><code>[PatientFamilienummer]</code> – familienummer</li>
              <li><code>[PatientFødselsdato]</code> – fødselsdato (dd-mm-åååå)</li>
              <li><code>[OrdinationID]</code> – ordinationens ID</li>
              <li><code>[OrdinationStatus]</code> – ordinationens status</li>
              <li><code>[OrdinationDato]</code> – bestillingsdato</li>
              <li><code>[OrdinationRekvirent]</code> – rekvirerende afdeling/læge</li>
              <li><code>[OrdinationPanel]</code> – valgt panel</li>
              <li><code>[OrdinationAnalyseansvarlig]</code> – analyseansvarlig</li>
              <li><code>[OrdinationTolker]</code> – tolk/fortolker</li>
              <li><code>[OrdinationGodkender]</code> – godkender</li>
              <li><code>[OrdinationIndikation]</code> – ordinationens kliniske indikation</li>
              <li><code>[OrdinationPatientgruppe]</code> – ordinationens patientgruppe</li>
              <li><code>[OrdinationHPO]</code> / <code>[OrdinationHPOTermer]</code> – registrerede HPO-termer</li>
            </ul>
          </div>
          <div>
            <h4>Prøve</h4>
            <ul>
              <li><code>[SampleID]</code> – prøve-ID</li>
              <li><code>[SamplePMB]</code> – PMB-nummer</li>
              <li><code>[SampleType]</code> – prøvetype</li>
              <li><code>[SampleStatus]</code> – prøvens status</li>
              <li><code>[SampleDato]</code> – prøvetagningsdato</li>
            </ul>
          </div>
          <div>
            <h4>Varianter (fælles)</h4>
            <ul>
              <li><code>[VariantAntal]</code> – antal valgte varianter</li>
              <li><code>[VariantTyper]</code> / <code>[VariantType]</code> – liste over varianttyper (SNV, CNV, strukturel m.m.)</li>
              <li><code>[Gen]</code>, <code>[Transkript]</code>, <code>[HGVS_c]</code>, <code>[HGVS_p]</code> – lister over værdier på tværs af varianter</li>
              <li><code>[Zygositet]</code>, <code>[ACMG-klasse]</code>, <code>[Kriterier]</code> – kombinerede klassifikationer</li>
              <li><code>[Annoteringer]</code> – samlede annoteringer (inkl. VarSeq-noter)</li>
              <li><code>[Tolkning]</code> – samlede tolkninger</li>
              <li><code>[VariantListe]</code> – nummereret oversigt med detaljer (inkl. type, HGVS, ISCN m.m.)</li>
              <li><code>[Variant]</code> / <code>[Variant1]</code> – detaljeret tekst for den første variant</li>
            </ul>
            <h4>CNV, strukturelle &amp; cytogenetiske felter</h4>
            <ul>
              <li><code>[VariantISCN]</code> / <code>[ISCN]</code> – kombineret ISCN-notation for de valgte varianter</li>
              <li><code>[VariantGenomiskPosition]</code> / <code>[VariantPosition]</code> – genomiske positioner eller intervaller</li>
              <li><code>[VariantKopital]</code> / <code>[VariantCopyNumber]</code> – kopitaler/copy-number-resultater</li>
              <li><code>[VariantStrukturType]</code> / <code>[VariantSubtype]</code> – navngivne strukturtyper eller subtyper</li>
              <li><code>[VariantBeskrivelse]</code> – tekstbeskrivelser af strukturelle fund</li>
              <li><code>[BerørteGener]</code> / <code>[AffectedGenes]</code> – liste over berørte eller involverede gener</li>
            </ul>
          </div>
        </div>
        <p class="placeholder-guide-footnote">Tilgå enkelte varianter med nummererede pladsholdere, fx <code>[Variant1Gene]</code>, <code>[Variant1StrukturType]</code> eller <code>[Variant2ISCN]</code>. Manglende oplysninger giver tom tekst, og pladsholdere er uafhængige af store/små bogstaver. Punktum kan bruges som adskillelse, fx <code>[Patient.MRN]</code>.</p>
      </div>
    </details>
  `;
}

function renderConclusionLibrary(section) {
  const list = getCached('conclusion_library').slice().sort((a, b) => {
    const titleCompare = (a.title || '').localeCompare(b.title || '', 'da');
    if (titleCompare) return titleCompare;
    return (a.id || 0) - (b.id || 0);
  });
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="conclusionLibrarySearch">Søg</label>
        <input id="conclusionLibrarySearch" type="search" placeholder="Titel eller tekst...">
        <table>
          <thead>
            <tr><th>ID</th><th>Titel</th><th>Uddrag</th><th>Opdateret</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h2>Standardtekst</h2>
        <form id="conclusionLibraryForm">
          <input type="hidden" name="id">
          <label>Titel<input name="title" required></label>
          <label>Standardtekst<textarea name="body" rows="8" required></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="conclusionLibraryClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="conclusionLibraryDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
        <div data-placeholder-guide="library"></div>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#conclusionLibrarySearch');
  const form = section.querySelector('#conclusionLibraryForm');
  const clearBtn = section.querySelector('#conclusionLibraryClear');
  const deleteBtn = section.querySelector('#conclusionLibraryDelete');
  const placeholderGuideHost = section.querySelector('[data-placeholder-guide="library"]');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  if (placeholderGuideHost) {
    placeholderGuideHost.innerHTML = buildConclusionPlaceholderGuide('library');
  }
  let selectedId = null;
  let filtered = list.slice();
  const renderRows = () => {
    const term = (search?.value || '').toLowerCase().trim();
    filtered = list.filter(entry => {
      if (!term) return true;
      const haystack = `${entry.title || ''} ${(entry.body || '').replace(/\s+/g, ' ')}`.toLowerCase();
      return haystack.includes(term);
    });
    if (selectedId && !filtered.some(entry => entry.id === selectedId)) {
      selectedId = null;
    }
    if (!filtered.length) {
      tbody.innerHTML = '<tr><td colspan="4">Ingen standardtekster matcher søgningen.</td></tr>';
      annotateTableCells(section);
      return;
    }
    tbody.innerHTML = filtered.map(entry => {
      const snippetSource = (entry.body || '').replace(/\s+/g, ' ').trim();
      const snippet = snippetSource.length > 120 ? `${snippetSource.slice(0, 117)}…` : snippetSource;
      const updatedAt = formatDanishDate(entry.updated_at);
      const selectedAttr = entry.id === selectedId ? ' data-selected="true"' : '';
      return `<tr data-id="${entry.id}"${selectedAttr}><td>${entry.id}</td><td>${esc(entry.title || '')}</td><td>${esc(snippet)}</td><td>${esc(updatedAt)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search?.addEventListener('input', renderRows);
  tbody?.addEventListener('click', e => {
    const tr = e.target.closest('tr[data-id]');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const entry = list.find(item => item.id === id);
    if (!entry) return;
    selectedId = id;
    fillForm(form, entry);
    renderRows();
  });
  const clearForm = () => {
    if (!form) return;
    form.reset();
  };
  clearBtn?.addEventListener('click', clearForm);
  deleteBtn?.addEventListener('click', async () => {
    if (!ensureWrite('conclusion_library')) return;
    const id = Number(form?.elements.id.value);
    if (!id) {
      alert('Vælg en standardtekst der skal slettes.');
      return;
    }
    if (!confirm('Slet den valgte standardtekst?')) return;
    await deleteRecord('conclusion_library', id);
    setStatus(`Standardtekst ${id} slettet.`);
    renderTab('conclusion_library');
  });
  form?.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('conclusion_library')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    const payload = {
      title: (data.title || '').trim(),
      body: (data.body || '').trim()
    };
    if (!payload.title || !payload.body) {
      alert('Udfyld både titel og tekst.');
      return;
    }
    const id = Number(data.id || 0);
    if (id) {
      const before = findById('conclusion_library', id);
      if (!before) {
        alert('Kunne ikke finde standardteksten.');
        return;
      }
      const updated = {...before, ...payload, id};
      await updateRecord('conclusion_library', updated, before);
      setStatus(`Standardtekst ${id} opdateret.`);
    } else {
      await addRecord('conclusion_library', payload);
      setStatus('Standardtekst oprettet.');
    }
    renderTab('conclusion_library');
  });
  form?.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedId = null;
    renderRows();
  });
}

function renderReports(section) {
  const list = getCached('reports');
  const orders = getCached('orders');
  const samples = getCached('samples');
  const orderMap = new Map(orders.map(o => [Number(o.id), o]));
  const sampleMap = new Map(samples.map(s => [Number(s.id), s]));
  const orderOptions = orders.map(o => {
    const patientName = getName('patients', o.patient_id);
    const patientGroupName = getPatientGroupName(o.patient_group_id);
    const labelParts = [patientName];
    if (patientGroupName) labelParts.push(patientGroupName);
    const label = labelParts.filter(Boolean).join(' • ');
    return `<option value="${o.id}">${o.id} – ${esc(label || getOrderDisplayName(o.id))}</option>`;
  }).join('');
  const conclusionLibrary = getCached('conclusion_library').slice().sort((a, b) => (a.title || '').localeCompare(b.title || '', 'da'));
  const conclusionOptions = conclusionLibrary.map(entry => `<option value="${entry.id}">${esc(entry.title || `Tekst #${entry.id}`)}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="reportSearch">Søg</label>
        <input id="reportSearch" type="search" placeholder="Status...">
        <label class="list-toggle"><input type="checkbox" id="reportsActiveOnly" checked> Vis kun aktive</label>
        <details class="advanced-filter" id="reportsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-reports="id" placeholder="Rapport-ID"></label>
            <label>Ordination<input type="search" data-filter-reports="order" placeholder="Ordination (navn eller ID)"></label>
            <label>Prøve<input type="search" data-filter-reports="sample" placeholder="Prøve (ID eller PMB)"></label>
            <label>Status<input type="search" data-filter-reports="status" placeholder="Status"></label>
            <label>Udstedt fra<input type="date" data-filter-reports="issued_from"></label>
            <label>Udstedt til<input type="date" data-filter-reports="issued_to"></label>
          </div>
        </details>
        <table><thead><tr><th class="table-shortcuts"><span class="sr-only">Genveje</span></th><th>ID</th><th>Ordination</th><th>Status</th><th>Oprettet af</th><th>Udstedt</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="reportsExport">Eksportér filtrerede rapporter</button>
        </div>
      </div>
      <div>
        <h2>Rapport</h2>
        <form id="reportForm">
          <input type="hidden" name="id">
          <label>Ordination
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer ordinationer">
              <select name="order_id" required>
                <option value="" selected>Vælg ordination</option>
                ${orderOptions}
              </select>
            </div>
          </label>
          <label>Status<select name="status"><option value="draft">Udkast</option><option value="final">Endelig</option><option value="amended">Ændret</option></select></label>
          <label>Udstedt<input type="datetime-local" name="issued_at"></label>
          <label>Fund
            <div class="report-variant-selector">
              <div class="filterable-select">
                <input type="search" placeholder="Filtrer varianter" data-report-variant-filter>
                <select id="reportVariantSelect" disabled>
                  <option value="" selected>Vælg variant</option>
                </select>
              </div>
              <button class="secondary" type="button" id="reportAddVariant" disabled>Tilføj</button>
            </div>
          </label>
          <div class="report-variant-list" id="reportVariantList">
            <p class="report-variant-empty">Ingen varianter valgt.</p>
          </div>
          <input type="hidden" name="variant_ids" value="[]">
          <label>Konklusion<textarea name="summary"></textarea></label>
          <div class="conclusion-library-controls">
            <label>Standardtekst
              <select id="conclusionLibrarySelect">
                <option value="" selected>Vælg standardtekst</option>
                ${conclusionOptions}
              </select>
            </label>
            <div class="conclusion-library-buttons">
              <button class="secondary" type="button" id="conclusionLibraryInsert">Erstat konklusion</button>
              <button class="secondary" type="button" id="conclusionLibraryAppend">Tilføj til konklusion</button>
            </div>
          </div>
          <div data-placeholder-guide="report"></div>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="reportClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="reportDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
            <button class="secondary" type="button" id="reportPreview">Udskriv/forhåndsvis</button>
            <button class="secondary" type="button" id="reportDownloadPdf">Hent PDF</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#reportSearch');
  const form = section.querySelector('#reportForm');
  const orderSelect = form?.elements.order_id;
  const variantSelect = form?.querySelector('#reportVariantSelect');
  const variantFilterInput = form?.querySelector('[data-report-variant-filter]');
  const variantAddButton = form?.querySelector('#reportAddVariant');
  const variantList = form?.querySelector('#reportVariantList');
  const variantIdsInput = form?.elements.variant_ids;
  const conclusionSelect = form?.querySelector('#conclusionLibrarySelect');
  const conclusionInsertBtn = form?.querySelector('#conclusionLibraryInsert');
  const conclusionAppendBtn = form?.querySelector('#conclusionLibraryAppend');
  const summaryField = form?.elements.summary;
  const conclusionMap = new Map(conclusionLibrary.map(entry => [String(entry.id), entry]));
  const placeholderGuideHost = section.querySelector('[data-placeholder-guide="report"]');
  let selectedReportVariants = [];
  let currentReportOrderId = null;
  let variantOptionState = [];
  if (placeholderGuideHost) {
    placeholderGuideHost.innerHTML = buildConclusionPlaceholderGuide('report');
  }
  const updateAddButtonState = () => {
    if (!variantAddButton || !variantSelect) return;
    const id = Number(variantSelect.value);
    const exists = selectedReportVariants.some(v => v.id === id);
    variantAddButton.disabled = variantSelect.disabled || !variantSelect.value || exists;
  };
  const syncVariantIdsInput = () => {
    if (!variantIdsInput) return;
    const ids = selectedReportVariants.map(v => v.id).filter(id => id != null);
    variantIdsInput.value = JSON.stringify(ids);
  };
  const renderSelectedReportVariants = () => {
    if (!variantList) return;
    if (!selectedReportVariants.length) {
      variantList.innerHTML = '<p class="report-variant-empty">Ingen varianter valgt.</p>';
      return;
    }
    const items = selectedReportVariants.map(variant => {
      const title = formatVariantTitle(variant) || `Variant ${variant.id ?? ''}`.trim();
      const metaParts = [];
      if (variant.id != null) metaParts.push(`<span><strong>ID:</strong> ${esc(variant.id)}</span>`);
      const typeLabel = getVariantTypeLabel(variant.variant_type);
      if (typeLabel) metaParts.push(`<span><strong>Type:</strong> ${esc(typeLabel)}</span>`);
      if (variant.transcript) metaParts.push(`<span><strong>Transkript:</strong> ${esc(variant.transcript)}</span>`);
      if (variant.classification) metaParts.push(`<span><strong>Klasse:</strong> ${esc(variant.classification)}</span>`);
      if (variant.criteria) metaParts.push(`<span><strong>ACMG:</strong> ${esc(variant.criteria)}</span>`);
      if (variant.af !== undefined && variant.af !== null && variant.af !== '') metaParts.push(`<span><strong>AF:</strong> ${esc(variant.af)}</span>`);
      if (variant.zygosity) metaParts.push(`<span><strong>Zygositet:</strong> ${esc(variant.zygosity)}</span>`);
      const genomic = formatVariantGenomicRange(variant);
      if (genomic) metaParts.push(`<span><strong>Position:</strong> ${esc(genomic)}</span>`);
      if (variant.copy_number) metaParts.push(`<span><strong>Kopital:</strong> ${esc(variant.copy_number)}</span>`);
      if (variant.iscn) metaParts.push(`<span><strong>ISCN:</strong> ${esc(variant.iscn)}</span>`);
      const metaHtml = metaParts.length ? `<div class="report-variant-meta">${metaParts.join('')}</div>` : '';
      const interpretationHtml = variant.interpretation ? `<p>${esc(variant.interpretation)}</p>` : '';
      return `<div class="report-variant-item" data-variant-id="${variant.id}"><header><span>${esc(title)}</span><button type="button" class="report-variant-remove" data-action="remove" data-variant-id="${variant.id}">Fjern</button></header>${metaHtml}${interpretationHtml}</div>`;
    }).join('');
    variantList.innerHTML = items;
  };
  const setSelectedReportVariants = variants => {
    selectedReportVariants = (variants || []).map(v => ({...v}));
    syncVariantIdsInput();
    renderSelectedReportVariants();
    updateAddButtonState();
  };
  const buildVariantOptionLabel = variant => {
    const title = formatVariantTitle(variant);
    if (title) return title;
    return `Variant ${variant.id}`;
  };
  const applyVariantFilter = () => {
    if (!variantFilterInput) return;
    const term = variantFilterInput.value.trim().toLowerCase();
    variantOptionState.forEach(({option, text}) => {
      const matches = !term || text.includes(term) || option.selected;
      option.hidden = !matches;
    });
    if (term && variantSelect) {
      const firstVisible = variantOptionState.find(({option}) => !option.hidden);
      if (firstVisible && !firstVisible.option.selected) {
        variantSelect.value = firstVisible.option.value;
      }
    }
    updateAddButtonState();
  };
  const refreshVariantOptions = () => {
    if (!variantSelect) return;
    const orderId = Number(orderSelect?.value || '');
    currentReportOrderId = Number.isFinite(orderId) && orderId ? orderId : null;
    variantOptionState = [];
    variantSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Vælg variant';
    variantSelect.appendChild(placeholder);
    if (!currentReportOrderId) {
      variantSelect.disabled = true;
      if (variantFilterInput) {
        variantFilterInput.value = '';
        variantFilterInput.disabled = true;
      }
      updateAddButtonState();
      return;
    }
    const variantsForOrder = getCached('variants').filter(v => v.order_id === currentReportOrderId);
    variantsForOrder.forEach(variant => {
      const option = document.createElement('option');
      option.value = variant.id;
      option.textContent = buildVariantOptionLabel(variant);
      variantSelect.appendChild(option);
      variantOptionState.push({option, text: option.textContent.toLowerCase()});
    });
    variantSelect.disabled = variantsForOrder.length === 0;
    if (variantFilterInput) {
      variantFilterInput.value = '';
      variantFilterInput.disabled = variantsForOrder.length === 0;
    }
    variantSelect.value = '';
    applyVariantFilter();
  };
  const filterInputs = {
    id: section.querySelector('[data-filter-reports="id"]'),
    order: section.querySelector('[data-filter-reports="order"]'),
    sample: section.querySelector('[data-filter-reports="sample"]'),
    status: section.querySelector('[data-filter-reports="status"]'),
    issued_from: section.querySelector('[data-filter-reports="issued_from"]'),
    issued_to: section.querySelector('[data-filter-reports="issued_to"]')
  };
  const activeToggle = section.querySelector('#reportsActiveOnly');
  const updateConclusionButtons = () => {
    const hasSelection = !!conclusionSelect?.value;
    if (conclusionInsertBtn) conclusionInsertBtn.disabled = !hasSelection;
    if (conclusionAppendBtn) conclusionAppendBtn.disabled = !hasSelection;
  };
  const normalizePlaceholderKey = key => {
    if (!key) return '';
    return key
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/[^a-z0-9_.æøå-]/g, '')
      .replace(/-+/g, '')
      .replace(/^[.]+|[.]+$/g, '');
  };
  const joinUnique = (values, separator = ', ') => {
    const seen = new Set();
    const result = [];
    for (const value of values || []) {
      const text = value == null ? '' : String(value).trim();
      if (!text || seen.has(text)) continue;
      seen.add(text);
      result.push(text);
    }
    return result.join(separator);
  };
  const joinUniqueParagraphs = values => {
    const seen = new Set();
    const result = [];
    for (const value of values || []) {
      const text = value == null ? '' : String(value).trim();
      if (!text || seen.has(text)) continue;
      seen.add(text);
      result.push(text);
    }
    return result.join('\n\n');
  };
  const describeVariantBlock = variant => {
    if (!variant) return '';
    const lines = [];
    const header = formatVariantTitle(variant);
    if (header) lines.push(header);
    const detailLines = formatVariantDetailLines(variant);
    if (detailLines.length) lines.push(detailLines.join(' – '));
    if (variant.annotations) lines.push(`Annoteringer: ${variant.annotations}`);
    if (variant.interpretation) lines.push(`Tolkning: ${variant.interpretation}`);
    return lines.join('\n');
  };
  const buildConclusionPlaceholderMap = () => {
    const map = new Map();
    const add = (keys, value) => {
      if (!Array.isArray(keys)) keys = [keys];
      const text = value == null ? '' : String(value);
      for (const key of keys) {
        const normalized = normalizePlaceholderKey(key);
        if (!normalized) continue;
        map.set(normalized, text);
      }
    };
    const orderId = Number(form?.elements.order_id?.value || '') || null;
    const order = orderId ? findById('orders', orderId) : null;
    const patient = order?.patient_id ? findById('patients', Number(order.patient_id)) : null;
    const sample = order?.sample_id ? findById('samples', Number(order.sample_id)) : null;
    const panel = order?.panel_id ? findById('panels', Number(order.panel_id)) : null;
    const analysisUser = order?.analysis_responsible_id ? findById('users', Number(order.analysis_responsible_id)) : null;
    const interpreterUser = order?.interpreter_id ? findById('users', Number(order.interpreter_id)) : null;
    const approverUser = order?.approver_id ? findById('users', Number(order.approver_id)) : null;
    const patientGroupName = order?.patient_group_id ? getPatientGroupName(order.patient_group_id) : '';
    const variants = selectedReportVariants.slice();
    const variantCount = variants.length;
    const firstVariant = variants[0] || null;
    add(['Patient', 'PatientNavn', 'Patient.Name'], patient?.name || '');
    add(['PatientMRN', 'MRN', 'Patient.MRN'], patient?.mrn || '');
    add(['PatientID', 'PatientId', 'PatientEkstraId', 'PatientEkstraID', 'EkstraID', 'Patient.EkstraID'], patient?.extra_id || '');
    add(['PatientFamilienummer', 'Familienummer', 'Patient.Familienummer'], patient?.family_number || '');
    add(['PatientFodselsdato', 'PatientFødselsdato', 'Patient.BirthDate'], patient?.birth_date ? formatDanishDate(patient.birth_date) : '');
    add(['OrdinationID', 'Ordination.Id', 'OrderID'], orderId ? String(orderId) : '');
    add(['OrdinationStatus', 'Ordination.Status'], order?.status || '');
    add(['OrdinationDato', 'OrdinationBestilt', 'Ordination.Ordered'], order?.ordered_at ? formatDanishDate(order.ordered_at) : '');
    add(['OrdinationRekvirent', 'Ordination.Clinician', 'Clinician'], order?.clinician || '');
    add(['OrdinationPanel', 'PanelNavn', 'Panel'], panel?.name || '');
    add(['OrdinationAnalyseansvarlig', 'Analyseansvarlig'], analysisUser?.name || '');
    add(['OrdinationTolker', 'Tolker'], interpreterUser?.name || '');
    add(['OrdinationGodkender', 'Godkender'], approverUser?.name || '');
    add(['OrdinationIndikation', 'Ordination.Indikation', 'Indikation'], order?.indication || '');
    add(['OrdinationPatientgruppe', 'Ordination.Patientgruppe', 'Patientgruppe'], patientGroupName || '');
    add(['OrdinationHPO', 'OrdinationHPOTermer', 'Ordination.HPO', 'HPO', 'HPOliste', 'HPOList'], formatHpoList(order?.hpo_terms));
    add(['SampleID', 'ProeveID', 'PrøveID'], sample?.id ? String(sample.id) : '');
    add(['SamplePMB', 'PMB'], sample?.pmb_number || '');
    add(['SampleType', 'ProeveType', 'PrøveType'], sample?.sample_type || '');
    add(['SampleStatus', 'ProeveStatus', 'PrøveStatus'], sample?.status || '');
    add(['SampleDato', 'Sample.Collected', 'PrøveDato'], sample?.collected_at ? formatDanishDate(sample.collected_at) : '');
    add(['VariantAntal', 'AntalVarianter'], variantCount ? String(variantCount) : '');
    const geneList = joinUnique(variants.map(v => v.gene));
    const transcriptList = joinUnique(variants.map(v => v.transcript));
    const hgvscList = joinUnique(variants.map(v => v.hgvs_c));
    const hgvsPList = joinUnique(variants.map(v => v.hgvs_p));
    const zygosityList = joinUnique(variants.map(v => v.zygosity));
    const classificationList = joinUnique(variants.map(v => v.classification));
    const criteriaList = joinUnique(variants.map(v => v.criteria));
    const typeList = joinUnique(variants.map(v => getVariantTypeLabel(v.variant_type)));
    const iscnList = joinUnique(variants.map(v => v.iscn));
    const genomicList = joinUnique(variants.map(v => formatVariantGenomicRange(v)));
    const copyNumberList = joinUnique(variants.map(v => v.copy_number));
    const subtypeList = joinUnique(variants.map(v => getStructureTypeLabel(v.sv_subtype || v.structural_type || '')));
    const annotationsText = joinUniqueParagraphs(variants.map(v => v.annotations));
    const interpretationText = joinUniqueParagraphs(variants.map(v => v.interpretation));
    const descriptionText = joinUniqueParagraphs(variants.map(v => v.description));
    const affectedGenesText = joinUnique(variants.map(v => v.affected_genes));
    const variantSummaryBlocks = variants.map((variant, index) => {
      const block = describeVariantBlock(variant);
      if (!block) return '';
      const indented = block.replace(/\n/g, '\n   ');
      return `${index + 1}. ${indented}`;
    }).filter(Boolean);
    const variantSummary = variantSummaryBlocks.join('\n\n');
    add(['Gen', 'Gene', 'Gener'], geneList);
    add(['Transkript', 'Transcript'], transcriptList);
    add(['HGVS_c', 'HGVS c', 'HGVSc'], hgvscList);
    add(['HGVS_p', 'HGVS p', 'HGVSp'], hgvsPList);
    add(['Zygositet', 'Zygosity'], zygosityList);
    add(['ACMG-klasse', 'ACMGklasse', 'ACMG'], classificationList);
    add(['Kriterier', 'Criteria'], criteriaList);
    add(['VariantTyper', 'VariantType', 'Varianttype'], typeList);
    add(['VariantISCN', 'ISCN'], iscnList);
    add(['VariantGenomisk', 'VariantGenomiskPosition', 'VariantPosition'], genomicList);
    add(['VariantKopital', 'VariantCopyNumber'], copyNumberList);
    add(['VariantStrukturType', 'VariantSubtype', 'VariantSVType'], subtypeList);
    add(['Annoteringer', 'Annotationer', 'Annotations', 'VarSeq'], annotationsText);
    add(['Tolkning', 'Tolkninger', 'Interpretation', 'Interpretations'], interpretationText);
    add(['VariantBeskrivelse', 'VariantBeskrivelser', 'VariantDescription'], descriptionText);
    add(['BerørteGener', 'AffectedGenes'], affectedGenesText);
    add(['VariantListe', 'VariantList', 'Varianter'], variantSummary);
    if (firstVariant) {
      add(['Variant', 'VariantNavn', 'Variant1'], describeVariantBlock(firstVariant));
      add(['VariantGene', 'VariantGen', 'Variant1Gene', 'Variant1.Gen'], firstVariant.gene || '');
      add(['VariantTranskript', 'Variant1Transkript'], firstVariant.transcript || '');
      add(['VariantHGVS_c', 'Variant1HGVS_c', 'Variant1.HGVS_c'], firstVariant.hgvs_c || '');
      add(['VariantHGVS_p', 'Variant1HGVS_p', 'Variant1.HGVS_p'], firstVariant.hgvs_p || '');
      add(['VariantZygositet', 'Variant1Zygositet'], firstVariant.zygosity || '');
      add(['VariantACMG', 'Variant1ACMG'], firstVariant.classification || '');
      add(['VariantKriterier', 'Variant1Kriterier'], firstVariant.criteria || '');
      add(['VariantAnnoteringer', 'Variant1Annoteringer'], firstVariant.annotations || '');
      add(['VariantTolkning', 'Variant1Tolkning'], firstVariant.interpretation || '');
      add(['VariantType', 'Variant1Type'], getVariantTypeLabel(firstVariant.variant_type));
      add(['VariantISCN', 'Variant1ISCN'], firstVariant.iscn || '');
      add(['VariantGenomiskPosition', 'Variant1GenomiskPosition'], formatVariantGenomicRange(firstVariant));
      add(['VariantKopital', 'Variant1Kopital'], firstVariant.copy_number || '');
      add(['VariantStrukturType', 'Variant1StrukturType', 'Variant1Subtype'], getStructureTypeLabel(firstVariant.sv_subtype || firstVariant.structural_type || ''));
      add(['VariantBeskrivelse', 'Variant1Beskrivelse'], firstVariant.description || '');
      add(['VariantBerørteGener', 'Variant1BerørteGener', 'Variant1AffectedGenes'], firstVariant.affected_genes || '');
    }
    variants.forEach((variant, index) => {
      const idx = index + 1;
      const prefix = `Variant${idx}`;
      add([`${prefix}`, `${prefix}Navn`, `${prefix}.Navn`], describeVariantBlock(variant));
      add([`${prefix}Gene`, `${prefix}.Gene`, `${prefix}Gen`, `${prefix}.Gen`], variant.gene || '');
      add([`${prefix}Transkript`, `${prefix}.Transkript`], variant.transcript || '');
      add([`${prefix}HGVS_c`, `${prefix}.HGVS_c`], variant.hgvs_c || '');
      add([`${prefix}HGVS_p`, `${prefix}.HGVS_p`], variant.hgvs_p || '');
      add([`${prefix}Zygositet`, `${prefix}.Zygositet`], variant.zygosity || '');
      add([`${prefix}ACMG`, `${prefix}.ACMG`], variant.classification || '');
      add([`${prefix}Kriterier`, `${prefix}.Kriterier`], variant.criteria || '');
      add([`${prefix}Annoteringer`, `${prefix}.Annoteringer`], variant.annotations || '');
      add([`${prefix}Tolkning`, `${prefix}.Tolkning`], variant.interpretation || '');
      add([`${prefix}Type`, `${prefix}.Type`], getVariantTypeLabel(variant.variant_type));
      add([`${prefix}ISCN`, `${prefix}.ISCN`], variant.iscn || '');
      add([`${prefix}GenomiskPosition`, `${prefix}.GenomiskPosition`], formatVariantGenomicRange(variant));
      add([`${prefix}Kopital`, `${prefix}.Kopital`], variant.copy_number || '');
      add([`${prefix}StrukturType`, `${prefix}.StrukturType`, `${prefix}Subtype`, `${prefix}.Subtype`], getStructureTypeLabel(variant.sv_subtype || variant.structural_type || ''));
      add([`${prefix}Beskrivelse`, `${prefix}.Beskrivelse`], variant.description || '');
      add([`${prefix}BerørteGener`, `${prefix}.BerørteGener`, `${prefix}AffectedGenes`, `${prefix}.AffectedGenes`], variant.affected_genes || '');
    });
    return map;
  };
  const resolveConclusionTemplate = template => {
    if (!template) return '';
    const replacements = buildConclusionPlaceholderMap();
    return String(template).replace(/\[([^\]]+)\]/g, (match, rawKey) => {
      const normalized = normalizePlaceholderKey(rawKey);
      if (!normalized) return match;
      return replacements.has(normalized) ? replacements.get(normalized) : match;
    });
  };
  const applyConclusionText = mode => {
    if (!summaryField || !conclusionSelect) return;
    const entry = conclusionMap.get(conclusionSelect.value);
    if (!entry) return;
    const text = resolveConclusionTemplate(entry.body || '');
    if (mode === 'replace') {
      summaryField.value = text;
    } else if (mode === 'append') {
      const existing = summaryField.value || '';
      const trimmed = existing.replace(/\s+$/, '');
      summaryField.value = trimmed ? `${trimmed}\n\n${text}` : text;
    }
    summaryField.dispatchEvent(new Event('input', {bubbles: false}));
    summaryField.focus();
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  updateConclusionButtons();
  setSelectedReportVariants([]);
  refreshVariantOptions();
  if (variantFilterInput) {
    variantFilterInput.addEventListener('input', applyVariantFilter);
    variantFilterInput.addEventListener('keydown', evt => {
      if (evt.key === 'Escape') {
        variantFilterInput.value = '';
        applyVariantFilter();
      }
    });
  }
  if (variantSelect) {
    variantSelect.addEventListener('change', updateAddButtonState);
  }
  conclusionSelect?.addEventListener('change', updateConclusionButtons);
  conclusionInsertBtn?.addEventListener('click', () => applyConclusionText('replace'));
  conclusionAppendBtn?.addEventListener('click', () => applyConclusionText('append'));
  if (variantAddButton) {
    variantAddButton.addEventListener('click', () => {
      if (!variantSelect) return;
      const id = Number(variantSelect.value);
      if (!id || selectedReportVariants.some(v => v.id === id)) {
        updateAddButtonState();
        return;
      }
      const storeVariant = getCached('variants').find(v => v.id === id);
      const snapshot = snapshotVariant(storeVariant || {id, order_id: currentReportOrderId || Number(orderSelect?.value) || null});
      if (!snapshot.order_id) snapshot.order_id = currentReportOrderId || Number(orderSelect?.value) || null;
      setSelectedReportVariants(selectedReportVariants.concat(snapshot));
      variantSelect.value = '';
      applyVariantFilter();
    });
  }
  if (variantList) {
    variantList.addEventListener('click', evt => {
      const btn = evt.target.closest('[data-action="remove"]');
      if (!btn) return;
      const id = Number(btn.dataset.variantId);
      if (!id) return;
      setSelectedReportVariants(selectedReportVariants.filter(v => v.id !== id));
      updateAddButtonState();
    });
  }
  if (orderSelect) {
    orderSelect.addEventListener('change', () => {
      refreshVariantOptions();
      const orderId = Number(orderSelect.value);
      if (!orderId) {
        setSelectedReportVariants([]);
        return;
      }
      const filtered = selectedReportVariants.filter(v => Number(v.order_id) === orderId);
      if (filtered.length !== selectedReportVariants.length) {
        setSelectedReportVariants(filtered);
      } else {
        syncVariantIdsInput();
        renderSelectedReportVariants();
        updateAddButtonState();
      }
    });
  }
  const statusMap = {draft:'Udkast', final:'Endelig', amended:'Ændret'};
  let filteredReports = list.slice();
  let activeFilters = {};
  let pendingFilterOrderId = state.pendingReportFilterOrderId != null ? Number(state.pendingReportFilterOrderId) : null;
  if (!Number.isFinite(pendingFilterOrderId)) pendingFilterOrderId = null;
  let pendingFilterSampleId = state.pendingReportFilterSampleId != null ? Number(state.pendingReportFilterSampleId) : null;
  if (!Number.isFinite(pendingFilterSampleId)) pendingFilterSampleId = null;
  let requireExactSample = Boolean(state.pendingReportFilterSampleExact && pendingFilterSampleId != null);
  const pendingSelectOrderIdRaw = state.pendingReportSelectOrderId != null ? Number(state.pendingReportSelectOrderId) : null;
  let pendingSelectOrderId = Number.isFinite(pendingSelectOrderIdRaw) ? pendingSelectOrderIdRaw : null;
  const pendingSelectReportIdRaw = state.pendingReportSelectReportId != null ? Number(state.pendingReportSelectReportId) : null;
  const pendingSelectReportId = Number.isFinite(pendingSelectReportIdRaw) ? pendingSelectReportIdRaw : null;
  let selectedReportId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  if (pendingFilterOrderId != null) {
    if (filterInputs.order) filterInputs.order.value = String(pendingFilterOrderId);
    if (search) search.value = '';
    if (state.pendingReportShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    const matchingReports = list.filter(r => Number(r.order_id) === pendingFilterOrderId);
    if (matchingReports.length) {
      matchingReports.sort((a, b) => {
        const timeA = (a.issued_at || a.updated_at || a.created_at || '');
        const timeB = (b.issued_at || b.updated_at || b.created_at || '');
        return timeB.localeCompare(timeA);
      });
      selectedReportId = matchingReports[0].id;
    }
  }
  if (pendingFilterSampleId != null) {
    if (filterInputs.sample) filterInputs.sample.value = String(pendingFilterSampleId);
    if (search) search.value = '';
    if (state.pendingReportShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    const relatedOrders = orders.filter(o => Number(o.sample_id) === pendingFilterSampleId);
    const relatedOrderIds = new Set(relatedOrders.map(o => Number(o.id)).filter(id => Number.isFinite(id)));
    const matchingReports = list.filter(r => relatedOrderIds.has(Number(r.order_id)));
    if (matchingReports.length) {
      matchingReports.sort((a, b) => {
        const timeA = (a.issued_at || a.updated_at || a.created_at || '');
        const timeB = (b.issued_at || b.updated_at || b.created_at || '');
        return timeB.localeCompare(timeA);
      });
      if (selectedReportId == null) {
        selectedReportId = matchingReports[0].id;
      }
      if (pendingSelectOrderId == null) {
        const firstOrderId = Number(matchingReports[0].order_id);
        if (Number.isFinite(firstOrderId)) pendingSelectOrderId = firstOrderId;
      }
    } else if (relatedOrderIds.size === 1 && pendingSelectOrderId == null) {
      const onlyOrderId = relatedOrderIds.values().next().value;
      if (Number.isFinite(onlyOrderId)) pendingSelectOrderId = Number(onlyOrderId);
    }
  }
  if (selectedReportId == null && pendingSelectReportId != null) {
    selectedReportId = pendingSelectReportId;
  }
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      order: filterInputs.order?.value.trim().toLowerCase() || '',
      sample: filterInputs.sample?.value.trim().toLowerCase() || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      issued_from: filterInputs.issued_from?.value || '',
      issued_to: filterInputs.issued_to?.value || ''
    };
    const fromDate = filters.issued_from ? new Date(filters.issued_from) : null;
    const toDate = filters.issued_to ? new Date(filters.issued_to) : null;
    if (toDate) toDate.setHours(23, 59, 59, 999);
    const filterSummary = {...filters};
    const numericFilterSample = Number(filters.sample || '');
    const matchExactSample = requireExactSample && filters.sample !== '' && Number.isFinite(numericFilterSample) && numericFilterSample === pendingFilterSampleId;
    if (term) filterSummary.fritekst = term;
    if (filters.sample) {
      const sampleObj = sampleMap.get(Number(filters.sample));
      filterSummary.prøve = sampleObj ? `${sampleObj.id} (${sampleObj.pmb_number || '–'})` : filters.sample;
    }
    delete filterSummary.sample;
    filterSummary.visning = showActiveOnly ? 'Kun aktive' : 'Alle';
    activeFilters = filterSummary;
    filteredReports = list.filter(r => {
      const order = orderMap.get(Number(r.order_id));
      const sample = order ? sampleMap.get(Number(order.sample_id)) : null;
      const sampleStatus = (sample?.status || order?.status || '').toLowerCase();
      const samplePatientName = sample ? getName('patients', sample.patient_id) : '';
      if (!term) {
        if (showActiveOnly && !isActiveStatus(sampleStatus)) return false;
        return true;
      }
      const raw = (r.status || '').toLowerCase();
      const display = (statusMap[r.status] || r.status || '').toLowerCase();
      const creator = determineCreatedBy('reports', r).toLowerCase();
      const orderName = getOrderDisplayName(r.order_id).toLowerCase();
      const orderId = String(r.order_id || '').toLowerCase();
      const sampleIdString = sample ? String(sample.id || '').toLowerCase() : '';
      const samplePmb = (sample?.pmb_number || '').toLowerCase();
      const matches = [raw, display, creator, orderName, orderId, sampleStatus, sampleIdString, samplePmb, (samplePatientName || '').toLowerCase()].some(value => value.includes(term));
      if (!matches) return false;
      if (showActiveOnly && !isActiveStatus(sampleStatus)) return false;
      return true;
    }).filter(r => {
      if (filters.id && !String(r.id).includes(filters.id)) return false;
      if (filters.order) {
        const orderIdString = String(r.order_id || '').toLowerCase();
        const orderName = getOrderDisplayName(r.order_id).toLowerCase();
        if (!orderIdString.includes(filters.order) && !orderName.includes(filters.order)) return false;
      }
      const order = orderMap.get(Number(r.order_id));
      const sample = order ? sampleMap.get(Number(order.sample_id)) : null;
      const sampleStatus = (sample?.status || order?.status || '').toLowerCase();
      const samplePatientName = sample ? getName('patients', sample.patient_id) : '';
      if (filters.sample) {
        if (matchExactSample) {
          if (!sample || Number(sample.id) !== pendingFilterSampleId) return false;
        } else {
          const sampleValues = [
            sample ? String(sample.id || '').toLowerCase() : '',
            (sample?.pmb_number || '').toLowerCase(),
            (samplePatientName || '').toLowerCase()
          ];
          if (!sampleValues.some(v => v.includes(filters.sample))) return false;
        }
      }
      const statusStrings = [(r.status || '').toLowerCase(), (statusMap[r.status] || '').toLowerCase(), sampleStatus];
      if (filters.status && !statusStrings.some(v => v.includes(filters.status))) return false;
      if (fromDate || toDate) {
        if (!r.issued_at) return false;
        const issued = new Date(r.issued_at);
        if (Number.isNaN(issued.getTime())) return false;
        if (fromDate && issued < fromDate) return false;
        if (toDate && issued > toDate) return false;
      }
      if (showActiveOnly && !isActiveStatus(sampleStatus)) return false;
      return true;
    });
    if (selectedReportId != null && !filteredReports.some(r => r.id === selectedReportId)) {
      selectedReportId = null;
    }
    tbody.innerHTML = filteredReports.map(r => {
      const order = orderMap.get(Number(r.order_id));
      const sample = order ? sampleMap.get(Number(order?.sample_id)) : null;
      const sampleStatus = sample?.status || order?.status || '';
      const displayStatus = statusMap[r.status] || r.status || '';
      const createdBy = determineCreatedBy('reports', r);
      const issuedAt = formatDanishDate(r.issued_at);
      const orderName = getOrderDisplayName(r.order_id);
      const orderTitle = r.order_id != null ? ` title="Ordination #${r.order_id}"` : '';
      const sampleStatusBadge = sampleStatus && !isActiveStatus(sampleStatus)
        ? ` <span class="table-meta">(${esc(sampleStatus)})</span>`
        : '';
      const selectedAttr = r.id === selectedReportId ? ' data-selected="true"' : '';
      const hasOrder = r.order_id != null && Number.isFinite(Number(r.order_id));
      const sampleIdValue = sample ? Number(sample.id) : NaN;
      const orderTip = hasOrder
        ? 'Åbn Ordinationer-fanen med filter for denne rapport.'
        : 'Rapporten er ikke knyttet til en ordination.';
      const hasSample = Number.isFinite(sampleIdValue);
      const sampleTip = hasSample
        ? 'Åbn Prøver-fanen med filter for denne rapport.'
        : 'Rapportens ordination er ikke knyttet til en prøve.';
      const orderButtonDisabledAttr = hasOrder ? '' : ' disabled';
      const sampleButtonDisabledAttr = hasSample ? '' : ' disabled';
      const shortcutsCell = `<td class="table-actions-cell"><button type="button" class="icon-button" data-report-action="orders" data-report-id="${r.id}" data-tooltip="${esc(orderTip)}"${orderButtonDisabledAttr}><span class="icon-slot" data-icon="clipboard-document-list"></span></button><button type="button" class="icon-button" data-report-action="samples" data-report-id="${r.id}" data-tooltip="${esc(sampleTip)}"${sampleButtonDisabledAttr}><span class="icon-slot" data-icon="beaker"></span></button></td>`;
      return `<tr data-id="${r.id}"${selectedAttr}>${shortcutsCell}<td>${r.id}</td><td${orderTitle}>${esc(orderName)}</td><td>${esc(displayStatus)}${sampleStatusBadge}</td><td>${esc(createdBy)}</td><td>${esc(issuedAt)}</td></tr>`;
    }).join('');
    applyIconSlots(tbody);
    tbody.querySelectorAll('button[data-report-action]').forEach(btn => {
      const tip = btn.dataset.tooltip || btn.getAttribute('title') || '';
      if (tip) setTooltip(btn, tip);
    });
    annotateTableCells(section);
  };
  renderRows();
  if (selectedReportId != null) {
    const pendingReport = list.find(r => r.id === selectedReportId);
    if (pendingReport) {
      fillForm(form, pendingReport);
      const pendingRow = tbody?.querySelector(`tr[data-id="${pendingReport.id}"]`);
      if (pendingRow) {
        pendingRow.scrollIntoView({block: 'nearest'});
      }
      if (orderSelect) {
        orderSelect.dispatchEvent(new Event('change'));
      }
    }
  } else if (pendingSelectOrderId != null && orderSelect) {
    orderSelect.value = String(pendingSelectOrderId);
    orderSelect.dispatchEvent(new Event('change'));
  }
  state.pendingReportFilterOrderId = null;
  state.pendingReportFilterSampleId = null;
  state.pendingReportFilterSampleExact = false;
  state.pendingReportShowAll = false;
  state.pendingReportSelectOrderId = null;
  state.pendingReportSelectReportId = null;
  search.addEventListener('input', renderRows);
  const handleFilterChange = event => {
    if (event?.currentTarget === filterInputs.sample) {
      requireExactSample = false;
    }
    renderRows();
  };
  Object.values(filterInputs).forEach(input => {
    if (!input) return;
    const isSelect = input.tagName === 'SELECT';
    input.addEventListener(isSelect ? 'change' : 'input', handleFilterChange);
    if (isSelect) {
      input.addEventListener('input', handleFilterChange);
    }
  });
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  const reportExportColumns = [
    {key:'id', label:'ID'},
    {key:'order_id', label:'Ordination-ID'},
    {key:'order_name', label:'Ordination', value: row => getOrderDisplayName(row.order_id)},
    {key:'order_indication', label:'Ordination – indikation', value: row => orderMap.get(Number(row.order_id))?.indication || ''},
    {key:'order_patient_group_id', label:'Ordination – patientgruppe-ID', value: row => orderMap.get(Number(row.order_id))?.patient_group_id ?? ''},
    {key:'order_patient_group', label:'Ordination – patientgruppe', value: row => getPatientGroupName(orderMap.get(Number(row.order_id))?.patient_group_id)},
    {key:'order_hpo_terms', label:'Ordination – HPO-termer', value: row => formatHpoList(orderMap.get(Number(row.order_id))?.hpo_terms)},
    {key:'status', label:'Status (kode)'},
    {key:'status_label', label:'Status', value: row => statusMap[row.status] || row.status || ''},
    {key:'summary', label:'Konklusion'},
    {key:'findings', label:'Fund'},
    {key:'variant_ids', label:'Variant-ID\'er'},
    {key:'variant_details', label:'Variantdetaljer', value: row => formatJsonCell(row.variant_details)},
    {key:'issued_at', label:'Udstedt (ISO)'},
    {key:'issued_at_formatted', label:'Udstedt', value: row => formatDanishDate(row.issued_at, true)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#reportsExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('reports', filteredReports);
    exportFilteredCsv('glimr-rapporter-filtreret.csv', rows, reportExportColumns, {
      entity: 'rapporter',
      plural: 'rapporter'
    });
  });
  tbody.addEventListener('click', e => {
    const actionButton = e.target.closest('button[data-report-action]');
    if (actionButton) {
      if (actionButton.disabled) return;
      const {reportId, reportAction} = actionButton.dataset;
      if (reportAction === 'orders') {
        openOrdersForReport(reportId);
      } else if (reportAction === 'samples') {
        openSamplesForReport(reportId);
      }
      return;
    }
    const tr = e.target.closest('tr');
    if (!tr) return;
    const report = list.find(r => r.id === Number(tr.dataset.id));
    if (!report) return;
    selectedReportId = report.id;
    fillForm(form, report);
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
    refreshVariantOptions();
    const variants = getReportVariantSnapshots(report, Number(report.order_id));
    setSelectedReportVariants(variants);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('reports')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.order_id = Number(data.order_id);
    const orderId = data.order_id;
    const variantStore = getCached('variants');
    const variantSnapshots = selectedReportVariants.map(item => {
      const source = variantStore.find(v => v.id === item.id) || item;
      const snapshot = snapshotVariant(source);
      if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
      return snapshot;
    });
    data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
    data.variant_details = variantSnapshots;
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('reports', id)};
      const updated = {...before, ...data, id};
      await updateRecord('reports', updated, before);
    } else {
      delete data.id;
      await addRecord('reports', data);
    }
    await loadStore('reports');
    renderTab('reports');
  });
  section.querySelector('#reportDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg rapport');
    if (!ensureWrite('reports')) return;
    if (confirm('Slet rapport?')) {
      await deleteRecord('reports', id);
      renderTab('reports');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedReportId = null;
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
    renderRows();
  });
  section.querySelector('#reportClear').addEventListener('click', () => {
    form.reset();
    setSelectedReportVariants([]);
    refreshVariantOptions();
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
  });
  section.querySelector('#reportPreview').addEventListener('click', () => {
    const data = Object.fromEntries(new FormData(form).entries());
    if (!data.order_id) return alert('Vælg ordre');
    const orderId = Number(data.order_id);
    data.order_id = orderId;
    const variantStore = getCached('variants');
    const variantSnapshots = selectedReportVariants.map(item => {
      const source = variantStore.find(v => v.id === item.id) || item;
      const snapshot = snapshotVariant(source);
      if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
      return snapshot;
    });
    data.variant_details = variantSnapshots;
    data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
    const html = buildReportHtml(orderId, data);
    const win = window.open('', '_blank');
    if (win) {
      win.document.write('<!DOCTYPE html><html><head><title>Rapport</title><style>body{font-family:Segoe UI,Arial;margin:2rem;}table{width:100%;border-collapse:collapse;}th,td{border:1px solid #ccc;padding:0.4rem;}th{background:#f0f0f0;}</style></head><body>' + html + '</body></html>');
      win.document.close();
    }
  });
  const downloadPdfButton = section.querySelector('#reportDownloadPdf');
  if (downloadPdfButton) {
    downloadPdfButton.addEventListener('click', async () => {
      const data = Object.fromEntries(new FormData(form).entries());
      if (!data.order_id) {
        alert('Vælg ordre');
        return;
      }
      const orderId = Number(data.order_id);
      data.order_id = orderId;
      const variantStore = getCached('variants');
      const variantSnapshots = selectedReportVariants.map(item => {
        const source = variantStore.find(v => v.id === item.id) || item;
        const snapshot = snapshotVariant(source);
        if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
        return snapshot;
      });
      data.variant_details = variantSnapshots;
      data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
      const exportedAt = new Date();
      const blob = await createReportPdfBlob(orderId, data, exportedAt);
      if (!blob) {
        alert('Kunne ikke generere PDF for rapporten.');
        return;
      }
      const filename = buildReportPdfFilename(orderId, data, exportedAt);
      const url = URL.createObjectURL(blob);
      triggerDownload(url, filename);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      setStatus(`Rapport PDF hentet som ${filename}.`);
    });
  }
}
function buildReportHtml(orderId, reportData) {
  const order = findById('orders', orderId);
  const patient = order ? findById('patients', Number(order.patient_id)) : null;
  const sample = order ? findById('samples', Number(order.sample_id)) : null;
  let variants = getReportVariantSnapshots(reportData, orderId);
  if (!variants.length) {
    variants = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
  }
  const patientGroupName = order ? getPatientGroupName(order.patient_group_id) : '';
  const sampleIdentifierParts = [];
  if (sample?.pmb_number) sampleIdentifierParts.push(sample.pmb_number);
  if (sample?.id != null) sampleIdentifierParts.push(`ID ${sample.id}`);
  const sampleIdentifier = sampleIdentifierParts.join(' / ');
  const hasIndication = !!collapseSpaces(order?.indication);
  const indicationHtml = hasIndication ? formatMultilineCell(order.indication) : esc('Ikke angivet');
  const hpoHtml = formatHpoHtml(order?.hpo_terms);
  const rows = variants.map(v => {
    const title = formatVariantTitle(v);
    const typeLabel = getVariantTypeLabel(v.variant_type);
    return `<tr><td>${esc(title)}</td><td>${esc(typeLabel)}</td><td>${esc(v.classification||'')}</td><td>${esc(v.criteria||'')}</td><td>${esc(v.af??'')}</td><td>${esc(v.zygosity||'')}</td><td>${esc(v.interpretation||'')}</td></tr>`;
  }).join('') || '<tr><td colspan="7">Ingen fund</td></tr>';
  const detailSections = variants.length ? variants.map(variant => {
    const heading = formatVariantTitle(variant) || `Variant ${variant.id ?? ''}`.trim();
    const meta = [];
    const typeLabel = getVariantTypeLabel(variant.variant_type);
    if (typeLabel) meta.push(`<li><strong>Type:</strong> ${esc(typeLabel)}</li>`);
    if (variant.transcript) meta.push(`<li><strong>Transkript:</strong> ${esc(variant.transcript)}</li>`);
    if (variant.zygosity) meta.push(`<li><strong>Zygositet:</strong> ${esc(variant.zygosity)}</li>`);
    if (variant.classification) meta.push(`<li><strong>Klasse:</strong> ${esc(variant.classification)}</li>`);
    if (variant.criteria) meta.push(`<li><strong>ACMG:</strong> ${esc(variant.criteria)}</li>`);
    if (variant.af !== undefined && variant.af !== null && variant.af !== '') meta.push(`<li><strong>AF:</strong> ${esc(variant.af)}</li>`);
    const genomic = formatVariantGenomicRange(variant);
    if (genomic) meta.push(`<li><strong>Genomisk position:</strong> ${esc(genomic)}</li>`);
    if (variant.copy_number) meta.push(`<li><strong>Kopital:</strong> ${esc(variant.copy_number)}</li>`);
    if (variant.iscn) meta.push(`<li><strong>ISCN:</strong> ${esc(variant.iscn)}</li>`);
    if (variant.affected_genes) meta.push(`<li><strong>Berørte gener:</strong> ${esc(variant.affected_genes)}</li>`);
    if (variant.description) meta.push(`<li><strong>Beskrivelse:</strong> ${esc(variant.description)}</li>`);
    const interpretation = variant.interpretation ? `<p>${esc(variant.interpretation)}</p>` : '';
    const metaList = meta.length ? `<ul>${meta.join('')}</ul>` : '';
    return `<div class="report-variant-detail"><h3>${esc(heading)}</h3>${metaList}${interpretation}</div>`;
  }).join('') : '<p>Ingen variantdetaljer registreret.</p>';
  const patientIdentifiersDisplay = (() => {
    const parts = [patient?.mrn, patient?.extra_id, patient?.family_number].filter(Boolean).map(esc);
    return parts.length ? ` (${parts.join(' • ')})` : '';
  })();
  return `
  <h1>Diagnostisk rapport</h1>
  <p><strong>Ordination:</strong> ${orderId}</p>
  <p><strong>Indikation:</strong><br>${indicationHtml}</p>
  ${patientGroupName ? `<p><strong>Patientgruppe:</strong> ${esc(patientGroupName)}</p>` : ''}
  ${hpoHtml ? `<p><strong>HPO-termer:</strong><br>${hpoHtml}</p>` : ''}
  <p><strong>Patient:</strong> ${esc(patient?.name||'')}${patientIdentifiersDisplay}</p>
  <p><strong>Prøve:</strong> ${esc(sample?.sample_type||'')}${sampleIdentifier ? ` (${esc(sampleIdentifier)})` : ''}</p>
  <p><strong>Status:</strong> ${esc(reportData.status||'')}</p>
  <p><strong>Udstedt:</strong> ${esc(formatDanishDate(reportData.issued_at))}</p>
  <h2>Konklusion</h2>
  <p>${esc(reportData.summary||'')}</p>
  <h2>Fund</h2>
  <table><thead><tr><th>Variant</th><th>Type</th><th>Klasse</th><th>ACMG</th><th>AF</th><th>Zygositet</th><th>Tolkning</th></tr></thead><tbody>${rows}</tbody></table>
  <h2>Detaljer</h2>
  ${detailSections}`;
}
function escapePdfText(text) {
  return String(text || '').replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)').replace(/\r/g, '').replace(/\n/g, '\\n');
}
function stringToPdfBytes(str) {
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    bytes[i] = code <= 0xFF ? code : 0x3F;
  }
  return bytes;
}
const PDF_PAGE_WIDTH = 595;
const PDF_PAGE_HEIGHT = 842;
const PDF_MARGIN = 48;
const PDF_GUTTER = 28;
const PDF_BODY_FONT_SIZE = 11;
const PDF_HEADING_FONT_SIZE = 13;
const PDF_TITLE_FONT_SIZE = 20;
const PDF_BODY_LEADING = 16;
const PDF_HEADING_LEADING = 20;
const PDF_HEADING_GAP = 6;
const PDF_SECTION_SPACING = 16;
const PDF_ROW_SPACING = 6;
const PDF_SIGNATURE_BLOCK_HEIGHT = 110;
const PDF_TITLE_LEADING = 28;
const PDF_SECTION_CARD_PADDING_X = 14;
const PDF_SECTION_CARD_PADDING_TOP = 14;
const PDF_SECTION_CARD_PADDING_BOTTOM = 16;
const PDF_SECTION_CARD_INSET = 6;
const PDF_HEADER_BAND_HEIGHT = 132;
const PDF_HEADER_TITLE_BASELINE_OFFSET = 26;
const PDF_TEXT_COLOR = '#1b2c45';
const PDF_MUTED_TEXT_COLOR = '#4a6080';
const PDF_HEADING_TEXT_COLOR = '#124c87';
const PDF_ACCENT_COLOR = '#124c87';
const PDF_HEADER_BAND_COLOR = '#e5effb';
const PDF_CARD_BACKGROUND_COLOR = '#f9fbff';
const PDF_CARD_BORDER_COLOR = '#c5d7ed';
const PDF_CARD_HEADING_COLOR = '#cfe0f6';
const PDF_SIGNATURE_BAND_COLOR = '#ecf2fb';
const PDF_SIGNATURE_LINE_COLOR = '#8ea8c7';
const PDF_HEADING_TEXT_OFFSET = 2;
const PDF_HEADING_BAR_OFFSET = 3;
const PT_TO_PX = 96 / 72;

function pdfColorToRgb(color) {
  if (!color) return null;
  if (Array.isArray(color) && color.length >= 3) {
    return color.slice(0, 3).map(component => Math.max(0, Math.min(1, Number(component) || 0))).join(' ');
  }
  if (typeof color === 'string') {
    let hex = color.trim();
    if (hex.startsWith('#')) hex = hex.slice(1);
    if (hex.length === 3) {
      hex = hex.split('').map(ch => ch + ch).join('');
    }
    if (hex.length === 6) {
      const r = parseInt(hex.slice(0, 2), 16) / 255;
      const g = parseInt(hex.slice(2, 4), 16) / 255;
      const b = parseInt(hex.slice(4, 6), 16) / 255;
      return [r, g, b].map(v => v.toFixed(4).replace(/0+$/, '').replace(/\.$/, '')).join(' ');
    }
  }
  return null;
}

let pdfMeasureCtx = null;

function getPdfMeasureContext(fontSize) {
  if (!pdfMeasureCtx) {
    const canvas = document.createElement('canvas');
    pdfMeasureCtx = canvas.getContext('2d');
  }
  if (pdfMeasureCtx) {
    pdfMeasureCtx.font = `${(fontSize * PT_TO_PX).toFixed(2)}px "Arial", "Helvetica", sans-serif`;
  }
  return pdfMeasureCtx;
}

function wrapPdfText(text, maxWidth, fontSize) {
  const ctx = getPdfMeasureContext(fontSize);
  if (!ctx) return [String(text ?? '')];
  const maxWidthPx = maxWidth * PT_TO_PX;
  const paragraphs = String(text ?? '').replace(/\r/g, '').split('\n');
  const lines = [];
  for (let p = 0; p < paragraphs.length; p++) {
    const paragraph = paragraphs[p];
    const words = paragraph.trim() ? paragraph.split(/\s+/) : [];
    if (!words.length) {
      if (p < paragraphs.length - 1) lines.push('');
      continue;
    }
    let current = '';
    const flush = () => {
      if (current) {
        lines.push(current);
        current = '';
      }
    };
    for (const word of words) {
      const candidate = current ? `${current} ${word}` : word;
      if (ctx.measureText(candidate).width <= maxWidthPx) {
        current = candidate;
        continue;
      }
      flush();
      if (ctx.measureText(word).width <= maxWidthPx) {
        current = word;
        continue;
      }
      let segment = '';
      for (const char of word) {
        const attempt = segment + char;
        if (ctx.measureText(attempt).width > maxWidthPx && segment) {
          lines.push(segment);
          segment = char;
        } else {
          segment = attempt;
        }
      }
      current = segment;
    }
    flush();
    if (p < paragraphs.length - 1) lines.push('');
  }
  if (!lines.length) lines.push('');
  return lines;
}

function indentWrappedLines(lines, indentText) {
  if (!indentText) return lines;
  return lines.map((line, index) => (index === 0 ? `${indentText}${line}` : `${indentText}${line}`));
}

function formatDanishDate(value, includeTimeHint) {
  if (!value) return '';
  const formatFromDate = (date, includeTime) => {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const base = `${day}.${month}.${year}`;
    const shouldIncludeTime = includeTime ?? (date.getHours() !== 0 || date.getMinutes() !== 0 || date.getSeconds() !== 0 || date.getMilliseconds() !== 0);
    if (!shouldIncludeTime) return base;
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${base}, ${hours}.${minutes}.${seconds}`;
  };
  if (value instanceof Date) {
    return formatFromDate(value, includeTimeHint);
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return '';
    const isoDateMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (isoDateMatch) {
      const [, year, month, day] = isoDateMatch;
      return `${day}.${month}.${year}`;
    }
    const isoDateTimeMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2})(?::(\d{2}))?/);
    if (isoDateTimeMatch) {
      const parsed = new Date(trimmed);
      if (!Number.isNaN(parsed.getTime())) {
        return formatFromDate(parsed, true);
      }
    }
    const parsed = new Date(trimmed);
    if (!Number.isNaN(parsed.getTime())) {
      const includeTime = trimmed.includes('T') || /\d{2}:\d{2}/.test(trimmed);
      return formatFromDate(parsed, includeTime);
    }
    return trimmed;
  }
  if (typeof value === 'number') {
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) {
      return formatFromDate(parsed, true);
    }
  }
  return '';
}

const numberFormatterCache = new Map();
function formatNumberDa(value, decimals = 0) {
  if (value === null || value === undefined) return '—';
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) return '—';
  const key = `${decimals}`;
  let formatter = numberFormatterCache.get(key);
  if (!formatter) {
    formatter = new Intl.NumberFormat('da-DK', {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals
    });
    numberFormatterCache.set(key, formatter);
  }
  return formatter.format(numeric);
}

function parseDateTimeValue(value) {
  if (!value && value !== 0) return null;
  if (value instanceof Date) {
    return Number.isNaN(value.getTime()) ? null : value;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = new Date(trimmed);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  if (typeof value === 'number') {
    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  return null;
}

function formatDaysSince(value, referenceValue = new Date()) {
  const baseDate = parseDateTimeValue(value);
  const referenceDate = parseDateTimeValue(referenceValue) || new Date();
  if (!baseDate || !referenceDate) return '';
  const diffMs = referenceDate.getTime() - baseDate.getTime();
  if (!Number.isFinite(diffMs) || diffMs < 0) return '';
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  if (diffDays === 0) return '0 dage siden';
  if (diffDays === 1) return '1 dag siden';
  return `${diffDays} dage siden`;
}

function calculatePercentile(values, percentile) {
  if (!Array.isArray(values) || !values.length) return null;
  const sorted = values.slice().sort((a, b) => a - b);
  const index = (sorted.length - 1) * percentile;
  const lower = Math.floor(index);
  const upper = Math.ceil(index);
  if (lower === upper) return sorted[lower];
  const weight = index - lower;
  return sorted[lower] * (1 - weight) + sorted[upper] * weight;
}

function formatDurationDays(days) {
  if (days === null || days === undefined || Number.isNaN(days) || days < 0) {
    return 'Ingen data';
  }
  if (days < 1) {
    const hours = Math.round(days * 24);
    if (hours <= 0) return '<1 time';
    return `${hours} ${hours === 1 ? 'time' : 'timer'}`;
  }
  if (days < 7) {
    const decimals = days < 3 ? 1 : 0;
    return `${formatNumberDa(days, decimals)} dage`;
  }
  const weeks = days / 7;
  if (weeks < 12) {
    const decimals = weeks < 3 ? 1 : 0;
    return `${formatNumberDa(weeks, decimals)} uger`;
  }
  return `${formatNumberDa(days, 0)} dage`;
}

function normalizeDateOnly(value) {
  if (!value && value !== 0) return null;
  if (value instanceof Date) {
    if (Number.isNaN(value.getTime())) return null;
    return new Date(value.getFullYear(), value.getMonth(), value.getDate());
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const dateOnlyMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (dateOnlyMatch) {
      const [, year, month, day] = dateOnlyMatch;
      const y = Number(year);
      const m = Number(month);
      const d = Number(day);
      if (Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(d)) {
        const parsed = new Date(y, m - 1, d);
        if (!Number.isNaN(parsed.getTime())) return parsed;
      }
      return null;
    }
    const parsed = new Date(trimmed);
    if (!Number.isNaN(parsed.getTime())) {
      return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
    }
    return null;
  }
  if (typeof value === 'number') {
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) {
      return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
    }
  }
  return null;
}

function formatAgeFromBirthDate(birthValue, referenceValue = new Date()) {
  const birthDate = normalizeDateOnly(birthValue);
  const referenceDate = normalizeDateOnly(referenceValue) || normalizeDateOnly(new Date());
  if (!birthDate || !referenceDate) return '';
  if (referenceDate < birthDate) return '';
  let years = referenceDate.getFullYear() - birthDate.getFullYear();
  const hasHadBirthday =
    referenceDate.getMonth() > birthDate.getMonth() ||
    (referenceDate.getMonth() === birthDate.getMonth() && referenceDate.getDate() >= birthDate.getDate());
  if (!hasHadBirthday) years -= 1;
  if (years > 1) return `${years} år`;
  if (years === 1) return '1 år';
  const totalMonths = (referenceDate.getFullYear() - birthDate.getFullYear()) * 12 + referenceDate.getMonth() - birthDate.getMonth();
  const adjustedMonths = hasHadBirthday ? totalMonths : totalMonths - 1;
  if (adjustedMonths > 1) return `${adjustedMonths} mdr`;
  if (adjustedMonths === 1) return '1 mdr';
  const diffMs = referenceDate.getTime() - birthDate.getTime();
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  if (diffDays > 1) return `${diffDays} dage`;
  if (diffDays === 1) return '1 dag';
  return '0 dage';
}

function translateGender(value) {
  if (value === null || value === undefined) return '';
  const text = String(value).trim();
  if (!text) return '';
  const normalized = text.toLowerCase();
  if (['male', 'mand', 'm'].includes(normalized)) return 'Mand';
  if (['female', 'kvinde', 'f'].includes(normalized)) return 'Kvinde';
  if (['other', 'andet'].includes(normalized)) return 'Andet';
  if (['unknown', 'ukendt'].includes(normalized)) return 'Uoplyst';
  return text;
}

class SimplePdfBuilder {
  constructor() {
    this.width = PDF_PAGE_WIDTH;
    this.height = PDF_PAGE_HEIGHT;
    this.margin = PDF_MARGIN;
    this.pages = [];
    this.images = [];
    this.currentPage = null;
  }
  startPage() {
    const page = {ops: [], imageNames: new Set()};
    this.pages.push(page);
    this.currentPage = page;
    return page;
  }
  ensurePage() {
    if (!this.currentPage) this.startPage();
  }
  addText(text, x, y, fontSize = PDF_BODY_FONT_SIZE, color = null) {
    this.ensurePage();
    const fill = pdfColorToRgb(color || PDF_TEXT_COLOR);
    const colorPart = fill ? `${fill} rg\n` : '';
    this.currentPage.ops.push(`BT\n${colorPart}/F1 ${fontSize.toFixed(2)} Tf\n1 0 0 1 ${x.toFixed(2)} ${y.toFixed(2)} Tm (${escapePdfText(text)}) Tj\nET`);
  }
  addLine(x1, y1, x2, y2, width = 1, color = null) {
    this.ensurePage();
    const stroke = pdfColorToRgb(color || PDF_ACCENT_COLOR);
    const colorPart = stroke ? `${stroke} RG ` : '';
    this.currentPage.ops.push(`q ${colorPart}${width.toFixed(2)} w ${x1.toFixed(2)} ${y1.toFixed(2)} m ${x2.toFixed(2)} ${y2.toFixed(2)} l S Q`);
  }
  fillRect(x, y, width, height, color = null) {
    this.ensurePage();
    const fill = pdfColorToRgb(color);
    const colorPart = fill ? `${fill} rg ` : '';
    this.currentPage.ops.push(`q ${colorPart}${x.toFixed(2)} ${y.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)} re f Q`);
  }
  strokeRect(x, y, width, height, lineWidth = 1, color = null) {
    this.ensurePage();
    const stroke = pdfColorToRgb(color || PDF_CARD_BORDER_COLOR);
    const colorPart = stroke ? `${stroke} RG ` : '';
    this.currentPage.ops.push(`q ${colorPart}${lineWidth.toFixed(2)} w ${x.toFixed(2)} ${y.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)} re S Q`);
  }
  registerImage(image) {
    const name = `Im${this.images.length + 1}`;
    this.images.push({...image, name});
    return name;
  }
  drawImage(name, x, y, width, height) {
    this.ensurePage();
    this.currentPage.imageNames.add(name);
    this.currentPage.ops.push(`q ${width.toFixed(2)} 0 0 ${height.toFixed(2)} ${x.toFixed(2)} ${y.toFixed(2)} cm /${name} Do Q`);
  }
  build() {
    if (!this.pages.length) this.startPage();
    const pageCount = this.pages.length;
    let pdf = '%PDF-1.4\n';
    const offsets = [0];
    const addObject = str => {
      offsets.push(pdf.length);
      pdf += str;
    };
    const kids = this.pages.map((_, idx) => `${3 + idx} 0 R`).join(' ');
    addObject('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
    addObject(`2 0 obj\n<< /Type /Pages /Count ${pageCount} /Kids [${kids}] >>\nendobj\n`);
    const fontObjNumber = 3 + pageCount * 2;
    const imageStart = fontObjNumber + 1;
    this.images.forEach((image, index) => {
      image.objectNumber = imageStart + index;
    });
    const contentObjects = [];
    this.pages.forEach((page, idx) => {
      const pageObjNumber = 3 + idx;
      const contentObjNumber = 3 + pageCount + idx;
      const resourceParts = [`/Font << /F1 ${fontObjNumber} 0 R >>`];
      if (page.imageNames.size) {
        const entries = [];
        page.imageNames.forEach(name => {
          const image = this.images.find(img => img.name === name);
          if (image) entries.push(`/${name} ${image.objectNumber} 0 R`);
        });
        if (entries.length) resourceParts.push(`/XObject << ${entries.join(' ')} >>`);
      }
      addObject(`${pageObjNumber} 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${this.width} ${this.height}] /Contents ${contentObjNumber} 0 R /Resources << ${resourceParts.join(' ')} >> >>\nendobj\n`);
      const content = page.ops.join('\n');
      contentObjects.push({number: contentObjNumber, content});
    });
    contentObjects.forEach(obj => {
      addObject(`${obj.number} 0 obj\n<< /Length ${obj.content.length} >>\nstream\n${obj.content}\nendstream\nendobj\n`);
    });
    addObject(`${fontObjNumber} 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica /Encoding /WinAnsiEncoding >>\nendobj\n`);
    this.images.forEach(image => {
      const filter = image.filter || '/DCTDecode';
      const colorSpace = image.colorSpace || '/DeviceRGB';
      addObject(`${image.objectNumber} 0 obj\n<< /Type /XObject /Subtype /Image /Width ${image.width} /Height ${image.height} /ColorSpace ${colorSpace} /BitsPerComponent ${image.bitsPerComponent || 8} /Filter ${filter} /Length ${image.dataString.length} >>\nstream\n${image.dataString}\nendstream\nendobj\n`);
    });
    const totalObjects = fontObjNumber + this.images.length;
    const xrefOffset = pdf.length;
    pdf += `xref\n0 ${totalObjects + 1}\n0000000000 65535 f \n`;
    for (let i = 1; i <= totalObjects; i++) {
      const offset = offsets[i] || 0;
      pdf += `${String(offset).padStart(10, '0')} 00000 n \n`;
    }
    pdf += `trailer\n<< /Size ${totalObjects + 1} /Root 1 0 R >>\nstartxref\n${xrefOffset}\n%%EOF`;
    return stringToPdfBytes(pdf);
  }
}

function bytesToBinaryString(bytes) {
  let result = '';
  for (let i = 0; i < bytes.length; i++) {
    result += String.fromCharCode(bytes[i]);
  }
  return result;
}

function base64ToUint8Array(base64) {
  const binary = atob(base64);
  const length = binary.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}

async function loadReportLogoImage() {
  if (loadReportLogoImage.cache !== undefined) {
    return loadReportLogoImage.cache;
  }
  try {
    const img = await new Promise((resolve, reject) => {
      const element = new Image();
      element.onload = () => resolve(element);
      element.onerror = reject;
      element.src = `logo.png?ts=${Date.now()}`;
    });
    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
    const base64 = dataUrl.split(',')[1];
    const bytes = base64ToUint8Array(base64);
    loadReportLogoImage.cache = {
      width: img.naturalWidth,
      height: img.naturalHeight,
      data: bytes,
      dataString: bytesToBinaryString(bytes),
      bitsPerComponent: 8,
      filter: '/DCTDecode',
      colorSpace: '/DeviceRGB'
    };
  } catch (err) {
    console.warn('Kunne ikke indlæse logo til PDF', err);
    loadReportLogoImage.cache = null;
  }
  return loadReportLogoImage.cache;
}

function drawReportHeader(builder, logo, exportedAt) {
  const margin = builder.margin;
  const pageHeight = builder.height;
  const headerBottom = pageHeight - margin - PDF_HEADER_BAND_HEIGHT;
  const titleBaseline = headerBottom + PDF_HEADER_TITLE_BASELINE_OFFSET;
  builder.fillRect(0, headerBottom, builder.width, PDF_HEADER_BAND_HEIGHT, PDF_HEADER_BAND_COLOR);
  let imageWidth = 0;
  let imageHeight = 0;
  if (logo) {
    if (!logo.objectName) {
      logo.objectName = builder.registerImage({
        width: logo.width,
        height: logo.height,
        dataString: logo.dataString,
        bitsPerComponent: logo.bitsPerComponent,
        filter: logo.filter,
        colorSpace: logo.colorSpace
      });
    }
    const maxHeaderImageHeight = PDF_HEADER_BAND_HEIGHT - 48;
    const targetHeight = Math.max(48, Math.min(68, maxHeaderImageHeight));
    const aspect = logo.width && logo.height ? logo.width / logo.height : 1;
    imageHeight = Math.min(targetHeight, Math.max(0, maxHeaderImageHeight));
    imageWidth = imageHeight * aspect;
    const imageY = headerBottom + PDF_HEADER_BAND_HEIGHT - imageHeight - 12;
    builder.drawImage(logo.objectName, margin, imageY, imageWidth, imageHeight);
  }
  const titleX = imageWidth ? margin + imageWidth + 28 : margin + PDF_SECTION_CARD_PADDING_X;
  builder.addText('Diagnostisk Rapport', titleX, titleBaseline, PDF_TITLE_FONT_SIZE, PDF_ACCENT_COLOR);
  const dateFormatter = drawReportHeader.dateFormatter || new Intl.DateTimeFormat('da-DK');
  drawReportHeader.dateFormatter = dateFormatter;
  const dateLabel = dateFormatter.format(exportedAt || new Date());
  const dateWidth = measurePdfTextWidth(dateLabel, 12);
  const dateX = builder.width - margin - dateWidth;
  builder.addText(dateLabel, dateX, titleBaseline, 12, PDF_MUTED_TEXT_COLOR);
  builder.addLine(margin, headerBottom + 8, builder.width - margin, headerBottom + 8, 1.1, PDF_ACCENT_COLOR);
  const contentStart = Math.min(titleBaseline - PDF_TITLE_LEADING, headerBottom - 12, pageHeight - margin - imageHeight - 42);
  return {contentTop: contentStart};
}

function measurePdfTextWidth(text, fontSize) {
  const ctx = getPdfMeasureContext(fontSize);
  if (!ctx) return String(text || '').length * fontSize * 0.5;
  return ctx.measureText(String(text || '')).width * (72 / 96);
}

function pdfValueIsBlank(value) {
  if (value === null || value === undefined) return true;
  if (typeof value === 'number') return false;
  if (typeof value === 'boolean') return false;
  if (value instanceof Date) return Number.isNaN(value.getTime());
  if (Array.isArray(value)) return value.length === 0;
  const text = collapseSpaces(value);
  return text === '';
}

function shouldRenderPdfRow(row) {
  if (!row || row.renderWhenEmpty) return true;
  switch (row.type) {
    case 'kv':
      return !pdfValueIsBlank(row.value);
    case 'paragraph':
      return !pdfValueIsBlank(row.value);
    case 'text':
      return collapseSpaces(row.text) !== '';
    case 'list':
      return Array.isArray(row.items) && row.items.some(item => collapseSpaces(item) !== '');
    default:
      return true;
  }
}

function buildSectionLayout(heading, rows, width) {
  const contentWidth = Math.max(10, width - PDF_SECTION_CARD_PADDING_X * 2);
  const layout = {
    heading,
    width,
    contentWidth,
    blocks: [],
    height: PDF_SECTION_CARD_PADDING_TOP + PDF_HEADING_TEXT_OFFSET + PDF_HEADING_LEADING + PDF_HEADING_GAP + PDF_SECTION_CARD_PADDING_BOTTOM + PDF_SECTION_SPACING
  };
  const sourceRows = Array.isArray(rows) ? rows : [];
  const renderRows = sourceRows.filter(shouldRenderPdfRow);
  renderRows.forEach((row, index) => {
    switch (row.type) {
      case 'kv': {
        const value = !pdfValueIsBlank(row.value) ? String(row.value) : row.fallback || '';
        if (!value) break;
        const text = `${row.label}: ${value}`;
        const lines = wrapPdfText(text, contentWidth, PDF_BODY_FONT_SIZE);
        layout.blocks.push({lines});
        layout.height += lines.length * PDF_BODY_LEADING;
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'paragraph': {
        const label = row.label ? `${row.label}:` : '';
        if (label) {
          const labelLines = wrapPdfText(label, contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines: labelLines});
          layout.height += labelLines.length * PDF_BODY_LEADING;
        }
        const hasBody = !pdfValueIsBlank(row.value);
        const bodyText = hasBody ? String(row.value) : (row.emptyText || '');
        if (!bodyText) break;
        const bodyLines = wrapPdfText(bodyText, contentWidth, PDF_BODY_FONT_SIZE);
        const indented = row.indent ? indentWrappedLines(bodyLines, row.indent) : bodyLines;
        layout.blocks.push({lines: indented});
        layout.height += indented.length * PDF_BODY_LEADING;
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'text': {
        const lines = wrapPdfText(row.text || '', contentWidth, PDF_BODY_FONT_SIZE);
        layout.blocks.push({lines});
        layout.height += lines.length * PDF_BODY_LEADING;
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'list': {
        const items = Array.isArray(row.items) ? row.items : [];
        if (!items.length) {
          const emptyLines = wrapPdfText(row.emptyText || 'Ingen poster.', contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines: emptyLines});
          layout.height += emptyLines.length * PDF_BODY_LEADING;
          if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
          break;
        }
        items.forEach((item, idx) => {
          const lines = wrapPdfText(item, contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines});
          layout.height += lines.length * PDF_BODY_LEADING;
          if (idx < items.length - 1) layout.height += PDF_ROW_SPACING / 2;
        });
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      default:
        break;
    }
  });
  return layout;
}

function renderSection(builder, column, section) {
  const startCursor = column.cursor;
  const bodyHeight = section.height - PDF_SECTION_SPACING;
  const cardBottom = startCursor - bodyHeight;
  const cardX = column.x - PDF_SECTION_CARD_INSET;
  const cardWidth = column.width + PDF_SECTION_CARD_INSET * 2;
  builder.fillRect(cardX, cardBottom, cardWidth, bodyHeight, PDF_CARD_BACKGROUND_COLOR);
  builder.strokeRect(cardX, cardBottom, cardWidth, bodyHeight, 0.8, PDF_CARD_BORDER_COLOR);
  const headingBaseline = startCursor - PDF_SECTION_CARD_PADDING_TOP;
  const baseHeadingBarBottom = Math.max(cardBottom, headingBaseline - (PDF_HEADING_FONT_SIZE + 2));
  const baseHeadingBarTop = Math.min(startCursor - 2, headingBaseline + PDF_SECTION_CARD_PADDING_TOP - 2);
  const headingBarBottom = baseHeadingBarBottom + PDF_HEADING_BAR_OFFSET;
  const headingBarTop = baseHeadingBarTop + PDF_HEADING_BAR_OFFSET;
  const headingFillHeight = headingBarTop - headingBarBottom;
  if (headingFillHeight > 0.1) {
    builder.fillRect(cardX, headingBarBottom, cardWidth, headingFillHeight, PDF_CARD_HEADING_COLOR);
  }
  let cursor = headingBaseline - PDF_HEADING_TEXT_OFFSET;
  const textX = column.x + PDF_SECTION_CARD_PADDING_X;
  builder.addText(section.heading, textX, cursor, PDF_HEADING_FONT_SIZE, PDF_HEADING_TEXT_COLOR);
  cursor -= (PDF_HEADING_LEADING + PDF_HEADING_GAP);
  section.blocks.forEach((block, idx) => {
    const lines = block.lines || [];
    lines.forEach(line => {
      builder.addText(line, textX, cursor, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
      cursor -= PDF_BODY_LEADING;
    });
    if (idx < section.blocks.length - 1) cursor -= PDF_ROW_SPACING;
  });
  cursor -= PDF_SECTION_CARD_PADDING_BOTTOM;
  cursor -= PDF_SECTION_SPACING;
  column.cursor = cursor;
}

function ensureSingleColumnSpace(builder, column, neededHeight, reserveBottom) {
  const bottomLimit = builder.margin + (reserveBottom || 0);
  if (column.cursor - neededHeight < bottomLimit) {
    const {logo, exportedAt} = ensureSingleColumnSpace;
    const header = startNewReportPage(builder, logo, exportedAt);
    column.cursor = header.contentTop;
  }
}

function startNewReportPage(builder, logo, exportedAt) {
  builder.startPage();
  return drawReportHeader(builder, logo, exportedAt);
}

async function createReportPdfBlob(orderId, reportData, exportedAt = new Date()) {
  try {
    const order = findById('orders', orderId);
    if (!order) return null;
    const patient = findById('patients', Number(order.patient_id));
    const sample = findById('samples', Number(order.sample_id));
    const panel = order?.panel_id ? findById('panels', Number(order.panel_id)) : null;
    const interpreterName = order?.interpreter_id ? getName('users', order.interpreter_id) : '';
    const approverName = order?.approver_id ? getName('users', order.approver_id) : '';
    const analysisResponsible = order?.analysis_responsible_id ? getName('users', order.analysis_responsible_id) : '';
    const clinician = order?.clinician || '';
    const patientGroupName = getPatientGroupName(order?.patient_group_id);
    const qcEntries = sample ? getCached('qc').filter(q => Number(q.sample_id) === Number(sample.id)) : [];
    let variants = getReportVariantSnapshots(reportData, orderId);
    if (!variants.length) {
      variants = getCached('variants').filter(v => Number(v.order_id) === Number(order.id)).map(snapshotVariant);
    }
    const builder = new SimplePdfBuilder();
    const logo = await loadReportLogoImage();
    const initialHeader = startNewReportPage(builder, logo, exportedAt);
    ensureSingleColumnSpace.logo = logo;
    ensureSingleColumnSpace.exportedAt = exportedAt;
    const columnWidth = (builder.width - builder.margin * 2 - PDF_GUTTER) / 2;
    const leftColumn = {x: builder.margin, width: columnWidth, cursor: initialHeader.contentTop};
    const rightColumn = {x: builder.margin + columnWidth + PDF_GUTTER, width: columnWidth, cursor: initialHeader.contentTop};
    const patientBirthDate = formatDanishDate(patient?.birth_date) || (patient?.birth_date || '');
    const patientRows = [
      {type: 'kv', label: 'Navn', value: patient?.name},
      {type: 'kv', label: 'MRN', value: patient?.mrn},
      {type: 'kv', label: 'ID', value: patient?.extra_id},
      {type: 'kv', label: 'Familienummer', value: patient?.family_number},
      {type: 'kv', label: 'Køn', value: translateGender(patient?.gender)},
      {type: 'kv', label: 'Fødselsdato', value: patientBirthDate}
    ];
    const sampleRows = [
      {type: 'kv', label: 'PMB-nummer', value: sample?.pmb_number},
      {type: 'kv', label: 'Prøvetype', value: sample?.sample_type},
      {type: 'kv', label: 'Status', value: sample?.status},
      {type: 'kv', label: 'Opsamlet', value: sample?.collected_at},
      {type: 'paragraph', label: 'Noter', value: sample?.notes, emptyText: 'Ingen noter.', indent: '  '}
    ];
    const orderIndicationText = collapseSpaces(order?.indication) ? order.indication : '';
    const analysisRows = [
      {type: 'kv', label: 'Panel', value: panel?.name},
      {type: 'kv', label: 'Analyseansvarlig', value: analysisResponsible},
      {type: 'kv', label: 'Rekvirent', value: clinician},
      {type: 'kv', label: 'Patientgruppe', value: patientGroupName, fallback: 'Ikke angivet'},
      {type: 'kv', label: 'Bestilt', value: order?.ordered_at},
      {type: 'paragraph', label: 'Indikation', value: orderIndicationText, emptyText: 'Ingen indikation angivet.'}
    ];
    const qcRows = [];
    if (qcEntries.length) {
      qcEntries.forEach((qc, index) => {
        const label = `${index + 1}. ${qc.metric}`;
        const unit = qc.unit ? ` ${qc.unit}` : '';
        const value = `${qc.value}${unit}`;
        const parts = [value];
        if (qc.notes) parts.push(`Noter: ${qc.notes}`);
        qcRows.push({type: 'paragraph', label, value: parts.join('\n'), indent: '  '});
      });
    } else {
      qcRows.push({type: 'text', text: 'Ingen registrerede kvalitetsmålinger.'});
    }
    const patientSection = buildSectionLayout('Patientoplysninger', patientRows, columnWidth);
    const analysisSection = buildSectionLayout('Analyse', analysisRows, columnWidth);
    const sampleSection = buildSectionLayout('Prøvedata', sampleRows, columnWidth);
    const qcSection = buildSectionLayout('Kvalitetsmålinger', qcRows, columnWidth);
    renderSection(builder, leftColumn, patientSection);
    renderSection(builder, rightColumn, sampleSection);
    renderSection(builder, leftColumn, analysisSection);
    renderSection(builder, rightColumn, qcSection);
    const singleColumn = {
      x: builder.margin,
      width: builder.width - builder.margin * 2,
      cursor: Math.min(leftColumn.cursor, rightColumn.cursor) - PDF_SECTION_SPACING
    };
    if (singleColumn.cursor < builder.margin + PDF_SIGNATURE_BLOCK_HEIGHT + 40) {
      const header = startNewReportPage(builder, logo, exportedAt);
      singleColumn.cursor = header.contentTop;
    }
    const fundRows = [];
    if (variants.length) {
      variants.forEach((variant, index) => {
        const heading = formatVariantTitle(variant) || `Variant ${variant.id ?? index + 1}`;
        const meta = [];
        const typeLabel = getVariantTypeLabel(variant.variant_type);
        if (typeLabel) meta.push(`Type: ${typeLabel}`);
        if (variant.transcript) meta.push(`Transkript: ${variant.transcript}`);
        if (variant.zygosity) meta.push(`Zygositet: ${variant.zygosity}`);
        if (variant.classification) meta.push(`Klasse: ${variant.classification}`);
        if (variant.criteria) meta.push(`ACMG: ${variant.criteria}`);
        if (variant.af !== undefined && variant.af !== null && variant.af !== '') meta.push(`AF: ${variant.af}`);
        const genomic = formatVariantGenomicRange(variant);
        if (genomic) meta.push(`Genomisk position: ${genomic}`);
        if (variant.copy_number) meta.push(`Kopital: ${variant.copy_number}`);
        if (variant.iscn) meta.push(`ISCN: ${variant.iscn}`);
        if (variant.affected_genes) meta.push(`Berørte gener: ${variant.affected_genes}`);
        if (variant.description) meta.push(`Beskrivelse: ${variant.description}`);
        if (variant.annotations) meta.push(`Annoteringer: ${variant.annotations}`);
        const bodyParts = [];
        if (meta.length) bodyParts.push(meta.join(' · '));
        if (variant.interpretation) bodyParts.push(variant.interpretation);
        fundRows.push({
          type: 'paragraph',
          label: `${index + 1}. ${heading}`,
          value: bodyParts.join('\n\n'),
          emptyText: 'Ingen detaljer angivet.',
          indent: '  ',
          renderWhenEmpty: true
        });
      });
    } else {
      fundRows.push({type: 'text', text: 'Ingen registrerede varianter.'});
    }
    const fundSection = buildSectionLayout('Fund', fundRows, singleColumn.width);
    const conclusionText = reportData.summary || '';
    const conclusionRows = [
      conclusionText ? {type: 'text', text: conclusionText} : {type: 'text', text: 'Ingen konklusion angivet.'}
    ];
    const conclusionSection = buildSectionLayout('Konklusion', conclusionRows, singleColumn.width);
    const singleSections = [fundSection, conclusionSection];
    singleSections.forEach((section, index) => {
      const remaining = singleSections.slice(index + 1).reduce((sum, item) => sum + item.height, 0);
      const reserve = remaining + PDF_SIGNATURE_BLOCK_HEIGHT + 20;
      ensureSingleColumnSpace(builder, singleColumn, section.height, reserve);
      renderSection(builder, singleColumn, section);
    });
    ensureSingleColumnSpace(builder, singleColumn, PDF_SIGNATURE_BLOCK_HEIGHT, 0);
    const signatureBottom = builder.margin;
    const signatureHeight = PDF_SIGNATURE_BLOCK_HEIGHT;
    const signatureX = builder.margin - PDF_SECTION_CARD_INSET;
    const signatureWidth = builder.width - 2 * builder.margin + PDF_SECTION_CARD_INSET * 2;
    builder.fillRect(signatureX, signatureBottom, signatureWidth, signatureHeight, PDF_SIGNATURE_BAND_COLOR);
    builder.strokeRect(signatureX, signatureBottom, signatureWidth, signatureHeight, 0.8, PDF_CARD_BORDER_COLOR);
    const signatureHeadingY = signatureBottom + signatureHeight - 18;
    const signatureTextX = singleColumn.x + PDF_SECTION_CARD_PADDING_X;
    builder.addText('Signering', signatureTextX, signatureHeadingY, PDF_HEADING_FONT_SIZE, PDF_HEADING_TEXT_COLOR);
    const signatureInnerWidth = singleColumn.width - PDF_SECTION_CARD_PADDING_X * 2;
    const signatureLineY = signatureBottom + 40;
    const firstLineStart = signatureTextX;
    const midPoint = signatureTextX + signatureInnerWidth / 2;
    const gap = 24;
    let firstLineEnd = midPoint - gap;
    if (firstLineEnd - firstLineStart < 80) firstLineEnd = firstLineStart + 80;
    firstLineEnd = Math.min(firstLineEnd, midPoint - 6);
    let secondLineStart = midPoint + gap;
    if (secondLineStart < firstLineEnd + 24) {
      secondLineStart = firstLineEnd + 24;
    }
    let secondLineEnd = signatureTextX + signatureInnerWidth;
    if (secondLineEnd - secondLineStart < 80) {
      secondLineStart = Math.max(secondLineEnd - 80, secondLineStart);
    }
    builder.addLine(firstLineStart, signatureLineY, firstLineEnd, signatureLineY, 1, PDF_SIGNATURE_LINE_COLOR);
    builder.addText(`Tolker: ${interpreterName || 'Ikke angivet'}`, firstLineStart, signatureLineY + 24, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
    builder.addLine(secondLineStart, signatureLineY, secondLineEnd, signatureLineY, 1, PDF_SIGNATURE_LINE_COLOR);
    builder.addText(`Godkender: ${approverName || 'Ikke angivet'}`, secondLineStart, signatureLineY + 24, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
    const bytes = builder.build();
    return new Blob([bytes], {type: 'application/pdf'});
  } catch (err) {
    console.error('Kunne ikke generere PDF for rapporten', err);
    return null;
  }
}

function sanitizeFilenameComponent(value) {
  if (!value) return 'ukendt';
  return String(value).trim().replace(/[^0-9A-Za-zÆØÅæøå_-]+/g, '_') || 'ukendt';
}

function buildReportPdfFilename(orderId, reportData, exportedAt = new Date()) {
  const order = findById('orders', Number(orderId));
  const patient = order ? findById('patients', Number(order?.patient_id)) : null;
  const mrnPart = sanitizeFilenameComponent(patient?.mrn || patient?.extra_id || patient?.cpr || 'ukendt');
  const dateStamp = exportedAt.toISOString().slice(0, 10).replace(/-/g, '');
  return `${mrnPart}_Diagnostisk_Rapport_${dateStamp}.pdf`;
}
function renderQC(section) {
  const list = getCached('qc');
  const samples = getCached('samples');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="qcSearch">Søg</label>
        <input id="qcSearch" type="search" placeholder="Måling...">
        <label class="list-toggle"><input type="checkbox" id="qcActiveOnly" checked> Vis kun aktive</label>
        <table><thead><tr><th>ID</th><th>Prøve</th><th>Måling</th><th>Værdi</th><th>Enhed</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
      </div>
      <div>
        <h2>Kvalitetsmåling</h2>
        <form id="qcForm">
          <input type="hidden" name="id">
          <label>Prøve
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer prøver">
              <select name="sample_id" required>
                <option value="" selected>Vælg prøve</option>
                ${samples.map(s => `<option value="${s.id}">${s.id} (${esc(s.pmb_number||'–')}) – ${esc(getName('patients', s.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Måling<input name="metric" required></label>
          <label>Værdi<input name="value" type="number" step="0.0001" required></label>
          <label>Enhed<input name="unit"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="qcClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="qcDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#qcSearch');
  const form = section.querySelector('#qcForm');
  const activeToggle = section.querySelector('#qcActiveOnly');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  const sampleMap = new Map(samples.map(s => [Number(s.id), s]));
  let selectedQcId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  const renderRows = () => {
    const term = search.value.trim().toLowerCase();
    const filteredQc = list.filter(q => {
      const sample = sampleMap.get(Number(q.sample_id));
      const sampleStatus = sample?.status || '';
      if (showActiveOnly && sampleStatus && !isActiveStatus(sampleStatus)) return false;
      if (!term) return true;
      const creator = determineCreatedBy('qc', q);
      return [
        q.metric,
        q.unit,
        q.notes,
        creator,
        q.sample_id,
        sample?.pmb_number,
        sample?.sample_type,
        sampleStatus
      ].some(v => String(v ?? '').toLowerCase().includes(term));
    });
    if (selectedQcId != null && !filteredQc.some(q => q.id === selectedQcId)) {
      selectedQcId = null;
    }
    tbody.innerHTML = filteredQc.map(q => {
      const createdBy = determineCreatedBy('qc', q);
      const sample = sampleMap.get(Number(q.sample_id));
      const sampleStatus = sample?.status || '';
      const sampleLabel = getName('samples', Number(q.sample_id));
      const sampleDisplay = sampleLabel || (q.sample_id != null ? `#${q.sample_id}` : '');
      const sampleStatusMeta = sampleStatus && !isActiveStatus(sampleStatus)
        ? ` <span class="table-meta">(${esc(sampleStatus)})</span>`
        : '';
      const selectedAttr = q.id === selectedQcId ? ' data-selected="true"' : '';
      return `<tr data-id="${q.id}"${selectedAttr}><td>${q.id}</td><td>${esc(sampleDisplay)}${sampleStatusMeta}</td><td>${esc(q.metric)}</td><td>${esc(q.value)}</td><td>${esc(q.unit||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const qc = list.find(q => q.id === Number(tr.dataset.id));
    if (!qc) return;
    selectedQcId = qc.id;
    fillForm(form, qc);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('qc')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.sample_id = Number(data.sample_id);
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('qc', id)};
      const updated = {...before, ...data, id};
      await updateRecord('qc', updated, before);
    } else {
      delete data.id;
      await addRecord('qc', data);
    }
    await loadStore('qc');
    renderTab('qc');
  });
  section.querySelector('#qcDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg QC-post');
    if (!ensureWrite('qc')) return;
    if (confirm('Slet QC-post?')) {
      await deleteRecord('qc', id);
      renderTab('qc');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedQcId = null;
    renderRows();
  });
  section.querySelector('#qcClear').addEventListener('click', () => form.reset());
}

function renderTools(section) {
  const STRENGTH_DEFINITIONS = {
    pathogenic: {
      veryStrong: {label: 'Meget stærk (+8)', summary: 'meget stærk', weight: 8},
      strong: {label: 'Stærk (+4)', summary: 'stærk', weight: 4},
      moderate: {label: 'Moderat (+2)', summary: 'moderat', weight: 2},
      supporting: {label: 'Supporting (+1)', summary: 'supporting', weight: 1}
    },
    benign: {
      standAlone: {label: 'Stand-alone (–8)', summary: 'stand-alone', weight: -8},
      strong: {label: 'Stærk (–4)', summary: 'stærk', weight: -4},
      supporting: {label: 'Supporting (–1)', summary: 'supporting', weight: -1}
    }
  };
  const DEFAULT_STRENGTH_ORDER = {
    pathogenic: ['veryStrong', 'strong', 'moderate', 'supporting'],
    benign: ['standAlone', 'strong', 'supporting']
  };
  const pathogenicCriteria = [
    {code: 'PVS1', label: 'Loss-of-function variant i gen hvor loss-of-function er kendt sygdomsmekanisme.', defaultStrength: 'veryStrong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Nedgrader ved usikker LoF-effekt (fx initierende exon, alternativ splejsning).', strengthGuidance: {veryStrong: 'Meget stærk når varianten forventes at udløse nonsense mediated decay eller tydelig truncering i et gen hvor loss-of-function er veletableret sygdomsmekanisme uden kendte undtagelser.', strong: 'Stærk når LoF-effekten er sandsynlig men placeret i sidste exon eller når redundans reducerer forventet fuld tabsfunktion.', moderate: 'Moderat når LoF kun delvist understøttes af modeller eller når alternative transkripter kan bevare funktion.', supporting: 'Supporting når LoF kun indikeres af indirekte data og yderligere bevis er nødvendigt for højere styrke.'}},
    {code: 'PS1', label: 'Samme aminosyreændring som kendt patogen variant uden ændret nukleotid.', defaultStrength: 'strong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Overvej styrkejustering når evidens for ækvivalens er begrænset eller stærkere end reference.', strengthGuidance: {veryStrong: 'Meget stærk når ækvivalente aminosyreændringer har omfattende klinisk dokumentation og funktionelle studier der klart viser patogenicitet.', strong: 'Stærk når referencevarianten er kurateret patogen og ækvivalensen er veldokumenteret.', moderate: 'Moderat når referencevarianten kun er sandsynligvis patogen eller dokumentationen for samme mekanisme er begrænset.', supporting: 'Supporting når ligheden primært bygger på in silico vurdering eller enkelte rapporter.'}},
    {code: 'PS2', label: 'De novo (bekræftet) hos patient med sund(e) forælder(e).', defaultStrength: 'strong', strengths: ['strong', 'moderate', 'supporting'], description: 'Kræver verifikation af forældres status. Nedgrader ved begrænset test eller phenotypematch.', strengthGuidance: {strong: 'Stærk når de novo-status er bekræftet med forældretest og fænotypen er stærkt forenelig.', moderate: 'Moderat når kun en forælder er testet, eller når fænotypen er delvist konsistent.', supporting: 'Supporting når de novo-mistanken bygger på familiesygehistorie uden fuld laboratoriebekræftelse.'}},
    {code: 'PS3', label: 'Funktionelle studier viser skadelig effekt.', defaultStrength: 'strong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Justér efter kvalitet og sygdomsrelevans af den funktionelle evidens.', strengthGuidance: {veryStrong: 'Meget stærk når validerede sygdomsrelevante assays reproducerbart demonstrerer alvorligt tab af funktion.', strong: 'Stærk når robuste funktionelle studier viser klar patologisk effekt i passende modeller.', moderate: 'Moderat når assays viser effekt men har begrænsninger i validering eller sygdomsrelevans.', supporting: 'Supporting når data kommer fra explorative modeller eller enkeltstående resultater.'}},
    {code: 'PS4', label: 'Signifikant øget forekomst i syge kontra kontroller.', defaultStrength: 'strong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Styrke afhænger af størrelsen på kohorter og statistisk signifikans.', strengthGuidance: {veryStrong: 'Meget stærk ved store uafhængige kohorter med odds ratio over ca. 10 og stringente kontroller.', strong: 'Stærk når case-control-data viser signifikant berigelse med passende korrigering for multiple test.', moderate: 'Moderat når kohorten er mindre eller odds ratio ligger omkring 5 med konsistente data.', supporting: 'Supporting ved begrænset men signifikant berigelse eller meta-analyser med moderate effekter.'}},
    {code: 'PM1', label: 'Hotspot/domæne uden godartede variationer.', defaultStrength: 'moderate', strengths: ['strong', 'moderate', 'supporting'], description: 'Opjuster ved veletablerede hotspots; nedgrader ved begrænset domænedata.', strengthGuidance: {strong: 'Stærk når varianten sidder i et veldefineret funktionelt hotspot med mange uafhængige patogene fund og fravær af godartede varianter.', moderate: 'Moderat for dokumenteret kritiske domæner med få godartede observationer.', supporting: 'Supporting når domænet antages vigtigt men evidensen for hotspot-status er begrænset.'}},
    {code: 'PM2', label: 'Fraværende eller ekstremt lav frekvens i kontroller.', defaultStrength: 'moderate', strengths: ['moderate', 'supporting'], description: 'Opdater med populationsdatabaser; nedgrader hvis sparsom dækning eller blandede populationer.', strengthGuidance: {moderate: 'Moderat når varianten er fraværende eller under forventet frekvens i store populationer med tilstrækkelig dækning.', supporting: 'Supporting når populationstallene er små eller når variantens fravær kun vises i enkelte datasæt.'}},
    {code: 'PM3', label: 'Påvist i trans med patogen variant i recessiv sygdom.', defaultStrength: 'moderate', strengths: ['strong', 'moderate', 'supporting'], description: 'Opjuster ved flere uafhængige observationer; kræver kendt patogen partner-variant.', strengthGuidance: {strong: 'Stærk ved flere uafhængige observationer i trans med velkarakteriserede patogene varianter eller dokumenteret compound heterozygoti.', moderate: 'Moderat når observationen er begrænset til få familier men med sikker fasebestemmelse.', supporting: 'Supporting når fase er antaget i stedet for bevist eller når partner-varianten er sandsynligvis patogen.'}},
    {code: 'PM4', label: 'Proteinaltering der påvirker læseramme eller stopper protein.', defaultStrength: 'moderate', strengths: ['strong', 'moderate', 'supporting'], description: 'Ekskluderer velkarakteriserede LoF-gen undtagelser; overvej nedgradering ved in-frame ændringer.', strengthGuidance: {strong: 'Stærk når ændringen giver trunkering før kritiske domæner uden forventet NMD-redning.', moderate: 'Moderat for in-frame deletioner/indsættelser eller truncering nær C-terminus hvor effekt er sandsynlig.', supporting: 'Supporting når strukturel påvirkning er usikker men proteinændringen er forenelig med funktionstab.'}},
    {code: 'PM5', label: 'Ny missense på samme aminosyre som anden patogen variant.', defaultStrength: 'moderate', strengths: ['moderate', 'supporting'], description: 'Forudsætter samme sygdomsmekanisme som den kendte variant; nedgrader hvis evidens er svag.', strengthGuidance: {moderate: 'Moderat når en anden nukleotidændring på samme kodon er velunderbygget patogen og mekanismen deles.', supporting: 'Supporting når referencevarianten kun er sandsynligvis patogen eller når mekanismen kan variere.'}},
    {code: 'PM6', label: 'De novo (uformelt) uden bekræftede forældre.', defaultStrength: 'moderate', strengths: ['moderate', 'supporting'], description: 'Nedgrader hvis fænotypen er mindre specifik eller forældrestatus er usikker.', strengthGuidance: {moderate: 'Moderat når de novo-status understøttes af kliniske oplysninger men genetisk test af forældre mangler.', supporting: 'Supporting når mistanken om de novo stammer fra familiehistorik eller når kun en forælder er testet.'}},
    {code: 'PP1', label: 'Segregerer med sygdommen i familien.', defaultStrength: 'supporting', strengths: ['strong', 'moderate', 'supporting'], description: 'Opgrader ved robuste LOD-beregninger; nedgrader ved få informative meioser.', strengthGuidance: {strong: 'Stærk når kombineret LOD-score er over 3 eller når flere uafhængige familier viser overbevisende segregering.', moderate: 'Moderat når LOD-score er mellem cirka 1,5 og 3 eller få men informative meioser foreligger.', supporting: 'Supporting når segregeringen ses i begrænset antal familier uden formel LOD-beregning.'}},
    {code: 'PP2', label: 'Missense i gen hvor missense er hyppig sygdomsmekanisme.', defaultStrength: 'supporting', strengths: ['moderate', 'supporting'], description: 'Kræver lav forekomst af godartede missense-varianter og LoF-dominans fraværende.', strengthGuidance: {moderate: 'Moderat når genets sygdomsmekanisme stærkt favoriserer missense-varianter og godartede missense er sjældne.', supporting: 'Supporting når data tyder på missense-sårbarhed men referencegrundlaget er begrænset.'}},
    {code: 'PP3', label: 'In silico-støtte for skadelig effekt.', defaultStrength: 'supporting', strengths: ['moderate', 'supporting'], description: 'Vurder konsistens mellem flere algoritmer; undgå brug når modeller er uenige.', strengthGuidance: {moderate: 'Moderat når flere orthogonale algoritmer og konservationsdata er samstemmende om skadelig effekt.', supporting: 'Supporting når de fleste modeller peger på skade men enkelte kilder er usikre.'}},
    {code: 'PP4', label: 'Fænotype/specifik sygdom i tråd med genet.', defaultStrength: 'supporting', strengths: ['moderate', 'supporting'], description: 'Kræver høj specificitet i fænotypen; opgrader ved veldefinerede syndromer.', strengthGuidance: {moderate: 'Moderat når patientens fænotype er højt specifik for genet eller når flere tilfælde matcher samme syndrom.', supporting: 'Supporting ved delvis overlap mellem fænotype og kendt spektrum eller når differentialdiagnoser er mulige.'}},
    {code: 'PP5', label: 'Anført som patogen af velrenommeret kilde.', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Bruges kun når kilden dokumenterer evidens og er uafhængig.', strengthGuidance: {supporting: 'Supporting når en uafhængig klinisk laboratorierapport giver transparent dokumentation for patogenicitet.'}}
  ];
  const benignCriteria = [
    {code: 'BA1', label: 'Allelfrekvens >5 % i kontroller (stand-alone).', effect: 'benign', defaultStrength: 'standAlone', strengths: ['standAlone', 'strong', 'supporting'], description: 'Kræver tilstrækkelig populationsrepræsentation og passende sygdomsprævalens.', strengthGuidance: {standAlone: 'Stand-alone når frekvensen overstiger 5 procent i en velrepræsenteret population og klart er uforenelig med sygdommens forekomst.', strong: 'Stærk når frekvensen ligger over maksimal forventet for sygdommen efter justering for penetrans men under stand-alone tærsklen.', supporting: 'Supporting når frekvensen er højere end forventet men datasættet er lille eller populationsrelevantheden begrænset.'}},
    {code: 'BS1', label: 'Allelfrekvens større end forventet for lidelsen.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Justér efter penetrans og genetisk heterogenitet.', strengthGuidance: {strong: 'Stærk når beregnet maksimumsfrekvens klart overskrides i flere populationer med god dækning.', supporting: 'Supporting når frekvensen kun svagt overstiger forventet eller når enkelte populationsdatasæt driver signalet.'}},
    {code: 'BS2', label: 'Observeret hos sund homozygot/hemizygot.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Kræver veldokumenteret fænotype og eksklusion af alder-afhængig debut.', strengthGuidance: {strong: 'Stærk når flere voksne uden sygdom er dokumenteret homozygote eller hemizygote med passende klinisk opfølgning.', supporting: 'Supporting når observationen er enkeltstående eller når opfølgningen er begrænset.'}},
    {code: 'BS3', label: 'Funktionelle studier viser ingen skadelig effekt.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Vurder assayets robusthed; nedgrader ved begrænset sygdomsrelevans.', strengthGuidance: {strong: 'Stærk når validerede sygdomsrelevante assays konsekvent viser normal funktion.', supporting: 'Supporting når assays er mindre validerede eller når resultaterne kun delvist understøtter normal funktion.'}},
    {code: 'BS4', label: 'Mangel på segregering med sygdommen.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Kræver flere informative familier; nedgrader ved mulige fenokopier.', strengthGuidance: {strong: 'Stærk når varianten ikke segregerer i flere informative familier med klare sygdomsdefinitioner.', supporting: 'Supporting når brudt segregering ses i begrænsede familier eller når fenokopier ikke kan udelukkes.'}},
    {code: 'BP1', label: 'Missense i gen hvor loss-of-function er dominerende mekanisme.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Anvendes når missense sjældent er sygdomsfremkaldende i genet.', strengthGuidance: {supporting: 'Supporting når genets kendte patogene variationer primært er loss-of-function og missense sjældent giver sygdom.'}},
    {code: 'BP2', label: 'Observeret sammen med patogen variant for dominant sygdom.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Forudsætter sikre fasedata og veldokumenteret patogen partner.', strengthGuidance: {supporting: 'Supporting når varianten findes i trans eller cis med uafhængigt patogen variant i dominant tilstand og patienten er rask.'}},
    {code: 'BP3', label: 'In-frame indel i repetitiv region uden kendt funktion.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Anvendes når indel ikke forventes at påvirke proteinfunktionen.', strengthGuidance: {supporting: 'Supporting når ændringen ligger i repetitivt motiv uden bevaret funktion og lignende variation er hyppig i raske populationer.'}},
    {code: 'BP4', label: 'In silico understøtter benign effekt.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Kræver samstemmende modeller for neutral effekt.', strengthGuidance: {supporting: 'Supporting når flere uafhængige algoritmer og konservationsdata peger på neutral eller tolerant effekt.'}},
    {code: 'BP5', label: 'Variant forklarer alternativ diagnose.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Kræver veldokumenteret alternativ årsag til fænotypen.', strengthGuidance: {supporting: 'Supporting når patientens fænotype forklares af en anden evidensbaseret genetisk diagnose og varianten er i linkage.'}},
    {code: 'BP6', label: 'Anført som godartet af velrenommeret kilde.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Brug kun når kilde dokumenterer bevis for benignitet.', strengthGuidance: {supporting: 'Supporting når et akkrediteret laboratorie eller database dokumenterer benignitet med sporbar evidens.'}},
    {code: 'BP7', label: 'Synonym variant uden splice-påvirkning.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Kræver fravær af spliceeffekt i relevante modeller.', strengthGuidance: {supporting: 'Supporting når splice-site analyser og funktionelle data viser uændret splejsning og ingen påvirkning af regulerende elementer.'}}
  ];
  const SNP_REFERENCE_BASELINE = 2.05; // Tidligere arrays (~2,05 i nordeuropæiske kohorter)
  const WGS_TARGET_BASELINE = 1.62;   // WGS-observation: "lige over 1,6" het/hom i nordeuropæiske patienter
  const WGS_BASELINE_FACTOR = WGS_TARGET_BASELINE / SNP_REFERENCE_BASELINE;
  const scaleWgsBaseline = baseline => Number((baseline * WGS_BASELINE_FACTOR).toFixed(3));
  const consanguinityProfiles = [
    {
      value: 'generic',
      label: 'Ukendt/blandet (global baseline)',
      snpBaseline: 2.0,
      wgsBaseline: scaleWgsBaseline(2.0),
      note: 'Generisk baseline; vælg WGS for helgenomdata eller SNP for ældre array-profiler.',
      defaultSelected: true
    },
    {
      value: 'northern_europe',
      label: 'Nordeuropæisk/Skandinavisk',
      snpBaseline: 2.05,
      wgsBaseline: scaleWgsBaseline(2.05),
      note: 'Kalibreret til helgenomsekventering; skandinaviske patienter viser het/hom ≈ 1,62 (≈62 % heterozygote).'
    },
    {
      value: 'southern_europe_middle_east',
      label: 'Sydeuropæisk/Mellemøstlig',
      snpBaseline: 1.85,
      wgsBaseline: scaleWgsBaseline(1.85),
      note: 'Historisk øget beslægtethed med WGS-justeret forventet het/hom omkring 1,4.'
    },
    {
      value: 'south_asia',
      label: 'Sydasiatisk',
      snpBaseline: 1.7,
      wgsBaseline: scaleWgsBaseline(1.7),
      note: 'Populationsstudier rapporterer lavere heterozygositet; WGS-justeret baseline ~1,3.'
    },
    {
      value: 'east_asia',
      label: 'Østasiatisk',
      snpBaseline: 1.95,
      wgsBaseline: scaleWgsBaseline(1.95),
      note: 'Store urbaniserede populationer med moderat heterozygositet; WGS-justeret baseline ~1,5.'
    },
    {
      value: 'sub_saharan_africa',
      label: 'Subsaharisk Afrika',
      snpBaseline: 2.3,
      wgsBaseline: scaleWgsBaseline(2.3),
      note: 'Høj genetisk diversitet; WGS viser het/hom omkring 1,8 for outbred kohorter.'
    },
    {
      value: 'americas',
      label: 'Latinamerikansk/admixed',
      snpBaseline: 2.0,
      wgsBaseline: scaleWgsBaseline(2.0),
      note: 'Stor variation – baseline sat til WGS-justeret global gennemsnitsværdi (~1,6).'
    }
  ];
  const consanguinityCategories = [
    {minF: 0.1875, title: 'Forælder-barn eller fulde søskende', detail: 'Typisk F≈25 % (1. grads slægtskab).', pedigree: 'parentChild'},
    {minF: 0.09375, title: 'Halvsøskende / onkel-niece / tante-nevø', detail: 'Typisk F≈12,5 % (1½. grad).', pedigree: 'avuncular'},
    {minF: 0.046875, title: 'Fætter/kusine (første)', detail: 'Typisk F≈6,25 % (2. grad).', pedigree: 'firstCousin'},
    {minF: 0.0234375, title: 'Fætter/kusine én gang fjernet', detail: 'Typisk F≈3,1 % (2½.–3. grad).', pedigree: 'cousinOnceRemoved'},
    {minF: 0.01171875, title: 'Anden fætter/kusine', detail: 'Typisk F≈1,6 % (3. grad).', pedigree: 'secondCousin'},
    {minF: 0.005, title: 'Fjern beslægtning (≥3.-4. led)', detail: 'Typisk F≈0,5–1 %.', pedigree: 'distant'}
  ];
  const renderPedigreeNode = (x, y, label, note = '', options = {}) => {
    const width = Number(options.width ?? 44);
    const height = Number(options.height ?? 26);
    const xPos = (x - width / 2).toFixed(1);
    const yPos = (y - height / 2).toFixed(1);
    const classes = ['pedigree-node'];
    if (options.proband) classes.push('proband');
    const nameClasses = ['pedigree-label', 'name'];
    if (options.proband) nameClasses.push('proband');
    const labelY = (y + 4).toFixed(1);
    const noteY = (y + height / 2 + 9).toFixed(1);
    return `
      <rect class="${classes.join(' ')}" x="${xPos}" y="${yPos}" width="${width.toFixed(1)}" height="${height.toFixed(1)}" rx="6" ry="6"></rect>
      <text class="${nameClasses.join(' ')}" x="${x.toFixed(1)}" y="${labelY}">${esc(label)}</text>
      ${note ? `<text class="pedigree-label" x="${x.toFixed(1)}" y="${noteY}">${esc(note)}</text>` : ''}
    `;
  };
  const renderPedigreeLine = (x1, y1, x2, y2, extraClass = '') => `
    <line class="pedigree-link${extraClass ? ' ' + extraClass : ''}" x1="${x1.toFixed(1)}" y1="${y1.toFixed(1)}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}"></line>
  `;
  const consanguinityPedigreeTemplates = {
    parentChild: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 51, 120, 51),
        renderPedigreeLine(120, 51, 120, 81),
        renderPedigreeLine(120, 81, 150, 81),
        renderPedigreeLine(70, 51, 70, 126),
        renderPedigreeLine(150, 107, 150, 126),
        renderPedigreeLine(70, 126, 150, 126),
        renderPedigreeLine(110, 126, 110, 137)
      ];
      const nodes = [
        renderPedigreeNode(70, 38, 'Forælder A', '(ældre generation)'),
        renderPedigreeNode(150, 94, 'Forælder B', '(barn af A)'),
        renderPedigreeNode(110, 150, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 220 190',
        title: `Stamtræ – ${relationText}`,
        desc: 'Illustration af et forælder-barn-forhold; fulde søskende giver tilsvarende F.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    avuncular: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 41, 150, 41),
        renderPedigreeLine(110, 41, 110, 54),
        renderPedigreeLine(70, 54, 150, 54),
        renderPedigreeLine(70, 54, 70, 60),
        renderPedigreeLine(150, 54, 150, 60),
        renderPedigreeLine(70, 85, 70, 105),
        renderPedigreeLine(150, 85, 150, 131),
        renderPedigreeLine(70, 131, 150, 131),
        renderPedigreeLine(110, 131, 110, 149)
      ];
      const nodes = [
        renderPedigreeNode(70, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(150, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(70, 72, 'Forælder A', '(søskende)'),
        renderPedigreeNode(150, 72, 'Onkel/tante', '(søskende)'),
        renderPedigreeNode(70, 118, 'Forælder B', '(barn af A)'),
        renderPedigreeNode(110, 162, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 220 200',
        title: `Stamtræ – ${relationText}`,
        desc: 'Skitsen viser et onkel/niece-forhold; halvsøskende følger samme logik.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    firstCousin: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 41, 170, 41),
        renderPedigreeLine(120, 41, 120, 56),
        renderPedigreeLine(70, 56, 170, 56),
        renderPedigreeLine(70, 56, 70, 60),
        renderPedigreeLine(170, 56, 170, 60),
        renderPedigreeLine(70, 84, 70, 106),
        renderPedigreeLine(170, 84, 170, 106),
        renderPedigreeLine(70, 130, 170, 130),
        renderPedigreeLine(120, 130, 120, 146)
      ];
      const nodes = [
        renderPedigreeNode(70, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(170, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(70, 72, 'Forælder A', '(søskende)'),
        renderPedigreeNode(170, 72, 'Forælder B', '(søskende)'),
        renderPedigreeNode(70, 118, 'Forælder 1', '(barn af A)'),
        renderPedigreeNode(170, 118, 'Forælder 2', '(barn af B)'),
        renderPedigreeNode(120, 158, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 240 200',
        title: `Stamtræ – ${relationText}`,
        desc: 'Første fætre/kusiner får et barn – probanden er markeret nederst.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    cousinOnceRemoved: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 37, 170, 37),
        renderPedigreeLine(120, 37, 120, 48),
        renderPedigreeLine(70, 48, 170, 48),
        renderPedigreeLine(70, 48, 70, 52),
        renderPedigreeLine(170, 48, 170, 52),
        renderPedigreeLine(70, 76, 70, 94),
        renderPedigreeLine(170, 76, 170, 94),
        renderPedigreeLine(170, 118, 170, 132),
        renderPedigreeLine(70, 117, 70, 157),
        renderPedigreeLine(70, 157, 170, 157),
        renderPedigreeLine(120, 157, 120, 167)
      ];
      const nodes = [
        renderPedigreeNode(70, 24, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(170, 24, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(70, 64, 'Forælder A', '(søskende)'),
        renderPedigreeNode(170, 64, 'Forælder B', '(søskende)'),
        renderPedigreeNode(70, 102, 'Forælder 1', '(barn af A)'),
        renderPedigreeNode(170, 102, 'Fætter', '(barn af B)'),
        renderPedigreeNode(170, 140, 'Forælder 2', '(barn af fætter)'),
        renderPedigreeNode(120, 178, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 240 210',
        title: `Stamtræ – ${relationText}`,
        desc: 'Et første fætter/kusine-forhold med én generations forskydning.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    secondCousin: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(60, 37, 160, 37),
        renderPedigreeLine(110, 37, 110, 48),
        renderPedigreeLine(60, 48, 160, 48),
        renderPedigreeLine(60, 48, 60, 51),
        renderPedigreeLine(160, 48, 160, 51),
        renderPedigreeLine(60, 77, 60, 91),
        renderPedigreeLine(160, 77, 160, 91),
        renderPedigreeLine(60, 117, 60, 131),
        renderPedigreeLine(160, 117, 160, 131),
        renderPedigreeLine(60, 157, 160, 157),
        renderPedigreeLine(110, 157, 110, 167)
      ];
      const nodes = [
        renderPedigreeNode(60, 24, 'Oldeforælder', '(fælles)'),
        renderPedigreeNode(160, 24, 'Oldeforælder', '(fælles)'),
        renderPedigreeNode(60, 64, 'Bedsteforælder A', '(søskende)'),
        renderPedigreeNode(160, 64, 'Bedsteforælder B', '(søskende)'),
        renderPedigreeNode(60, 104, 'Forælder A', '(barn af A)'),
        renderPedigreeNode(160, 104, 'Forælder B', '(barn af B)'),
        renderPedigreeNode(60, 144, 'Forælder 1', '(barnebarn af A)'),
        renderPedigreeNode(160, 144, 'Forælder 2', '(barnebarn af B)'),
        renderPedigreeNode(110, 180, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 240 210',
        title: `Stamtræ – ${relationText}`,
        desc: 'Andet fætre/kusiner deler oldeforældre; probanden er nederst.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    distant: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(110, 34, 110, 58, 'distant'),
        renderPedigreeLine(80, 58, 140, 58, 'distant'),
        renderPedigreeLine(80, 58, 80, 92, 'distant'),
        renderPedigreeLine(140, 58, 170, 92, 'distant'),
        renderPedigreeLine(80, 118, 110, 140, 'distant'),
        renderPedigreeLine(170, 118, 170, 128, 'distant')
      ];
      const nodes = [
        renderPedigreeNode(110, 24, 'Fælles forfader'),
        renderPedigreeNode(80, 104, 'Probandens gren'),
        renderPedigreeNode(170, 104, 'Fjern gren'),
        renderPedigreeNode(170, 140, 'Fjern slægtning', '(vejledende)'),
        renderPedigreeNode(110, 170, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 220 200',
        title: `Stamtræ – ${relationText}`,
        desc: 'Illustration af fjern beslægtning med delt forfader flere led tilbage.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    }
  };
  const consangOptions = consanguinityProfiles.map(profile => `
    <option value="${esc(profile.value)}"${profile.defaultSelected ? ' selected' : ''}>${esc(profile.label)}</option>
  `).join('');
  const BLAST_PROGRAMS = [
    {value: 'blastn', label: 'blastn – nukleotid mod nukleotid'},
    {value: 'blastp', label: 'blastp – protein mod protein'},
    {value: 'blastx', label: 'blastx – oversæt nukleotid mod protein'},
    {value: 'tblastn', label: 'tblastn – protein mod oversatte nukleotider'},
    {value: 'tblastx', label: 'tblastx – oversatte nukleotider mod oversatte nukleotider'}
  ];
  const BLAST_DATABASES = {
    blastn: [
      {value: 'nt', label: 'nt – NCBI nukleotid-database'},
      {value: 'refseq_rna', label: 'refseq_rna – RefSeq RNA'},
      {value: 'refseq_genomic', label: 'refseq_genomic – RefSeq genom'},
      {value: 'wgs', label: 'wgs – whole genome shotgun contigs'}
    ],
    blastp: [
      {value: 'nr', label: 'nr – NCBI protein'},
      {value: 'swissprot', label: 'swissprot – Swiss-Prot kurateret'},
      {value: 'refseq_protein', label: 'refseq_protein – RefSeq protein'}
    ],
    blastx: [
      {value: 'nr', label: 'nr – NCBI protein'},
      {value: 'swissprot', label: 'swissprot – Swiss-Prot kurateret'},
      {value: 'refseq_protein', label: 'refseq_protein – RefSeq protein'}
    ],
    tblastn: [
      {value: 'nt', label: 'nt – NCBI nukleotid-database'},
      {value: 'refseq_rna', label: 'refseq_rna – RefSeq RNA'},
      {value: 'refseq_genomic', label: 'refseq_genomic – RefSeq genom'}
    ],
    tblastx: [
      {value: 'nt', label: 'nt – NCBI nukleotid-database'},
      {value: 'refseq_rna', label: 'refseq_rna – RefSeq RNA'}
    ]
  };
  const DEFAULT_BLAST_PROGRAM = 'blastn';
  const DEFAULT_BLAST_DATABASE = 'nt';
  const renderBlastDatabaseOptions = (program, selectedValue) => {
    const items = BLAST_DATABASES[program] || [];
    if (!items.length) {
      return '<option value="" disabled>Ingen database tilgængelig</option>';
    }
    return items.map((item, index) => {
      const value = esc(item.value);
      const label = esc(item.label);
      const selected = selectedValue ? selectedValue === item.value : index === 0;
      return `<option value="${value}"${selected ? ' selected' : ''}>${label}</option>`;
    }).join('');
  };
  const blastProgramOptions = BLAST_PROGRAMS.map(item => {
    const value = esc(item.value);
    const label = esc(item.label);
    const selected = item.value === DEFAULT_BLAST_PROGRAM ? ' selected' : '';
    return `<option value="${value}"${selected}>${label}</option>`;
  }).join('');
  const initialBlastDatabaseOptions = renderBlastDatabaseOptions(DEFAULT_BLAST_PROGRAM, DEFAULT_BLAST_DATABASE);
  const makeCriteriaList = list => list.map(item => {
    const code = esc(item.code);
    const label = esc(item.label);
    const effectRaw = item.effect === 'benign' ? 'benign' : 'pathogenic';
    const effect = esc(effectRaw);
    const description = item.description ? ` ${item.description}` : '';
    const tooltip = esc(`${item.code} – ${item.label}${description}`);
    const allowedStrengths = Array.isArray(item.strengths) && item.strengths.length
      ? item.strengths
      : DEFAULT_STRENGTH_ORDER[effectRaw] || [];
    const validStrengths = allowedStrengths.filter(strength => STRENGTH_DEFINITIONS[effectRaw]?.[strength]);
    const fallbackStrength = DEFAULT_STRENGTH_ORDER[effectRaw]?.find(strength => STRENGTH_DEFINITIONS[effectRaw]?.[strength]);
    const defaultStrength = (item.defaultStrength && STRENGTH_DEFINITIONS[effectRaw]?.[item.defaultStrength])
      ? item.defaultStrength
      : (validStrengths[0] || fallbackStrength || 'supporting');
    const options = (validStrengths.length ? validStrengths : [defaultStrength]).map(strength => {
      const definition = STRENGTH_DEFINITIONS[effectRaw]?.[strength];
      if (!definition) return '';
      const optionLabel = esc(definition.label);
      const selected = strength === defaultStrength ? ' selected' : '';
      const guidance = item.strengthGuidance?.[strength];
      const titleAttr = guidance ? ` title="${esc(guidance)}"` : '';
      return `<option value="${strength}"${selected}${titleAttr}>${optionLabel}</option>`;
    }).join('');
    return `
    <label class="tool-criteria" title="${tooltip}">
      <input type="checkbox" class="criterion-toggle" value="${code}" data-effect="${effect}">
      <span>
        <span class="criterion-text"><strong>${code}</strong> ${label}</span>
        <span class="criterion-strength-wrapper">
          <select class="criterion-strength" data-code="${code}" data-effect="${effect}" data-default-strength="${esc(defaultStrength)}" disabled>
            ${options}
          </select>
        </span>
      </span>
    </label>
  `;
  }).join('');
  section.innerHTML = `
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">ACMG klassifikationshjælper</span>
        <span class="tool-subtitle">Forenklet vægtning af ACMG/AMP 2015 med opdaterede pointværdier.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>ACMG klassifikationshjælper</h3>
      <p>Vælg de kriterier der er opfyldt for varianten. Resultatet bruger en forenklet vægtning af ACMG/AMP 2015 med opdaterede pointværdier.</p>
      <form id="acmgTool">
        <div class="tool-columns">
          <fieldset>
            <legend>Patogene kriterier</legend>
            <div class="tool-criteria-list">
              ${makeCriteriaList(pathogenicCriteria)}
            </div>
          </fieldset>
          <fieldset>
            <legend>Benigne kriterier</legend>
            <div class="tool-criteria-list">
              ${makeCriteriaList(benignCriteria)}
            </div>
          </fieldset>
        </div>
        <div class="btn-row">
          <button type="button" class="secondary" id="acmgReset">Nulstil kriterier</button>
        </div>
      </form>
      <div class="tool-result" id="acmgResult">Vælg kriterier for at se forslag til klassifikation.</div>
      <p class="tool-note">Vurderingen er vejledende og kræver altid manuel gennemgang og dokumentation.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">HGVS c. nomenklaturhjælper</span>
        <span class="tool-subtitle">Byg hurtigt cDNA-notation for substitutioner, deletioner m.m.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>HGVS c. nomenklaturhjælper</h3>
      <p>Udfyld felterne for at få foreslået et gyldigt HGVS c.-udtryk til simple varianter. Vælg varianttype og angiv de relevante positioner og sekvenser.</p>
      <form id="hgvsForm">
        <div class="tool-inline">
          <label for="hgvsTranscript" title="Angiv referencetranskript (RefSeq, LRG eller tilsvarende).">
            Referencetranskript
            <input id="hgvsTranscript" name="transcript" placeholder="fx NM_000546.5">
          </label>
          <label for="hgvsType" title="Vælg varianttypen for at vise de relevante felter.">
            Varianttype
            <select id="hgvsType" name="type">
              <option value="substitution">Basiskift (substitution)</option>
              <option value="deletion">Deletion</option>
              <option value="insertion">Insertion</option>
              <option value="duplication">Duplikation</option>
              <option value="delins">Delins (deletion+insertion)</option>
            </select>
          </label>
        </div>
        <div class="tool-inline">
          <label for="hgvsStart" data-hgvs-field="start" title="Startpositionen for ændringen. Brug intronnotation ved behov (fx 123+1).">
            Position (start)
            <input id="hgvsStart" name="start" placeholder="fx 215">
          </label>
          <label for="hgvsEnd" data-hgvs-field="end" title="Slutpositionen for ændringen. Udelades for enkeltbase-varianter.">
            Position (slut)
            <input id="hgvsEnd" name="end" placeholder="fx 217">
          </label>
        </div>
        <div class="tool-inline">
          <label for="hgvsRef" data-hgvs-field="ref" title="Referencebase(r) eller slettet sekvens, hvis kendt.">
            Reference/sekvens
            <input id="hgvsRef" name="ref" placeholder="fx C eller AGT">
          </label>
          <label for="hgvsAlt" data-hgvs-field="alt" title="Ændringen, indsatte baser eller erstatningssekvens.">
            Ændring/indsættelse
            <input id="hgvsAlt" name="alt" placeholder="fx G eller TTA">
          </label>
        </div>
        <p class="tool-note">Felter skjules automatisk for varianttyper, hvor de ikke anvendes. Positioner kan skrives med intronnotation (fx 123+1).</p>
        <div class="btn-row">
          <button type="button" class="secondary" id="hgvsCopy">Kopiér notation</button>
        </div>
      </form>
      <div class="tool-result" id="hgvsResult">Udfyld felterne for at få et HGVS-forslag.</div>
      <p class="tool-note">Kontroller altid notationen mod HGVS-retningslinjerne og kliniske SOP&apos;er før rapportering.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Konsangvinitetsestimator</span>
        <span class="tool-subtitle">Oversæt het/hom-forhold til vejledende slægtskab.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Konsangvinitetsestimator</h3>
      <p>Angiv prøvens heterozygot/homozygot-forhold og vælg en befolkningsbaseline. Beregningen antager at reduktion i heterozygositet primært skyldes beslægtethed.</p>
      <form id="consangForm">
        <div class="tool-inline">
          <label for="consangRatio" title="Forholdet mellem heterozygote og homozygote varianter (fx 1,80).">
            Het/hom ratio
            <input id="consangRatio" name="ratio" inputmode="decimal" placeholder="fx 1,80">
          </label>
          <label for="consangEthnicity" title="Baseline anvendt til forventet heterozygositet.">
            Etnicitet/baggrund
            <select id="consangEthnicity" name="ethnicity">
              ${consangOptions}
            </select>
          </label>
        </div>
        <fieldset class="consang-baseline">
          <legend>Baseline-type</legend>
          <label class="radio-option" title="Brug helgenomsekventeringsdata som reference (1,62 i nordiske kohorter).">
            <input type="radio" name="consangBaseline" value="wgs" checked>
            <span>WGS-kalibreret (helgenom)</span>
          </label>
          <label class="radio-option" title="Brug tidligere SNP-array baseline uden WGS-kalibrering.">
            <input type="radio" name="consangBaseline" value="snp">
            <span>SNP-array baseline (ukalibreret)</span>
          </label>
        </fieldset>
      </form>
      <p class="tool-note" id="consangProfileNote"></p>
      <div class="tool-result" id="consangResult">Angiv et positivt het/hom-forhold for at få et estimat.</div>
      <p class="tool-note">Estimatet er vejledende og bør understøttes af andre mål (ROH, IBD, familieoplysninger) før kliniske konklusioner.</p>
      <figure class="consang-diagram" id="consangDiagram" hidden></figure>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Genomisk afstandsberegner</span>
        <span class="tool-subtitle">Beregn antal baser mellem to lokationer.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Genomisk afstandsberegner</h3>
      <p>Beregn antal baser mellem to lokationer. Indtast fx <code>chr7:55191822</code> og <code>chr7:55277778</code>.</p>
      <form id="distanceTool">
        <div class="tool-inline">
          <label for="distanceStart">Startposition<input id="distanceStart" name="start" placeholder="fx chr7:55191822"></label>
          <label for="distanceEnd">Slutposition<input id="distanceEnd" name="end" placeholder="fx 55277778"></label>
        </div>
        <div class="btn-row">
          <button type="button" class="secondary" id="distanceSwap">Byt positioner</button>
        </div>
      </form>
      <div class="tool-result" id="distanceResult">Indtast positioner for at se resultatet.</div>
      <p class="tool-note">Resultatet viser både eksklusiv (end-start) og inklusiv (end-start+1) afstand.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Genome browser opslag</span>
        <span class="tool-subtitle">Åbn koordinater, gener eller varianter direkte i Ensembl eller UCSC.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Genome browser opslag</h3>
      <p>Angiv en position (fx chr1:123456-123789), et gen (fx BRCA1) eller et variant-id (fx rs80357713) og vælg browser og reference.</p>
      <form id="genomeBrowserForm">
        <div class="tool-inline">
          <label for="genomeLookupType">
            Opslagstype
            <select id="genomeLookupType" name="lookup_type">
              <option value="position">Position</option>
              <option value="gene">Gen</option>
              <option value="variant">Variant-id</option>
            </select>
          </label>
          <label for="genomeAssembly">
            Reference
            <select id="genomeAssembly" name="assembly">
              <option value="grch38" selected>GRCh38 / hg38</option>
              <option value="grch37">GRCh37 / hg19</option>
            </select>
          </label>
          <label for="genomeBrowserChoice">
            Browser
            <select id="genomeBrowserChoice" name="browser">
              <option value="ensembl" selected>Ensembl</option>
              <option value="ucsc">UCSC Genome Browser</option>
            </select>
          </label>
        </div>
        <label for="genomeLookupValue">
          Søgeværdi
          <input id="genomeLookupValue" name="value" placeholder="fx chr7:140453136-140453250 eller BRCA1" autocomplete="off">
        </label>
        <div class="tool-inline" data-padding-row>
          <label for="genomePadding" title="Bruges når kun en enkelt position angives for at definere visningsvinduet omkring positionen.">
            Visningsvindue (bp)
            <input type="number" id="genomePadding" name="padding" min="10" max="2000000" value="1000">
          </label>
        </div>
        <div class="btn-row">
          <button type="submit" class="primary" id="genomeBrowserOpen">Åbn i ny fane</button>
          <button type="button" class="secondary" id="genomeBrowserClear">Ryd</button>
        </div>
      </form>
      <div class="tool-result" id="genomeBrowserStatus">Indtast en søgeværdi og vælg browser for at åbne visningen.</div>
      <p class="tool-note">Positioner udvides automatisk med et vindue omkring koordinatet, hvis der ikke angives et interval.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Sekvens BLAST</span>
        <span class="tool-subtitle">Send sekvenser til NCBI BLAST i en ny fane.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Sekvens BLAST</h3>
      <p>Indsæt en DNA- eller proteinsekvens og vælg program og database. Forespørgslen sendes til NCBI BLAST i en ny browserfane.</p>
      <form id="blastForm">
        <div class="tool-inline">
          <label for="blastProgram">
            Program
            <select id="blastProgram" name="program">
              ${blastProgramOptions}
            </select>
          </label>
          <label for="blastDatabase">
            Database
            <select id="blastDatabase" name="database">
              ${initialBlastDatabaseOptions}
            </select>
          </label>
          <label for="blastExpect">
            E-værdi (valgfri)
            <input id="blastExpect" name="expect" placeholder="fx 1e-5">
          </label>
        </div>
        <div class="tool-inline">
          <label for="blastTitle">
            Sekvenstitel (valgfri)
            <input id="blastTitle" name="title" placeholder="fx Patient123_variant">
          </label>
          <label for="blastOrganism">
            Organisme-filter (valgfri)
            <input id="blastOrganism" name="organism" placeholder="fx Homo sapiens [taxid:9606]">
          </label>
        </div>
        <label for="blastQuery">
          Sekvens
          <textarea id="blastQuery" name="query" rows="6" placeholder="Indsæt DNA- eller proteinsekvens (FASTA eller rå tekst)"></textarea>
        </label>
        <label class="list-toggle" id="blastMegablastRow">
          <input type="checkbox" id="blastMegablast" name="megablast" checked>
          <span>Brug MEGABLAST for højt lignende DNA-sekvenser (blastn)</span>
        </label>
        <div class="btn-row">
          <button type="submit" class="primary" id="blastSubmit">Kør BLAST (NCBI)</button>
          <button type="button" class="secondary" id="blastClear">Ryd</button>
        </div>
      </form>
      <div class="tool-result" id="blastStatus">Indsæt en sekvens og kør BLAST for at åbne resultatet hos NCBI.</div>
      <p class="tool-note">Sekvensen sendes direkte til NCBI BLAST via en ny fane og gemmes ikke i GlimR.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Primerdesign</span>
        <span class="tool-subtitle">Foreslå primerpar ud fra sekvens, målområde og ønsket Tm.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Primerdesign</h3>
      <p>Angiv en sekvens og evt. målområde for at få et forslag til forward og reverse primer baseret på simple heuristikker.</p>
      <form id="primerTool">
        <label for="primerSequence">Sekvens
          <textarea id="primerSequence" name="sequence" rows="4" placeholder="Indsæt målsekvens (DNA) her"></textarea>
        </label>
        <div class="tool-inline">
          <label for="primerStart">Amplicon-start (1-baseret)
            <input type="number" id="primerStart" name="start" min="1" placeholder="fx 120">
          </label>
          <label for="primerEnd">Amplicon-slut (1-baseret)
            <input type="number" id="primerEnd" name="end" min="1" placeholder="fx 420">
          </label>
        </div>
        <div class="tool-inline">
          <label for="primerMinLen">Minimum primerlængde
            <input type="number" id="primerMinLen" name="min_len" min="10" max="60" value="18">
          </label>
          <label for="primerMaxLen">Maksimum primerlængde
            <input type="number" id="primerMaxLen" name="max_len" min="10" max="60" value="24">
          </label>
          <label for="primerTargetTm">Ønsket Tm (°C)
            <input type="number" step="0.1" id="primerTargetTm" name="target_tm" min="30" max="80" value="60">
          </label>
        </div>
        <div class="btn-row">
          <button type="submit" class="primary" id="primerDesign">Design primere</button>
          <button type="button" class="secondary" id="primerClear">Ryd</button>
        </div>
      </form>
      <div class="tool-result" id="primerResult">Indsæt en sekvens og angiv evt. målområde for at foreslå primere.</div>
      <p class="tool-note">Primere beregnes med simple regler (Wallace-Tm og GC-clamp) og kræver laboratoriel validering før brug.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">GC- og sekvensværktøj</span>
        <span class="tool-subtitle">Analyser sekvensen for GC-indhold og reverse komplement.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>GC- og sekvensværktøj</h3>
      <p>Analyser en DNA/RNA-sekvens for længde, GC-indhold og generér reverse komplement.</p>
      <form id="gcTool">
        <label for="gcSequence">Sekvens
          <textarea id="gcSequence" name="sequence" rows="4" placeholder="Indsæt sekvens her"></textarea>
        </label>
        <div class="btn-row">
          <button type="button" class="secondary" id="gcUpper">Rens og formater</button>
          <button type="button" class="secondary" id="gcReverse">Reverse komplement</button>
        </div>
      </form>
      <div class="tool-result" id="gcResult">Indsæt en sekvens for at beregne GC%.</div>
      <p class="tool-note">Beregningen ignorerer mellemrum og tal. Ambigue baser (fx N, R, Y) medtages i længden.</p>
    </div>
  </details>`;

  applyButtonTooltips(section);
  applyControlTooltips(section);
  section.querySelectorAll('form').forEach(form => applyFormTooltips(form));

  const cleanSequence = value => value.replace(/[^A-Za-z]/g, '').toUpperCase();
  const toDnaSequence = value => cleanSequence(value).replace(/U/g, 'T');
  const COMPLEMENT_MAP = {A: 'T', T: 'A', U: 'A', G: 'C', C: 'G', Y: 'R', R: 'Y', S: 'S', W: 'W', K: 'M', M: 'K', B: 'V', V: 'B', D: 'H', H: 'D', N: 'N'};

  const acmgForm = section.querySelector('#acmgTool');
  const acmgResult = section.querySelector('#acmgResult');
  const acmgToggles = Array.from(acmgForm.querySelectorAll('.criterion-toggle'));
  const acmgReset = section.querySelector('#acmgReset');
  const formatList = list => list.length ? list.join(', ') : 'Ingen';
  const syncCriterionStrength = toggle => {
    const container = toggle.closest('.tool-criteria');
    const select = container?.querySelector('.criterion-strength');
    if (!select) return;
    if (toggle.checked) {
      select.disabled = false;
    } else {
      select.disabled = true;
      const defaultStrength = select.dataset.defaultStrength;
      if (defaultStrength) {
        select.value = defaultStrength;
      }
    }
  };
  const updateAcmgResult = () => {
    let score = 0;
    const selectedPath = [];
    const selectedBenign = [];
    acmgToggles.forEach(toggle => {
      if (!toggle.checked) return;
      const effect = toggle.dataset.effect === 'benign' ? 'benign' : 'pathogenic';
      const container = toggle.closest('.tool-criteria');
      const select = container?.querySelector('.criterion-strength');
      const strength = select?.value;
      const definition = strength ? STRENGTH_DEFINITIONS[effect]?.[strength] : null;
      const delta = definition ? definition.weight : 0;
      score += delta;
      const summaryLabel = definition?.summary;
      const entry = summaryLabel ? `${toggle.value} (${summaryLabel})` : toggle.value;
      if (effect === 'benign') {
        selectedBenign.push(entry);
      } else {
        selectedPath.push(entry);
      }
    });
    if (!selectedPath.length && !selectedBenign.length) {
      acmgResult.textContent = 'Vælg kriterier for at se forslag til klassifikation.';
      return;
    }
    let classification;
    if (score >= 10) classification = 'Patogen';
    else if (score >= 6) classification = 'Sandsynligvis patogen';
    else if (score <= -6) classification = 'Godartet';
    else if (score <= -2) classification = 'Sandsynligvis godartet';
    else classification = 'Variant af ukendt betydning (VUS)';
    acmgResult.innerHTML = `<strong>${classification}</strong><br>` +
      `Vægtet score: ${score}.<br>` +
      `Patogene kriterier: ${formatList(selectedPath)}.<br>` +
      `Benigne kriterier: ${formatList(selectedBenign)}.`;
  };
  acmgToggles.forEach(toggle => {
    syncCriterionStrength(toggle);
    toggle.addEventListener('change', () => syncCriterionStrength(toggle));
  });
  acmgForm.addEventListener('change', event => {
    if (event.target.classList.contains('criterion-strength') && event.target.disabled) {
      return;
    }
    updateAcmgResult();
  });
  acmgReset?.addEventListener('click', () => {
    acmgToggles.forEach(toggle => {
      toggle.checked = false;
      syncCriterionStrength(toggle);
    });
    acmgForm.querySelectorAll('.criterion-strength').forEach(select => {
      const defaultStrength = select.dataset.defaultStrength;
      if (defaultStrength) {
        select.value = defaultStrength;
      }
    });
    updateAcmgResult();
  });
  updateAcmgResult();

  const hgvsForm = section.querySelector('#hgvsForm');
  const hgvsResult = section.querySelector('#hgvsResult');
  if (hgvsForm && hgvsResult) {
    const hgvsType = hgvsForm.querySelector('#hgvsType');
    if (hgvsType) {
      const hgvsCopy = section.querySelector('#hgvsCopy');
      const hgvsFields = {
        transcript: hgvsForm.querySelector('#hgvsTranscript'),
        start: hgvsForm.querySelector('#hgvsStart'),
        end: hgvsForm.querySelector('#hgvsEnd'),
        ref: hgvsForm.querySelector('#hgvsRef'),
        alt: hgvsForm.querySelector('#hgvsAlt')
      };
      const hgvsFieldVisibility = {
        substitution: {start: true, end: false, ref: true, alt: true},
        deletion: {start: true, end: true, ref: true, alt: false},
        insertion: {start: true, end: true, ref: false, alt: true},
        duplication: {start: true, end: true, ref: false, alt: false},
        delins: {start: true, end: true, ref: true, alt: true}
      };
      const hgvsRequiredFields = {
        substitution: ['start', 'ref', 'alt'],
        deletion: ['start'],
        insertion: ['start', 'end', 'alt'],
        duplication: ['start'],
        delins: ['start', 'alt']
      };
      const hgvsFieldLabels = {
        start: 'Position (start)',
        end: 'Position (slut)',
        ref: 'Reference/sekvens',
        alt: 'Ændring/indsættelse'
      };
      const hgvsFieldControls = Array.from(hgvsForm.querySelectorAll('[data-hgvs-field]'));
      const setHgvsVisibility = type => {
        const config = hgvsFieldVisibility[type] || hgvsFieldVisibility.substitution;
        hgvsFieldControls.forEach(label => {
          const field = label.getAttribute('data-hgvs-field');
          label.hidden = config[field] === false;
        });
      };
      const normaliseTranscript = value => value.trim();
      const normaliseSequenceField = value => value.replace(/\s+/g, '').toUpperCase();
      const buildCoordinate = (start, end) => {
        if (!end || end === start) return start;
        return `${start}_${end}`;
      };
      const updateHgvsResult = () => {
        const type = hgvsType.value;
        setHgvsVisibility(type);
        const config = hgvsFieldVisibility[type] || hgvsFieldVisibility.substitution;
        const transcript = normaliseTranscript(hgvsFields.transcript?.value || '');
        const start = (hgvsFields.start?.value || '').trim();
        const rawEnd = (hgvsFields.end?.value || '').trim();
        const end = config.end === false ? '' : rawEnd;
        const rawRef = hgvsFields.ref?.value || '';
        const rawAlt = hgvsFields.alt?.value || '';
        const ref = config.ref === false ? '' : normaliseSequenceField(rawRef);
        const alt = config.alt === false ? '' : normaliseSequenceField(rawAlt);
        const required = hgvsRequiredFields[type] || hgvsRequiredFields.substitution;
        const values = {start, end, ref, alt};
        const missing = required.filter(key => !values[key]);
        if (missing.length) {
          const names = missing.map(key => hgvsFieldLabels[key] || key).join(', ');
          hgvsResult.textContent = `Udfyld følgende felter: ${names}.`;
          hgvsResult.dataset.hgvsString = '';
          return;
        }
        let coordinate = start;
        if (end) {
          coordinate = buildCoordinate(start, end);
        }
        let variantPart = '';
        switch (type) {
          case 'deletion':
            variantPart = `${coordinate}del${ref}`;
            break;
          case 'insertion':
            variantPart = `${coordinate}ins${alt}`;
            break;
          case 'duplication':
            variantPart = `${coordinate}dup${ref || ''}`;
            break;
          case 'delins':
            variantPart = `${coordinate}delins${alt}`;
            break;
          default:
            variantPart = `${coordinate}${ref}>${alt}`;
        }
        let transcriptPart = '';
        if (transcript) {
          let cleaned = transcript.replace(/\s+/g, '');
          if (/^c\./i.test(cleaned)) {
            cleaned = cleaned.replace(/^c\./i, '');
            transcriptPart = '';
          } else {
            const lower = cleaned.toLowerCase();
            const colonIndex = lower.indexOf(':c.');
            if (colonIndex !== -1) {
              cleaned = cleaned.slice(0, colonIndex);
            } else {
              cleaned = cleaned.replace(/:$/,'').replace(/:c$/i, '');
            }
            if (cleaned) {
              transcriptPart = `${cleaned}:`;
            }
          }
        }
        const notation = `${transcriptPart}c.${variantPart}`;
        hgvsResult.innerHTML = `<strong>Forslag:</strong> <code>${esc(notation)}</code>`;
        hgvsResult.dataset.hgvsString = notation;
      };
      hgvsForm.addEventListener('input', updateHgvsResult);
      hgvsType.addEventListener('change', updateHgvsResult);
      updateHgvsResult();
      hgvsCopy?.addEventListener('click', async () => {
        const notation = hgvsResult.dataset.hgvsString;
        if (!notation) {
          alert('Der er ingen notation at kopiere endnu.');
          return;
        }
        try {
          await navigator.clipboard.writeText(notation);
          setStatus(`HGVS-notation kopieret: ${notation}`);
        } catch (err) {
          console.error(err);
          alert('Kunne ikke kopiere til udklipsholderen.');
        }
      });
    }
  }

  const genomeBrowserForm = section.querySelector('#genomeBrowserForm');
  const genomeBrowserStatus = section.querySelector('#genomeBrowserStatus');
  if (genomeBrowserForm && genomeBrowserStatus) {
    const typeField = genomeBrowserForm.querySelector('#genomeLookupType');
    const assemblyField = genomeBrowserForm.querySelector('#genomeAssembly');
    const browserField = genomeBrowserForm.querySelector('#genomeBrowserChoice');
    const valueField = genomeBrowserForm.querySelector('#genomeLookupValue');
    const paddingField = genomeBrowserForm.querySelector('#genomePadding');
    const clearButton = genomeBrowserForm.querySelector('#genomeBrowserClear');
    const paddingRow = genomeBrowserForm.querySelector('[data-padding-row]');
    const placeholders = {
      position: 'fx chr7:140453136-140453250',
      gene: 'fx BRCA1',
      variant: 'fx rs80357713 eller NM_007294.3:c.68_69del'
    };
    const assemblyConfig = {
      grch38: {label: 'GRCh38 / hg38', ensemblHost: 'https://www.ensembl.org', ucscDb: 'hg38'},
      grch37: {label: 'GRCh37 / hg19', ensemblHost: 'https://grch37.ensembl.org', ucscDb: 'hg19'}
    };
    const browserLabels = {
      ensembl: 'Ensembl',
      ucsc: 'UCSC Genome Browser'
    };
    const typeStatusLabels = {
      position: 'positionen',
      gene: 'genet',
      variant: 'varianten'
    };
    const updateLookupUi = () => {
      const type = typeField?.value || 'position';
      if (valueField) {
        valueField.placeholder = placeholders[type] || 'Angiv søgeværdi';
      }
      if (paddingRow) {
        paddingRow.hidden = type !== 'position';
      }
    };
    updateLookupUi();
    typeField?.addEventListener('change', updateLookupUi);

    const parseWindowSize = () => {
      if (!paddingField) return 1000;
      const parsed = Number.parseInt(paddingField.value, 10);
      if (!Number.isFinite(parsed) || parsed <= 0) return 1000;
      return Math.min(parsed, 2000000);
    };
    const parsePositionValue = (value, windowSize) => {
      if (!value) return null;
      const normalised = value.toString().trim().replace(/\s+/g, '');
      if (!normalised) return null;
      const match = normalised.match(/^(?:chr)?([0-9]{1,2}|X|Y|M|MT)(?::(\d+)(?:-(\d+))?)?$/i);
      if (!match) return null;
      let chrom = match[1].toUpperCase();
      if (chrom === 'M') chrom = 'MT';
      let start = match[2] ? Number.parseInt(match[2], 10) : NaN;
      let end = match[3] ? Number.parseInt(match[3], 10) : NaN;
      if (!Number.isFinite(start)) return null;
      start = Math.max(1, start);
      if (Number.isFinite(end)) {
        end = Math.max(1, end);
        if (end < start) [start, end] = [end, start];
        if (end === start) end = start + 1;
      } else {
        const span = Number.isFinite(windowSize) && windowSize > 0 ? windowSize : 1000;
        const half = Math.max(1, Math.round(span / 2));
        const startCandidate = Math.max(1, start - half);
        const endCandidate = startCandidate + span;
        start = startCandidate;
        end = endCandidate;
      }
      const ensemblRange = `${chrom}:${start}-${end}`;
      const ucscChrom = chrom === 'MT' ? 'chrM' : `chr${chrom}`;
      const ucscRange = `${ucscChrom}:${start}-${end}`;
      return {chrom, start, end, ensemblRange, ucscRange, displayRange: ucscRange};
    };
    const isRsId = value => /^rs\d+$/i.test((value || '').trim());
    const buildStatusLink = (url, text) => `<a href="${esc(url)}" target="_blank" rel="noopener">${esc(text)}</a>`;

    genomeBrowserForm.addEventListener('submit', event => {
      event.preventDefault();
      const type = typeField?.value || 'position';
      const assemblyKey = assemblyField?.value || 'grch38';
      const browserKey = browserField?.value || 'ensembl';
      const assembly = assemblyConfig[assemblyKey];
      if (!assembly) {
        genomeBrowserStatus.textContent = 'Vælg en understøttet reference.';
        return;
      }
      const rawValue = (valueField?.value || '').trim();
      if (!rawValue) {
        genomeBrowserStatus.textContent = 'Angiv en søgeværdi først.';
        valueField?.focus();
        return;
      }
      let url = '';
      let displayValue = rawValue;
      if (type === 'position') {
        const windowSize = parseWindowSize();
        const parsed = parsePositionValue(rawValue, windowSize);
        if (!parsed) {
          genomeBrowserStatus.textContent = 'Kunne ikke tolke positionen. Brug formatet chr1:123456-123789.';
          return;
        }
        displayValue = parsed.displayRange;
        if (browserKey === 'ensembl') {
          url = `${assembly.ensemblHost}/Homo_sapiens/Location/View?r=${encodeURIComponent(parsed.ensemblRange)}`;
        } else if (browserKey === 'ucsc') {
          url = `https://genome.ucsc.edu/cgi-bin/hgTracks?db=${encodeURIComponent(assembly.ucscDb)}&position=${encodeURIComponent(parsed.ucscRange)}`;
        }
      } else if (type === 'gene') {
        if (browserKey === 'ensembl') {
          url = `${assembly.ensemblHost}/Multi/Search/Results?q=${encodeURIComponent(rawValue)};site=ensembl`;
        } else if (browserKey === 'ucsc') {
          url = `https://genome.ucsc.edu/cgi-bin/hgTracks?db=${encodeURIComponent(assembly.ucscDb)}&position=${encodeURIComponent(rawValue)}`;
        }
      } else {
        if (browserKey === 'ensembl') {
          if (isRsId(rawValue)) {
            url = `${assembly.ensemblHost}/Homo_sapiens/Variation/Summary?v=${encodeURIComponent(rawValue)}`;
          } else {
            url = `${assembly.ensemblHost}/Multi/Search/Results?q=${encodeURIComponent(rawValue)};site=ensembl`;
          }
        } else if (browserKey === 'ucsc') {
          url = `https://genome.ucsc.edu/cgi-bin/hgTracks?db=${encodeURIComponent(assembly.ucscDb)}&position=${encodeURIComponent(rawValue)}`;
        }
      }
      if (!url) {
        genomeBrowserStatus.textContent = 'Kombinationen understøttes ikke endnu.';
        return;
      }
      const browserLabel = browserLabels[browserKey] || browserKey;
      const opened = window.open(url, '_blank', 'noopener');
      const linkHtml = buildStatusLink(url, displayValue);
      if (opened) {
        genomeBrowserStatus.innerHTML = `<strong>Åbnede:</strong> ${linkHtml} i ${esc(browserLabel)} (${esc(assembly.label || assemblyKey)}).`;
        const typeLabel = typeStatusLabels[type] || 'opslaget';
        setStatus(`Åbnede ${typeLabel} ${displayValue} i ${browserLabel}.`);
      } else {
        genomeBrowserStatus.innerHTML = `Pop-up blev blokeret. Åbn manuelt: ${linkHtml}`;
      }
    });

    clearButton?.addEventListener('click', () => {
      genomeBrowserForm.reset();
      updateLookupUi();
      genomeBrowserStatus.textContent = 'Indtast en søgeværdi og vælg browser for at åbne visningen.';
    });
  }

  const consangForm = section.querySelector('#consangForm');
  const consangResult = section.querySelector('#consangResult');
  const consangProfileNote = section.querySelector('#consangProfileNote');
  const consangDiagram = section.querySelector('#consangDiagram');
  if (consangForm && consangResult) {
    const ratioInput = consangForm.querySelector('#consangRatio');
    const ethnicitySelect = consangForm.querySelector('#consangEthnicity');
    const baselineRadios = Array.from(consangForm.querySelectorAll('input[name="consangBaseline"]'));
    const setConsangPedigree = (relationship, inbreedingValue) => {
      if (!consangDiagram) return;
      if (!relationship) {
        consangDiagram.hidden = true;
        consangDiagram.innerHTML = '';
        return;
      }
      const templateBuilder = relationship.pedigree ? consanguinityPedigreeTemplates[relationship.pedigree] : null;
      if (typeof templateBuilder !== 'function') {
        consangDiagram.hidden = true;
        consangDiagram.innerHTML = '';
        return;
      }
      const template = templateBuilder({
        relationText: relationship.title,
        detailText: relationship.detail,
        inbreedingText: formatPercent(inbreedingValue)
      }) || {};
      const viewBox = template.viewBox || '0 0 220 200';
      const title = esc(template.title || relationship.title || 'Vejledende slægtskab');
      const desc = esc(template.desc || relationship.detail || 'Pedigree illustration');
      const caption = template.caption || '';
      if (!template.content) {
        consangDiagram.hidden = true;
        consangDiagram.innerHTML = '';
        return;
      }
      consangDiagram.hidden = false;
      consangDiagram.innerHTML = `
        <svg viewBox="${viewBox}" role="img" aria-labelledby="consangDiagramTitle consangDiagramDesc">
          <title id="consangDiagramTitle">${title}</title>
          <desc id="consangDiagramDesc">${desc}</desc>
          ${template.content}
        </svg>
        <figcaption>${caption}</figcaption>
      `;
    };
    const parseRatio = value => {
      if (!value) return NaN;
      const normalised = value.toString().replace(/\s+/g, '').replace(',', '.');
      const number = Number(normalised);
      return Number.isFinite(number) ? number : NaN;
    };
    const formatRatio = value => Number.isFinite(value)
      ? Number(value).toLocaleString('da-DK', {minimumFractionDigits: 2, maximumFractionDigits: 2})
      : '–';
    const formatPercent = value => Number.isFinite(value)
      ? Number(value).toLocaleString('da-DK', {style: 'percent', maximumFractionDigits: 1})
      : '–';
    const getBaselineRatio = (profile, mode) => {
      if (!profile) return NaN;
      if (mode === 'snp') {
        return Number(profile?.snpBaseline);
      }
      const wgs = Number(profile?.wgsBaseline ?? profile?.baseline);
      if (Number.isFinite(wgs) && wgs > 0) {
        return wgs;
      }
      return Number(profile?.snpBaseline);
    };
    const updateConsang = () => {
      setConsangPedigree(null, 0);
      const selectedValue = ethnicitySelect?.value;
      const profile = consanguinityProfiles.find(p => p.value === selectedValue) || consanguinityProfiles[0];
      const baselineMode = baselineRadios.find(r => r.checked)?.value || 'wgs';
      const baselineModeLabel = baselineMode === 'snp' ? 'SNP-array baseline' : 'WGS-kalibreret baseline';
      const baselineRatio = getBaselineRatio(profile, baselineMode);
      const baselineHet = Number.isFinite(baselineRatio) && baselineRatio > 0 ? baselineRatio / (1 + baselineRatio) : NaN;
      if (consangProfileNote) {
        let noteText = profile ? `${profile.label} (${baselineModeLabel}): ` : '';
        const snpBaseline = Number(profile?.snpBaseline);
        const hasSnpBaseline = Number.isFinite(snpBaseline) && snpBaseline > 0;
        if (Number.isFinite(baselineHet) && baselineHet > 0) {
          noteText += `forventet het/hom ≈ ${formatRatio(baselineRatio)} (${formatPercent(baselineHet)} heterozygote)`;
          if (hasSnpBaseline && Math.abs(snpBaseline - baselineRatio) > 0.001) {
            noteText += ` – kalibreret fra SNP baseline ${formatRatio(snpBaseline)} (faktor ${formatRatio(WGS_BASELINE_FACTOR)} ≈ ${formatPercent(WGS_BASELINE_FACTOR)} af SNP-niveauet)`;
          }
          noteText += '.';
        } else {
          noteText += 'forventet het/hom ikke tilgængeligt.';
        }
        if (profile?.note) {
          noteText += ` ${profile.note}`;
        }
        consangProfileNote.textContent = noteText.trim();
      }
      if (!Number.isFinite(baselineRatio) || baselineRatio <= 0 || !Number.isFinite(baselineHet) || baselineHet <= 0) {
        consangResult.textContent = 'Baseline for den valgte baggrund er ikke tilstrækkeligt defineret.';
        return;
      }
      const ratio = parseRatio(ratioInput?.value || '');
      if (!Number.isFinite(ratio) || ratio <= 0) {
        consangResult.textContent = 'Angiv et positivt het/hom-forhold for at få et estimat.';
        return;
      }
      const observedHet = ratio / (1 + ratio);
      if (!Number.isFinite(observedHet) || observedHet <= 0) {
        consangResult.textContent = 'Kunne ikke beregne heterozygositet ud fra de angivne værdier.';
        return;
      }
      const heterozygosityRatio = observedHet / baselineHet;
      let inbreedingCoefficient = 1 - heterozygosityRatio;
      if (!Number.isFinite(inbreedingCoefficient)) {
        consangResult.textContent = 'Kunne ikke beregne estimat fra værdierne.';
        return;
      }
      inbreedingCoefficient = Math.max(0, Math.min(inbreedingCoefficient, 1));
      const relationship = consanguinityCategories.find(cat => inbreedingCoefficient >= cat.minF) || null;
      const relationText = relationship ? `${relationship.title} (${relationship.detail})` : 'Ingen tydelig forhøjet konsangvinitet (F < 0,5 %).';
      const baselineHetPct = formatPercent(baselineHet);
      const observedHetPct = formatPercent(observedHet);
      const retentionPct = formatPercent(heterozygosityRatio);
      const Fpct = formatPercent(inbreedingCoefficient);
      setConsangPedigree(relationship, inbreedingCoefficient);
      consangResult.innerHTML = `<strong>Forventet het/hom (${baselineModeLabel}):</strong> ${formatRatio(baselineRatio)} (${baselineHetPct} heterozygote)<br>` +
        `<strong>Observeret:</strong> ${formatRatio(ratio)} (${observedHetPct} heterozygote)<br>` +
        `<strong>Bevaret heterozygositet:</strong> ${retentionPct}<br>` +
        `<strong>Estimeret inavlskoefficient (F):</strong> ${Fpct}<br>` +
        `<strong>Vejledende slægtskab:</strong> ${esc(relationText)}.`;
    };
    if (ratioInput) {
      ratioInput.addEventListener('input', updateConsang);
      ratioInput.addEventListener('blur', updateConsang);
    }
    ethnicitySelect?.addEventListener('change', updateConsang);
    baselineRadios.forEach(radio => radio.addEventListener('change', updateConsang));
    updateConsang();
  }

  const distanceForm = section.querySelector('#distanceTool');
  const distanceResult = section.querySelector('#distanceResult');
  const distanceStart = distanceForm.querySelector('#distanceStart');
  const distanceEnd = distanceForm.querySelector('#distanceEnd');
  const parsePosition = value => {
    if (!value) return NaN;
    const cleaned = value.replace(/,/g, '');
    const matches = cleaned.match(/-?\d+/g);
    if (!matches) return NaN;
    return Number(matches[matches.length - 1]);
  };
  const updateDistance = () => {
    const startVal = parsePosition(distanceStart.value);
    const endVal = parsePosition(distanceEnd.value);
    if (!Number.isFinite(startVal) || !Number.isFinite(endVal)) {
      distanceResult.textContent = 'Indtast gyldige numeriske positioner for begge felter.';
      return;
    }
    const diff = Math.abs(endVal - startVal);
    const inclusive = diff + 1;
    const orientation = endVal === startVal ? 'samme position' : endVal > startVal ? 'stigende koordinater' : 'faldende koordinater';
    distanceResult.innerHTML = `<strong>Eksklusiv afstand:</strong> ${diff.toLocaleString('da-DK')} baser` +
      `<br><strong>Inklusiv afstand:</strong> ${inclusive.toLocaleString('da-DK')} baser` +
      `<br><span class="tool-note">Fortolkning: ${orientation}.</span>`;
  };
  distanceForm.addEventListener('input', updateDistance);
  section.querySelector('#distanceSwap')?.addEventListener('click', () => {
    const tmp = distanceStart.value;
    distanceStart.value = distanceEnd.value;
    distanceEnd.value = tmp;
    updateDistance();
  });
  updateDistance();

  const blastForm = section.querySelector('#blastForm');
  const blastStatus = section.querySelector('#blastStatus');
  if (blastForm && blastStatus) {
    const sequenceInput = blastForm.querySelector('#blastQuery');
    const titleInput = blastForm.querySelector('#blastTitle');
    const programSelect = blastForm.querySelector('#blastProgram');
    const databaseSelect = blastForm.querySelector('#blastDatabase');
    const organismInput = blastForm.querySelector('#blastOrganism');
    const expectInput = blastForm.querySelector('#blastExpect');
    const megablastToggle = blastForm.querySelector('#blastMegablast');
    const megablastRow = blastForm.querySelector('#blastMegablastRow');
    let lastMegablastState = megablastToggle?.checked ?? true;

    const updateBlastDatabases = () => {
      if (programSelect && databaseSelect) {
        const program = programSelect.value || DEFAULT_BLAST_PROGRAM;
        const current = databaseSelect.value;
        databaseSelect.innerHTML = renderBlastDatabaseOptions(program, current);
        if (!Array.from(databaseSelect.options).some(opt => opt.selected) && databaseSelect.options.length) {
          databaseSelect.selectedIndex = 0;
        }
        if (megablastRow) {
          const isBlastn = program === 'blastn';
          megablastRow.hidden = !isBlastn;
          if (megablastToggle) {
            if (!isBlastn) {
              lastMegablastState = megablastToggle.checked;
              megablastToggle.checked = false;
            } else {
              megablastToggle.checked = lastMegablastState;
            }
          }
        }
      }
    };

    const normaliseFastaTitle = title => {
      return (title || '')
        .trim()
        .replace(/\s+/g, '_')
        .replace(/[^A-Za-z0-9_.-]/g, '_')
        .slice(0, 80);
    };

    const wrapSequence = seq => seq.replace(/(.{1,70})/g, '$1\n').trim();

    const ensureFastaInput = (title, text) => {
      const trimmed = (text || '').replace(/\r\n/g, '\n').trim();
      if (!trimmed) return '';
      if (trimmed.startsWith('>')) {
        return trimmed;
      }
      const sequence = trimmed.replace(/[^A-Za-z*\-]/g, '').toUpperCase();
      if (!sequence) return '';
      const safeTitle = normaliseFastaTitle(title) || 'Query';
      return `>${safeTitle}\n${wrapSequence(sequence)}`;
    };

    const countLetters = text => (text || '').replace(/^>.*$/gm, '').replace(/[^A-Za-z]/g, '').length;

    updateBlastDatabases();
    programSelect?.addEventListener('change', updateBlastDatabases);

    blastForm.addEventListener('submit', event => {
      event.preventDefault();
      const raw = sequenceInput?.value || '';
      const letters = countLetters(raw);
      if (!letters) {
        blastStatus.textContent = 'Indsæt en sekvens før du kører BLAST.';
        sequenceInput?.focus();
        return;
      }
      if (letters < 10) {
        blastStatus.textContent = 'Sekvensen er meget kort – BLAST kræver typisk mindst 10 baser/aminosyrer.';
        sequenceInput?.focus();
        return;
      }
      const fasta = ensureFastaInput(titleInput?.value || '', raw);
      if (!fasta) {
        blastStatus.textContent = 'Kunne ikke formatere sekvensen til FASTA. Kontroller indholdet.';
        return;
      }
      const program = programSelect?.value;
      if (!program) {
        blastStatus.textContent = 'Vælg et BLAST-program.';
        programSelect?.focus();
        return;
      }
      const database = databaseSelect?.value;
      if (!database) {
        blastStatus.textContent = 'Vælg en database for søgningen.';
        databaseSelect?.focus();
        return;
      }
      const hiddenForm = document.createElement('form');
      hiddenForm.method = 'post';
      hiddenForm.action = 'https://blast.ncbi.nlm.nih.gov/Blast.cgi';
      hiddenForm.target = '_blank';
      const appendField = (name, value) => {
        if (value === undefined || value === null || value === '') return;
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = name;
        input.value = value;
        hiddenForm.appendChild(input);
      };
      appendField('CMD', 'Put');
      appendField('PROGRAM', program);
      appendField('DATABASE', database);
      appendField('QUERY', fasta);
      const expect = expectInput?.value.trim();
      if (expect) appendField('EXPECT', expect);
      const organism = organismInput?.value.trim();
      if (organism) appendField('ENTREZ_QUERY', organism);
      if (program === 'blastn' && megablastToggle?.checked) {
        appendField('MEGABLAST', 'on');
      }
      appendField('CLIENT', 'GlimR');
      document.body.appendChild(hiddenForm);
      const offline = typeof navigator !== 'undefined' && navigator && navigator.onLine === false;
      if (offline) {
        blastStatus.textContent = 'Forsøger at åbne NCBI BLAST, men der er ingen registreret internetforbindelse.';
      } else {
        blastStatus.textContent = 'Sekvens sendt til NCBI BLAST i en ny fane. Følg status i den åbne fane.';
      }
      try {
        hiddenForm.submit();
        setStatus('BLAST-forespørgsel åbnet i ny fane.');
      } catch (err) {
        console.error(err);
        blastStatus.textContent = 'Kunne ikke åbne NCBI BLAST. Kontrollér popup-blokering og internetforbindelse.';
      } finally {
        window.setTimeout(() => hiddenForm.remove(), 1000);
      }
    });

    section.querySelector('#blastClear')?.addEventListener('click', () => {
      if (sequenceInput) sequenceInput.value = '';
      if (titleInput) titleInput.value = '';
      if (organismInput) organismInput.value = '';
      if (expectInput) expectInput.value = '';
      if (programSelect) programSelect.value = DEFAULT_BLAST_PROGRAM;
      updateBlastDatabases();
      if (megablastToggle) {
        megablastToggle.checked = true;
        lastMegablastState = true;
      }
      blastStatus.textContent = 'Indsæt en sekvens og kør BLAST for at åbne resultatet hos NCBI.';
      sequenceInput?.focus();
    });
  }

  const primerForm = section.querySelector('#primerTool');
  if (primerForm) {
    const primerResult = section.querySelector('#primerResult');
    const sequenceField = primerForm.querySelector('#primerSequence');
    const startField = primerForm.querySelector('#primerStart');
    const endField = primerForm.querySelector('#primerEnd');
    const minLenField = primerForm.querySelector('#primerMinLen');
    const maxLenField = primerForm.querySelector('#primerMaxLen');
    const targetTmField = primerForm.querySelector('#primerTargetTm');
    const reverseComplement = seq => seq.split('').reverse().map(base => COMPLEMENT_MAP[base] || base).join('');
    const calculateTm = seq => {
      const gcCount = (seq.match(/[GC]/g) || []).length;
      const atCount = seq.length - gcCount;
      return (4 * gcCount) + (2 * atCount);
    };
    const calculateGc = seq => {
      if (!seq.length) return 0;
      const gcCount = (seq.match(/[GC]/g) || []).length;
      return (gcCount / seq.length) * 100;
    };
    const hasHomopolymer = seq => /([ACGT])\1{3,}/.test(seq);
    const readPositiveInt = (field, fallback) => {
      if (!field) return fallback;
      const value = (field.value || '').trim();
      if (!value) return fallback;
      const parsed = Number.parseInt(value, 10);
      return Number.isFinite(parsed) && parsed > 0 ? parsed : NaN;
    };
    const readNumber = (field, fallback) => {
      if (!field) return fallback;
      const value = (field.value || '').trim();
      if (!value) return fallback;
      const normalised = value.replace(',', '.');
      const parsed = Number.parseFloat(normalised);
      return Number.isFinite(parsed) ? parsed : NaN;
    };
    const buildWarnings = primer => {
      const warnings = [];
      if (!primer.clamp) warnings.push('Manglende GC-clamp i 3′-enden');
      if (primer.gc < 35 || primer.gc > 65) warnings.push('GC% uden for 35–65 %');
      if (primer.homopolymer) warnings.push('Homopolymer på ≥4 baser');
      return warnings;
    };
    const designPrimers = () => {
      const template = toDnaSequence(sequenceField?.value || '');
      if (!template.length) {
        primerResult.textContent = 'Indsæt en sekvens for at foreslå primere.';
        return;
      }
      let start = readPositiveInt(startField, 1);
      let end = readPositiveInt(endField, template.length);
      if (Number.isNaN(start) || Number.isNaN(end)) {
        primerResult.textContent = 'Angiv gyldige tal for start og slut (1-baseret).';
        return;
      }
      start = Math.max(1, Math.min(start, template.length));
      end = Math.max(1, Math.min(end, template.length));
      if (start > end) {
        const tmp = start;
        start = end;
        end = tmp;
      }
      let minLen = readPositiveInt(minLenField, 18);
      let maxLen = readPositiveInt(maxLenField, 24);
      if (Number.isNaN(minLen) || Number.isNaN(maxLen)) {
        primerResult.textContent = 'Angiv gyldige primerlængder.';
        return;
      }
      if (minLen > maxLen) [minLen, maxLen] = [maxLen, minLen];
      minLen = Math.max(10, Math.min(minLen, 60));
      maxLen = Math.max(minLen, Math.min(maxLen, 60));
      let targetTm = readNumber(targetTmField, 60);
      if (Number.isNaN(targetTm)) targetTm = 60;
      targetTm = Math.max(30, Math.min(targetTm, 80));
      const regionStartIndex = start - 1;
      const regionEndIndex = end - 1;
      if (regionEndIndex - regionStartIndex + 1 < minLen) {
        primerResult.textContent = 'Målområdet er kortere end den ønskede primerlængde.';
        return;
      }
      const invalidPattern = /[^ACGT]/;
      const searchWindow = 80;
      const evaluateForward = () => {
        let best = null;
        const limit = Math.min(regionEndIndex - minLen + 1, regionStartIndex + searchWindow);
        for (let pos = regionStartIndex; pos <= limit; pos++) {
          const maxLenAtPos = Math.min(maxLen, regionEndIndex - pos + 1);
          for (let len = minLen; len <= maxLenAtPos; len++) {
            const candidate = template.slice(pos, pos + len);
            if (!candidate || invalidPattern.test(candidate)) continue;
            const tm = calculateTm(candidate);
            const gc = calculateGc(candidate);
            const clamp = /[GC]$/.test(candidate);
            const homopolymer = hasHomopolymer(candidate);
            const score = Math.abs(tm - targetTm) + (clamp ? 0 : 1.5) + ((gc < 35 || gc > 65) ? 0.5 : 0) + (homopolymer ? 0.75 : 0) + ((pos - regionStartIndex) * 0.02);
            if (!best || score < best.score) {
              best = {
                sequence: candidate,
                tm,
                gc,
                clamp,
                homopolymer,
                length: len,
                start: pos + 1,
                end: pos + len,
                score
              };
            }
          }
        }
        return best;
      };
      const evaluateReverse = () => {
        let best = null;
        const startLimit = Math.max(regionStartIndex + minLen - 1, regionEndIndex - searchWindow);
        for (let endPos = regionEndIndex; endPos >= startLimit; endPos--) {
          const maxLenAtPos = Math.min(maxLen, endPos - regionStartIndex + 1);
          for (let len = minLen; len <= maxLenAtPos; len++) {
            const startPos = endPos - len + 1;
            if (startPos < regionStartIndex) continue;
            const templateSegment = template.slice(startPos, endPos + 1);
            if (!templateSegment || invalidPattern.test(templateSegment)) continue;
            const primerSeq = reverseComplement(templateSegment);
            const tm = calculateTm(primerSeq);
            const gc = calculateGc(primerSeq);
            const clamp = /[GC]$/.test(primerSeq);
            const homopolymer = hasHomopolymer(primerSeq);
            const score = Math.abs(tm - targetTm) + (clamp ? 0 : 1.5) + ((gc < 35 || gc > 65) ? 0.5 : 0) + (homopolymer ? 0.75 : 0) + ((regionEndIndex - endPos) * 0.02);
            if (!best || score < best.score) {
              best = {
                sequence: primerSeq,
                tm,
                gc,
                clamp,
                homopolymer,
                length: len,
                start: startPos + 1,
                end: endPos + 1,
                score
              };
            }
          }
        }
        return best;
      };
      const forward = evaluateForward();
      const reverse = evaluateReverse();
      if (!forward || !reverse) {
        primerResult.textContent = 'Kunne ikke finde egnede primere. Justér længder, Tm eller målområde.';
        return;
      }
      const tmDelta = Math.abs(forward.tm - reverse.tm);
      const ampliconSize = (reverse.end - forward.start) + 1;
      if (ampliconSize <= 0) {
        primerResult.textContent = 'Primere overlapper hinanden – udvid målområdet eller justér parametre.';
        return;
      }
      const forwardWarnings = buildWarnings(forward);
      const reverseWarnings = buildWarnings(reverse);
      const summaryLines = [
        `<strong>Amplicon:</strong> ${forward.start.toLocaleString('da-DK')}–${reverse.end.toLocaleString('da-DK')} (${ampliconSize.toLocaleString('da-DK')} bp)`,
        `<strong>Forward primer (5′→3′)</strong> ${forward.sequence}`,
        `• Position: ${forward.start.toLocaleString('da-DK')}–${forward.end.toLocaleString('da-DK')} | Længde: ${forward.length} bp | GC: ${forward.gc.toFixed(1)} % | Tm: ${forward.tm.toFixed(1)} °C${forward.clamp ? ' | 3′-ende: GC-clamp' : ''}`,
        forwardWarnings.length ? `• Bemærkninger: ${forwardWarnings.join('; ')}` : '',
        `<strong>Reverse primer (5′→3′)</strong> ${reverse.sequence}`,
        `• Position: ${reverse.start.toLocaleString('da-DK')}–${reverse.end.toLocaleString('da-DK')} | Længde: ${reverse.length} bp | GC: ${reverse.gc.toFixed(1)} % | Tm: ${reverse.tm.toFixed(1)} °C${reverse.clamp ? ' | 3′-ende: GC-clamp' : ''}`,
        reverseWarnings.length ? `• Bemærkninger: ${reverseWarnings.join('; ')}` : '',
        `ΔTm mellem primere: ${tmDelta.toFixed(1)} °C (mål: ${targetTm.toFixed(1)} °C)`
      ].filter(Boolean);
      if (tmDelta > 3) {
        summaryLines.push('Advarsel: Stor forskel i Tm – overvej at justere længder eller målområde.');
      }
      primerResult.innerHTML = summaryLines.join('<br>');
    };
    primerForm.addEventListener('submit', e => {
      e.preventDefault();
      designPrimers();
    });
    section.querySelector('#primerClear')?.addEventListener('click', () => {
      primerForm.reset();
      primerResult.textContent = 'Indsæt en sekvens og angiv evt. målområde for at foreslå primere.';
      sequenceField?.focus();
    });
  }

  const gcTextarea = section.querySelector('#gcSequence');
  const gcResult = section.querySelector('#gcResult');
  const gcUpper = section.querySelector('#gcUpper');
  const gcReverse = section.querySelector('#gcReverse');
  const normaliseSequence = value => value.replace(/[^A-Za-z]/g, '').toUpperCase();
  const updateGc = () => {
    const seq = normaliseSequence(gcTextarea.value);
    if (!seq.length) {
      gcResult.textContent = 'Indsæt en sekvens for at beregne GC%.';
      return;
    }
    const gcCount = (seq.match(/[GC]/g) || []).length;
    const atCount = (seq.match(/[ATU]/g) || []).length;
    const nCount = (seq.match(/[N]/g) || []).length;
    const otherCount = seq.length - (gcCount + atCount + nCount);
    const gcPct = (gcCount / seq.length) * 100;
    gcResult.innerHTML = `<strong>Længde:</strong> ${seq.length.toLocaleString('da-DK')} baser` +
      `<br><strong>GC-indhold:</strong> ${gcPct.toFixed(1)} % (${gcCount} G/C)` +
      `<br><strong>A/T/U:</strong> ${atCount}` +
      `<br><strong>N/andre:</strong> ${nCount + otherCount}`;
  };
  gcTextarea.addEventListener('input', updateGc);
  gcUpper?.addEventListener('click', () => {
    gcTextarea.value = normaliseSequence(gcTextarea.value);
    updateGc();
  });
  gcReverse?.addEventListener('click', () => {
    const seq = normaliseSequence(gcTextarea.value);
    if (!seq.length) {
      gcResult.textContent = 'Indsæt en sekvens for at beregne GC%.';
      return;
    }
    const reversed = seq.split('').reverse().map(base => COMPLEMENT_MAP[base] || base).join('');
    gcTextarea.value = reversed;
    updateGc();
  });
  updateGc();
}

function renderResponses(section) {
  const list = getCached('responses').slice().reverse();
  section.innerHTML = `
  <div class="panel">
    <div class="btn-row">
      <label class="secondary" id="fhirImportLabel" style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.4rem 0.8rem;border-radius:0.5rem;cursor:pointer;">Importér FHIR...
        <input type="file" id="fhirImport" accept="application/json" style="display:none;">
      </label>
    </div>
    <table><thead><tr><th>Tid</th><th>Sender</th><th>Patient</th><th>Rapport</th><th>Varianter</th></tr></thead><tbody>
      ${list.map(r => `<tr><td>${esc(r.ts)}</td><td>${esc(r.sender||'')}</td><td>${esc(r.patient||'')}</td><td>${esc(r.diagnostic_report_id||'')}</td><td>${esc(r.variant_count||0)}</td></tr>`).join('') || '<tr><td colspan="5">Ingen svar</td></tr>'}
    </tbody></table>
  </div>
  <div class="panel">
    <h2>Udgående MedCom-svar</h2>
    <label>Vælg ordre<select id="fhirOrderSelect"><option value="">Vælg...</option>${getCached('orders').map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}</select></label>
    <div class="btn-row">
      <button class="primary" id="generateFhir">Generér FHIR-bundle</button>
      <button class="secondary" id="previewFhir">Forhåndsvis</button>
    </div>
    <pre id="fhirPreview" style="display:none"></pre>
  </div>`;
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  const orderLabel = section.querySelector('#fhirOrderSelect')?.closest('label');
  if (orderLabel) setTooltip(orderLabel, tooltipCatalog.controls.fhirOrderSelect);
  section.querySelector('#fhirOrderSelect').addEventListener('change', () => section.querySelector('#fhirPreview').style.display='none');
  section.querySelector('#generateFhir').addEventListener('click', () => exportFhir(section, true));
  section.querySelector('#previewFhir').addEventListener('click', () => exportFhir(section, false));
  section.querySelector('#fhirImport').addEventListener('change', async e => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const json = JSON.parse(text);
      await handleInboundFhir(json, true);
      alert('FHIR bundle importeret.');
      await loadStore('responses');
      renderTab('responses');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke importere: ' + err.message);
    }
    e.target.value = '';
  });
}
async function exportFhir(section, download) {
  const select = section.querySelector('#fhirOrderSelect');
  const id = Number(select.value);
  if (!id) return alert('Vælg ordre');
  const bundle = buildFhirBundle(id);
  const json = JSON.stringify(bundle, null, 2);
  const preview = section.querySelector('#fhirPreview');
  preview.textContent = json;
  preview.style.display = 'block';
  if (download) {
    const blob = new Blob([json], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp(`glimr-ordre-${id}.json`);
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`FHIR-meddelelse for ordination ${id} downloadet som ${filename}.`);
  }
}
function buildFhirBundle(orderId) {
  const order = findById('orders', orderId);
  if (!order) throw new Error('Ordination ikke fundet');
  const patient = findById('patients', Number(order.patient_id));
  const sample = findById('samples', Number(order.sample_id));
  const panel = order.panel_id ? findById('panels', Number(order.panel_id)) : null;
  const report = getCached('reports').find(r => r.order_id === orderId) || {status:'final', summary:'', variant_ids:'[]', variant_details:[]};
  let variants = getReportVariantSnapshots(report, orderId);
  if (!variants.length) {
    variants = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
  }
  const timestamp = new Date().toISOString();
  const patientIdentifiers = [];
  if (patient?.mrn) patientIdentifiers.push({system:'urn:oid:1.2.208.176.1.2', value:patient.mrn});
  if (patient?.extra_id) patientIdentifiers.push({system:'urn:glimr:patient-extra-id', value:patient.extra_id});
  const patientResource = {
    resourceType:'Patient',
    id:`patient-${patient?.id||order.patient_id}`,
    identifier: patientIdentifiers.length ? patientIdentifiers : undefined,
    name: patient?.name ? [{text:patient.name}] : undefined,
    gender: patient?.gender || undefined,
    birthDate: patient?.birth_date || undefined
  };
  const specimenResource = {
    resourceType:'Specimen',
    id:`specimen-${sample?.id||order.sample_id}`,
    status:'available',
    identifier: sample?.pmb_number ? [{system:'urn:glimr:pmb', value: sample.pmb_number}] : undefined,
    type: {text: sample?.sample_type || 'Genomic specimen'},
    receivedTime: sample?.collected_at || undefined,
    subject: {reference:`Patient/${patientResource.id}`}
  };
  const producerOrg = {
    resourceType:'Organization',
    id:'org-producer',
    name:'GenLab Producer'
  };
  const requesterOrg = {
    resourceType:'Organization',
    id:'org-requester',
    name: order.clinician || 'Requester'
  };
  const diagnosticReport = {
    resourceType:'DiagnosticReport',
    id:`dr-${orderId}`,
    status: report.status || 'final',
    category:[{coding:[{system:'http://terminology.hl7.org/CodeSystem/v2-0074', code:'LAB', display:'Laboratory'}]}],
    code:{coding:[{system:'http://loinc.org', code:'51969-4', display:'Genetic analysis report'}]},
    subject:{reference:`Patient/${patientResource.id}`},
    effectiveDateTime: report.issued_at || new Date().toISOString(),
    issued: report.issued_at || new Date().toISOString(),
    performer:[{reference:'Organization/org-producer'}],
    resultsInterpreter: requesterOrg.name ? [{reference:'Organization/org-requester'}] : undefined,
    conclusion: report.summary || undefined
  };
  const narrative = variants.map(describeVariantNarrative).filter(Boolean).join('\n');
  if (narrative) {
    diagnosticReport.presentedForm = [{contentType:'text/plain', data:base64EncodeUtf8(narrative)}];
  }
  const entries = [];
  const addEntry = resource => entries.push({fullUrl:`urn:uuid:${crypto.randomUUID?.() || Math.random().toString(36).slice(2)}`, resource});
  const messageHeader = {
    resourceType:'MessageHeader',
    id:`mh-${orderId}`,
    eventCoding:{system:'http://medcom.dk/fhir/medcom-messaging-communication-event', code:'medcom-lab-reporting', display:'MedCom Lab Report'},
    source:{name:'GlimR'},
    destination:[{name:'Recipient'}],
    sender:{reference:'Organization/org-producer'},
    focus:[{reference:`DiagnosticReport/${diagnosticReport.id}`}] 
  };
  addEntry(messageHeader);
  addEntry(patientResource);
  addEntry(producerOrg);
  addEntry(requesterOrg);
  addEntry(specimenResource);
  addEntry(diagnosticReport);
  variants.forEach((variant, idx) => {
    const obs = {
      resourceType:'Observation',
      id:`var-${orderId}-${idx+1}`,
      status:'final',
      category:[{coding:[{system:'http://terminology.hl7.org/CodeSystem/observation-category', code:'laboratory'}]}],
      code:{coding:[{system:'http://loinc.org', code:'69548-6', display:'Genomic sequence variation interpretation'}]},
      subject:{reference:`Patient/${patientResource.id}`},
      specimen:{reference:`Specimen/${specimenResource.id}`},
      valueCodeableConcept:{text:[variant.hgvs_c, variant.hgvs_p].filter(Boolean).join(' / ') || variant.gene},
      component:[{code:{text:'Gene'}, valueCodeableConcept:{text:variant.gene}}],
      interpretation: classificationMap[String(variant.classification)] ? [{coding:[{system:'http://loinc.org', code:classificationMap[String(variant.classification)].code, display:classificationMap[String(variant.classification)].display}]}] : undefined,
      note: variant.criteria ? [{text:`ACMG: ${variant.criteria}`}]: undefined
    };
    addEntry(obs);
    diagnosticReport.result = diagnosticReport.result || [];
    diagnosticReport.result.push({reference:`Observation/${obs.id}`});
  });
  const bundle = {
    resourceType:'Bundle',
    type:'message',
    timestamp,
    entry: entries
  };
  return bundle;
}
async function handleInboundFhir(bundle, offerLibrary=false) {
  if (!ensureWrite('responses')) return;
  if (!bundle || bundle.resourceType !== 'Bundle') throw new Error('Ikke en FHIR Bundle');
  const entries = bundle.entry || [];
  const findResource = type => entries.map(e => e.resource).find(r => r.resourceType === type);
  const diagnosticReport = findResource('DiagnosticReport');
  const patient = findResource('Patient');
  const observations = entries.map(e => e.resource).filter(r => r.resourceType === 'Observation');
  const response = {
    ts: new Date().toISOString(),
    sender: findResource('MessageHeader')?.sender?.reference || 'ukendt',
    patient: patient?.name?.[0]?.text || patient?.id || '',
    diagnostic_report_id: diagnosticReport?.id || '',
    variant_count: observations.length,
    variants: JSON.stringify(observations.map(o => ({gene:o.component?.[0]?.valueCodeableConcept?.text, note:o.note?.[0]?.text, value:o.valueCodeableConcept?.text}))),
    raw: JSON.stringify(bundle)
  };
  await addRecord('responses', response);
  if (offerLibrary && observations.length) {
    if (ensureWrite('variant_library') && confirm('Tilføj varianter til bibliotek?')) {
      for (const obs of observations) {
        const note = obs.note?.[0]?.text || '';
        await addRecord('variant_library', {
          gene: obs.component?.[0]?.valueCodeableConcept?.text || '',
          transcript: '',
          hgvs_c: obs.valueCodeableConcept?.text || '',
          hgvs_p: '',
          classification: note.includes('Pathogenic') ? '5' : '',
          criteria: note.replace('ACMG: ','') || '',
          evidence: note,
          condition: '',
          inheritance: '',
          curated_by: 'FHIR import',
          last_review: new Date().toISOString().split('T')[0]
        });
      }
      await loadStore('variant_library');
    }
  }
}
function renderUsers(section) {
  const list = getCached('users');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="userSearch">Søg</label>
        <input id="userSearch" type="search" placeholder="Navn/mail...">
        <table><thead><tr><th>ID</th><th>Navn</th><th>E-mail</th><th>Rolle</th></tr></thead><tbody></tbody></table>
      </div>
      <div>
        <h2>Bruger</h2>
        <form id="userForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <label>E-mail<input type="email" name="email" required></label>
          <label>Rolle<select name="role" required>${ROLE_OPTIONS.map(opt => `<option value="${opt.value}">${opt.value} – ${opt.description}</option>`).join('')}</select></label>
          <label>Adgangskode (PIN)<input type="password" name="pin" placeholder="Valgfri kode"></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="userClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="userDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#userSearch');
  const form = section.querySelector('#userForm');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  let selectedUserId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filteredUsers = list.filter(u => !term || [u.name,u.email,u.role].some(v => (v||'').toLowerCase().includes(term)));
    if (selectedUserId != null && !filteredUsers.some(u => u.id === selectedUserId)) {
      selectedUserId = null;
    }
    tbody.innerHTML = filteredUsers.map(u => {
      const selectedAttr = u.id === selectedUserId ? ' data-selected="true"' : '';
      const emailCell = u.email
        ? `<a href="mailto:${encodeURIComponent(u.email)}">${esc(u.email)}</a>`
        : '';
      return `<tr data-id="${u.id}"${selectedAttr}><td>${u.id}</td><td>${esc(u.name)}</td><td>${emailCell}</td><td>${esc(roleLabel(u.role))}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const user = list.find(u => u.id === Number(tr.dataset.id));
    if (!user) return;
    selectedUserId = user.id;
    fillForm(form, user);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('users')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('users', id)};
      if (!data.pin) data.pin = before?.pin || '';
      const updated = {...before, ...data, id};
      await updateRecord('users', updated, before);
    } else {
      if (!data.pin) data.pin = '';
      delete data.id;
      await addRecord('users', data);
    }
    await loadStore('users');
    refreshLoginOptions();
    restoreUserSession();
    renderTab('users');
  });
  section.querySelector('#userDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg bruger');
    if (!ensureWrite('users')) return;
    if (confirm('Slet bruger?')) {
      await deleteRecord('users', id);
      refreshLoginOptions();
      const storedId = storage.getItem('glimr-user-id');
      if (storedId && Number(storedId) === id) {
        logoutUser();
      }
      renderTab('users');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedUserId = null;
    renderRows();
  });
  section.querySelector('#userClear').addEventListener('click', () => form.reset());
}
function renderAudit(section) {
  const list = getCached('audit').slice().reverse();
  section.innerHTML = `
  <div class="panel">
    <table><thead><tr><th>Tid</th><th>Bruger</th><th>Handling</th><th>Entitet</th><th>ID</th><th>Før</th><th>Efter</th></tr></thead><tbody>
      ${list.map(a => `<tr><td>${esc(a.ts)}</td><td>${esc(a.user)}</td><td>${esc(a.action)}</td><td>${esc(a.entity)}</td><td>${esc(a.entity_id??'')}</td><td>${esc(a.before||'')}</td><td>${esc(a.after||'')}</td></tr>`).join('') || '<tr><td colspan="7">Ingen revisionsposter</td></tr>'}
    </tbody></table>
  </div>`;
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
}

function renderDbTab(section) {
  section = section || document.querySelector('section[data-tab="db"]');
  const status = state.boundHandle ? `Tilknyttet fil: ${state.boundHandle.name}` : 'Ingen fil tilknyttet';
  const memoryWarning = state.usingMemoryDb
    ? '<p class="panel-hint warning">Browseren blokerer for IndexedDB. Data gemmes kun midlertidigt i denne session.</p>'
    : '';
  if (!section) return;
  section.innerHTML = `
  <div class="panel">
    <h2>Filbaseret database</h2>
    <p>${esc(status)}</p>
    ${memoryWarning}
    <div class="btn-row">
      <button class="secondary" id="bindFile">Knyt/åbn DB-fil...</button>
      <button class="secondary" id="saveNow">Gem nu</button>
      <label style="display:flex;align-items:center;gap:0.5rem;">
        <input type="checkbox" id="autosaveToggle" ${state.autosave?'checked':''}> Autogem
      </label>
    </div>
  </div>
  <div class="panel">
    <h2>Backup</h2>
    <div class="btn-row">
      <button class="secondary" id="downloadBackup">Hent backup (JSON)</button>
      <label class="secondary" id="restoreLabel" style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.4rem 0.8rem;border-radius:0.5rem;cursor:pointer;">Gendan fra backup<input type="file" id="restoreFile" accept="application/json" style="display:none;"></label>
    </div>
    <div class="btn-row">
      <button class="danger" id="resetDataBtn">Backup &amp; ryd data (undtagen brugere)</button>
    </div>
    <p class="panel-hint">Downloader en fuld backup og nulstiller alle andre data. Kræver skriveadgang.</p>
  </div>`;
  applyButtonTooltips(section);
  applyControlTooltips(section);
  section.querySelector('#bindFile').addEventListener('click', bindDbFile);
  section.querySelector('#saveNow').addEventListener('click', manualSave);
  section.querySelector('#autosaveToggle').addEventListener('change', e => {
    state.autosave = e.target.checked;
    setStatus('Autogemning ' + (state.autosave ? 'aktiveret' : 'deaktiveret'));
  });
  section.querySelector('#downloadBackup').addEventListener('click', downloadBackup);
  section.querySelector('#restoreFile').addEventListener('change', async e => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      await restoreFromFile(file);
      alert('Backup gendannet.');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke gendanne: ' + err.message);
    }
    e.target.value = '';
  });
  const resetBtn = section.querySelector('#resetDataBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', backupAndResetData);
  }
}
function renderAdmin(section) {
  section.innerHTML = `
  <div class="panel">
    <div class="btn-row">
      <button class="primary" id="demoDataBtn">Indlæs demo-data</button>
    </div>
    <div class="btn-row">
      <button class="primary" id="downloadSql">Hent glimr.sql</button>
      <button class="secondary" id="showSchema">Vis skema</button>
      <button class="secondary" id="downloadZip">Hent ZIP</button>
    </div>
    <textarea id="schemaText" style="width:100%;min-height:200px;margin-top:1rem;display:none;"></textarea>
  </div>
  <div class="panel">
    <div class="flex">
      <div>
        <label for="patientGroupSearch">Søg</label>
        <input id="patientGroupSearch" type="search" placeholder="Patientgruppe...">
        <table data-patient-group-table>
          <thead><tr><th>ID</th><th>Navn</th><th>Opdateret</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h2>Patientgruppe</h2>
        <form id="patientGroupForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="patientGroupClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="patientGroupDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  applyButtonTooltips(section);
  applyControlTooltips(section);
  const demoBtn = section.querySelector('#demoDataBtn');
  if (demoBtn) {
    demoBtn.addEventListener('click', () => {
      if (!ensureWrite('patients')) return;
      loadDemoData();
    });
  }
  section.querySelector('#downloadSql').addEventListener('click', async () => {
    const sql = await generateSqlDump();
    const blob = new Blob([sql], {type:'text/sql'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp('glimr.sql');
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`MySQL-dump downloadet som ${filename}.`);
  });
  section.querySelector('#showSchema').addEventListener('click', async () => {
    const sql = await generateSqlDump();
    const textarea = section.querySelector('#schemaText');
    textarea.value = sql;
    textarea.style.display = 'block';
  });
  section.querySelector('#downloadZip').addEventListener('click', async () => {
    const files = await buildZipFiles();
    const zipBytes = createZip(files);
    const blob = new Blob([zipBytes], {type:'application/zip'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp('glimr.zip');
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`ZIP-arkiv downloadet som ${filename}.`);
  });
  const groupTableBody = section.querySelector('[data-patient-group-table] tbody');
  const groupSearch = section.querySelector('#patientGroupSearch');
  const groupForm = section.querySelector('#patientGroupForm');
  const groupClearBtn = section.querySelector('#patientGroupClear');
  const groupDeleteBtn = section.querySelector('#patientGroupDelete');
  const groups = getCached('patient_groups').slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'da'));
  let filteredGroups = groups.slice();
  let selectedGroupId = null;
  const refreshDependentTabs = () => {
    ['orders','case_create','reports'].forEach(id => {
      const target = document.querySelector(`section[data-tab="${id}"]`);
      if (target && target.classList.contains('active')) {
        renderTab(id);
      }
    });
  };
  const renderGroupRows = () => {
    if (!groupTableBody) return;
    const term = (groupSearch?.value || '').trim().toLowerCase();
    filteredGroups = groups.filter(group => {
      if (!term) return true;
      const haystack = `${group.name || ''} ${(group.created_by || '')}`.toLowerCase();
      return haystack.includes(term);
    });
    if (!filteredGroups.length) {
      groupTableBody.innerHTML = '<tr><td colspan="3">Ingen patientgrupper.</td></tr>';
      annotateTableCells(section);
      return;
    }
    groupTableBody.innerHTML = filteredGroups.map(group => {
      const updated = formatDanishDate(group.updated_at, true) || formatDanishDate(group.updated_at) || (group.updated_at || '');
      const selectedAttr = group.id === selectedGroupId ? ' data-selected="true"' : '';
      return `<tr data-id="${group.id}"${selectedAttr}><td>${group.id}</td><td>${esc(group.name || '')}</td><td>${esc(updated)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderGroupRows();
  groupSearch?.addEventListener('input', renderGroupRows);
  groupTableBody?.addEventListener('click', evt => {
    const row = evt.target.closest('tr[data-id]');
    if (!row) return;
    const id = Number(row.dataset.id);
    const group = groups.find(item => item.id === id);
    if (!group) return;
    selectedGroupId = id;
    if (groupForm) {
      fillForm(groupForm, group);
    }
    renderGroupRows();
  });
  groupClearBtn?.addEventListener('click', () => {
    groupForm?.reset();
    selectedGroupId = null;
    renderGroupRows();
  });
  groupForm?.addEventListener('submit', async evt => {
    evt.preventDefault();
    if (!ensureWrite('patient_groups')) return;
    const data = Object.fromEntries(new FormData(groupForm).entries());
    data.name = (data.name || '').trim();
    if (!data.name) {
      alert('Angiv et navn for patientgruppen.');
      groupForm.elements.name?.focus();
      return;
    }
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('patient_groups', id)};
      const updated = {...before, ...data, id};
      await updateRecord('patient_groups', updated, before);
    } else {
      delete data.id;
      await addRecord('patient_groups', data);
    }
    await loadStore('patient_groups');
    renderTab('admin');
    refreshDependentTabs();
  });
  groupDeleteBtn?.addEventListener('click', async () => {
    const id = Number(groupForm?.elements.id?.value);
    if (!id) {
      alert('Vælg en patientgruppe der skal slettes.');
      return;
    }
    if (!ensureWrite('patient_groups')) return;
    if (!confirm('Slet patientgruppe? Dette påvirker ikke eksisterende ordinationer, men feltet vil stå tomt.')) return;
    await deleteRecord('patient_groups', id);
    await loadStore('patient_groups');
    renderTab('admin');
    refreshDependentTabs();
  });
}
function renderTestsTab(section) {
  section.innerHTML = `
  <div class="panel">
    <h2>Selvtest</h2>
    <div class="btn-row">
      <button class="primary" id="runTestsBtn">Kør selvtest</button>
    </div>
    <table><thead><tr><th>Test</th><th>Status</th><th>Detaljer</th></tr></thead><tbody id="testsBody"></tbody></table>
  </div>`;
  const tbody = section.querySelector('#testsBody');
  if (tbody) {
    tbody.innerHTML = state.testResults.length
      ? state.testResults.map(([name, pass, detail]) => `<tr><td>${esc(name)}</td><td>${pass ? 'OK' : 'FEJL'}</td><td>${esc(detail||'')}</td></tr>`).join('')
      : '<tr><td colspan="3">Ingen tests kørt endnu.</td></tr>';
  }
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  const testsBtn = section.querySelector('#runTestsBtn');
  if (testsBtn) {
    testsBtn.addEventListener('click', () => {
      runTests();
    });
  }
}
async function runTests() {
  if (!ensureWrite('patients')) return;
  let section = document.querySelector('section[data-tab="tests"]');
  if (!section) {
    activateTab('tests');
    return setTimeout(runTests, 200);
  }
  setStatus('Kører selvtest...');
  const snapshot = await exportData();
  const results = [];
  try {
    const patientId = await addRecord('patients', {mrn:'TEST1', name:'Testpatient', gender:'other', birth_date:'1980-01-01', notes:''});
    const patient = findById('patients', patientId);
    results.push(['Oprettelse/udlæsning patient', patient?.name === 'Testpatient', `Navn: ${patient?.name}`]);
    const sampleId = await addRecord('samples', {patient_id:patientId, pmb_number:`PMB-SELFTST-${Date.now()}`, sample_type:'Blod', status:'Modtaget', collected_at:new Date().toISOString(), notes:''});
    const orderId = await addRecord('orders', {patient_id:patientId, sample_id:sampleId, panel_id:null, clinician:'Testperson', status:'Analyse', acute:false, urgent:false, ordered_at:new Date().toISOString()});
    await addRecord('variants', {
      order_id: orderId,
      gene: 'BRCA1',
      transcript: '',
      hgvs_c: 'c.5266dupC',
      hgvs_p: 'p.(Gln1756Profs*74)',
      classification: '5',
      criteria: 'PVS1',
      af: '',
      interpretation: ''
    });
    const variantCount = getCached('variants').filter(v => v.order_id === orderId).length;
    results.push(['Tilføj testvariant', variantCount > 0, `Varianter: ${variantCount}`]);
    results.push(['Oprettelse ordination med FK', !!findById('orders', orderId), `Ordination ${orderId}`]);
    const variantDetails = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
    const reportHtml = buildReportHtml(orderId, {status:'draft', issued_at:new Date().toISOString(), summary:'Test', variant_details: variantDetails});
    results.push(['Generering af rapport HTML', reportHtml.includes('Diagnostisk rapport'), 'HTML længde ' + reportHtml.length]);
    const bundle = buildFhirBundle(orderId);
    const hasResources = ['MessageHeader','Patient','DiagnosticReport','Observation'].every(type => (bundle.entry||[]).some(e => e.resource.resourceType === type));
    results.push(['Udgående FHIR-bundle indhold', hasResources, `Ressourcer: ${(bundle.entry||[]).length}`]);
    const files = await buildZipFiles();
    const zip = createZip(files);
    const view = new DataView(zip.buffer);
    const centralDirOffset = view.getUint32(zip.length - 6, true);
    results.push(['ZIP-bytes genereret', centralDirOffset > 0, `Centraldir-offset: ${centralDirOffset}`]);
    const sql = await generateSqlDump();
    results.push(['SQL-dump indeholder variants.criteria', sql.includes('`criteria`'), 'Længde ' + sql.length]);
    results.push(['Filbinding API', 'showOpenFilePicker' in window || 'showSaveFilePicker' in window, 'Filadgang ' + (('showOpenFilePicker' in window) ? 'tilgængelig' : 'ukendt')]);
  } catch (err) {
    console.error(err);
    results.push(['Testfejl', false, err.message]);
  } finally {
    state.testResults = results;
    await replaceAllData(snapshot);
    renderAll();
    section = document.querySelector('section[data-tab="tests"]');
    if (section) renderTestsTab(section);
    setStatus('Selvtest gennemført. Data gendannet til udgangspunktet.');
  }
}
async function buildZipFiles() {
  const backup = JSON.stringify(await exportData(), null, 2);
  const html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
  const readme = 'GlimR - lokalt enkeltfil-LIMS\n\nÅbn GlimR.html i en moderne browser.\n';
  return [
    {name:'GlimR.html', data:utf8Encode(html)},
    {name:'glimr-backup.json', data:utf8Encode(backup)},
    {name:'README.txt', data:utf8Encode(readme)}
  ];
}
function base64EncodeUtf8(str) {
  const bytes = utf8Encode(str);
  let binary = '';
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  return btoa(binary);
}
function utf8Encode(str) {
  return new TextEncoder().encode(str);
}
function crc32(buf) {
  let crc = -1;
  for (let i=0; i<buf.length; i++) {
    crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ buf[i]) & 0xff];
  }
  return (crc ^ -1) >>> 0;
}
const CRC_TABLE = (() => {
  const table = new Uint32Array(256);
  for (let n=0; n<256; n++) {
    let c = n;
    for (let k=0; k<8; k++) {
      c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[n] = c >>> 0;
  }
  return table;
})();
function createZip(files) {
  let total = 0;
  files.forEach(f => total += 30 + f.name.length + f.data.length);
  total += files.length * 46;
  total += 22;
  const buffer = new Uint8Array(total + 1024);
  let offset = 0;
  const central = [];
  const now = new Date();
  const dostime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() / 2)) & 0xffff;
  const dosdate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth()+1) << 5) | now.getDate()) & 0xffff;
  for (const file of files) {
    const nameBytes = utf8Encode(file.name);
    const crc = crc32(file.data);
    const localHeader = new DataView(buffer.buffer, offset, 30);
    localHeader.setUint32(0, 0x04034b50, true);
    localHeader.setUint16(4, 20, true);
    localHeader.setUint16(6, 0, true);
    localHeader.setUint16(8, 0, true);
    localHeader.setUint16(10, dostime, true);
    localHeader.setUint16(12, dosdate, true);
    localHeader.setUint32(14, crc, true);
    localHeader.setUint32(18, file.data.length, true);
    localHeader.setUint32(22, file.data.length, true);
    localHeader.setUint16(26, nameBytes.length, true);
    localHeader.setUint16(28, 0, true);
    offset += 30;
    buffer.set(nameBytes, offset);
    offset += nameBytes.length;
    buffer.set(file.data, offset);
    offset += file.data.length;
    central.push({nameBytes, crc, size:file.data.length, offset: offset - file.data.length - nameBytes.length - 30});
  }
  const centralStart = offset;
  for (const entry of central) {
    const view = new DataView(buffer.buffer, offset, 46);
    view.setUint32(0, 0x02014b50, true);
    view.setUint16(4, 0x031E, true);
    view.setUint16(6, 20, true);
    view.setUint16(8, 0, true);
    view.setUint16(10, 0, true);
    view.setUint16(12, dostime, true);
    view.setUint16(14, dosdate, true);
    view.setUint32(16, entry.crc, true);
    view.setUint32(20, entry.size, true);
    view.setUint32(24, entry.size, true);
    view.setUint16(28, entry.nameBytes.length, true);
    view.setUint16(30, 0, true);
    view.setUint16(32, 0, true);
    view.setUint16(34, 0, true);
    view.setUint16(36, 0, true);
    view.setUint32(38, 0, true);
    view.setUint32(42, entry.offset, true);
    offset += 46;
    buffer.set(entry.nameBytes, offset);
    offset += entry.nameBytes.length;
  }
  const centralSize = offset - centralStart;
  const view = new DataView(buffer.buffer, offset, 22);
  view.setUint32(0, 0x06054b50, true);
  view.setUint16(4, 0, true);
  view.setUint16(6, 0, true);
  view.setUint16(8, central.length, true);
  view.setUint16(10, central.length, true);
  view.setUint32(12, centralSize, true);
  view.setUint32(16, centralStart, true);
  view.setUint16(20, 0, true);
  offset += 22;
  return buffer.slice(0, offset);
}
async function generateSqlDump() {
  const createStatements = `SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS=0;
CREATE TABLE IF NOT EXISTS \`patients\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`mrn\` VARCHAR(64),
  \`extra_id\` VARCHAR(64),
  \`family_number\` VARCHAR(64),
  \`name\` VARCHAR(255),
  \`gender\` VARCHAR(32),
  \`birth_date\` DATE,
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`users\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`name\` VARCHAR(255),
  \`email\` VARCHAR(255),
  \`role\` VARCHAR(128),
  \`pin\` VARCHAR(128),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`panels\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`name\` VARCHAR(255),
  \`description\` TEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`samples\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`pmb_number\` VARCHAR(64),
  \`patient_id\` INT,
  \`sample_type\` VARCHAR(128),
  \`collected_at\` DATETIME,
  \`status\` VARCHAR(64),
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_samples_patient FOREIGN KEY (patient_id) REFERENCES patients(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  CREATE TABLE IF NOT EXISTS \`orders\` (
    \`id\` INT AUTO_INCREMENT PRIMARY KEY,
    \`patient_id\` INT,
    \`sample_id\` INT,
    \`panel_id\` INT NULL,
    \`analysis_responsible_id\` INT NULL,
    \`interpreter_id\` INT NULL,
    \`approver_id\` INT NULL,
    \`patient_group_id\` INT NULL,
    \`clinician\` VARCHAR(255),
    \`status\` VARCHAR(64),
    \`urgent\` TINYINT(1) DEFAULT 0,
    \`ordered_at\` DATETIME,
    \`created_by\` VARCHAR(255),
    \`created_at\` DATETIME,
    \`updated_at\` DATETIME,
    CONSTRAINT fk_orders_patient FOREIGN KEY (patient_id) REFERENCES patients(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_orders_sample FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_orders_panel FOREIGN KEY (panel_id) REFERENCES panels(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_analysis_responsible FOREIGN KEY (analysis_responsible_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_interpreter FOREIGN KEY (interpreter_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_approver FOREIGN KEY (approver_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_patient_group FOREIGN KEY (patient_group_id) REFERENCES patient_groups(id) ON DELETE SET NULL ON UPDATE CASCADE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  CREATE TABLE IF NOT EXISTS \`patient_groups\` (
    \`id\` INT AUTO_INCREMENT PRIMARY KEY,
    \`name\` VARCHAR(255),
    \`created_by\` VARCHAR(255),
    \`created_at\` DATETIME,
    \`updated_at\` DATETIME
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  CREATE TABLE IF NOT EXISTS \`reports\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`order_id\` INT,
  \`findings\` TEXT,
  \`variant_ids\` TEXT,
  \`variant_details\` LONGTEXT,
  \`summary\` TEXT,
  \`status\` VARCHAR(32),
  \`issued_at\` DATETIME,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_reports_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`qc_metrics\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`sample_id\` INT,
  \`metric\` VARCHAR(128),
  \`value\` DECIMAL(18,6),
  \`unit\` VARCHAR(64),
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_qc_sample FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`variants\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`order_id\` INT,
  \`gene\` VARCHAR(128),
  \`transcript\` VARCHAR(128),
  \`hgvs_c\` VARCHAR(255),
  \`hgvs_p\` VARCHAR(255),
  \`zygosity\` VARCHAR(64),
  \`classification\` VARCHAR(8),
  \`criteria\` VARCHAR(255),
  \`af\` DECIMAL(18,6),
  \`interpretation\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_variants_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`variant_library\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`gene\` VARCHAR(128),
  \`transcript\` VARCHAR(128),
  \`hgvs_c\` VARCHAR(255),
  \`hgvs_p\` VARCHAR(255),
  \`classification\` VARCHAR(8),
  \`criteria\` VARCHAR(255),
  \`evidence\` TEXT,
  \`condition\` VARCHAR(255),
  \`inheritance\` VARCHAR(128),
  \`curated_by\` VARCHAR(255),
  \`last_review\` DATE,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`conclusion_library\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`title\` VARCHAR(255),
  \`body\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`responses\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`ts\` DATETIME,
  \`sender\` VARCHAR(255),
  \`patient\` VARCHAR(255),
  \`diagnostic_report_id\` VARCHAR(255),
  \`variant_count\` INT,
  \`variants\` TEXT,
  \`raw\` LONGTEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`audit_log\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`ts\` DATETIME,
  \`user\` VARCHAR(128),
  \`action\` VARCHAR(64),
  \`entity\` VARCHAR(64),
  \`entity_id\` INT,
  \`before\` LONGTEXT,
  \`after\` LONGTEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;`;
  const rows = await exportData();
  const inserts = [];
  const mapTable = {
    patients: 'patients',
    patient_groups: 'patient_groups',
    users: 'users',
    samples: 'samples',
    panels: 'panels',
    orders: 'orders',
    reports: 'reports',
    qc: 'qc_metrics',
    variants: 'variants',
    variant_library: 'variant_library',
    conclusion_library: 'conclusion_library',
    responses: 'responses',
    audit: 'audit_log'
  };
  for (const [store, table] of Object.entries(mapTable)) {
    const data = rows[store] || [];
    if (!data.length) continue;
    const fields = schemaFields[store];
    const fieldList = fields.map(f => `\`${f}\``).join(',');
    const values = data
      .map(row => `(${fields.map(field => sqlValue(row[field])).join(',')})`)
      .join(',\n');
    inserts.push(
      `INSERT INTO \`${table}\` (${fieldList}) VALUES\n${values};`
    );
  }
  return createStatements + inserts.join('\n\n') + '\n';
}


function sqlValue(val) {
  if (val === null || val === undefined || val === '') return 'NULL';
  if (typeof val === 'number') return String(val);
  const str = String(val).replace(/'/g, "''");
  return `'${str}'`;
}
async function loadDemoData() {
  if (!ensureWrite('patients')) return;
  if (!confirm('Indlæse demo-data? Dette overskriver ikke eksisterende poster men tilføjer hvis tomt.')) return;
  const groups = getCached('patient_groups');
  const firstGroupId = groups[0]?.id || null;
  const secondGroupId = groups[1]?.id || firstGroupId;
  if (!getCached('patients').length) {
    const p1 = await addRecord('patients', {mrn:'MRN001', extra_id:'ALT-001', family_number:'FAM-001', name:'Anna Jensen', gender:'female', birth_date:'1985-03-12', notes:'Familiehistorik positiv'});
    const p2 = await addRecord('patients', {mrn:'MRN002', extra_id:'ALT-002', family_number:'FAM-002', name:'Lars Petersen', gender:'male', birth_date:'1978-11-03', notes:''});
    const s1 = await addRecord('samples', {patient_id:p1, pmb_number:'PMB-0001', sample_type:'Blod', status:'QC', collected_at:new Date().toISOString(), notes:''});
    const s2 = await addRecord('samples', {patient_id:p2, pmb_number:'PMB-0002', sample_type:'Kindskrab', status:'Analyse', collected_at:new Date().toISOString(), notes:''});
    const panel = await addRecord('panels', {name:'Onko-panel', description:'50 gener'});
    const o1 = await addRecord('orders', {patient_id:p1, sample_id:s1, panel_id:panel, analysis_responsible_id:null, interpreter_id:null, approver_id:null, clinician:'Dr. Holm', indication:'Mistanke om arvelig brystkræft', patient_group_id:firstGroupId, hpo_terms:normalizeHpoTerms('HP:0003002; HP:0006770'), status:'Analyse', acute:false, urgent:false, ordered_at:new Date().toISOString()});
    const o2 = await addRecord('orders', {patient_id:p2, sample_id:s2, panel_id:panel, analysis_responsible_id:null, interpreter_id:null, approver_id:null, clinician:'Dr. Holm', indication:'Kolorektal cancer – postoperativ opfølgning', patient_group_id:secondGroupId, hpo_terms:normalizeHpoTerms('HP:0100242'), status:'Rapport', acute:false, urgent:false, ordered_at:new Date().toISOString()});
    await addRecord('variants', {order_id:o1, gene:'BRCA1', transcript:'NM_007294.3', hgvs_c:'c.5266dupC', hgvs_p:'p.Gln1756Profs', zygosity:'heterozygot', classification:'5', criteria:'PVS1,PS3,PM2,PP3', af:0.0001, interpretation:'Patogen variant med høj risiko'});
    await addRecord('qc', {sample_id:s1, metric:'Dækning', value:98.5, unit:'%', notes:''});
    await addRecord('reports', {order_id:o2, variant_ids:'[]', variant_details:[], summary:'Negativ rapport', status:'final', issued_at:new Date().toISOString()});
    await addRecord('users', {name:'Admin', email:'admin@example.com', role:'Administrator', pin:'admin'});
  } else {
    alert('Demo-data allerede til stede.');
  }
  await loadAllStores();
  renderAll();
  refreshLoginOptions();
  updateAuthUi();
}
function hookUi() {
  const loginForm = document.getElementById('loginForm');
  if (loginForm) loginForm.addEventListener('submit', handleLogin);
  const logoutBtn = document.getElementById('logoutBtn');
  if (logoutBtn) {
    logoutBtn.addEventListener('click', logoutUser);
    setTooltip(logoutBtn, tooltipCatalog.buttons.logoutBtn);
  }
  const themeBtn = document.getElementById('themeToggle');
  if (themeBtn) {
    themeBtn.addEventListener('click', toggleTheme);
    setTooltip(themeBtn, tooltipCatalog.buttons.themeToggle);
  }
  const logoImg = document.getElementById('glimrLogo');
  if (logoImg) {
    const brand = logoImg.closest('.brand');
    const brandMark = brand ? brand.querySelector('.brand-mark') : null;
    const showBrandMark = (show) => {
      if (!brandMark) return;
      brandMark.setAttribute('aria-hidden', show ? 'false' : 'true');
    };
    const markMissing = () => {
      if (brand) {
        brand.classList.add('logo-missing');
      }
      showBrandMark(true);
      if (logoImg.parentElement) {
        logoImg.remove();
      }
    };
    const markLoaded = () => {
      if (brand) {
        brand.classList.remove('logo-missing');
      }
      showBrandMark(false);
    };
    logoImg.addEventListener('error', markMissing, { once: true });
    logoImg.addEventListener('load', markLoaded);
    if (logoImg.complete) {
      if (logoImg.naturalWidth === 0) {
        markMissing();
      } else {
        markLoaded();
      }
    } else {
      markLoaded();
    }
  }
  applyTheme();
  refreshLoginOptions();
  updateAuthUi();
  applyControlTooltips(document.body);
}
async function init() {
  initTabs();
  try {
    setStatus('Åbner database...');
    state.db = await openDb();
    setStatus(state.usingMemoryDb ? 'Database åben (midlertidig hukommelse)' : 'Database åben');
    await loadAllStores();
    await ensureDefaultPatientGroups();
    await ensureCreationMetadata();
    hookUi();
    restoreUserSession();
    renderAll();
    activateTab('dashboard');
  } catch (err) {
    console.error(err);
    setStatus('Kunne ikke åbne database: ' + err.message);
  }
}
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
})();
</script>
</body>
</html>
