<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<title>GlimR – Genetic LIMS Reporter</title>
<style>
:root {
  font-family: "Segoe UI", Arial, sans-serif;
  color-scheme: light;
  --bg: #f5f7fb;
  --text: #162941;
  --muted-text: #41516b;
  --panel-bg: #ffffff;
  --panel-border: #c7d2e3;
  --shadow: 0 4px 14px rgba(18, 76, 135, 0.08);
  --accent: #186faf;
  --accent-strong: #124c87;
  --accent-shadow: rgba(24, 111, 175, 0.2);
  --danger: #c0392b;
  --priority-urgent: #f59e0b;
  --priority-acute: #c0392b;
  --nav-bg: #ffffff;
  --nav-border: #c7d2e3;
  --nav-button-bg: #e3ecf8;
  --nav-button-color: #124c87;
  --nav-button-active-bg: #124c87;
  --nav-button-active-color: #ffffff;
  --table-header-bg: #f0f4fb;
  --table-row-border: #dde4f1;
  --badge-bg: #dce6f7;
  --badge-color: #0f4173;
  --input-bg: #ffffff;
  --input-border: #c3cde0;
  --input-placeholder: #6b7d97;
  --input-focus: rgba(24, 111, 175, 0.35);
  --header-bg: linear-gradient(135deg, #124c87, #186faf);
  --header-text: #ffffff;
  --code-bg: #101927;
  --code-text: #e8f1ff;
}
[data-theme="dark"] {
  color-scheme: dark;
  --bg: #0f172a;
  --text: #e2e8f0;
  --muted-text: #94a3b8;
  --panel-bg: #1e293b;
  --panel-border: #334155;
  --shadow: 0 6px 18px rgba(8, 47, 73, 0.55);
  --accent: #38bdf8;
  --accent-strong: #0ea5e9;
  --accent-shadow: rgba(56, 189, 248, 0.2);
  --danger: #ef4444;
  --priority-urgent: #fbbf24;
  --priority-acute: #ef4444;
  --nav-bg: #111c30;
  --nav-border: #1f2a3c;
  --nav-button-bg: #1f2a3c;
  --nav-button-color: #cbd5f5;
  --nav-button-active-bg: #0ea5e9;
  --nav-button-active-color: #0b1120;
  --table-header-bg: #233049;
  --table-row-border: #2f3e58;
  --badge-bg: #1d4ed8;
  --badge-color: #bfdbfe;
  --input-bg: #0f172a;
  --input-border: #334155;
  --input-placeholder: #64748b;
  --input-focus: rgba(56, 189, 248, 0.45);
  --header-bg: linear-gradient(135deg, #0b2a4a, #14395d);
  --header-text: #e2e8f0;
  --code-bg: #0b1120;
  --code-text: #e2e8f0;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  transition: background 0.2s ease, color 0.2s ease;
}
header {
  background: var(--header-bg);
  color: var(--header-text);
  padding: 1rem 2rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 1rem;
}
.brand {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex: 1 1 260px;
  min-width: 200px;
}
.icon-slot {
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.icon {
  width: 1.1em;
  height: 1.1em;
  display: block;
}
.with-icon {
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
}
.with-icon .icon-slot {
  flex: 0 0 auto;
}
.brand-mark {
  width: 64px;
  height: 64px;
  border-radius: 18px;
  background: rgba(255, 255, 255, 0.18);
  display: none;
  align-items: center;
  justify-content: center;
  color: var(--header-text);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
}
.brand-mark .icon-slot {
  width: 2.4rem;
  height: 2.4rem;
}
.brand-mark .icon {
  width: 100%;
  height: 100%;
}
.brand.logo-missing .brand-mark {
  display: flex;
}
[data-theme="dark"] .brand-mark {
  background: rgba(15, 23, 42, 0.55);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.45);
}
.brand img {
  width: 64px;
  height: 64px;
  object-fit: contain;
}
.brand.logo-missing::after {
  content: 'Logo mangler – placer logo.png ved siden af GlimR.html.';
  display: block;
  font-size: 0.75rem;
  color: var(--muted-text);
}
.with-icon .icon {
  width: 1.2em;
  height: 1.2em;
}
header h1 {
  margin: 0;
  font-size: 1.8rem;
}
#statusBar {
  font-size: 0.9rem;
  margin-top: 0.3rem;
  color: var(--header-text);
}
.header-actions {
  display: flex;
  gap: 1rem;
  align-items: stretch;
  flex-wrap: wrap;
  justify-content: flex-end;
}
.auth-block {
  background: rgba(255, 255, 255, 0.12);
  border-radius: 0.75rem;
  padding: 0.6rem 0.8rem;
  display: flex;
  align-items: center;
  gap: 0.6rem;
}
[data-theme="dark"] .auth-block {
  background: rgba(15, 23, 42, 0.45);
}
.auth-block form {
  display: flex;
  gap: 0.4rem;
  flex-wrap: wrap;
  align-items: center;
}
.auth-block select,
.auth-block input {
  min-width: 160px;
}
.auth-block .user-info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.auth-block .user-info span {
  font-weight: 600;
}
.quick-actions {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  flex-wrap: wrap;
  justify-content: flex-end;
}
nav {
  background: var(--nav-bg);
  border-bottom: 1px solid var(--nav-border);
  display: flex;
  flex-wrap: wrap;
  padding: 0.5rem 1rem;
  gap: 0.5rem;
}
nav button {
  border: none;
  background: var(--nav-button-bg);
  color: var(--nav-button-color);
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-size: 0.95rem;
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}
nav button.active {
  background: var(--nav-button-active-bg);
  color: var(--nav-button-active-color);
}
nav button .icon-slot {
  width: 1.2em;
  height: 1.2em;
}
nav button .icon {
  width: 100%;
  height: 100%;
}
main {
  padding: 1.5rem;
}
section[data-tab] {
  display: none;
}
section[data-tab].active {
  display: block;
}
.panel {
  background: var(--panel-bg);
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  padding: 1rem 1.2rem;
  margin-bottom: 1.2rem;
  border: 1px solid var(--panel-border);
}
.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
  flex-wrap: wrap;
}
.panel-header h2 {
  margin: 0;
}
.audit-controls,
.response-controls {
  display: inline-flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  align-items: center;
}
.fhir-template-summary {
  margin-top: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.fhir-template-summary .form-hint {
  margin: 0;
}
.template-summary-list {
  display: grid;
  grid-template-columns: minmax(120px, 0.4fr) 1fr;
  gap: 0.35rem 1rem;
  margin: 0;
}
.template-summary-list dt {
  font-weight: 600;
  color: var(--muted-text);
}
.template-summary-list dd {
  margin: 0;
}
.fhir-template-manager {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  align-items: flex-start;
}
.fhir-template-list {
  flex: 1 1 260px;
  min-width: 240px;
}
.fhir-template-form {
  flex: 2 1 360px;
  min-width: 320px;
}
.fhir-template-form textarea {
  min-height: 120px;
  resize: vertical;
}
.fhir-template-checkboxes {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  margin: 0.5rem 0 0;
}
.fhir-template-checkboxes label {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.9rem;
}
.template-form-grid {
  display: grid;
  gap: 0.75rem 1rem;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  margin-top: 0.75rem;
}
.template-form-grid label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.template-advanced {
  margin-top: 1rem;
}
.template-advanced summary {
  cursor: pointer;
  font-weight: 600;
  color: var(--accent-strong);
}
.template-advanced summary:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.template-advanced .template-form-grid {
  margin-top: 0.5rem;
}
.audit-controls input[type="search"],
.audit-controls select,
.response-controls input[type="search"],
.response-controls select {
  min-height: 2.2rem;
}
.response-controls .filter-field {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.tool-panel {
  padding: 0;
  overflow: hidden;
}
.tool-panel summary {
  margin: 0;
  padding: 1rem 1.2rem;
  list-style: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
  background: transparent;
  color: inherit;
  transition: background 0.2s ease, color 0.2s ease;
}
.tool-panel summary:hover {
  background: rgba(24, 111, 175, 0.08);
}
.tool-panel[open] summary {
  color: var(--accent-strong);
  background: rgba(24, 111, 175, 0.08);
}
[data-theme="dark"] .tool-panel summary:hover {
  background: rgba(56, 189, 248, 0.12);
}
[data-theme="dark"] .tool-panel[open] summary {
  background: rgba(56, 189, 248, 0.12);
  color: var(--accent);
}
.tool-panel summary:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.tool-panel summary::-webkit-details-marker {
  display: none;
}
.tool-panel summary::marker {
  display: none;
}
.tool-panel summary::after {
  content: '\25B6';
  font-size: 0.95rem;
  color: var(--muted-text);
  transition: transform 0.2s ease;
}
.tool-panel[open] summary::after {
  transform: rotate(90deg);
  color: var(--accent-strong);
}
.tool-summary-text {
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
}
.tool-summary-text .tool-title {
  font-size: 1.05rem;
  font-weight: 600;
}
.tool-summary-text .tool-subtitle {
  font-size: 0.9rem;
  color: var(--muted-text);
}
.tool-panel .tool-body {
  padding: 0 1.2rem 1.2rem;
  border-top: 1px solid var(--panel-border);
}
.tool-panel .tool-body > h3 {
  margin-top: 1rem;
  margin-bottom: 0.5rem;
  font-size: 1.2rem;
}
.tool-panel .tool-body > p:first-of-type {
  margin-top: 0;
}
[data-theme="dark"] .tool-panel summary::after {
  color: var(--muted-text);
}
[data-theme="dark"] .tool-panel[open] summary::after {
  color: var(--accent);
}
.tool-panel[open] {
  padding-bottom: 0;
}
.tool-columns {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 0.75rem;
  margin-top: 0.75rem;
}
.tool-criteria-list {
  display: grid;
  gap: 0.4rem;
  justify-items: stretch;
}
.planning-summary {
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
  margin-bottom: 0.8rem;
}
.planning-summary-intro {
  font-size: 0.95rem;
  color: var(--muted-text);
}
.planning-summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 0.6rem;
}
.planning-summary-item {
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 0.6rem 0.8rem;
  background: var(--panel-bg);
  box-shadow: var(--shadow);
}
.planning-summary-value {
  font-size: 1.35rem;
  font-weight: 600;
  color: var(--text);
}
.planning-summary-label {
  font-size: 0.85rem;
  color: var(--muted-text);
}
.planning-controls {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.8rem;
}
.planning-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}
.planning-status {
  font-size: 0.85rem;
  color: var(--muted-text);
}
.planning-guide {
  margin-top: 1rem;
  padding: 0.75rem 0.9rem;
  border-left: 3px solid var(--accent);
  background: rgba(24, 111, 175, 0.08);
  border-radius: 0.65rem;
  font-size: 0.9rem;
  line-height: 1.5;
}
.planning-guide h4 {
  margin: 0 0 0.4rem 0;
  font-size: 1rem;
}
.planning-guide ul {
  margin: 0;
  padding-left: 1.1rem;
  display: grid;
  gap: 0.3rem;
}
.planning-missing-panel {
  margin-top: 1.2rem;
}
.planning-missing-intro {
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
  margin-bottom: 0.8rem;
}
.planning-missing-controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.planning-missing-controls label {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
}
.planning-missing-controls select {
  min-width: 200px;
  background: var(--input-bg);
  border: 1px solid var(--input-border);
  border-radius: 0.5rem;
  padding: 0.35rem 0.55rem;
  font: inherit;
  color: inherit;
}
.planning-missing-controls select:focus {
  outline: none;
  box-shadow: 0 0 0 3px var(--input-focus);
}
.planning-missing-totals {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.planning-missing-totals span {
  display: inline-flex;
  gap: 0.25rem;
  align-items: baseline;
}
.planning-missing-totals strong {
  font-weight: 600;
}
.planning-missing-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
}
.planning-missing-table th,
.planning-missing-table td {
  text-align: left;
  padding: 0.55rem 0.6rem;
  border-bottom: 1px solid var(--table-row-border);
  vertical-align: top;
}
.planning-missing-table thead th {
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 0.03em;
  color: var(--muted-text);
}
.planning-missing-table tbody tr {
  cursor: pointer;
  transition: background 0.15s ease;
}
.planning-missing-table tbody tr:hover {
  background: rgba(24, 111, 175, 0.08);
}
.planning-missing-table tbody tr:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
  background: rgba(24, 111, 175, 0.12);
}
[data-theme="dark"] .planning-missing-table tbody tr:hover {
  background: rgba(56, 189, 248, 0.12);
}
.planning-missing-order {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}
.planning-missing-name {
  font-weight: 600;
}
.planning-missing-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 0.35rem;
  color: var(--muted-text);
  font-size: 0.8rem;
}
.planning-missing-meta span {
  display: inline-flex;
  gap: 0.2rem;
  align-items: center;
}
.planning-missing-meta .planning-missing-sep {
  color: var(--muted-text);
  opacity: 0.6;
}
.planning-missing-missing {
  font-weight: 600;
}
.planning-missing-priority {
  display: inline-flex;
  gap: 0.2rem;
  align-items: center;
}
.planning-missing-empty {
  font-size: 0.9rem;
  color: var(--muted-text);
  margin: 0.6rem 0 0;
}
.planning-board {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 0.8rem;
}
.planning-lane {
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.75rem;
  background: var(--panel-bg);
  box-shadow: var(--shadow);
  padding: 0.8rem;
}
.planning-lane-header {
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
}
.planning-stage-title {
  font-weight: 600;
}
.planning-lane-count {
  font-size: 0.85rem;
  color: var(--muted-text);
}
.planning-lane-subtitle {
  font-size: 0.85rem;
  color: var(--muted-text);
  margin: 0;
}
.planning-lane-body {
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
}
.planning-card {
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  background: rgba(24, 111, 175, 0.02);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
  transition: border-color 0.2s ease, background 0.2s ease;
}
.planning-card[data-healthy="true"] {
  background: rgba(99, 179, 237, 0.12);
  border-color: rgba(99, 179, 237, 0.65);
}
.planning-card[data-status="done"] {
  background: rgba(56, 189, 248, 0.08);
  border-color: rgba(56, 189, 248, 0.35);
}
.planning-card[data-status="in_progress"] {
  border-color: rgba(24, 111, 175, 0.45);
}
.planning-card[data-due="overdue"] {
  border-color: var(--danger);
}
.planning-card[data-due="soon"] {
  border-color: rgba(245, 158, 11, 0.55);
}
.planning-card-header {
  display: flex;
  justify-content: space-between;
  gap: 0.6rem;
}
.planning-card-badges {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.3rem;
}
.planning-card-flag {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  border-radius: 999px;
  background: rgba(99, 179, 237, 0.18);
  color: var(--accent-strong);
  font-size: 0.75rem;
  font-weight: 600;
  padding: 0.15rem 0.55rem;
  white-space: nowrap;
}
.planning-card-title {
  font-weight: 600;
}
.planning-card-meta {
  font-size: 0.85rem;
  color: var(--muted-text);
  display: flex;
  flex-wrap: wrap;
  gap: 0.3rem;
}
.planning-card-stage {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.9rem;
}
.planning-stage-badge {
  background: var(--badge-bg);
  color: var(--badge-color);
  border-radius: 999px;
  padding: 0.1rem 0.5rem;
  font-size: 0.8rem;
  font-weight: 600;
  letter-spacing: 0.01em;
}
.planning-card-status-label {
  font-weight: 600;
}
.planning-card-info,
.planning-card-extra {
  display: grid;
  gap: 0.3rem;
  font-size: 0.9rem;
}
.planning-card-info span {
  display: block;
}
.planning-info-list {
  margin: 0;
  padding-left: 1rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.planning-info-list li {
  margin: 0.1rem 0;
}
.planning-card-controls {
  display: grid;
  gap: 0.5rem;
}
.planning-card-controls label {
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
  font-size: 0.85rem;
}
.planning-note-block {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.planning-note-actions {
  display: inline-flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.45rem;
  font-size: 0.8rem;
  color: var(--muted-text);
}
.planning-note-actions .planning-note-save {
  font-size: 0.8rem;
}
.planning-note-hint {
  font-style: italic;
}
.planning-card.planning-note-dirty .planning-note {
  border-color: var(--accent);
  box-shadow: 0 0 0 1px rgba(24, 111, 175, 0.25);
}
.planning-card-controls input[type="datetime-local"],
.planning-card-controls textarea,
.planning-card-controls select {
  width: 100%;
  max-width: 100%;
  border: 1px solid var(--input-border);
  border-radius: 0.5rem;
  padding: 0.4rem 0.5rem;
  background: var(--input-bg);
  color: inherit;
  font: inherit;
  box-sizing: border-box;
}
.planning-card-controls select {
  appearance: none;
}
.planning-card-controls textarea {
  min-height: 60px;
  resize: vertical;
}
.planning-checkbox {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  justify-self: start;
  justify-content: flex-start;
  align-self: start;
  text-align: left;
}
.planning-checkbox input {
  width: auto;
  accent-color: var(--accent);
}
.planning-card-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
}
.planning-button {
  font-size: 0.85rem;
  padding: 0.35rem 0.6rem;
  border-radius: 0.5rem;
}
.planning-empty {
  font-size: 0.9rem;
  color: var(--muted-text);
  font-style: italic;
}
[data-theme="dark"] .planning-card {
  background: rgba(14, 165, 233, 0.06);
}
[data-theme="dark"] .planning-card[data-healthy="true"] {
  background: rgba(56, 189, 248, 0.12);
  border-color: rgba(56, 189, 248, 0.55);
}
[data-theme="dark"] .planning-card[data-status="done"] {
  background: rgba(14, 165, 233, 0.12);
}
[data-theme="dark"] .planning-guide {
  border-left-color: var(--accent);
  background: rgba(56, 189, 248, 0.12);
}
[data-theme="dark"] .planning-summary-item {
  background: rgba(14, 165, 233, 0.06);
}
.tool-criteria {
  display: grid;
  grid-template-columns: auto 1fr;
  align-items: flex-start;
  gap: 0.55rem;
  padding: 0.45rem 0.6rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.55rem;
  background: rgba(24, 111, 175, 0.08);
  text-align: left;
}
[data-theme="dark"] .tool-criteria {
  background: rgba(14, 165, 233, 0.12);
}
.tool-criteria input[type="checkbox"] {
  margin-top: 0.25rem;
}
.tool-criteria .criterion-text {
  display: block;
  line-height: 1.35;
}
.tool-criteria .criterion-strength-wrapper {
  display: block;
  margin-top: 0.4rem;
}
.tool-criteria .criterion-strength {
  width: 100%;
  font: inherit;
  font-size: 0.9rem;
  padding: 0.35rem 0.4rem;
  border-radius: 0.45rem;
  border: 1px solid var(--input-border);
  background: var(--input-bg);
  color: var(--text);
}
.tool-criteria .criterion-strength:disabled {
  opacity: 0.65;
}
.tool-result {
  margin-top: 0.9rem;
  padding: 0.7rem 0.9rem;
  border-radius: 0.55rem;
  background: rgba(24, 111, 175, 0.08);
  border: 1px solid var(--panel-border);
}
[data-theme="dark"] .tool-result {
  background: rgba(14, 165, 233, 0.15);
}
.tool-inline {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 0.75rem;
  align-items: end;
  margin-top: 0.75rem;
}
.tool-inline label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.consang-baseline {
  margin-top: 0.5rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 0.5rem 0.85rem;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  column-gap: 1.5rem;
  row-gap: 0.35rem;
  background: rgba(24, 111, 175, 0.06);
}
[data-theme="dark"] .consang-baseline {
  background: rgba(14, 165, 233, 0.12);
}
.consang-baseline legend {
  font-weight: 600;
  margin: 0;
  padding: 0 0.35rem 0 0;
  white-space: nowrap;
}
.consang-baseline .radio-option {
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
  font-size: 0.95rem;
  white-space: nowrap;
}
.consang-baseline .radio-option input[type="radio"] {
  margin: 0;
}
.consang-diagram {
  margin-top: 0.75rem;
  padding: 0.6rem 0.75rem;
  border-radius: 0.65rem;
  background: rgba(24, 111, 175, 0.05);
  border: 1px solid rgba(24, 111, 175, 0.15);
  max-width: 360px;
}
[data-theme="dark"] .consang-diagram {
  background: rgba(14, 165, 233, 0.12);
  border-color: rgba(56, 189, 248, 0.25);
}
.consang-diagram svg {
  display: block;
  width: 100%;
  height: auto;
}
.consang-diagram figcaption {
  margin-top: 0.5rem;
  font-size: 0.8rem;
  color: var(--muted-text);
}
.consang-diagram svg .pedigree-link {
  stroke: var(--accent);
  stroke-width: 1.8;
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.consang-diagram svg .pedigree-link.distant {
  stroke-dasharray: 4 3;
  opacity: 0.8;
}
.consang-diagram svg .pedigree-node {
  fill: var(--panel-bg);
  stroke: var(--accent-strong);
  stroke-width: 1.6;
}
[data-theme="dark"] .consang-diagram svg .pedigree-node {
  fill: rgba(15, 23, 42, 0.65);
}
.consang-diagram svg .pedigree-node.proband {
  fill: var(--accent);
  stroke: var(--accent-strong);
}
.consang-diagram svg .pedigree-label {
  font-size: 10px;
  font-family: 'Segoe UI', Arial, sans-serif;
  text-anchor: middle;
  fill: var(--muted-text);
}
[data-theme="dark"] .consang-diagram svg .pedigree-label {
  fill: var(--muted-text);
}
.consang-diagram svg .pedigree-label.name {
  fill: var(--text);
}
[data-theme="dark"] .consang-diagram svg .pedigree-label.name {
  fill: var(--text);
}
.consang-diagram svg .pedigree-label.proband {
  fill: var(--panel-bg);
  font-weight: 600;
}
.tool-note {
  color: var(--muted-text);
  font-size: 0.85rem;
  margin-top: 0.5rem;
}
.placeholder-guide {
  margin-top: 1rem;
  border-radius: 0.75rem;
  border: 1px solid var(--panel-border);
  background: rgba(24, 111, 175, 0.08);
  padding: 0;
  overflow: hidden;
}
[data-theme="dark"] .placeholder-guide {
  background: rgba(14, 165, 233, 0.12);
}
.placeholder-guide summary {
  padding: 1rem 1.25rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  list-style: none;
}
.placeholder-guide summary::-webkit-details-marker {
  display: none;
}
.placeholder-guide summary h3 {
  margin: 0;
  font-size: 1.05rem;
}
.placeholder-guide-subtitle {
  margin-left: auto;
  font-size: 0.85rem;
  font-weight: 500;
  color: var(--muted-text);
}
.placeholder-guide summary::after {
  content: '\25BC';
  font-size: 0.9rem;
  color: var(--muted-text);
  margin-left: 0.5rem;
  transition: transform 0.2s ease;
}
.placeholder-guide[open] summary::after {
  transform: rotate(180deg);
}
.placeholder-guide summary:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 3px;
  border-radius: 0.5rem;
}
.placeholder-guide summary:hover {
  background: rgba(24, 111, 175, 0.12);
}
[data-theme="dark"] .placeholder-guide summary:hover {
  background: rgba(14, 165, 233, 0.18);
}
.placeholder-guide-body {
  padding: 0 1.25rem 1.25rem;
}
.placeholder-guide[open] .placeholder-guide-body {
  border-top: 1px solid var(--panel-border);
  padding-top: 1rem;
}
.placeholder-guide p {
  margin: 0 0 0.75rem;
}
.placeholder-guide h4 {
  margin: 0.75rem 0 0.35rem;
  font-size: 0.95rem;
}
.placeholder-guide-columns {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 1rem;
}
.placeholder-guide ul {
  margin: 0;
  padding-left: 1.1rem;
  font-size: 0.92rem;
  color: var(--muted-text);
}
.placeholder-guide li + li {
  margin-top: 0.35rem;
}
.placeholder-guide code {
  font-family: 'Fira Code', 'Fira Mono', 'Consolas', monospace;
  background: rgba(24, 111, 175, 0.15);
  color: var(--accent-strong);
  border-radius: 0.45rem;
  padding: 0.05rem 0.35rem;
  font-size: 0.85rem;
}
[data-theme="dark"] .placeholder-guide code {
  background: rgba(14, 165, 233, 0.2);
  color: var(--code-text);
}
.placeholder-guide-footnote {
  margin-top: 0.75rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.variant-picker-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.45);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 1.5rem;
}
[data-theme="dark"] .variant-picker-overlay {
  background: rgba(8, 13, 23, 0.75);
}
.variant-picker {
  background: var(--panel-bg);
  color: var(--text);
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  border: 1px solid var(--panel-border);
  max-width: 960px;
  width: 100%;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
}
.variant-picker header {
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--panel-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}
.variant-picker header h3 {
  margin: 0;
  font-size: 1.25rem;
}
.variant-picker .picker-body {
  padding: 1rem 1.25rem 1.25rem;
  overflow: auto;
}
.variant-picker .picker-actions {
  display: flex;
  justify-content: flex-end;
  padding: 0 1.25rem 1rem;
}
.variant-picker table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 0.75rem;
}
.variant-picker table th,
.variant-picker table td {
  padding: 0.5rem 0.75rem;
  border-bottom: 1px solid var(--table-row-border);
  text-align: left;
}
.variant-picker table tbody tr {
  cursor: pointer;
  transition: background 0.15s ease;
}
.variant-picker table tbody tr:hover,
.variant-picker table tbody tr:focus-within {
  background: var(--table-header-bg);
}
.variant-picker table tbody tr:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
}
.variant-picker-empty {
  text-align: center;
  padding: 1.5rem 0.5rem;
  color: var(--muted-text);
}
.panel h2 {
  margin-top: 0;
}
.panel .panel-title-left {
  text-align: left;
}
.dashboard-metrics {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  align-items: stretch;
}
.dashboard-metric {
  display: flex;
  align-items: center;
  gap: 0.85rem;
  padding: 0.9rem 1rem;
  border-radius: 0.9rem;
  border: 1px solid var(--panel-border);
  background: rgba(24, 111, 175, 0.06);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
  transition: box-shadow 0.15s ease, background 0.15s ease;
}
.dashboard-metric:hover,
.dashboard-metric:focus-within {
  background: rgba(24, 111, 175, 0.1);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.45), var(--shadow);
}
[data-theme="dark"] .dashboard-metric {
  background: rgba(56, 189, 248, 0.14);
  box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.35);
}
[data-theme="dark"] .dashboard-metric:hover,
[data-theme="dark"] .dashboard-metric:focus-within {
  background: rgba(56, 189, 248, 0.18);
  box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.55), var(--shadow);
}
.dashboard-metric .icon-slot {
  width: 2.75rem;
  height: 2.75rem;
  border-radius: 0.85rem;
  background: rgba(24, 111, 175, 0.18);
  color: var(--accent-strong);
  flex: 0 0 auto;
}
[data-theme="dark"] .dashboard-metric .icon-slot {
  background: rgba(14, 165, 233, 0.25);
  color: var(--accent);
}
.dashboard-metric h3 {
  margin: 0;
  font-size: 2rem;
  line-height: 1.1;
}
.dashboard-metric .badge {
  margin-bottom: 0.25rem;
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.8rem;
}
.dashboard-stats {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}
.dashboard-stat {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.85rem 1rem;
  border-radius: 0.8rem;
  border: 1px solid var(--panel-border);
  background: rgba(24, 111, 175, 0.08);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
}
[data-theme="dark"] .dashboard-stat {
  background: rgba(56, 189, 248, 0.14);
  box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.25);
}
.dashboard-stat .icon-slot {
  width: 2.4rem;
  height: 2.4rem;
  border-radius: 0.75rem;
  background: rgba(24, 111, 175, 0.12);
  color: var(--accent-strong);
  flex: 0 0 auto;
}
[data-theme="dark"] .dashboard-stat .icon-slot {
  background: rgba(56, 189, 248, 0.18);
  color: var(--accent);
}
.dashboard-stat .stat-label {
  font-size: 0.85rem;
  color: var(--muted-text);
}
.dashboard-stat .stat-value {
  margin-top: 0.2rem;
  font-size: 1.6rem;
  font-weight: 700;
  color: var(--text);
}
.flex {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}
.flex > * {
  flex: 1 1 280px;
}
.variant-hotspot {
  margin-bottom: 1.5rem;
  padding-bottom: 1.25rem;
  border-bottom: 1px solid var(--panel-border);
}
.variant-hotspot[data-collapsed="true"] .variant-hotspot__body {
  display: none;
}
.variant-hotspot__header {
  display: flex;
  flex-wrap: wrap;
  align-items: flex-start;
  justify-content: space-between;
  gap: 0.6rem 1rem;
  margin-bottom: 0.75rem;
}
.variant-hotspot__title {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  min-width: 0;
}
.variant-hotspot__header h2 {
  margin: 0;
  font-size: 1.2rem;
}
.variant-hotspot__summary {
  color: var(--muted-text);
  font-size: 0.85rem;
}
.variant-hotspot__toggle {
  background: var(--nav-button-bg);
  color: var(--nav-button-color);
  border: 1px solid var(--panel-border);
  border-radius: 999px;
  padding: 0.35rem 0.9rem;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(18, 76, 135, 0.12);
  transition: background 0.2s ease, color 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
}
.variant-hotspot__toggle:hover,
.variant-hotspot__toggle:focus-visible {
  background: var(--nav-button-active-bg);
  color: var(--nav-button-active-color);
  border-color: var(--nav-button-active-bg);
  box-shadow: 0 4px 10px rgba(18, 76, 135, 0.2);
}
.variant-hotspot__toggle:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.variant-hotspot__body {
  display: flex;
  flex-direction: column;
}
.variant-hotspot__chart {
  position: relative;
  width: 100%;
  min-height: 220px;
  background: var(--panel-bg);
  border-radius: 1rem;
  border: 1px solid var(--panel-border);
  padding: 1.25rem 1.5rem 1.5rem;
  box-shadow: var(--shadow);
  box-sizing: border-box;
  overflow: hidden;
}
.variant-hotspot__controls {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  gap: 0.75rem;
  margin-bottom: 0.75rem;
  flex-wrap: wrap;
}
.variant-hotspot__controls > * {
  flex: 0 0 auto;
}
.variant-hotspot__build-control {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--muted-text);
  white-space: nowrap;
}
.variant-hotspot__build-select {
  appearance: none;
  border-radius: 0.55rem;
  border: 1px solid var(--panel-border);
  background: var(--panel-bg);
  color: var(--text);
  font-size: 0.85rem;
  padding: 0.35rem 2rem 0.35rem 0.75rem;
  min-width: 9rem;
  box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
}
.variant-hotspot__build-select:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.variant-hotspot__build-select::-ms-expand {
  display: none;
}
.variant-hotspot__build-select option {
  color: var(--text);
}
.variant-hotspot__zoom-indicator {
  font-size: 0.9rem;
  color: var(--muted-text);
}
.variant-hotspot__zoom-reset {
  appearance: none;
  border: 1px solid var(--panel-border);
  background: var(--panel-bg);
  color: var(--accent-strong);
  padding: 0.35rem 0.9rem;
  border-radius: 0.7rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease, transform 0.15s ease;
  box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
}
.variant-hotspot__zoom-reset:hover,
.variant-hotspot__zoom-reset:focus-visible {
  background: var(--nav-button-bg);
  color: var(--nav-button-active-color);
  border-color: var(--accent);
  transform: translateY(-1px);
  outline: none;
}
.variant-hotspot__zoom-reset:active {
  transform: translateY(0);
}
.variant-hotspot__chart svg {
  width: 100%;
  height: auto;
  display: block;
}
.variant-hotspot__empty {
  text-align: center;
  color: var(--muted-text);
  font-size: 0.95rem;
  padding: 1.5rem 0.5rem;
}
.variant-hotspot__caption {
  margin-top: 0.75rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.variant-hotspot__legend-label {
  fill: var(--muted-text);
  font-size: 0.75rem;
}
.variant-hotspot__tooltip {
  position: absolute;
  pointer-events: none;
  background: var(--panel-bg);
  color: var(--text);
  border: 1px solid var(--panel-border);
  border-radius: 0.6rem;
  padding: 0.4rem 0.65rem;
  box-shadow: 0 8px 18px rgba(15, 23, 42, 0.12);
  font-size: 0.75rem;
  line-height: 1.2;
  display: flex;
  flex-direction: column;
  gap: 0.15rem;
  transform: translate(-9999px, -9999px);
  transition: opacity 0.12s ease;
  opacity: 0;
  z-index: 2;
}
.variant-hotspot__tooltip[data-visible="true"] {
  opacity: 1;
}
.variant-hotspot__tooltip strong {
  font-weight: 700;
}
.variant-hotspot__tooltip span {
  color: var(--muted-text);
}
.variant-hotspot__track {
  fill: rgba(24, 111, 175, 0.08);
}
.variant-hotspot__bands {
  pointer-events: none;
  mix-blend-mode: multiply;
}
.variant-hotspot__band {
  fill-opacity: 0.9;
}
.variant-hotspot__centromeres {
  pointer-events: none;
  mix-blend-mode: multiply;
}
.variant-hotspot__centromere {
  fill: rgba(148, 163, 184, 0.4);
  pointer-events: none;
}
.variant-hotspot__centromere-boundaries {
  pointer-events: none;
}
.variant-hotspot__centromere-boundary {
  stroke: #000000;
  stroke-width: 2.5;
  shape-rendering: crispEdges;
}
.variant-hotspot__band-overlay {
  fill: rgba(15, 23, 42, 0.001);
  pointer-events: all;
  cursor: help;
  transition: fill 0.12s ease;
}
.variant-hotspot__band-overlay:hover,
.variant-hotspot__band-overlay:focus-visible,
.variant-hotspot__band-overlay.is-hovered {
  fill: rgba(24, 111, 175, 0.16);
}
.variant-hotspot__band-labels {
  pointer-events: none;
}
.variant-hotspot__band-label {
  font-size: 0.55rem;
  font-weight: 600;
  fill: var(--text);
  paint-order: stroke;
  stroke: rgba(255, 255, 255, 0.85);
  stroke-width: 3px;
  stroke-linejoin: round;
  letter-spacing: 0.01em;
  text-anchor: middle;
}
[data-theme="dark"] .variant-hotspot__band-label {
  fill: #e2e8f0;
  stroke: rgba(15, 23, 42, 0.85);
}
[data-theme="dark"] .variant-hotspot__centromere {
  fill: rgba(148, 163, 184, 0.35);
}
[data-theme="dark"] .variant-hotspot__centromere-boundary {
  stroke: #000000;
}
[data-theme="dark"] .variant-hotspot__band-overlay {
  fill: rgba(226, 232, 240, 0.0025);
}
[data-theme="dark"] .variant-hotspot__band-overlay:hover,
[data-theme="dark"] .variant-hotspot__band-overlay:focus-visible,
[data-theme="dark"] .variant-hotspot__band-overlay.is-hovered {
  fill: rgba(56, 189, 248, 0.22);
}
.variant-hotspot__highlights {
  pointer-events: none;
}
.variant-hotspot__highlight {
  fill: #22c55e;
  fill-opacity: 0.9;
  stroke: #15803d;
  stroke-width: 0.75;
  pointer-events: none;
}
[data-theme="dark"] .variant-hotspot__highlight {
  fill: #4ade80;
  stroke: #16a34a;
}
.variant-hotspot__bars rect {
  shape-rendering: crispEdges;
}
.variant-hotspot__chromosome {
  fill: var(--muted-text);
  font-size: 0.8rem;
  font-weight: 600;
}
.variant-hotspot__axis text {
  fill: var(--muted-text);
  font-size: 0.7rem;
}
.variant-hotspot__axis line,
.variant-hotspot__axis path {
  stroke: var(--panel-border);
}
[data-theme="dark"] .variant-hotspot {
  border-color: var(--panel-border);
}
[data-theme="dark"] .variant-hotspot__axis line,
[data-theme="dark"] .variant-hotspot__axis path {
  stroke: var(--panel-border);
}
[data-theme="dark"] .variant-hotspot__track {
  fill: rgba(56, 189, 248, 0.16);
}
[data-theme="dark"] .variant-hotspot__bands {
  mix-blend-mode: normal;
}
[data-theme="dark"] .variant-hotspot__band {
  fill-opacity: 1;
}
[data-theme="dark"] .variant-hotspot__centromere {
  fill: #000000;
}
[data-theme="dark"] .variant-hotspot__band-overlay:hover,
[data-theme="dark"] .variant-hotspot__band-overlay:focus-visible,
[data-theme="dark"] .variant-hotspot__band-overlay.is-hovered {
  fill: rgba(56, 189, 248, 0.18);
}
[data-theme="dark"] .variant-hotspot__tooltip {
  background: rgba(15, 23, 42, 0.94);
  border-color: rgba(148, 163, 184, 0.4);
  box-shadow: 0 12px 28px rgba(8, 47, 73, 0.55);
}
[data-theme="dark"] .variant-hotspot__chart svg {
  color: var(--text);
}
table {
  width: 100%;
  border-collapse: collapse;
  background: var(--panel-bg);
  color: inherit;
}
th, td {
  padding: 0.45rem 0.6rem;
  border-bottom: 1px solid var(--table-row-border);
  text-align: left;
  font-size: 0.9rem;
}
th {
  background: var(--table-header-bg);
}
tbody tr[data-selected="true"] {
  background: rgba(24, 111, 175, 0.12);
}
[data-theme="dark"] tbody tr[data-selected="true"] {
  background: rgba(56, 189, 248, 0.18);
}
tbody tr[data-order-id] {
  cursor: pointer;
}
tbody tr[data-order-id]:hover {
  background: rgba(24, 111, 175, 0.08);
}
[data-theme="dark"] tbody tr[data-order-id]:hover {
  background: rgba(56, 189, 248, 0.12);
}
.priority-indicator {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-right: 0.35rem;
}
.priority-indicator svg {
  width: 0.95em;
  height: 0.95em;
}
.role-status-indicator {
  display: inline-block;
  width: 0.3rem;
  height: 0.3rem;
  border-radius: 999px;
  background: #86efac;
  margin-right: 0.3rem;
  box-shadow: 0 0 4px 2px rgba(134, 239, 172, 0.6);
  vertical-align: middle;
  transform: translateY(-0.1rem);
}
[data-theme="dark"] .role-status-indicator {
  background: #4ade80;
  box-shadow: 0 0 4px 2px rgba(74, 222, 128, 0.55);
}
.urgent-indicator {
  color: var(--priority-urgent);
}
.acute-indicator {
  color: var(--priority-acute);
}
.inline-field-group {
  display: flex;
  gap: 1rem;
  align-items: flex-end;
  flex-wrap: wrap;
}
.inline-field-group > label {
  flex: 1 1 220px;
  margin-top: 0.4rem;
}
.inline-field-group > .checkbox-field {
  flex: 0 0 auto;
  margin-top: 0.4rem;
}
.order-id {
  display: inline-block;
}
.table-meta {
  display: inline-block;
  margin-left: 0.35rem;
  font-size: 0.75rem;
  color: var(--muted-text);
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
.table-shortcuts {
  width: 2.75rem;
}
.table-actions-cell {
  padding: 0.2rem 0.3rem;
}

.table-shortcut-actions {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  align-content: center;
  gap: 0.25rem;
}
button.icon-button {
  border: none;
  background: transparent;
  color: var(--muted-text);
  padding: 0.35rem;
  border-radius: 0.45rem;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: background 0.2s ease, color 0.2s ease, opacity 0.2s ease;
}
button.icon-button .icon-slot {
  width: 1.1em;
  height: 1.1em;
}
button.icon-button:hover {
  background: rgba(24, 111, 175, 0.12);
  color: var(--accent-strong);
}
[data-theme="dark"] button.icon-button:hover {
  background: rgba(56, 189, 248, 0.18);
  color: var(--accent);
}
button.icon-button:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
  background: rgba(24, 111, 175, 0.12);
  color: var(--accent-strong);
}
[data-theme="dark"] button.icon-button:focus-visible {
  background: rgba(56, 189, 248, 0.18);
  color: var(--accent);
}
@media (hover: none) {
  button.icon-button:hover {
    background: transparent;
    color: var(--muted-text);
  }
  button.icon-button:focus-visible {
    background: rgba(24, 111, 175, 0.12);
    color: var(--accent-strong);
  }
  [data-theme="dark"] button.icon-button:focus-visible {
    background: rgba(56, 189, 248, 0.18);
    color: var(--accent);
  }
}
button.icon-button:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}
.table-shortcut-actions button.icon-button {
  flex: 0 0 auto;
  padding: 0.25rem;
}

@media (max-width: 1200px) {
  .table-actions-cell {
    padding: 0.35rem 0.3rem;
  }

  .table-shortcut-actions {
    flex-direction: column;
    gap: 0.3rem;
    width: 100%;
  }

  .table-shortcut-actions button.icon-button {
    width: 100%;
  }
}
label.checkbox-field {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--muted-text);
  margin-top: 0.6rem;
}
label.checkbox-field input[type="checkbox"] {
  transform: scale(1.05);
}
td.truncate-cell {
  vertical-align: top;
}

.orders-table td.truncate-cell {
  vertical-align: middle;
}
.truncate-text {
  display: block;
  width: 100%;
  max-width: clamp(12rem, 40vw, 28rem);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.truncate-text--narrow {
  max-width: clamp(10rem, 35vw, 22rem);
}
.truncate-text--wide {
  max-width: clamp(16rem, 55vw, 36rem);
}
.truncate-text--order-indication {
  max-width: clamp(10rem, 28vw, 18rem);
}
.orders-table col.col-shortcuts {
  width: 2.75rem;
}
.orders-table col.col-patient {
  width: clamp(12rem, 32vw, 24rem);
}
.orders-table col.col-panel {
  width: clamp(9rem, 24vw, 16rem);
}
.orders-table col.col-indication {
  width: clamp(10rem, 28vw, 18rem);
}
.orders-table col.col-indication {
  width: clamp(10rem, 28vw, 18rem);
}
.orders-table col.col-hpo {
  width: clamp(9rem, 24vw, 16rem);
}
.orders-table td:nth-child(3) .truncate-text {
  max-width: clamp(12rem, 32vw, 24rem);
}
.orders-table td:nth-child(5) .truncate-text {
  max-width: clamp(9rem, 24vw, 16rem);
}
.orders-table td:nth-child(11) .truncate-text {
  max-width: clamp(9rem, 24vw, 16rem);
}
form label {
  display: block;
  font-size: 0.8rem;
  font-weight: 600;
  margin-top: 0.4rem;
  color: var(--muted-text);
}
.label-note {
  display: inline-block;
  margin-left: 0.35rem;
  font-size: 0.75rem;
  font-weight: 400;
  color: var(--muted-text);
}
form input,
form select,
form textarea {
  width: 100%;
  padding: 0.4rem;
  border-radius: 0.4rem;
  border: 1px solid var(--input-border);
  font-size: 0.95rem;
  background: var(--input-bg);
  color: var(--text);
  transition: border 0.2s ease, box-shadow 0.2s ease;
}
form input::placeholder,
form textarea::placeholder {
  color: var(--input-placeholder);
}
form input:focus,
form select:focus,
form textarea:focus {
  outline: 2px solid var(--input-focus);
  border-color: var(--accent);
}
form textarea {
  min-height: 80px;
  resize: vertical;
}
.btn-row {
  margin-top: 0.8rem;
  display: flex;
  gap: 0.6rem;
  flex-wrap: wrap;
}
.panel.single-action-panel .btn-row {
  justify-content: flex-start;
  margin-top: 0;
}
.panel.single-action-panel .btn-row button {
  flex: 0 0 auto;
}
.panel-hint {
  margin-top: 0.4rem;
  color: var(--muted-text);
  font-size: 0.85rem;
}
.panel-hint.warning {
  color: var(--danger);
  font-weight: 600;
}
.case-form fieldset,
.panel fieldset[data-collapsible] {
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 1rem;
  margin: 0 0 1rem 0;
}
.case-form legend,
.panel fieldset[data-collapsible] > legend {
  font-weight: 600;
  padding: 0 0.4rem;
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  margin-bottom: 0.6rem;
}
.case-form legend .fieldset-title,
.panel fieldset[data-collapsible] > legend .fieldset-title {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
}
.case-form fieldset[data-collapsible],
.panel fieldset[data-collapsible] {
  position: relative;
}
.case-form fieldset[data-collapsible] .fieldset-toggle,
.panel fieldset[data-collapsible] .fieldset-toggle {
  border: none;
  background: transparent;
  color: var(--muted-text);
  font-size: 0.85rem;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  cursor: pointer;
  padding: 0.2rem 0.4rem;
  border-radius: 0.4rem;
  transition: color 0.2s ease, background 0.2s ease;
}
.case-form fieldset[data-collapsible] .fieldset-toggle::before,
.panel fieldset[data-collapsible] .fieldset-toggle::before {
  content: '−';
  font-size: 1rem;
  line-height: 1;
}
.case-form fieldset[data-collapsible].collapsed .fieldset-toggle::before,
.panel fieldset[data-collapsible].collapsed .fieldset-toggle::before {
  content: '+';
}
.case-form fieldset[data-collapsible] .fieldset-toggle:focus-visible,
.panel fieldset[data-collapsible] .fieldset-toggle:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.case-form fieldset[data-collapsible] .fieldset-toggle:hover,
.panel fieldset[data-collapsible] .fieldset-toggle:hover {
  color: var(--accent-strong);
  background: var(--accent-shadow);
}
.case-form fieldset[data-collapsible].collapsed,
.panel fieldset[data-collapsible].collapsed {
  padding-bottom: 0.6rem;
}
.case-form fieldset[data-collapsible].collapsed > legend,
.panel fieldset[data-collapsible].collapsed > legend {
  margin-bottom: 0;
}
.case-form fieldset[data-collapsible] .fieldset-body,
.panel fieldset[data-collapsible] .fieldset-body {
  display: block;
}
.case-form fieldset[data-collapsible][data-collapsed="true"] > .fieldset-body,
.case-form fieldset[data-collapsible].collapsed > .fieldset-body,
.panel fieldset[data-collapsible][data-collapsed="true"] > .fieldset-body,
.panel fieldset[data-collapsible].collapsed > .fieldset-body {
  display: none;
}
.case-form .inline-group {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 0.5rem;
  align-items: flex-start;
}
.case-form .inline-group > label,
.case-form label.inline {
  flex: 1 1 220px;
}
.case-form label.inline {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.case-form .form-hint {
  margin: 0.2rem 0 0.6rem 0;
  color: var(--muted-text);
  font-size: 0.85rem;
}
.case-form .case-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  align-items: flex-end;
  margin-bottom: 0.75rem;
}
.case-form .case-row > label {
  flex: 1 1 180px;
}
.case-form .case-row > label.wide {
  flex: 1 1 100%;
}
.case-form .case-row textarea {
  min-height: 60px;
}
.case-form .case-row button {
  align-self: flex-start;
}
.variant-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 0.9rem 1rem;
  align-items: start;
  padding: 1rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.9rem;
  background: var(--panel-bg);
  box-shadow: 0 4px 12px rgba(18, 76, 135, 0.08);
}
.variant-row > label,
.variant-row > .variant-batch-group,
.variant-row > button {
  margin: 0;
}
.variant-row > label,
.variant-row .variant-batch-group > label {
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  font-weight: 600;
  color: var(--muted-text);
  font-size: 0.9rem;
}
.variant-row > label input,
.variant-row > label select,
.variant-row > label textarea,
.variant-row .variant-batch-group > label input,
.variant-row .variant-batch-group > label select,
.variant-row .variant-batch-group > label textarea {
  width: 100%;
  font-weight: 400;
  color: var(--text);
  background: var(--input-bg);
}
.variant-row > label.wide,
.variant-row > .variant-batch-group > label.wide {
  grid-column: 1 / -1;
}
.variant-row > button {
  justify-self: flex-start;
  min-width: 160px;
  margin-top: 0.5rem;
}
.variant-row .variant-batch-group {
  display: contents;
}
.variant-row .variant-structure-grid {
  display: contents;
}
.variant-row textarea.small {
  min-height: 60px;
}
@media (max-width: 720px) {
  .variant-row {
    padding: 0.85rem;
    gap: 0.75rem;
  }
}
[data-theme="dark"] .variant-row {
  box-shadow: 0 6px 18px rgba(8, 47, 73, 0.45);
}
[data-theme="dark"] .variant-row > label,
[data-theme="dark"] .variant-row .variant-batch-group > label {
  color: var(--muted-text);
}
[data-theme="dark"] .variant-row > label input,
[data-theme="dark"] .variant-row > label select,
[data-theme="dark"] .variant-row > label textarea,
[data-theme="dark"] .variant-row .variant-batch-group > label input,
[data-theme="dark"] .variant-row .variant-batch-group > label select,
[data-theme="dark"] .variant-row .variant-batch-group > label textarea {
  color: var(--text);
}
.variant-batch-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.variant-batch-form .panel-hint {
  margin: 0;
}
.variant-batch-form .stacked-control {
  display: flex;
  flex-direction: column;
  gap: 0.4rem;
  font-weight: 600;
  color: var(--muted-text);
  max-width: min(100%, 420px);
  font-size: 0.9rem;
}
.variant-batch-form .stacked-control .filterable-select {
  margin-top: 0;
}
.variant-batch-form .stacked-control input,
.variant-batch-form .stacked-control select {
  width: 100%;
  font-weight: 400;
  color: var(--text);
  background: var(--input-bg);
}
[data-theme="light"] .variant-row > label input,
[data-theme="light"] .variant-row > label select,
[data-theme="light"] .variant-row > label textarea,
[data-theme="light"] .variant-row .variant-batch-group > label input,
[data-theme="light"] .variant-row .variant-batch-group > label select,
[data-theme="light"] .variant-row .variant-batch-group > label textarea,
[data-theme="light"] .variant-batch-form .stacked-control input,
[data-theme="light"] .variant-batch-form .stacked-control select {
  background-color: #ffffff;
  color: #162941;
}
.variant-batch-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.variant-batch-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  align-items: center;
  margin-top: 0.3rem;
}
.variant-batch-actions #variantBatchSave {
  margin-left: auto;
}
@media (max-width: 640px) {
  .variant-batch-actions {
    flex-direction: column;
    align-items: stretch;
  }
  .variant-batch-actions #variantBatchSave {
    margin-left: 0;
    width: 100%;
  }
  .variant-batch-actions button,
  .variant-batch-actions label {
    width: 100%;
  }
}
[data-variant-types][hidden],
[data-variant-types].variant-type-hidden {
  display: none !important;
}
.case-form .toggle {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.6rem 0;
  font-weight: 600;
  color: var(--muted-text);
}
.case-form .toggle input[type="checkbox"] {
  width: auto;
  accent-color: var(--accent);
}
.case-form textarea.small {
  min-height: 48px;
}
.table-actions {
  margin-top: 0.8rem;
  display: flex;
  justify-content: flex-end;
}
.table-actions button {
  min-width: 220px;
}
#libraryOpenPatients {
  margin-right: auto;
}
.filter-banner {
  display: none;
  align-items: center;
  gap: 0.75rem;
  margin: 0.75rem 0;
  padding: 0.75rem 1rem;
  border-radius: 0.75rem;
  border-left: 4px solid var(--accent);
  background: rgba(24, 111, 175, 0.12);
  color: var(--muted-text);
}
.filter-banner[data-visible="true"] {
  display: flex;
}
[data-theme="dark"] .filter-banner {
  background: rgba(56, 189, 248, 0.18);
  color: var(--text);
}
.filter-banner span {
  flex: 1 1 auto;
}
.filter-banner button {
  flex: 0 0 auto;
}
.list-toggle {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.6rem 0;
  font-weight: 600;
  color: var(--muted-text);
}
.list-toggle input[type="checkbox"] {
  width: auto;
  accent-color: var(--accent);
}
button.primary {
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 0.5rem;
  padding: 0.5rem 0.9rem;
  cursor: pointer;
}
button.danger {
  background: var(--danger);
  color: #fff;
}
button.secondary {
  background: var(--nav-button-bg);
  color: var(--nav-button-color);
  border: 1px solid transparent;
}
button.text-link {
  background: none;
  border: none;
  padding: 0;
  color: var(--accent-strong);
  font-weight: 600;
  cursor: pointer;
}
button.text-link:hover {
  text-decoration: underline;
}
button.text-link:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
button.action-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.55rem;
  font-weight: 600;
  letter-spacing: 0.01em;
  border-radius: 0.75rem;
  padding: 0.55rem 1.1rem;
  border: 1px solid transparent;
  box-shadow: 0 6px 14px rgba(24, 111, 175, 0.12);
  transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease, color 0.18s ease;
}
button.action-button .icon-slot {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 1.9em;
  height: 1.9em;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.28);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
}
button.action-button svg {
  width: 1.35em;
  height: 1.35em;
  stroke: currentColor;
  stroke-width: 1.8;
  stroke-linecap: round;
  stroke-linejoin: round;
  fill: none;
}
button.action-button .label {
  display: inline-flex;
  align-items: center;
}
button.action-button:hover,
button.action-button:focus-visible {
  transform: translateY(-1px);
  box-shadow: 0 10px 18px rgba(24, 111, 175, 0.2);
}
button.action-button:focus-visible {
  outline: 3px solid var(--accent-shadow);
  outline-offset: 2px;
}
button.action-button.action-save,
button.action-button.action-save-new {
  background: linear-gradient(135deg, var(--accent), var(--accent-strong));
  color: #fff;
  box-shadow: 0 12px 20px var(--accent-shadow);
}
button.action-button.action-save-new {
  background: linear-gradient(135deg, #2a7fbe, var(--accent-strong));
}
button.action-button.action-save .icon-slot,
button.action-button.action-save-new .icon-slot {
  background: rgba(255, 255, 255, 0.32);
}
button.action-button.action-new {
  background: rgba(24, 111, 175, 0.1);
  color: var(--accent-strong);
  border-color: rgba(24, 111, 175, 0.35);
}
button.action-button.action-new .icon-slot {
  background: rgba(24, 111, 175, 0.18);
  box-shadow: inset 0 0 0 1px rgba(24, 111, 175, 0.35);
}
button.action-button.action-delete {
  background: linear-gradient(135deg, #d24b3c, var(--danger));
  color: #fff;
  box-shadow: 0 12px 20px rgba(192, 57, 43, 0.25);
}
button.action-button.action-delete .icon-slot {
  background: rgba(255, 255, 255, 0.26);
}
[data-theme="dark"] button.action-button.action-new {
  background: rgba(56, 189, 248, 0.16);
  color: #e0f2ff;
  border-color: rgba(56, 189, 248, 0.45);
  box-shadow: 0 8px 16px rgba(14, 165, 233, 0.25);
}
[data-theme="dark"] button.action-button .icon-slot {
  background: rgba(148, 163, 184, 0.24);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.38);
}
[data-theme="dark"] button.action-button.action-save .icon-slot,
[data-theme="dark"] button.action-button.action-save-new .icon-slot {
  background: rgba(226, 232, 240, 0.28);
}
[data-theme="dark"] button.action-button.action-new .icon-slot {
  background: rgba(56, 189, 248, 0.3);
}
[data-theme="dark"] button.action-button.action-delete .icon-slot {
  background: rgba(255, 255, 255, 0.24);
}
[data-theme="dark"] button.action-button.action-delete {
  box-shadow: 0 12px 20px rgba(239, 68, 68, 0.3);
}
button:disabled {
  opacity: 0.55;
  cursor: not-allowed;
}
.badge {
  display: inline-block;
  padding: 0.2rem 0.5rem;
  border-radius: 0.4rem;
  background: var(--badge-bg);
  color: var(--badge-color);
  font-size: 0.75rem;
}
.rsid-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  padding: 0.15rem 0.6rem;
  border-radius: 999px;
  background: var(--badge-bg);
  color: var(--accent-strong);
  font-weight: 600;
  text-decoration: none;
  border: 1px solid currentColor;
  transition: color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  line-height: 1.2;
}
.rsid-badge::after {
  content: '\2197';
  font-size: 0.75em;
  opacity: 0.8;
}
.rsid-badge:hover,
.rsid-badge:focus-visible {
  background: var(--accent-strong);
  color: #fff;
  box-shadow: 0 0 0 3px var(--accent-shadow);
}
.variant-lookup-links {
  display: inline-flex;
  gap: 0.25rem;
  align-items: center;
}
.variant-lookup-link {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 1.5rem;
  height: 1.5rem;
  border-radius: 0.35rem;
  background: var(--badge-bg);
  color: var(--accent-strong);
  font-weight: 600;
  font-size: 0.7rem;
  line-height: 1;
  text-decoration: none;
  border: 1px solid currentColor;
  transition: color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
}
.variant-lookup-link:hover,
.variant-lookup-link:focus-visible {
  background: var(--accent-strong);
  color: #fff;
  box-shadow: 0 0 0 3px var(--accent-shadow);
}

input[type="search"] {
  border-radius: 1rem;
}
.filterable-select {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  margin-top: 0.3rem;
}
.filterable-select input[type="search"] {
  padding: 0.35rem 0.5rem;
}
.filterable-select select {
  max-height: 220px;
}
.report-variant-selector {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  align-items: flex-end;
  margin-top: 0.4rem;
}
.report-variant-selector .filterable-select {
  flex: 1 1 260px;
  margin-top: 0;
}
.conclusion-library-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  align-items: flex-end;
  margin-top: 0.4rem;
}
.conclusion-library-controls label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.conclusion-library-controls select {
  min-width: 220px;
}
.conclusion-library-buttons {
  display: flex;
  gap: 0.4rem;
  align-items: center;
}
.conclusion-library-buttons button {
  margin-top: 0.35rem;
}
.report-variant-list {
  margin-top: 0.6rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.report-variant-item {
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 0.6rem 0.75rem;
  box-shadow: inset 0 1px 0 rgba(15, 27, 45, 0.04);
}
[data-theme="dark"] .report-variant-item {
  background: rgba(15, 23, 42, 0.45);
}
.report-variant-item header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-weight: 600;
}
.report-variant-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem 0.8rem;
  margin-top: 0.35rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.report-variant-meta strong {
  font-weight: 600;
}
.report-variant-item p {
  margin: 0.35rem 0 0;
}
.report-variant-remove {
  background: none;
  border: none;
  color: var(--danger);
  cursor: pointer;
  padding: 0.15rem 0.35rem;
  border-radius: 0.4rem;
  font-size: 0.85rem;
}
.report-variant-remove:hover,
.report-variant-remove:focus {
  text-decoration: underline;
}
.report-variant-empty {
  color: var(--muted-text);
  font-style: italic;
  font-size: 0.9rem;
}
.report-variant-detail {
  margin-top: 0.75rem;
  padding: 0.6rem 0.8rem;
  border-left: 3px solid var(--accent);
  border-radius: 0.6rem;
  background: var(--panel-bg);
}
[data-theme="dark"] .report-variant-detail {
  background: rgba(15, 23, 42, 0.45);
}
.report-variant-detail h3 {
  margin: 0;
}
.report-variant-detail ul {
  margin: 0.4rem 0 0;
  padding-left: 1.2rem;
}
.report-variant-detail p {
  margin: 0.5rem 0 0;
}
.family-combo {
  display: flex;
  flex-wrap: wrap;
  gap: 0.35rem 0.4rem;
  align-items: center;
}
.family-combo select {
  flex: 1 0 11rem;
  min-width: 9rem;
}
.family-combo input:not([type="checkbox"]) {
  flex: 1 1 12rem;
  min-width: 10rem;
}
.family-combo input[type="checkbox"] {
  flex: 0 0 auto;
}
.family-combo .family-healthy {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  font-size: 0.85rem;
  white-space: nowrap;
}
.family-healthy-group {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  margin-left: auto;
}
.family-healthy-group input[type="checkbox"] {
  margin: 0;
  width: auto;
  accent-color: var(--accent);
}
.advanced-filter {
  margin-top: 0.6rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.75rem;
  padding: 0.35rem 0.75rem;
  background: var(--panel-bg);
  box-shadow: inset 0 1px 2px rgba(15, 27, 45, 0.08);
}
.advanced-filter summary {
  cursor: pointer;
  font-weight: 600;
  color: var(--accent-strong);
  outline: none;
}
.advanced-filter summary::-webkit-details-marker {
  display: none;
}
.advanced-filter summary::after {
  content: '▾';
  float: right;
  transform: rotate(0deg);
  transition: transform 0.2s ease;
}
.advanced-filter[open] summary::after {
  transform: rotate(-180deg);
}
.advanced-filter .filter-grid {
  margin-top: 0.6rem;
  display: grid;
  gap: 0.6rem;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}
.advanced-filter label {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.advanced-filter input,
.advanced-filter select {
  font-size: 0.9rem;
}
.read-only-banner {
  background: rgba(192, 57, 43, 0.1);
  color: var(--danger);
  border: 1px dashed var(--danger);
  border-radius: 0.5rem;
  padding: 0.6rem 0.8rem;
  margin-bottom: 1rem;
  font-weight: 600;
}
pre {
  background: var(--code-bg);
  color: var(--code-text);
  padding: 0.8rem;
  border-radius: 0.6rem;
  overflow: auto;
}
@media (max-width: 900px) {
  header {
    flex-direction: column;
    align-items: stretch;
  }
  .header-actions {
    width: 100%;
    justify-content: space-between;
  }
  .auth-block,
  .quick-actions {
    width: 100%;
    justify-content: space-between;
  }
}
@media (max-width: 600px) {
  .auth-block form,
  .quick-actions {
    flex-direction: column;
    align-items: stretch;
  }
  .auth-block form > * {
    width: 100%;
  }
}
</style>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
</head>
<body>
<header>
  <div class="brand">
    <span class="brand-mark" aria-hidden="true">
      <span class="icon-slot" data-icon="dna"></span>
    </span>
    <img id="glimrLogo" src="logo.png" alt="G" loading="lazy">
    <div>
      <h1>GlimR – Genetic LIMS Reporter</h1>
      <div id="statusBar">Initialiserer...</div>
    </div>
  </div>
  <div class="header-actions">
    <div class="auth-block" id="authBlock">
      <form id="loginForm">
        <select id="loginUser" required></select>
        <input id="loginPass" type="password" placeholder="Adgangskode (valgfri)">
        <button type="submit" class="primary with-icon">
          <span class="icon-slot" data-icon="arrow-right-on-rectangle"></span>
          <span>Log ind</span>
        </button>
      </form>
      <div class="user-info" id="userInfo" hidden>
        <span id="currentUserLabel"></span>
        <button type="button" class="secondary with-icon" id="logoutBtn">
          <span class="icon-slot" data-icon="arrow-left-on-rectangle"></span>
          <span>Log ud</span>
        </button>
      </div>
    </div>
    <div class="quick-actions">
      <button class="secondary with-icon" id="themeToggle">
        <span class="icon-slot" data-icon="moon"></span>
        <span>Skift til mørkt tema</span>
      </button>
    </div>
  </div>
</header>
<nav id="tabNav"></nav>
<main id="tabContent"></main>
<script>
(() => {
'use strict';
const DB_NAME = 'glims';
const DB_VER = 11;
const STORES = ['patients','samples','orders','patient_groups','panels','variants','qc','qc_presets','reports','users','audit','variant_library','responses','fhir_templates','conclusion_library','planner'];
const SETTINGS_STORE = 'settings';
const MEMORY_DB_STORE_DEFINITIONS = {
  patients: {keyPath: 'id', autoIncrement: true},
  samples: {keyPath: 'id', autoIncrement: true},
  orders: {keyPath: 'id', autoIncrement: true},
  patient_groups: {keyPath: 'id', autoIncrement: true},
  panels: {keyPath: 'id', autoIncrement: true},
  variants: {keyPath: 'id', autoIncrement: true},
  qc: {keyPath: 'id', autoIncrement: true},
  qc_presets: {keyPath: 'id', autoIncrement: true},
  reports: {keyPath: 'id', autoIncrement: true},
  users: {keyPath: 'id', autoIncrement: true},
  audit: {keyPath: 'id', autoIncrement: true},
  variant_library: {keyPath: 'id', autoIncrement: true},
  responses: {keyPath: 'id', autoIncrement: true},
  fhir_templates: {keyPath: 'id', autoIncrement: true},
  conclusion_library: {keyPath: 'id', autoIncrement: true},
  planner: {keyPath: 'id', autoIncrement: false},
  [SETTINGS_STORE]: {keyPath: 'key', autoIncrement: false}
};
let memoryDbSnapshot = null;

function cloneMemoryValue(value) {
  if (value === null || typeof value !== 'object') {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(item => cloneMemoryValue(item));
  }
  const clone = {};
  for (const key of Object.keys(value)) {
    clone[key] = cloneMemoryValue(value[key]);
  }
  return clone;
}

function readMemoryDbSnapshot() {
  if (!memoryDbSnapshot || typeof memoryDbSnapshot !== 'object') {
    return null;
  }
  return cloneMemoryValue(memoryDbSnapshot);
}

function writeMemoryDbSnapshot(snapshot) {
  if (!snapshot || typeof snapshot !== 'object') {
    memoryDbSnapshot = {};
    return;
  }
  memoryDbSnapshot = cloneMemoryValue(snapshot);
}

function createMemoryDb(initialSnapshot = {}) {
  const storeState = new Map();
  for (const [name, definition] of Object.entries(MEMORY_DB_STORE_DEFINITIONS)) {
    storeState.set(name, {definition, records: new Map(), auto: 0});
  }

  const nextAutoKey = meta => {
    meta.auto = (Number.isFinite(meta.auto) ? meta.auto : 0) + 1;
    return meta.auto;
  };

  const normaliseKey = (definition, meta, key) => {
    if (definition.autoIncrement) {
      const numeric = Number(key);
      if (Number.isFinite(numeric)) {
        if (!Number.isFinite(meta.auto) || numeric > meta.auto) {
          meta.auto = numeric;
        }
        return numeric;
      }
    }
    return key;
  };

  const assignKey = (definition, meta, record, allowGenerate) => {
    let key = record?.[definition.keyPath];
    if ((key === undefined || key === null) && allowGenerate && definition.autoIncrement) {
      key = nextAutoKey(meta);
    }
    if (key === undefined || key === null) {
      throw new Error(`Primærnøgle mangler for ${definition.keyPath}`);
    }
    key = normaliseKey(definition, meta, key);
    record[definition.keyPath] = key;
    return key;
  };

  const applyInitialRecord = (name, record) => {
    const entry = storeState.get(name);
    if (!entry) return;
    try {
      const clone = cloneMemoryValue(record);
      const key = assignKey(entry.definition, entry, clone, true);
      entry.records.set(String(key), clone);
    } catch (err) {
      console.warn('Ignorerer ugyldig post i memory-database fallback', err);
    }
  };

  if (initialSnapshot && typeof initialSnapshot === 'object') {
    for (const [name, records] of Object.entries(initialSnapshot)) {
      if (!storeState.has(name)) continue;
      const list = Array.isArray(records) ? records : [];
      list.forEach(record => applyInitialRecord(name, record));
    }
  }

  const exportSnapshot = () => {
    const snapshot = {};
    for (const [name, entry] of storeState.entries()) {
      snapshot[name] = Array.from(entry.records.values()).map(cloneMemoryValue);
    }
    return snapshot;
  };

  const syncSnapshot = () => {
    writeMemoryDbSnapshot(exportSnapshot());
  };

  syncSnapshot();

  const createStoreApi = (name, entry, mode) => {
    const {definition, records} = entry;
    const ensureWritable = () => {
      if (mode !== 'readwrite') {
        console.warn(`Memory-database skriver via ${mode}-transaktion for ${name}.`);
      }
    };
    return {
      add(record) {
        return new Promise((resolve, reject) => {
          try {
            ensureWritable();
            const clone = cloneMemoryValue(record);
            const key = assignKey(definition, entry, clone, true);
            const keyStr = String(key);
            if (records.has(keyStr)) {
              throw new Error('Primærnøglen findes allerede.');
            }
            records.set(keyStr, clone);
            syncSnapshot();
            resolve(clone[definition.keyPath]);
          } catch (err) {
            reject(err);
          }
        });
      },
      put(record) {
        return new Promise((resolve, reject) => {
          try {
            ensureWritable();
            const clone = cloneMemoryValue(record);
            const key = assignKey(definition, entry, clone, true);
            records.set(String(key), clone);
            syncSnapshot();
            resolve(clone[definition.keyPath]);
          } catch (err) {
            reject(err);
          }
        });
      },
      delete(key) {
        return new Promise(resolve => {
          ensureWritable();
          records.delete(String(key));
          syncSnapshot();
          resolve();
        });
      },
      clear() {
        return new Promise(resolve => {
          ensureWritable();
          records.clear();
          if (definition.autoIncrement) {
            entry.auto = 0;
          }
          syncSnapshot();
          resolve();
        });
      },
      get(key) {
        const value = records.get(String(key));
        return Promise.resolve(value === undefined ? undefined : cloneMemoryValue(value));
      },
      getAll() {
        return Promise.resolve(Array.from(records.values()).map(cloneMemoryValue));
      },
      index() {
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve([]);
          }
        };
      }
    };
  };

  return {
    transaction(storeNames, mode = 'readonly') {
      const names = Array.isArray(storeNames) ? storeNames : [storeNames];
      if (!names.length) {
        throw new Error('Ingen objectStores angivet til transaktion.');
      }
      const mapping = new Map();
      for (const name of names) {
        const entry = storeState.get(name);
        if (!entry) {
          throw new Error(`Ukendt objectStore: ${name}`);
        }
        mapping.set(name, entry);
      }
      return {
        mode,
        done: Promise.resolve(),
        objectStore(targetName) {
          const name = targetName && mapping.has(targetName) ? targetName : names[0];
          const entry = mapping.get(name);
          return createStoreApi(name, entry, mode);
        },
        abort(reason) {
          this.error = reason instanceof Error ? reason : new Error(String(reason));
        },
        error: null
      };
    },
    close() {},
    objectStoreNames: {
      contains(name) {
        return storeState.has(name);
      }
    }
  };
}

const BOUND_HANDLE_SETTING_KEY = 'boundFileHandle';
const BOUND_HANDLE_NAME_KEY = 'glimr-bound-handle-name';
const AUTOSAVE_STORAGE_KEY = 'glimr-autosave';
const storage = (() => {
  try {
    const testKey = '__glimr_storage_test__';
    localStorage.setItem(testKey, '1');
    localStorage.removeItem(testKey);
    return localStorage;
  } catch (err) {
    console.warn('Local storage utilgængelig, bruger in-memory fallback.', err);
    const memory = new Map();
    return {
      getItem(key) {
        return memory.has(key) ? memory.get(key) : null;
      },
      setItem(key, value) {
        memory.set(key, String(value));
      },
      removeItem(key) {
        memory.delete(key);
      }
    };
  }
})();

const state = {
  db: null,
  cache: new Map(),
  creationLookup: new Map(),
  boundHandle: null,
  autosave: storage.getItem(AUTOSAVE_STORAGE_KEY) === '1',
  autosaveTimer: null,
  lastSyncedData: null,
  reloadFromFilePromise: null,
  currentTab: 'dashboard',
  currentUser: null,
  theme: storage.getItem('glimr-theme') || 'light',
  testResults: [],
  lastStatus: '',
  usingMemoryDb: false,
  pendingOrderId: null,
  pendingOrderShowAll: false,
  pendingOrderFilterSampleId: null,
  pendingOrderFilterSampleExact: false,
  pendingOrderFilterId: null,
  pendingSampleId: null,
  pendingSampleShowAll: false,
  pendingReportFilterOrderId: null,
  pendingReportFilterOrderExact: false,
  pendingReportFilterSampleId: null,
  pendingReportFilterSampleExact: false,
  pendingReportShowAll: false,
  pendingReportSelectOrderId: null,
  pendingReportSelectReportId: null,
  pendingPatientVariantFilter: null
};
const CREATED_BY_STORES = new Set(['patients','samples','orders','patient_groups','variants','qc','qc_presets','reports','fhir_templates','conclusion_library']);
const UPDATED_BY_STORES = new Set(['panels']);
const ROLE_OPTIONS = [
  {value: 'Observatør', description: 'Kun læseadgang til data', canWrite: false},
  {value: 'Bioinformatiker', description: 'Kan registrere analyser og varianter', canWrite: true},
  {value: 'Skriver', description: 'Kan oprette og redigere alle laboratoriedata', canWrite: true},
  {value: 'Administrator', description: 'Fuld systemadgang inkl. brugeradministration', canWrite: true}
];
const WRITE_ROLE_KEYS = new Set(ROLE_OPTIONS.filter(opt => opt.canWrite).map(opt => opt.value.toLowerCase()));
function normaliseRoleValue(role) {
  return (role || '').toString().trim();
}
function findRoleOption(role) {
  const normalised = normaliseRoleValue(role).toLowerCase();
  return ROLE_OPTIONS.find(opt => opt.value.toLowerCase() === normalised) || null;
}
function roleLabel(role) {
  if (!role) return '';
  const match = findRoleOption(role);
  return match ? match.value : normaliseRoleValue(role);
}
function roleWithDescription(role) {
  if (!role) return '';
  const match = findRoleOption(role);
  if (!match) return normaliseRoleValue(role);
  return `${match.value} – ${match.description}`;
}
const classificationMap = {
  '1': {code:'LA6576-8', display:'Benign'},
  '2': {code:'LA6577-6', display:'Formodet benign'},
  '3': {code:'LA4489-6', display:'Usikker signifikans'},
  '4': {code:'LA6668-3', display:'Formodet patogen'},
  '5': {code:'LA6708-8', display:'Patogen'}
};
const tabs = [
  {id:'dashboard', label:'Overblik'},
  {id:'planner', label:'Plan'},
  {id:'case_create', label:'Opret'},
  {id:'patients', label:'Patienter'},
  {id:'samples', label:'Prøver'},
  {id:'orders', label:'Ordinationer'},
  {id:'panels', label:'Paneler'},
  {id:'variants', label:'Varianter'},
  {id:'variant_library', label:'Variantbibliotek'},
  {id:'conclusion_library', label:'Standardtekster'},
  {id:'reports', label:'Rapporter'},
  {id:'qc', label:'Kvalitetskontrol'},
  {id:'responses', label:'Svar (MedCom)'},
  {id:'tools', label:'Værktøjskasse'},
  {id:'users', label:'Brugere'},
  {id:'audit', label:'Revision'},
  {id:'db', label:'Database & Backup'},
  {id:'admin', label:'Administration'}
];
const tabIcons = {
  dashboard: 'chart-bar',
  planner: 'calendar-days',
  case_create: 'folder-plus',
  patients: 'user-circle',
  samples: 'beaker',
  orders: 'document-text',
  panels: 'squares-2x2',
  variants: 'dna',
  variant_library: 'book-open',
  conclusion_library: 'clipboard-document',
  reports: 'document-chart-bar',
  qc: 'clipboard-document-check',
  responses: 'inbox',
  tools: 'wrench-screwdriver',
  users: 'user-group',
  audit: 'clock',
  db: 'circle-stack',
  admin: 'shield-check'
};
const ICON_NS = 'http://www.w3.org/2000/svg';
const iconLibrary = {
  'arrow-right-on-rectangle': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15m3 0 3-3m0 0-3-3m3 3H9'}
    ]
  },
  'arrow-left-on-rectangle': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15M12 9l-3 3m0 0 3 3m-3-3h12.75'}
    ]
  },
  'arrows-up-down': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M3 16.5l3 3m0 0 3-3m-3 3V4.5M21 7.5l-3-3m0 0-3 3m3-3v15'}
    ]
  },
  moon: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z'}
    ]
  },
  sun: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z'}
    ]
  },
  'calendar-days': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M6.75 3v2.25m10.5-2.25V5.25M3 8.25h18M4.5 7.5v11.25A2.25 2.25 0 0 0 6.75 21h10.5A2.25 2.25 0 0 0 19.5 18.75V7.5M8.25 12h.008v.008H8.25V12Zm3.75 0h.008v.008H12V12Zm3.75 0h.008v.008H15.75V12Zm-7.5 3.75h.008v.008H8.25V15.75Zm3.75 0h.008v.008H12V15.75Zm3.75 0h.008v.008H15.75V15.75Z'}
    ]
  },
  'chart-bar': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z'}
    ]
  },
  'exclamation-triangle': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l6.857 12.188c.75 1.334-.213 2.988-1.743 2.988H3.143c-1.53 0-2.493-1.654-1.743-2.988L8.257 3.1z'},
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 9v3m0 3h.01'}
    ]
  },
  'folder-plus': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 10.5v6m3-3H9m4.06-7.19-2.12-2.12a1.5 1.5 0 0 0-1.061-.44H4.5A2.25 2.25 0 0 0 2.25 6v12a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9a2.25 2.25 0 0 0-2.25-2.25h-5.379a1.5 1.5 0 0 1-1.06-.44Z'}
    ]
  },
  'user-circle': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M17.982 18.725A7.488 7.488 0 0 0 12 15.75a7.488 7.488 0 0 0-5.982 2.975m11.963 0a9 9 0 1 0-11.963 0m11.963 0A8.966 8.966 0 0 1 12 21a8.966 8.966 0 0 1-5.982-2.275M15 9.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z'}
    ]
  },
  beaker: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M9.75 3.104v5.714a2.25 2.25 0 0 1-.659 1.591L5 14.5M9.75 3.104c-.251.023-.501.05-.75.082m.75-.082a24.301 24.301 0 0 1 4.5 0m0 0v5.714c0 .597.237 1.17.659 1.591L19.8 15.3M14.25 3.104c.251.023.501.05.75.082M19.8 15.3l-1.57.393A9.065 9.065 0 0 1 12 15a9.065 9.065 0 0 0-6.23-.693L5 14.5m14.8.8 1.402 1.402c1.232 1.232.65 3.318-1.067 3.611A48.309 48.309 0 0 1 12 21c-2.773 0-5.491-.235-8.135-.687-1.718-.293-2.3-2.379-1.067-3.61L5 14.5'}
    ]
  },
  'document-text': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z'}
    ]
  },
  'squares-2x2': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M3.75 6A2.25 2.25 0 0 1 6 3.75h2.25A2.25 2.25 0 0 1 10.5 6v2.25a2.25 2.25 0 0 1-2.25 2.25H6a2.25 2.25 0 0 1-2.25-2.25V6ZM3.75 15.75A2.25 2.25 0 0 1 6 13.5h2.25a2.25 2.25 0 0 1 2.25 2.25V18a2.25 2.25 0 0 1-2.25 2.25H6A2.25 2.25 0 0 1 3.75 18v-2.25ZM13.5 6a2.25 2.25 0 0 1 2.25-2.25H18A2.25 2.25 0 0 1 20.25 6v2.25A2.25 2.25 0 0 1 18 10.5h-2.25a2.25 2.25 0 0 1-2.25-2.25V6ZM13.5 15.75a2.25 2.25 0 0 1 2.25-2.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-2.25A2.25 2.25 0 0 1 13.5 18v-2.25Z'}
    ]
  },
  dna: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.6'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M8 3C11 5.2 11 9 8 11.5S5 17.8 8 21'},
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M16 3C13 5.2 13 9 16 11.5S19 17.8 16 21'},
      {'stroke-linecap': 'round', d: 'M6 5h4'},
      {'stroke-linecap': 'round', d: 'M14 5h4'},
      {'stroke-linecap': 'round', d: 'M6 11.5h4'},
      {'stroke-linecap': 'round', d: 'M14 11.5h4'},
      {'stroke-linecap': 'round', d: 'M6 18h4'},
      {'stroke-linecap': 'round', d: 'M14 18h4'}
    ]
  },
  'book-open': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25'}
    ]
  },
  'clipboard-document': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.057 1.123-.08M15.75 18H18a2.25 2.25 0 0 0 2.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 0 0-1.123-.08M15.75 18.75v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5A3.375 3.375 0 0 0 6.375 7.5H5.25m11.9-3.664A2.251 2.251 0 0 0 15 2.25h-1.5a2.251 2.251 0 0 0-2.15 1.586m5.8 0c.065.21.1.433.1.664v.75h-6V4.5c0-.231.035-.454.1-.664M6.75 7.5H4.875c-.621 0-1.125.504-1.125 1.125v12c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V16.5a9 9 0 0 0-9-9Z'}
    ]
  },
  'document-chart-bar': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25M9 16.5v.75m3-3v3M15 12v5.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z'}
    ]
  },
  'clipboard-document-check': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75 2.25 2.25 0 0 0-.1-.664m-5.8 0A2.251 2.251 0 0 1 13.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0 1 18 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3 1.5 1.5 3-3.75'}
    ]
  },
  inbox: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M2.25 13.5h3.86a2.25 2.25 0 0 1 2.012 1.244l.256.512a2.25 2.25 0 0 0 2.013 1.244h3.218a2.25 2.25 0 0 0 2.013-1.244l.256-.512a2.25 2.25 0 0 1 2.013-1.244h3.859m-19.5.338V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18v-4.162c0-.224-.034-.447-.1-.661L19.24 5.338a2.25 2.25 0 0 0-2.15-1.588H6.911a2.25 2.25 0 0 0-2.15 1.588L2.35 13.177a2.25 2.25 0 0 0-.1.661Z'}
    ]
  },
  'wrench-screwdriver': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M11.42 15.17 17.25 21A2.652 2.652 0 0 0 21 17.25l-5.877-5.877M11.42 15.17l2.496-3.03c.317-.384.74-.626 1.208-.766M11.42 15.17l-4.655 5.653a2.548 2.548 0 1 1-3.586-3.586l6.837-5.63m5.108-.233c.55-.164 1.163-.188 1.743-.14a4.5 4.5 0 0 0 4.486-6.336l-3.276 3.277a3.004 3.004 0 0 1-2.25-2.25l3.276-3.276a4.5 4.5 0 0 0-6.336 4.486c.091 1.076-.071 2.264-.904 2.95l-.102.085m-1.745 1.437L5.909 7.5H4.5L2.25 3.75l1.5-1.5L7.5 4.5v1.409l4.26 4.26m-1.745 1.437 1.745-1.437m6.615 8.206L15.75 15.75M4.867 19.125h.008v.008h-.008v-.008Z'}
    ]
  },
  'user-group': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M18 18.72a9.094 9.094 0 0 0 3.741-.479 3 3 0 0 0-4.682-2.72m.94 3.198.001.031c0 .225-.012.447-.037.666A11.944 11.944 0 0 1 12 21c-2.17 0-4.207-.576-5.963-1.584A6.062 6.062 0 0 1 6 18.719m12 0a5.971 5.971 0 0 0-.941-3.197m0 0A5.995 5.995 0 0 0 12 12.75a5.995 5.995 0 0 0-5.058 2.772m0 0a3 3 0 0 0-4.681 2.72 8.986 8.986 0 0 0 3.74.477m.94-3.197a5.971 5.971 0 0 0-.94 3.197M15 6.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm6 3a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Zm-13.5 0a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Z'}
    ]
  },
  clock: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z'}
    ]
  },
  'circle-stack': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M20.25 6.375c0 2.278-3.694 4.125-8.25 4.125S3.75 8.653 3.75 6.375m16.5 0c0-2.278-3.694-4.125-8.25-4.125S3.75 4.097 3.75 6.375m16.5 0v11.25c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125V6.375m16.5 0v3.75m-16.5-3.75v3.75m16.5 0v3.75C20.25 16.153 16.556 18 12 18s-8.25-1.847-8.25-4.125v-3.75m16.5 0c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125'}
    ]
  },
  'shield-check': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M9 12.75 11.25 15 15 9.75m-3-7.036A11.959 11.959 0 0 1 3.598 6 11.99 11.99 0 0 0 3 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285Z'}
    ]
  },
  'clipboard-document-list': {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 0 0 2.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 0 0-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75 2.25 2.25 0 0 0-.1-.664m-5.8 0A2.251 2.251 0 0 1 13.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m0 0H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V9.375c0-.621-.504-1.125-1.125-1.125H8.25ZM6.75 12h.008v.008H6.75V12Zm0 3h.008v.008H6.75V15Zm0 3h.008v.008H6.75V18Z'}
    ]
  },
  trash: {
    viewBox: '0 0 24 24',
    attrs: {fill: 'none', stroke: 'currentColor', 'stroke-width': '1.5'},
    paths: [
      {'stroke-linecap': 'round', 'stroke-linejoin': 'round', d: 'M14.7404 9l-.3462 9M9.6058 18 9.2596 9m9.968-3.2094c.342.0517.6828.107 1.0224.1658m-1.0224-.1658L18.1598 19.6726c-.0902 1.1722-1.0677 2.0774-2.2434 2.0774H8.0836c-1.1757 0-2.1532-.9052-2.2434-2.0774L4.7724 5.7906m14.4552 0c-1.1464-.1731-2.3061-.3057-3.4776-.3963M3.75 5.9563c.3396-.0588.6804-.1141 1.0224-.1657m0 0c1.1464-.1731 2.3061-.3057 3.4776-.3963m7.5 0V4.4782c0-1.1794-.9107-2.1639-2.0894-2.2017C13.1092 2.2589 12.5556 2.25 12 2.25s-1.1092.0089-1.6606.0265C9.1606 2.3142 8.25 3.2988 8.25 4.4782v.9161m7.5 0c-1.2374-.0956-2.488-.1443-3.75-.1443s-2.5126.0487-3.75.1443'}
    ]
  }
};
function createIconElement(name) {
  const def = iconLibrary[name];
  if (!def) return null;
  const svg = document.createElementNS(ICON_NS, 'svg');
  svg.classList.add('icon');
  svg.setAttribute('viewBox', def.viewBox || '0 0 24 24');
  svg.setAttribute('aria-hidden', 'true');
  const attrs = def.attrs || {};
  Object.entries(attrs).forEach(([key, value]) => svg.setAttribute(key, value));
  (def.paths || []).forEach(segment => {
    const node = document.createElementNS(ICON_NS, segment.type || 'path');
    Object.entries(segment).forEach(([key, value]) => {
      if (key === 'type') return;
      node.setAttribute(key, value);
    });
    svg.appendChild(node);
  });
  return svg;
}
function setIcon(slot, name) {
  if (!slot) return;
  slot.dataset.icon = name;
  const icon = createIconElement(name);
  slot.innerHTML = '';
  if (icon) {
    slot.appendChild(icon);
  }
}
function applyIconSlots(scope = document) {
  const root = scope instanceof Element || scope instanceof DocumentFragment ? scope : document;
  root.querySelectorAll('.icon-slot[data-icon]').forEach(slot => {
    setIcon(slot, slot.dataset.icon);
  });
}
applyIconSlots(document);
const SAMPLE_TYPES = ['Blod','Kindskrab','Biopsi','Kontrol'];
const SAMPLE_STATUSES = ['Modtaget','Afventer','QC','Analyse','Tolkning','Godkendelse','Rapport','Svaret','Biobank','Annulleret'];
const FAMILY_TYPES = [
  {value: 'singleton', label: 'Singleton'},
  {value: 'duo', label: 'Duo'},
  {value: 'trio', label: 'Trio'},
  {value: 'other', label: 'Andet'}
];
const FAMILY_TYPE_LABELS = FAMILY_TYPES.reduce((acc, entry) => {
  acc[entry.value] = entry.label;
  return acc;
}, {});
function normalizeFamilyType(value) {
  const asString = typeof value === 'string' ? value.trim().toLowerCase() : '';
  switch (asString) {
    case 'singleton':
    case 'duo':
    case 'trio':
    case 'other':
      return asString;
    default:
      return 'singleton';
  }
}
function getFamilyTypeLabel(value) {
  return FAMILY_TYPE_LABELS[normalizeFamilyType(value)] || 'Singleton';
}
const INACTIVE_SAMPLE_STATUSES = new Set(['svaret','biobank','annulleret']);
function isActiveStatus(status) {
  return !INACTIVE_SAMPLE_STATUSES.has((status || '').toLowerCase());
}

function isLikelyControlSample(sample) {
  if (!sample) return false;
  const type = (sample.sample_type || '').toString().toLowerCase();
  if (type.includes('kontrol') || type.includes('control')) return true;
  const pmb = (sample.pmb_number || '').toString().toLowerCase();
  return pmb.includes('kontrol') || pmb.includes('control');
}

function isControlOrder(order) {
  if (!order) return false;
  const sampleId = Number(order.sample_id);
  if (!Number.isFinite(sampleId)) return false;
  const sample = findById('samples', sampleId);
  return !!sample && isLikelyControlSample(sample);
}

function normalizeCollectionDate(value) {
  if (!value) return '';
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return '';
    const datePart = trimmed.split('T')[0];
    if (datePart && /^\d{4}-\d{2}-\d{2}$/.test(datePart)) return datePart;
    const parsed = new Date(trimmed);
    if (!Number.isNaN(parsed.valueOf())) return parsed.toISOString().slice(0, 10);
    return datePart || '';
  }
  const parsed = new Date(value);
  if (!Number.isNaN(parsed.valueOf())) return parsed.toISOString().slice(0, 10);
  return '';
}

async function syncControlSampleStatus(sample, newStatus) {
  const result = {updated: false, ordersUpdated: false};
  if (!sample) return result;
  if (isLikelyControlSample(sample)) return result;
  const patientId = Number(sample.patient_id);
  if (!Number.isFinite(patientId)) return result;
  const collectedDate = normalizeCollectionDate(sample.collected_at);
  if (!collectedDate) return result;
  const statusToApply = newStatus == null ? '' : String(newStatus).trim();

  const samples = getCached('samples') || [];
  const orders = getCached('orders') || [];
  for (const candidate of samples) {
    if (!candidate || candidate.id === sample.id) continue;
    if (Number(candidate.patient_id) !== patientId) continue;
    if (!isLikelyControlSample(candidate)) continue;
    const candidateDate = normalizeCollectionDate(candidate.collected_at);
    if (!candidateDate || candidateDate !== collectedDate) continue;
    const currentStatus = (candidate.status || '').toString().trim();
    if (currentStatus === statusToApply) continue;
    const beforeSample = {...candidate};
    const updatedSample = {...candidate, status: statusToApply};
    await updateRecord('samples', updatedSample, beforeSample);
    result.updated = true;
    for (const order of orders) {
      if (Number(order.sample_id) !== Number(candidate.id)) continue;
      const orderStatus = (order.status || '').toString().trim();
      if (orderStatus === statusToApply) continue;
      const beforeOrder = {...order};
      const updatedOrder = {...order, status: statusToApply};
      await updateRecord('orders', updatedOrder, beforeOrder);
      result.ordersUpdated = true;
    }
  }
  return result;
}
const DEFAULT_PATIENT_GROUPS = [
  'Arvelige hjertesygdomme',
  'Arvelig hæmatologisk sygdom',
  'Arvelige kolestatiske og fibrotiske leversygdomme',
  'Audiogenetik',
  'Endokrinologiske patienter',
  'Føtal medicin',
  'Hæmatologisk kræft',
  'Kræft hos børn og unge (op til 18 år)',
  'Arvelig kræft hos voksne',
  'Neurogenetiske patienter',
  'Nyresvigt',
  'Oftalmologi',
  'Primær immundefekt',
  'Psykiatri børn og unge',
  'Sjældne sygdomme hos børn og voksne',
  'Svære arvelige hudsygdomme',
  'Udbredt og uhelbredelig kræft'
];
const DEFAULT_QC_METRICS = ['DNA konc.','Dækningsgrad 10X','Gns. dækning'];
const DEFAULT_QC_UNITS = ['ng','ug','%','X'];
const DEFAULT_FHIR_TEMPLATES = [
  {
    name: 'Sundhedsplatformen (SP) – rapport og journal',
    target_system: 'Sundhedsplatformen (EPIC)',
    description: 'CareCommunication-besked med journalnotat og laboratorierapport til Sundhedsplatformen.',
    bundle_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-careCommunication-message',
    message_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-careCommunication-messageHeader',
    message_event_system: 'http://medcom.dk/fhir/medcom-messaging-event',
    message_event_code: 'medcom-carecommunication-report',
    message_event_display: 'MedCom CareCommunication Report',
    destination_name: 'Sundhedsplatformen (SP)',
    diagnostic_report_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-careCommunication-diagnosticReport',
    observation_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-careCommunication-observation',
    include_document_reference: true,
    include_composition: true,
    include_variant_observations: true,
    composition_title: 'Genetisk notat til journal',
    composition_type_system: 'http://loinc.org',
    composition_type_code: '11488-4',
    composition_type_display: 'Consult note',
    composition_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-careCommunication-composition',
    document_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-careCommunication-documentReference',
    document_type_system: 'http://loinc.org',
    document_type_code: '51969-4',
    document_type_display: 'Genetic analysis report',
    document_title: 'Genetisk laboratoriesvar',
    destination_endpoint: '',
    destination_identifier_system: '',
    destination_identifier_value: ''
  },
  {
    name: 'Patologi og Genetik Databank (PGDB) – svar og variantdata',
    target_system: 'Patologi og Genetik Databank (www.patobank.dk)',
    description: 'Laboratoriesvar med variantobservationer til Patobank/PGDB i henhold til MedCom laboratoriemeddelelser.',
    bundle_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-laboratory-message',
    message_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-laboratory-messageHeader',
    message_event_system: 'http://medcom.dk/fhir/medcom-messaging-event',
    message_event_code: 'medcom-lab-reporting',
    message_event_display: 'MedCom Lab Report',
    destination_name: 'Patologi og Genetik Databank',
    destination_endpoint: 'https://www.patobank.dk/fhir/medcom/message',
    diagnostic_report_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-laboratory-diagnosticReport',
    observation_profile: 'http://medcom.dk/fhir/StructureDefinition/medcom-laboratory-observation',
    include_document_reference: false,
    include_composition: false,
    include_variant_observations: true,
    document_profile: '',
    document_type_system: '',
    document_type_code: '',
    document_type_display: '',
    document_title: '',
    composition_profile: '',
    composition_type_system: '',
    composition_type_code: '',
    composition_type_display: '',
    composition_title: ''
  }
];

function sortQcPresets(list) {
  return list
    .filter(item => item && item.value != null)
    .slice()
    .sort((a, b) => {
      const orderA = Number.isFinite(Number(a.sort_order)) ? Number(a.sort_order) : Number.MAX_SAFE_INTEGER;
      const orderB = Number.isFinite(Number(b.sort_order)) ? Number(b.sort_order) : Number.MAX_SAFE_INTEGER;
      if (orderA !== orderB) return orderA - orderB;
      const valueA = String(a.value || '');
      const valueB = String(b.value || '');
      return valueA.localeCompare(valueB, 'da');
    });
}

function getQcPresetValues(kind) {
  const presets = getCached('qc_presets') || [];
  const filtered = sortQcPresets(presets.filter(item => item && item.kind === kind));
  if (filtered.length) {
    return filtered.map(item => String(item.value ?? '')).filter(value => value.trim() !== '');
  }
  return (kind === 'metric' ? DEFAULT_QC_METRICS : DEFAULT_QC_UNITS).slice();
}

function buildQcPresetOptions(kind, currentValue, blankLabel) {
  const values = getQcPresetValues(kind);
  const normalised = new Set();
  const current = (currentValue ?? '').toString();
  const options = [];
  const blankSelected = current.trim() === '';
  options.push(`<option value=""${blankSelected ? ' selected' : ''}>${esc(blankLabel)}</option>`);
  for (const value of values) {
    const trimmed = value.trim();
    if (!trimmed) continue;
    const key = trimmed.toLowerCase();
    if (normalised.has(key)) continue;
    normalised.add(key);
    const selected = !blankSelected && trimmed === current ? ' selected' : '';
    options.push(`<option value="${esc(trimmed)}"${selected}>${esc(trimmed)}</option>`);
  }
  if (!blankSelected && current && !normalised.has(current.toLowerCase())) {
    options.push(`<option value="${esc(current)}" selected>${esc(current)}</option>`);
  }
  return options.join('');
}
const schemaFields = {
  patients: ['id','mrn','extra_id','family_number','healthy_family_member','name','gender','birth_date','notes','created_by','created_at','updated_at'],
  samples: ['id','pmb_number','patient_id','sample_type','collected_at','status','notes','created_by','created_at','updated_at'],
  panels: ['id','name','description','version','gene_list','gene_count','created_at','updated_at','updated_by'],
  orders: ['id','patient_id','sample_id','panel_id','analysis_responsible_id','interpreter_id','approver_id','clinician','indication','patient_group_id','family_type','hpo_terms','status','acute','urgent','ordered_at','created_by','created_at','updated_at'],
  patient_groups: ['id','name','created_by','created_at','updated_at'],
  variants: ['id','order_id','variant_type','gene','transcript','hgvs_c','hgvs_p','rsid','zygosity','classification','criteria','af','annotations','interpretation','genomic_position','genome_build','chromosome','start','end','copy_number','sv_subtype','size_bp','iscn','description','affected_genes','created_by','created_at','updated_at'],
  qc: ['id','sample_id','metric','value','unit','notes','created_by','created_at','updated_at'],
  qc_presets: ['id','kind','value','sort_order','created_by','created_at','updated_at'],
  reports: ['id','order_id','findings','variant_ids','variant_details','summary','status','issued_at','created_by','created_at','updated_at'],
  users: ['id','name','email','role','pin','created_at','updated_at'],
  audit: ['id','ts','user','action','entity','entity_id','before','after','created_at','updated_at'],
  variant_library: ['id','variant_type','gene','transcript','hgvs_c','hgvs_p','rsid','classification','criteria','genomic_position','evidence','condition','inheritance','genome_build','chromosome','start','end','copy_number','sv_subtype','size_bp','iscn','description','affected_genes','curated_by','last_review','created_at','updated_at'],
  responses: ['id','ts','sender','patient','diagnostic_report_id','variant_count','variants','raw','created_at','updated_at'],
  fhir_templates: ['id','name','target_system','description','bundle_profile','message_profile','message_event_system','message_event_code','message_event_display','destination_name','destination_endpoint','destination_identifier_system','destination_identifier_value','diagnostic_report_profile','observation_profile','include_document_reference','include_composition','include_variant_observations','composition_title','composition_type_system','composition_type_code','composition_type_display','composition_profile','document_type_system','document_type_code','document_type_display','document_title','document_profile','created_by','created_at','updated_at'],
  conclusion_library: ['id','title','body','created_by','created_at','updated_at'],
  planner: ['id','user_id','tasks','view','created_at','updated_at']
};
const tooltipCatalog = {
  tabs: {
    dashboard: 'Viser nøgletal, seneste ordinationer og seneste revisionshændelser.',
    planner: 'Planlæg laboratorieopgaver på tværs af ordinationer og roller.',
    case_create: 'Opret patient, prøve, ordination, QC og varianter i ét samlet flow.',
    patients: 'Administrer patientoplysninger og søg i patientlisten.',
    samples: 'Registrer og vedligehold prøver knyttet til patienter.',
    orders: 'Administrer analyseordinationer og deres status.',
    panels: 'Vedligehold genpaneler.',
    variants: 'Registrer genetiske varianter for ordinationer.',
    variant_library: 'Se og vedligehold det kuraterede variantbibliotek.',
    conclusion_library: 'Administrer standardtekster til rapportkonklusioner.',
    reports: 'Opret og redigér laboratoriesvar og rapporter.',
    qc: 'Registrer kvalitetskontrolmålinger for prøver.',
    responses: 'Importer og gennemse MedCom/FHIR-svar og eksportér via skabeloner.',
    tools: 'Åbn værktøjskassen med beregnere og hjælpeværktøjer til variantfortolkning.',
    users: 'Administrer GlimR-brugere og roller.',
    audit: 'Gennemgå revisionsloggen for alle ændringer.',
    db: 'Håndter lokal databasefil, backup, eksport og autogem.',
    admin: 'Tilgå administrative værktøjer, selvtest og patientgrupper.'
  },
  metrics: {
    'Patienter': 'Antal registrerede patienter i databasen.',
    'Prøver': 'Antal registrerede laboratorieprøver.',
    'Ordinationer': 'Samlet antal aktive og historiske ordinationer.',
    'Modtaget': 'Prøver registreret som modtaget i laboratoriet.',
    'Akutte/Haster': 'Aktive ordinationer markeret som akut eller haster.',
    'Analyse': 'Prøver markeret som i analysefasen.',
    'Tolkning': 'Prøver under tolkning eller godkendelse af resultater.',
    'Rapport': 'Prøver i rapporteringsfasen.',
    'Varianter': 'Antal registrerede genetiske varianter.',
    'Biobank': 'Prøver arkiveret i biobanken.'
  },
  headers: {
    'ID': 'Internt ID for posten eller patientens supplerende ID (valgfrit).',
    'MRN': 'Medicinsk journalnummer eller CPR-reference.',
    'Ekstra ID': 'Supplerende identifikator for patienten (valgfrit).',
    'Familienummer': 'Eksternt familienummer brugt til at gruppere beslægtede patienter.',
    'Navn': 'Navnet på patient, panel eller bruger.',
    'Rolle': 'Din registrerede funktion i relation til ordinationen (fx Analytiker eller Godkender).',
    'Køn': 'Patientens registrerede køn.',
    'Født': 'Patientens fødselsdato.',
    'Patient': 'Tilknyttet patient til posten.',
    'Prøve': 'Prøve-ID eller beskrivelse.',
    'Prøvetype': 'Type af biologisk materiale.',
    'Panel': 'Navn på det analyserede panel.',
    'Version': 'Versionsnummer for panelet. Øges automatisk ved ændringer men kan justeres manuelt.',
    'Opdateret af': 'Bruger der senest har gemt ændringer på panelet.',
    'Analyseansvarlig': 'Bruger der har det overordnede ansvar for analysen.',
    'Tolker': 'Bruger der tolker de genetiske fund.',
    'Godkender': 'Bruger der godkender ordinationen eller rapporten.',
    'Indikation': 'Klinisk indikation angivet for ordinationen.',
    'Indikationer': 'Kommasepareret liste over ordinationers indikationer for patienten.',
    'HPO-termer': 'Registrerede HPO-termer knyttet til ordinationen.',
    'Status': 'Aktuel status for posten.',
    'Opdateret': 'Seneste ændringstidspunkt.',
    'Antal gener': 'Optalt antal gener i panelets genliste.',
    'Genliste': 'Kommasepareret liste over gener inkluderet i panelet.',
    'Bestilt': 'Tidspunkt for oprettelse af ordinationen.',
    'Genveje': 'Genveje til relaterede visninger for ordinationen.',
    'Opsamlet': 'Dato og tidspunkt for prøveindsamling.',
    'Ordination': 'Reference til ordinationen.',
    'Gen': 'Genet hvor varianten er fundet.',
    'Transkript': 'Reference-transkript for varianten.',
    'HGVS c.': 'HGVS-beskrivelse på cDNA-niveau.',
    'HGVS p.': 'HGVS-beskrivelse på protein-niveau.',
    'rsID': 'dbSNP-referencenummer (rsID) for SNV/indel.',
    'Klasse': 'ACMG-klassifikation 1–5.',
    'Kriterier': 'Anvendte ACMG-kriterier.',
    'HGVS': 'HGVS-beskrivelse for varianten.',
    'Evidens': 'Kurateret evidens for varianten.',
    'Kurateret af': 'Navn på ansvarlig kurator.',
    'Sidst gennemgået': 'Dato for seneste kuratoriske gennemgang.',
    'Tilstand': 'Associeret sygdom eller klinisk tilstand.',
    'Nedarvning': 'Beskriver variantens nedarvningsmønster.',
    'Oprettet': 'Tidspunkt for hvornår posten blev oprettet.',
    'Opdateret': 'Tidspunkt for den seneste ændring.',
    'Beskrivelse': 'Uddybende beskrivelse.',
    'Måling': 'Navn på kvalitetskontrolmålingen.',
    'Værdi': 'Målt værdi.',
    'Enhed': 'Måleenhed for værdien.',
    'Tid': 'Tidsstempel for hændelsen.',
    'Handling': 'Registreret handlingstype.',
    'Entitet': 'Tabellen som blev ændret.',
    'Før': 'Data før ændringen.',
    'Efter': 'Data efter ændringen.',
    'Sender': 'Afsendende organisation eller system.',
    'Rapport': 'DiagnosticReport-identifikator.',
    'Varianter': 'Antal varianter i posten.',
    'Udstedt': 'Tidspunkt hvor rapporten blev udsendt.',
    'Test': 'Navn på selvtesten.',
    'Detaljer': 'Supplerende oplysninger til testen.'
  },
  search: {
    patientSearch: 'Filtrer patientlisten efter navn, MRN, ID, familienummer eller køn.',
    sampleSearch: 'Filtrer prøver efter ID, PMB-nummer, status eller type.',
      panelSearch: 'Find paneler efter navn, version, bruger eller gener.',
    orderSearch: 'Søg efter ordination ud fra status eller ID.',
    variantSearch: 'Søg efter varianter baseret på gen eller HGVS.',
    libSearch: 'Filtrer variantbiblioteket efter gen eller HGVS.',
    reportSearch: 'Find rapporter ved at søge på status.',
    qcSearch: 'Søg efter kvalitetsmålinger.',
    userSearch: 'Søg brugere på navn, e-mail eller rolle.',
    fhirTemplateSearch: 'Find FHIR-skabeloner efter navn, modtagersystem eller beskrivelse.'
  },
  forms: {
    patientForm: {
      mrn: 'Patientens MRN/CPR til entydig identifikation.',
      extra_id: 'Supplerende identifikator til intern brug (valgfrit).',
      family_number: 'Familienummer anvendt til at gruppere beslægtede patienter.',
      healthy_family_member: 'Markér patienten som rask familiemedlem. Opgaver får særlig markering i arbejdsplanlæggeren.',
      name: 'Patientens fulde navn som angivet i journalen.',
      gender: 'Registreret køn for patienten.',
      birth_date: 'Patientens fødselsdato (ÅÅÅÅ-MM-DD).',
      notes: 'Evt. kliniske noter om patienten.'
    },
    sampleForm: {
      patient_id: 'Vælg hvilken patient prøven tilhører.',
      pmb_number: 'Unikt PMB-nummer anvendt i andre systemer.',
      sample_type: 'Vælg prøvetype fra listen.',
      status: 'Prøvens aktuelle laboratoriestatus.',
      collected_at: 'Dato og tidspunkt for prøveindsamling.',
      notes: 'Evt. bemærkninger til prøven.'
    },
    panelForm: {
      name: 'Navn på analysepanelet eller assay.',
      description: 'Beskriv kort panelets indhold og formål.',
      gene_list: 'Kommasepareret liste over gener der indgår i panelet. Antallet beregnes automatisk.'
    },
    orderForm: {
      patient_id: 'Vælg patienten ordinationen vedrører.',
      sample_id: 'Vælg den prøve der analyseres.',
      panel_id: 'Vælg panel for analysen (valgfrit).',
      analysis_responsible_id: 'Vælg hvem der er analyseansvarlig.',
      interpreter_id: 'Vælg den bruger der tolker resultaterne.',
      approver_id: 'Vælg den bruger der godkender ordinationen.',
      clinician: 'Navn på rekvirerende kliniker eller afdeling.',
      indication: 'Klinisk indikation eller henvisningsårsag for ordinationen.',
      patient_group_id: 'Valgfrit – klassificér ordinationen efter patientgruppe.',
      hpo_terms: 'Valgfri liste over relevante HPO-termer (én per linje eller separeret af semikolon).',
      status: 'Ordinationens arbejdsgangstatus.',
      acute: 'Markér ordinationen som akut – vises med rødt advarselsikon i oversigten.',
      urgent: 'Markér ordinationen som haster – vises med gult advarselsikon i oversigten.',
      ordered_at: 'Tidspunkt for oprettelse af ordinationen.'
    },
    variantForm: {
      order_id: 'Ordination som varianten er registreret på.',
      variant_type: 'Vælg om fundet er en SNV/indel, CNV, strukturel variant eller cytogenetisk forandring.',
      gene: 'Gen-symbol eller primære gener for fundet.',
      transcript: 'Reference-transkript (fx NM_) for SNV/indel.',
      hgvs_c: 'HGVS-beskrivelse på cDNA-niveau (SNV/indel).',
      hgvs_p: 'HGVS-beskrivelse på protein-niveau (SNV/indel).',
      rsid: 'dbSNP-reference (rsID), fx rs80357713, for SNV/indel.',
      genomic_position: 'Genomisk position (fx chr19-11105362) for SNV/indel.',
      zygosity: 'Zygositetsstatus (fx heterozygot).',
      classification: 'ACMG-klassifikation 1 (benign) – 5 (patogen).',
      criteria: 'Anfør anvendte ACMG- eller CNV-kriterier, adskilt af komma.',
      af: 'VAF (Variant Allele Frequency) eller observationsfrekvens.',
      annotations: 'Supplerende annoteringer fra eksterne værktøjer såsom VarSeq.',
      interpretation: 'Klinisk tolkning og evidens for varianten.',
      genome_build: 'Angiv reference-genom (fx GRCh38) for CNV/SV.',
      chromosome: 'Kromosom eller kromosomarm for CNV/SV.',
      start: 'Genomisk startposition.',
      end: 'Genomisk slutposition.',
      copy_number: 'Angiv kopital (fx x1, x3) ved CNV/aneuploidi.',
      sv_subtype: 'Vælg strukturtype for CNV/SV/cytogenetiske fund.',
      size_bp: 'Variantens størrelse i baser eller Mb.',
      iscn: 'ISCN-beskrivelse af cytogenetisk fund.',
      description: 'Valgfri fri tekst til yderligere beskrivelse.',
      affected_genes: 'Liste over berørte gener ved CNV/SV.'
    },
    variantLibraryForm: {
      variant_type: 'Varianttype for biblioteksposten.',
      gene: 'Gen-symbol eller primære gener.',
      transcript: 'Reference-transkript brugt til kurateringen.',
      hgvs_c: 'HGVS cDNA-beskrivelse (SNV/indel).',
      hgvs_p: 'HGVS protein-beskrivelse (SNV/indel).',
      rsid: 'dbSNP-reference (rsID) knyttet til varianten.',
      genomic_position: 'Genomisk position (fx chr19-11105362) for SNV/indel.',
      classification: 'Kurateret ACMG-klassifikation eller tilsvarende vurdering.',
      criteria: 'De kriterier der understøtter klassifikationen.',
      evidence: 'Sammendrag af litteratur, observationer eller noter.',
      condition: 'Associeret sygdom eller klinisk tilstand.',
      inheritance: 'Beskriv nedarvningsmønstret, fx autosomal dominant.',
      genome_build: 'Reference-genom for CNV/SV.',
      chromosome: 'Kromosom/karyotypisk lokalisation.',
      start: 'Genomisk startposition.',
      end: 'Genomisk slutposition.',
      copy_number: 'Kopital for CNV eller aneuploidi.',
      sv_subtype: 'Vælg strukturtype fra listen for CNV/SV/cytogenetik.',
      size_bp: 'Størrelse i baser eller Mb.',
      iscn: 'ISCN-streng for cytogenetiske beskrivelser.',
      description: 'Supplerende fri tekst.',
      affected_genes: 'Berørte gener i varianten.',
      curated_by: 'Navn på kurator eller team der har ansvaret.',
      last_review: 'Dato for seneste gennemgang (ÅÅÅÅ-MM-DD).'
    },
    conclusionLibraryForm: {
      title: 'Sigende titel, fx formål eller patientgruppe.',
      body: 'Standardtekst der kan indsættes som rapportkonklusion.'
    },
    reportForm: {
      order_id: 'Ordinationen som rapporten beskriver.',
      status: 'Rapportstatus (udkast, endelig eller ændret).',
      issued_at: 'Dato og tidspunkt for rapportens udsendelse.',
      variant_ids: 'Tilføj de registrerede varianter, der skal indgå i rapporten.',
      summary: 'Kort konklusion til modtageren.'
    },
    qcForm: {
      sample_id: 'Vælg den prøve QC-målingen relaterer til.',
      metric: 'Navn på kvalitetskontrolparameteren.',
      value: 'Målt værdi for QC-parameteren.',
      unit: 'Måleenhed (fx %, ng/µl).',
      notes: 'Supplerende noter om målingen.'
    },
    primerTool: {
      sequence: 'Indsæt sekvensen som primere skal designes imod (tillader A/C/G/T/U/N).',
      start: '1-baseret startposition for det ønskede amplicon (valgfri).',
      end: '1-baseret slutposition for ampliconet (valgfri).',
      min_len: 'Mindste længde for foreslåede primere.',
      max_len: 'Største længde for foreslåede primere.',
      target_tm: 'Ønsket smeltetemperatur (Tm) for primerparret i °C.'
    },
    createCaseForm: {
      patient_mrn: 'Patientens MRN eller CPR til entydig identifikation.',
      patient_extra_id: 'Supplerende identifikator til lokal brug (valgfrit).',
      patient_family: 'Evt. familienummer der kobler patienten til andre sager.',
      patient_healthy: 'Markér patienten som rask familiemedlem. Opgaver får særlig markering i arbejdsplanlæggeren.',
      patient_name: 'Patientens fulde navn.',
      patient_gender: 'Patientens registrerede køn.',
      patient_birth: 'Patientens fødselsdato.',
      patient_notes: 'Evt. kliniske noter om patienten.',
      sample_pmb: 'Unikt PMB-nummer for den primære prøve.',
      sample_type: 'Vælg prøvetype for hovedprøven.',
      sample_status: 'Status for prøven og den tilknyttede ordination.',
      sample_collected: 'Dato og tidspunkt for prøveindsamlingen.',
      sample_notes: 'Noter om hovedprøven.',
      control_pmb: 'PMB-nummer for kontrolprøven.',
      control_type: 'Prøvetype for kontrolprøven.',
      control_status: 'Status for kontrolprøven.',
      control_collected: 'Dato og tidspunkt for kontrolprøven.',
      control_notes: 'Noter om kontrolprøven.',
      order_panel_id: 'Vælg hvilket panel ordinationen omfatter.',
      order_family_type: 'Vælg om ordinationen er for singleton, duo, trio eller andet forløb.',
      order_analysis_responsible: 'Vælg analyseansvarlig bruger.',
      order_interpreter: 'Vælg den bruger der tolker fundene.',
      order_approver: 'Vælg den bruger der godkender ordinationen.',
      order_clinician: 'Rekvirerende kliniker eller afdeling.',
      order_indication: 'Klinisk indikation eller henvisningsårsag for ordinationen.',
      order_acute: 'Markér ordinationen som akut – vises med rødt advarselsikon i oversigten.',
      order_urgent: 'Markér ordinationen som haster – vises med gult advarselsikon i oversigten.',
      order_patient_group: 'Valgfrit – vælg patientgruppe for ordinationen.',
      order_hpo_terms: 'Valgfri liste over HPO-termer (én per linje eller separeret af semikolon).',
      order_ordered_at: 'Tidspunkt hvor ordinationen registreres.'
    },
    fhirTemplateForm: {
      name: 'Navn der gør skabelonen let at genkende ved FHIR-eksport (fx Sundhedsplatformen).',
      target_system: 'Beskriv modtagersystemet, fx EPIC Sundhedsplatformen eller Patologi og Genetik Databank.',
      destination_name: 'Visningsnavn for destinationen i MessageHeader.destination.name.',
      destination_endpoint: 'HTTP-endpoint eller adresse til modtagerens MedCom gateway.',
      composition_title: 'Overskrift for Composition/journalnotat, når CareCommunication anvendes.',
      description: 'Kort forklaring af hvornår skabelonen bruges og særlige MedCom-krav.',
      message_event_system: 'URI til MedComs event-kodesystem (typisk http://medcom.dk/fhir/medcom-messaging-event).',
      message_event_code: 'Event-kode fra MedCom (fx medcom-carecommunication-report eller medcom-lab-reporting).',
      message_event_display: 'Visningstekst til event-koden som modtageren ser.',
      bundle_profile: 'FHIR-profil for hele bundlen (fx medcom-careCommunication-message).',
      message_profile: 'FHIR-profil for MessageHeader (fx medcom-careCommunication-messageHeader).',
      diagnostic_report_profile: 'Profil for DiagnosticReport (fx medcom-careCommunication-diagnosticReport).',
      observation_profile: 'Profil for Observationer, når variantdata skal følge MedCom laboratoriestandarder.',
      destination_identifier_system: 'Identifier-system for destination.receiver.identifier (urn:oid fra MedCom-aftalen).',
      destination_identifier_value: 'Identifier-værdi der matcher modtagerens registrerede endpoint-ID.',
      include_variant_observations: 'Medtag Observation-ressourcer for hver variant i svaret.',
      include_document_reference: 'Medtag DocumentReference med rapportbilag, når modtageren forventer dokumentprofilen.',
      include_composition: 'Medtag Composition/journalnotat for modtagere der understøtter CareCommunication-dokumenter.',
      document_profile: 'Profil for DocumentReference (fx medcom-careCommunication-documentReference).',
      document_type_system: 'Kodesystem til DocumentReference.type (ofte http://loinc.org).',
      document_type_code: 'Kode for DocumentReference.type (fx 51969-4 for genetisk rapport).',
      document_type_display: 'Visningstekst for DocumentReference.type.',
      document_title: 'Titel der vises på dokumentbilaget for modtageren.',
      composition_profile: 'Profil for Composition (fx medcom-careCommunication-composition).',
      composition_type_system: 'Kodesystem til Composition.type (fx http://loinc.org).',
      composition_type_code: 'Kode for Composition.type (fx 11488-4 for konsultationsnotat).',
      composition_type_display: 'Visningstekst for Composition.type.'
    },
    userForm: {
      name: 'Brugerens fulde navn.',
      email: 'Brugerens arbejds-e-mailadresse.',
      role: 'Vælg brugerrolle for at fastlægge læse- eller skriveadgang.',
      pin: 'Valgfri adgangskode, der kræves ved login for brugeren.'
    }
  },
  buttons: {
    demoDataBtn: 'Indlæser et demodatasæt til hurtig afprøvning (kræver skriveadgang).',
    runTestsBtn: 'Kører den indbyggede selvtest og viser resultater.',
    resetDataBtn: 'Downloader en fuld backup og rydder alle data undtagen brugerlisten.',
    patientClear: 'Ryd formularen for at registrere en ny patient.',
    patientDelete: 'Slet den valgte patient permanent.',
    sampleClear: 'Ryd formularen for at registrere en ny prøve.',
    sampleDelete: 'Slet den valgte prøve.',
    panelClear: 'Ryd formularen for at oprette et nyt panel.',
    panelDelete: 'Slet det valgte panel.',
    panelsExport: 'Eksportér den filtrerede panelliste som tekstfil.',
    orderClear: 'Ryd formularen for at oprette en ny ordination.',
    orderDelete: 'Slet den valgte ordination.',
    variantClear: 'Ryd formularen for at registrere en ny variant.',
    variantSaveNew: 'Gem varianten som en ny registrering uden at overskrive den valgte.',
    variantDelete: 'Slet den valgte variant.',
    variantToLibrary: 'Tilføj varianten til det kuraterede bibliotek.',
    variantFromLibrary: 'Hent variantoplysninger fra biblioteket.',
    variantLibraryClear: 'Ryd formularen for at oprette en ny bibliotekspost.',
    variantLibraryDelete: 'Slet den valgte bibliotekspost.',
    variantLibrarySaveNew: 'Gem biblioteksposten som en ny registrering.',
    variantLibrarySave: 'Gem ændringerne til den valgte bibliotekspost.',
    libraryExportCsv: 'Eksportér de viste biblioteksposter til en CSV-fil.',
    libraryImportCsv: 'Importer biblioteksposter fra en CSV-fil.',
    conclusionLibraryClear: 'Ryd formularen for at oprette en ny standardtekst.',
    conclusionLibraryDelete: 'Slet den valgte standardtekst.',
    conclusionLibraryInsert: 'Erstat konklusionsfeltet med den valgte standardtekst.',
    conclusionLibraryAppend: 'Tilføj den valgte tekst til eksisterende konklusion.',
    reportClear: 'Ryd formularen for at skrive en ny rapport.',
    reportDelete: 'Slet den valgte rapport.',
    reportPreview: 'Åbn rapporten i en ny fane til forhåndsvisning.',
    reportAddVariant: 'Tilføj den valgte variant til rapporten.',
    qcClear: 'Ryd formularen for at registrere en ny QC-måling.',
    qcDelete: 'Slet den valgte QC-måling.',
    userClear: 'Ryd formularen for at oprette en ny bruger.',
    userDelete: 'Slet den valgte bruger.',
    acmgReset: 'Ryd alle valgte ACMG-kriterier.',
    distanceSwap: 'Byt start- og slutposition for beregningen.',
    primerDesign: 'Analyser sekvensen og foreslå et primerpar baseret på indstillingerne.',
    primerClear: 'Ryd formularen for at starte et nyt primerdesign.',
    gcUpper: 'Fjern mellemrum og konverter sekvensen til store bogstaver.',
    gcReverse: 'Beregn og indsæt den omvendt komplementære sekvens.',
    blastSubmit: 'Sender sekvensen til NCBI BLAST i en ny fane.',
    blastClear: 'Rydder felterne for en ny BLAST-forespørgsel.',
    patientsExport: 'Eksportér den aktuelt filtrerede patientliste til en CSV-fil.',
    samplesExport: 'Eksportér de filtrerede prøver som CSV til deling eller videre analyse.',
    ordersExport: 'Eksportér ordinationerne der matcher filtrene som CSV.',
    variantsExport: 'Eksportér filtrerede varianter inklusive ACMG-data til CSV.',
    reportsExport: 'Eksportér rapportlisten med de valgte filtre som CSV.',
    themeToggle: 'Skifter mellem lyst og mørkt layout for GlimR.',
    logoutBtn: 'Log brugeren ud og lås GlimR for redigering.',
    generateFhir: 'Generér og download et FHIR-svar for ordinationen.',
    previewFhir: 'Vis FHIR-bundlen som JSON uden download.',
    downloadSql: 'Download komplet MySQL-dump af GlimR-data.',
    showSchema: 'Vis MySQL-skemaet direkte på siden.',
    downloadZip: 'Download ZIP med GlimR og aktuelle data.',
    downloadCsvBackup: 'Eksportér alle datatabeller som CSV-filer i et ZIP-arkiv.',
    restoreCsvBackup: 'Importer komplette CSV-datatabeller fra en CSV- eller ZIP-fil.',
    bindFile: 'Vælg eller opret en lokal databasefil til autogem.',
    saveNow: 'Gem straks til den tilknyttede databasefil.',
    downloadBackup: 'Eksportér alle data som JSON-backup.',
    submit: 'Gemmer formularens indhold i databasen.',
    addQcRow: 'Tilføj en ekstra QC-måling til prøven.',
    addVariantRow: 'Tilføj endnu en variant til ordinationen.',
    caseImportVarSeq: 'Importer varianter fra en VarSeq-CSV direkte i oprettelsesflowet.',
    variantBatchAdd: 'Tilføj en tom række til masseoprettelse af varianter.',
    variantBatchImport: 'Importer en VarSeq-CSV og udfyld rækkerne automatisk.',
    variantBatchSave: 'Gem alle udfyldte rækker på den valgte ordination.',
    variantBatchClear: 'Ryd alle midlertidige rækker uden at gemme dem.',
    createCaseSubmit: 'Opretter patient, prøve, ordination, QC og varianter i ét trin.',
    createCaseReset: 'Ryd alle felter i oprettelsesformularen.',
    'Vælg fra bibliotek': 'Hent variantoplysninger fra biblioteket.',
    fhirTemplateSave: 'Gem eller opdater den valgte FHIR-skabelon.',
    fhirTemplateClear: 'Ryd formularen og start en ny FHIR-skabelon.',
    fhirTemplateDelete: 'Slet den valgte FHIR-skabelon permanent.'
  },
  controls: {
    autosaveToggle: 'Aktiver eller deaktiver automatisk gemning til fil.',
    fhirOrderSelect: 'Vælg hvilken ordination der skal bruges til FHIR-svar.',
    fhirTemplateSelect: 'Vælg hvilken FHIR-skabelon og MedCom-profil der skal anvendes til eksport.',
    fhirTemplateSummary: 'Oversigt over felter, profiler og leveringsinformation for den valgte skabelon.',
    fhirImportLabel: 'Importer en modtaget FHIR JSON-fil.',
    fhirPreview: 'JSON-visning af den genererede FHIR-bundle.',
    reportVariantSelect: 'Vælg blandt ordinationens registrerede varianter.',
    reportVariantList: 'Varianter der er føjet til rapportens fund.',
    restoreBackup: 'Gendan databasen fra en tidligere JSON-backup.',
    restoreCsvFile: 'Vælg CSV- eller ZIP-filer med datatabeller til import.',
    schemaText: 'Viser MySQL-skema og INSERT-statements til reference.',
    patientsFilterPanel: 'Åbn avancerede filtre for at søge præcist i patientlisten.',
    samplesFilterPanel: 'Finfiltrér prøver efter patient, status og indsamlingstid.',
    ordersFilterPanel: 'Filtrer ordinationer på patient, panel, status og dato.',
    variantsFilterPanel: 'Indsnævr variantoversigten efter gen, ordination og ACMG-klasse.',
    reportsFilterPanel: 'Begræns rapportlisten efter status, ordination og udstedelsesdato.',
    loginUser: 'Vælg hvilken GlimR-bruger der skal logges ind.',
    loginPass: 'Indtast brugerens adgangskode hvis der er opsat en PIN.',
    includeControlSample: 'Aktiver for at registrere en ekstra kontrolprøve på samme patient.',
    orderStatusPreview: 'Viser hvilken status den nye ordination får. Status følger prøvens valg.',
    caseVariantHint: 'Information om tilknyttede varianter i den nye sag.',
    variantLibraryImportInput: 'Vælg en CSV-fil der indeholder biblioteksposter til import.',
    caseImportVarSeqInput: 'Vælg en VarSeq CSV-fil med fund, som skal tilføjes til sagen.',
    variantBatchOrder: 'Vælg den ordination som de importerede varianter skal knyttes til.',
    variantBatchMessage: 'Status og advarsler for masseoprettelse af varianter.',
    variantBatchFile: 'Vælg en VarSeq CSV-fil til masseimport.',
    acmgTool: 'Vælg de kriterier der er opfyldt, for at få et ACMG-forslag.',
    distanceTool: 'Indtast to koordinater for at udregne den genomiske afstand.',
    distanceStart: 'Genomisk startposition, fx 123456 eller chr7:123456.',
    distanceEnd: 'Genomisk slutposition. Bogstaver ignoreres automatisk.',
    distanceResult: 'Viser antal baser mellem positionerne (inkl./ekskl.).',
    primerTool: 'Design primere ud fra en målsekvens og ønskede parametre.',
    primerSequence: 'Indsæt målsekvensen for primerdesign (A/C/G/T/U/N tilladt).',
    primerStart: '1-baseret startposition for det ønskede amplicon (valgfri).',
    primerEnd: '1-baseret slutposition for ampliconet (valgfri).',
    primerMinLen: 'Mindste længde for foreslåede primere.',
    primerMaxLen: 'Største længde for foreslåede primere.',
    primerTargetTm: 'Ønsket smeltetemperatur (Tm) for primerparret.',
    primerResult: 'Opsummerer det foreslåede primerpar og relevante advarsler.',
    gcSequence: 'Indsæt DNA/RNA-sekvens for at beregne længde og GC%.',
    acmgResult: 'Opsummering af den foreslåede klassifikation baseret på kriterierne.',
    gcResult: 'Opsummerer længde, GC% og basefordeling for sekvensen.',
    blastForm: 'Send sekvensen til NCBI BLAST via en ny browserfane.',
    blastProgram: 'Vælg BLAST-program ud fra om sekvensen er nukleotid eller protein.',
    blastDatabase: 'Vælg hvilken NCBI-database der skal søges imod.',
    blastExpect: 'Valgfrit E-værditærskel (fx 1e-5) for resultaterne.',
    blastTitle: 'Valgfri titel der indsættes som FASTA-header hvis den mangler.',
    blastOrganism: 'Filtrér mod en organisme via Entrez-søgestreng (fx Homo sapiens [taxid:9606]).',
    blastQuery: 'Indsæt DNA- eller proteinsekvens (FASTA eller rå tekst).',
    blastMegablast: 'Brug MEGABLAST for hurtig søgning efter meget lignende DNA-sekvenser (kun blastn).',
    blastStatus: 'Statusbeskeder for BLAST-forespørgsler og eventuelle fejl.'
  }
};
function setTooltip(el, text) {
  if (!el || !text) return;
  el.title = text;
  el.dataset.tip = text;
  el.setAttribute('aria-label', text);
}
function annotateHeaders(root) {
  if (!root) return;
  root.querySelectorAll('th').forEach(th => {
    const key = th.textContent.trim();
    const tip = tooltipCatalog.headers[key] || `Kolonne: ${key}`;
    setTooltip(th, tip);
  });
}
function annotateTableCells(root) {
  if (!root) return;
  root.querySelectorAll('tbody td').forEach(td => {
    const nested = td.querySelector('[data-full-text]');
    const fullText = td.dataset.fullText || nested?.dataset.fullText || '';
    const text = fullText || td.textContent.trim();
    if (!text) return;
    setTooltip(td, text);
    td.querySelectorAll('.truncate-text').forEach(el => setTooltip(el, text));
  });
}
function annotateSearchInputs(root) {
  if (!root) return;
  root.querySelectorAll('input[type="search"]').forEach(input => {
    const tip = tooltipCatalog.search[input.id] || 'Filtrer tabellen ved at indtaste søgetekst.';
    setTooltip(input, tip);
  });
}
function applyMetricTooltips(root) {
  if (!root) return;
  root.querySelectorAll('.badge').forEach(badge => {
    const key = badge.textContent.trim();
    const tip = tooltipCatalog.metrics[key];
    if (tip) {
      setTooltip(badge, tip);
      const container = badge.parentElement;
      if (container) {
        setTooltip(container, tip);
        const value = container.querySelector('h3');
        if (value) setTooltip(value, tip);
      }
    }
  });
}
function applyFormTooltips(form) {
  if (!form) return;
  const map = tooltipCatalog.forms[form.id];
  if (map) {
    Object.entries(map).forEach(([name, tip]) => {
      const field = form.elements[name];
      if (!field) return;
      const isRadioList = typeof RadioNodeList !== 'undefined' && field instanceof RadioNodeList;
      const el = isRadioList ? field[0] : field;
      if (!el) return;
      setTooltip(el, tip);
      const label = el.closest('label');
      if (label) {
        setTooltip(label, tip);
      } else if (el.id) {
        const explicit = form.querySelector(`label[for="${el.id.replace(/"/g, '\\"')}"]`);
        if (explicit) setTooltip(explicit, tip);
      }
      const filterable = el.closest('.filterable-select');
      if (filterable) {
        setTooltip(filterable, tip);
        const filterInput = filterable.querySelector('input[data-select-filter]');
        if (filterInput) setTooltip(filterInput, tip);
      }
    });
  }
  const submit = form.querySelector('button[type="submit"]');
  if (submit) setTooltip(submit, tooltipCatalog.buttons.submit);
}
function applyButtonTooltips(root) {
  if (!root) return;
  root.querySelectorAll('button').forEach(btn => {
    const tip = tooltipCatalog.buttons[btn.id] || tooltipCatalog.buttons[btn.textContent.trim()];
    if (tip) setTooltip(btn, tip);
  });
}
function applyControlTooltips(root) {
  if (!root) return;
  Object.entries(tooltipCatalog.controls).forEach(([id, tip]) => {
    const el = root.querySelector(`#${id}`);
    if (el) {
      setTooltip(el, tip);
      if (el.tagName === 'INPUT' && el.type === 'checkbox' && el.parentElement) {
        setTooltip(el.parentElement, tip);
      }
    }
  });
}
function applySelectFilters(root) {
  if (!root) return;
  root.querySelectorAll('.filterable-select').forEach(wrapper => {
    const input = wrapper.querySelector('input[data-select-filter]');
    const select = wrapper.querySelector('select');
    if (!input || !select || wrapper.dataset.filterInit) return;
    const options = Array.from(select.options).map(option => ({
      option,
      text: option.textContent.toLowerCase()
    }));
    input.addEventListener('input', () => {
      const term = input.value.trim().toLowerCase();
      options.forEach(({option, text}) => {
        const matches = !term || text.includes(term) || option.selected;
        option.hidden = !matches;
      });
      if (term) {
        const firstMatch = options.find(({option}) => !option.hidden);
        if (firstMatch && !firstMatch.option.selected) {
          select.value = firstMatch.option.value;
        }
      }
    });
    input.addEventListener('keydown', evt => {
      if (evt.key === 'Escape') {
        input.value = '';
        input.dispatchEvent(new Event('input'));
      }
    });
    wrapper.dataset.filterInit = 'true';
  });
}

const VARIANT_TYPE_OPTIONS = [
  {value: 'snv', label: 'SNV/indel'},
  {value: 'cnv', label: 'Kopitalvariant (CNV)'},
  {value: 'sv', label: 'Strukturel variant'},
  {value: 'cyto', label: 'Cytogenetisk forandring'}
];

const STRUCTURE_TYPE_OPTION_GROUPS = [
  {
    label: 'CNV (kopital)',
    options: [
      {value: 'deletion', label: 'Deletion (tab)', synonyms: ['deletion','del','loss','tab','kopitaltab','copy loss']},
      {value: 'duplication', label: 'Duplikation', synonyms: ['duplication','dup','gain','kopitalgain']},
      {value: 'amplification', label: 'Amplifikation', synonyms: ['amplification','amp','forstærkning']},
      {value: 'copy_gain', label: 'Kopitalgain (x3/x4)', synonyms: ['copy gain','kopitalgain','x3','x4','copy-number gain']},
      {value: 'copy_loss', label: 'Kopitaltab (x1/x0)', synonyms: ['copy loss','kopitaltab','x1','x0']},
      {value: 'cnloh', label: 'Copy-neutral LOH', synonyms: ['cnloh','copy-neutral loh','copy neutral loh']},
      {value: 'loh', label: 'LOH', synonyms: ['loh','loss of heterozygosity']},
      {value: 'mosaic_gain', label: 'Mosaik gain', synonyms: ['mosaic gain','mosaik gain']},
      {value: 'mosaic_loss', label: 'Mosaik tab', synonyms: ['mosaic loss','mosaik tab']},
      {value: 'segmental_gain', label: 'Segmental gain', synonyms: ['segmental gain','segment gain','partial duplication','partial gain']},
      {value: 'segmental_loss', label: 'Segmental tab', synonyms: ['segmental loss','segment loss','partial deletion','partial loss']},
      {value: 'whole_arm_gain', label: 'Helarm gain', synonyms: ['whole arm gain','arm gain','p-arm gain','q-arm gain']},
      {value: 'whole_arm_loss', label: 'Helarm tab', synonyms: ['whole arm loss','arm loss','p-arm loss','q-arm loss']}
    ]
  },
  {
    label: 'Strukturel variant',
    options: [
      {value: 'translocation', label: 'Translokation (ikke specificeret)', synonyms: ['translocation','translokation']},
      {value: 'insertion', label: 'Insertion', synonyms: ['insertion','indsættelse']},
      {value: 'inversion', label: 'Inversion', synonyms: ['inversion','inversi','omvendt segment']},
      {value: 'balanced_translocation', label: 'Translokation (balanceret)', synonyms: ['balanced translocation','balanceret translokation']},
      {value: 'unbalanced_translocation', label: 'Translokation (ubalanceret)', synonyms: ['unbalanced translocation','ubalanceret translokation']},
      {value: 'fusion', label: 'Fusionsgen', synonyms: ['fusion','fusionsgen','gene fusion']},
      {value: 'breakend', label: 'Breakend (BND)', synonyms: ['breakend','bnd']},
      {value: 'tandem_duplication', label: 'Tandem duplikation', synonyms: ['tandem duplication','tandem duplikation']},
      {value: 'complex_rearrangement', label: 'Kompleks omlejring', synonyms: ['complex rearrangement','kompleks omlejring','complex']},
      {value: 'chromothripsis', label: 'Kromothripsis', synonyms: ['chromothripsis']},
      {value: 'transposition', label: 'Transposition', synonyms: ['transposition','transponering']},
      {value: 'duplication_inverted', label: 'Inverteret duplikation', synonyms: ['inverted duplication','duplication inverted','inv dup']},
      {value: 'gene_conversion', label: 'Genkonvertering', synonyms: ['gene conversion','genkonvertering']}
    ]
  },
  {
    label: 'Cytogenetisk forandring',
    options: [
      {value: 'monosomy', label: 'Monosomi', synonyms: ['monosomy','monosomi']},
      {value: 'trisomy', label: 'Trisomi', synonyms: ['trisomy','trisomi']},
      {value: 'tetrasomy', label: 'Tetrasomi', synonyms: ['tetrasomy','tetrasomi']},
      {value: 'aneuploidy', label: 'Aneuploidi (andet)', synonyms: ['aneuploidy','aneuploidi']},
      {value: 'polyploidy', label: 'Polyploidi', synonyms: ['polyploidy','polyploidi']},
      {value: 'ring_chromosome', label: 'Ringkromosom', synonyms: ['ring chromosome','ringkromosom']},
      {value: 'isochromosome', label: 'Isochromosom', synonyms: ['isochromosome','isochromosom']},
      {value: 'dicentric', label: 'Dicentrisk kromosom', synonyms: ['dicentric','dicentrisk']},
      {value: 'marker_chromosome', label: 'Marker-kromosom', synonyms: ['marker chromosome','marker-kromosom','marker kromosom']},
      {value: 'robertsonian', label: 'Robertsonsk translokation', synonyms: ['robertsonian','robertsonian translocation','robertsonsk translokation']},
      {value: 'partial_trisomy', label: 'Partiel trisomi', synonyms: ['partial trisomy','partiel trisomi']},
      {value: 'partial_monosomy', label: 'Partiel monosomi', synonyms: ['partial monosomy','partiel monosomi']},
      {value: 'whole_genome_duplication', label: 'Hel genom-duplikation', synonyms: ['whole genome duplication','genom duplikation','tetraploidi']}
    ]
  },
  {
    label: 'Andre',
    options: [
      {value: 'other', label: 'Anden/andet (specificer i beskrivelsen)', synonyms: ['other','andet','anden']}
    ]
  }
];

function renderStructureTypeOptions({includeBlank = true} = {}) {
  const parts = [];
  if (includeBlank) {
    parts.push('<option value="">Vælg strukturtype</option>');
  }
  STRUCTURE_TYPE_OPTION_GROUPS.forEach(group => {
    const options = group.options
      .map(option => `<option value="${option.value}">${option.label}</option>`)
      .join('');
    if (group.label) {
      parts.push(`<optgroup label="${group.label}">${options}</optgroup>`);
    } else {
      parts.push(options);
    }
  });
  return parts.join('');
}

function normalizeRsId(value) {
  if (value == null) return '';
  const trimmed = String(value).trim();
  if (!trimmed) return '';
  const match = trimmed.match(/^rs?(\d+)$/i);
  if (match) {
    return `rs${match[1]}`;
  }
  return trimmed;
}

function getVariantRsId(variant) {
  if (!variant || typeof variant !== 'object') return '';
  const candidates = [
    'rsid',
    'rs_id',
    'rsId',
    'rsID',
    'dbsnp',
    'dbsnp_id',
    'dbsnpid',
    'dbsnp_rs',
    'dbsnp_rsid',
    'dbsnp_rs_id',
    'dbsnpRef',
    'dbsnp_reference',
    'dbsnpReference',
    'dbsnpref',
    'dbsnpRsId',
    'dbsnpRsID',
    'dbSNP',
    'dbSNP_id',
    'dbSNPid',
    'dbSNP_rs',
    'dbSNP_rsid',
    'dbSNP_rs_id',
    'dbSNP_RSID',
    'dbSnpRsid',
    'dbSnpRsId',
    'db_snp',
    'db_snp_id',
    'db_snp_rs',
    'db_snp_rsid'
  ];
  for (const key of candidates) {
    const value = variant[key];
    if (value != null && String(value).trim()) {
      return normalizeRsId(value);
    }
  }
  return '';
}

function formatRsIdCell(rsid) {
  const normalized = normalizeRsId(rsid);
  if (!normalized) return '';
  if (/^rs\d+$/i.test(normalized)) {
    const canonical = normalized.replace(/^rs/i, 'rs');
    const url = `https://www.ncbi.nlm.nih.gov/snp/${encodeURIComponent(canonical)}`;
    const label = esc(canonical);
    return `<a class="rsid-badge" href="${url}" target="_blank" rel="noopener noreferrer" title="Åbn dbSNP-opslag for ${label}" aria-label="Åbn dbSNP-opslag for ${label}">${label}</a>`;
  }
  return esc(normalized);
}

function normalizeStructureTypeValue(value) {
  if (value == null) return '';
  const trimmed = String(value).trim();
  if (!trimmed) return '';
  const lower = trimmed.toLowerCase();
  for (const group of STRUCTURE_TYPE_OPTION_GROUPS) {
    for (const option of group.options) {
      const optionValue = option.value.toLowerCase();
      if (optionValue === lower) return option.value;
      const labelLower = option.label.toLowerCase();
      const labelBase = labelLower.split('(')[0].trim();
      if (labelLower === lower || (labelBase && labelBase === lower)) {
        return option.value;
      }
      if (labelBase && (labelBase.startsWith(lower) || lower.startsWith(labelBase))) {
        return option.value;
      }
      const synonyms = Array.isArray(option.synonyms) ? option.synonyms : option.synonyms ? [option.synonyms] : [];
      if (synonyms.some(syn => syn && syn.toLowerCase() === lower)) {
        return option.value;
      }
    }
  }
  return trimmed;
}

function getStructureTypeLabel(value) {
  if (value == null) return '';
  const normalized = normalizeStructureTypeValue(value);
  const lower = normalized.toLowerCase();
  for (const group of STRUCTURE_TYPE_OPTION_GROUPS) {
    for (const option of group.options) {
      if (option.value.toLowerCase() === lower) {
        return option.label;
      }
    }
  }
  return String(value).trim();
}

function normalizeVariantType(value) {
  if (!value) return 'snv';
  const normalized = String(value).trim().toLowerCase();
  return VARIANT_TYPE_OPTIONS.some(option => option.value === normalized) ? normalized : 'snv';
}

function getVariantTypeLabel(value) {
  const normalized = normalizeVariantType(value);
  const option = VARIANT_TYPE_OPTIONS.find(opt => opt.value === normalized);
  return option ? option.label : normalized;
}

const DEFAULT_GENOME_BUILD = 'hg38';
const GENOME_BUILD_LABELS = {hg38:'hg38 (GRCh38)',hg19:'hg19 (GRCh37)'};
const CYTOBAND_DATA = {"hg38":{"1":[[0,2300000,"p36.33","gneg"],[2300000,5300000,"p36.32","gpos25"],[5300000,7100000,"p36.31","gneg"],[7100000,9100000,"p36.23","gpos25"],[9100000,12500000,"p36.22","gneg"],[12500000,15900000,"p36.21","gpos50"],[15900000,20100000,"p36.13","gneg"],[20100000,23600000,"p36.12","gpos25"],[23600000,27600000,"p36.11","gneg"],[27600000,29900000,"p35.3","gpos25"],[29900000,32300000,"p35.2","gneg"],[32300000,34300000,"p35.1","gpos25"],[34300000,39600000,"p34.3","gneg"],[39600000,43700000,"p34.2","gpos25"],[43700000,46300000,"p34.1","gneg"],[46300000,50200000,"p33","gpos75"],[50200000,55600000,"p32.3","gneg"],[55600000,58500000,"p32.2","gpos50"],[58500000,60800000,"p32.1","gneg"],[60800000,68500000,"p31.3","gpos50"],[68500000,69300000,"p31.2","gneg"],[69300000,84400000,"p31.1","gpos100"],[84400000,87900000,"p22.3","gneg"],[87900000,91500000,"p22.2","gpos75"],[91500000,94300000,"p22.1","gneg"],[94300000,99300000,"p21.3","gpos75"],[99300000,101800000,"p21.2","gneg"],[101800000,106700000,"p21.1","gpos100"],[106700000,111200000,"p13.3","gneg"],[111200000,115500000,"p13.2","gpos50"],[115500000,117200000,"p13.1","gneg"],[117200000,120400000,"p12","gpos50"],[120400000,121700000,"p11.2","gneg"],[121700000,123400000,"p11.1","acen"],[123400000,125100000,"q11","acen"],[125100000,143200000,"q12","gvar"],[143200000,147500000,"q21.1","gneg"],[147500000,150600000,"q21.2","gpos50"],[150600000,155100000,"q21.3","gneg"],[155100000,156600000,"q22","gpos50"],[156600000,159100000,"q23.1","gneg"],[159100000,160500000,"q23.2","gpos50"],[160500000,165500000,"q23.3","gneg"],[165500000,167200000,"q24.1","gpos50"],[167200000,170900000,"q24.2","gneg"],[170900000,173000000,"q24.3","gpos75"],[173000000,176100000,"q25.1","gneg"],[176100000,180300000,"q25.2","gpos50"],[180300000,185800000,"q25.3","gneg"],[185800000,190800000,"q31.1","gpos100"],[190800000,193800000,"q31.2","gneg"],[193800000,198700000,"q31.3","gpos100"],[198700000,207100000,"q32.1","gneg"],[207100000,211300000,"q32.2","gpos25"],[211300000,214400000,"q32.3","gneg"],[214400000,223900000,"q41","gpos100"],[223900000,224400000,"q42.11","gneg"],[224400000,226800000,"q42.12","gpos25"],[226800000,230500000,"q42.13","gneg"],[230500000,234600000,"q42.2","gpos50"],[234600000,236400000,"q42.3","gneg"],[236400000,243500000,"q43","gpos75"],[243500000,248956422,"q44","gneg"]],"5":[[0,4400000,"p15.33","gneg"],[4400000,6300000,"p15.32","gpos25"],[6300000,9900000,"p15.31","gneg"],[9900000,15000000,"p15.2","gpos50"],[15000000,18400000,"p15.1","gneg"],[18400000,23300000,"p14.3","gpos100"],[23300000,24600000,"p14.2","gneg"],[24600000,28900000,"p14.1","gpos100"],[28900000,33800000,"p13.3","gneg"],[33800000,38400000,"p13.2","gpos25"],[38400000,42500000,"p13.1","gneg"],[42500000,46100000,"p12","gpos50"],[46100000,48800000,"p11","acen"],[48800000,51400000,"q11.1","acen"],[51400000,59600000,"q11.2","gneg"],[59600000,63600000,"q12.1","gpos75"],[63600000,63900000,"q12.2","gneg"],[63900000,67400000,"q12.3","gpos75"],[67400000,69100000,"q13.1","gneg"],[69100000,74000000,"q13.2","gpos50"],[74000000,77600000,"q13.3","gneg"],[77600000,82100000,"q14.1","gpos50"],[82100000,83500000,"q14.2","gneg"],[83500000,93000000,"q14.3","gpos100"],[93000000,98900000,"q15","gneg"],[98900000,103400000,"q21.1","gpos100"],[103400000,105100000,"q21.2","gneg"],[105100000,110200000,"q21.3","gpos100"],[110200000,112200000,"q22.1","gneg"],[112200000,113800000,"q22.2","gpos50"],[113800000,115900000,"q22.3","gneg"],[115900000,122100000,"q23.1","gpos100"],[122100000,127900000,"q23.2","gneg"],[127900000,131200000,"q23.3","gpos100"],[131200000,136900000,"q31.1","gneg"],[136900000,140100000,"q31.2","gpos25"],[140100000,145100000,"q31.3","gneg"],[145100000,150400000,"q32","gpos75"],[150400000,153300000,"q33.1","gneg"],[153300000,156300000,"q33.2","gpos50"],[156300000,160500000,"q33.3","gneg"],[160500000,169000000,"q34","gpos100"],[169000000,173300000,"q35.1","gneg"],[173300000,177100000,"q35.2","gpos25"],[177100000,181538259,"q35.3","gneg"]],"2":[[0,4400000,"p25.3","gneg"],[4400000,6900000,"p25.2","gpos50"],[6900000,12000000,"p25.1","gneg"],[12000000,16500000,"p24.3","gpos75"],[16500000,19000000,"p24.2","gneg"],[19000000,23800000,"p24.1","gpos75"],[23800000,27700000,"p23.3","gneg"],[27700000,29800000,"p23.2","gpos25"],[29800000,31800000,"p23.1","gneg"],[31800000,36300000,"p22.3","gpos75"],[36300000,38300000,"p22.2","gneg"],[38300000,41500000,"p22.1","gpos50"],[41500000,47500000,"p21","gneg"],[47500000,52600000,"p16.3","gpos100"],[52600000,54700000,"p16.2","gneg"],[54700000,61000000,"p16.1","gpos100"],[61000000,63900000,"p15","gneg"],[63900000,68400000,"p14","gpos50"],[68400000,71300000,"p13.3","gneg"],[71300000,73300000,"p13.2","gpos50"],[73300000,74800000,"p13.1","gneg"],[74800000,83100000,"p12","gpos100"],[83100000,91800000,"p11.2","gneg"],[91800000,93900000,"p11.1","acen"],[93900000,96000000,"q11.1","acen"],[96000000,102100000,"q11.2","gneg"],[102100000,105300000,"q12.1","gpos50"],[105300000,106700000,"q12.2","gneg"],[106700000,108700000,"q12.3","gpos25"],[108700000,112200000,"q13","gneg"],[112200000,118100000,"q14.1","gpos50"],[118100000,121600000,"q14.2","gneg"],[121600000,129100000,"q14.3","gpos50"],[129100000,131700000,"q21.1","gneg"],[131700000,134300000,"q21.2","gpos25"],[134300000,136100000,"q21.3","gneg"],[136100000,141500000,"q22.1","gpos100"],[141500000,143400000,"q22.2","gneg"],[143400000,147900000,"q22.3","gpos100"],[147900000,149000000,"q23.1","gneg"],[149000000,149600000,"q23.2","gpos25"],[149600000,154000000,"q23.3","gneg"],[154000000,158900000,"q24.1","gpos75"],[158900000,162900000,"q24.2","gneg"],[162900000,168900000,"q24.3","gpos75"],[168900000,177100000,"q31.1","gneg"],[177100000,179700000,"q31.2","gpos50"],[179700000,182100000,"q31.3","gneg"],[182100000,188500000,"q32.1","gpos75"],[188500000,191100000,"q32.2","gneg"],[191100000,196600000,"q32.3","gpos75"],[196600000,202500000,"q33.1","gneg"],[202500000,204100000,"q33.2","gpos50"],[204100000,208200000,"q33.3","gneg"],[208200000,214500000,"q34","gpos100"],[214500000,220700000,"q35","gneg"],[220700000,224300000,"q36.1","gpos75"],[224300000,225200000,"q36.2","gneg"],[225200000,230100000,"q36.3","gpos100"],[230100000,234700000,"q37.1","gneg"],[234700000,236400000,"q37.2","gpos50"],[236400000,242193529,"q37.3","gneg"]],"15":[[0,4200000,"p13","gvar"],[4200000,9700000,"p12","stalk"],[9700000,17500000,"p11.2","gvar"],[17500000,19000000,"p11.1","acen"],[19000000,20500000,"q11.1","acen"],[20500000,25500000,"q11.2","gneg"],[25500000,27800000,"q12","gpos50"],[27800000,30000000,"q13.1","gneg"],[30000000,30900000,"q13.2","gpos50"],[30900000,33400000,"q13.3","gneg"],[33400000,39800000,"q14","gpos75"],[39800000,42500000,"q15.1","gneg"],[42500000,43300000,"q15.2","gpos25"],[43300000,44500000,"q15.3","gneg"],[44500000,49200000,"q21.1","gpos75"],[49200000,52600000,"q21.2","gneg"],[52600000,58800000,"q21.3","gpos75"],[58800000,59000000,"q22.1","gneg"],[59000000,63400000,"q22.2","gpos25"],[63400000,66900000,"q22.31","gneg"],[66900000,67000000,"q22.32","gpos25"],[67000000,67200000,"q22.33","gneg"],[67200000,72400000,"q23","gpos25"],[72400000,74900000,"q24.1","gneg"],[74900000,76300000,"q24.2","gpos25"],[76300000,78000000,"q24.3","gneg"],[78000000,81400000,"q25.1","gpos50"],[81400000,84700000,"q25.2","gneg"],[84700000,88500000,"q25.3","gpos50"],[88500000,93800000,"q26.1","gneg"],[93800000,98000000,"q26.2","gpos50"],[98000000,101991189,"q26.3","gneg"]],"20":[[0,5100000,"p13","gneg"],[5100000,9200000,"p12.3","gpos75"],[9200000,12000000,"p12.2","gneg"],[12000000,17900000,"p12.1","gpos75"],[17900000,21300000,"p11.23","gneg"],[21300000,22300000,"p11.22","gpos25"],[22300000,25700000,"p11.21","gneg"],[25700000,28100000,"p11.1","acen"],[28100000,30400000,"q11.1","acen"],[30400000,33500000,"q11.21","gneg"],[33500000,35800000,"q11.22","gpos25"],[35800000,39000000,"q11.23","gneg"],[39000000,43100000,"q12","gpos75"],[43100000,43500000,"q13.11","gneg"],[43500000,47800000,"q13.12","gpos25"],[47800000,51200000,"q13.13","gneg"],[51200000,56400000,"q13.2","gpos75"],[56400000,57800000,"q13.31","gneg"],[57800000,59700000,"q13.32","gpos50"],[59700000,64444167,"q13.33","gneg"]],"22":[[0,4300000,"p13","gvar"],[4300000,9400000,"p12","stalk"],[9400000,13700000,"p11.2","gvar"],[13700000,15000000,"p11.1","acen"],[15000000,17400000,"q11.1","acen"],[17400000,21700000,"q11.21","gneg"],[21700000,23100000,"q11.22","gpos25"],[23100000,25500000,"q11.23","gneg"],[25500000,29200000,"q12.1","gpos50"],[29200000,31800000,"q12.2","gneg"],[31800000,37200000,"q12.3","gpos50"],[37200000,40600000,"q13.1","gneg"],[40600000,43800000,"q13.2","gpos50"],[43800000,48100000,"q13.31","gneg"],[48100000,49100000,"q13.32","gpos50"],[49100000,50818468,"q13.33","gneg"]],"4":[[0,4500000,"p16.3","gneg"],[4500000,6000000,"p16.2","gpos25"],[6000000,11300000,"p16.1","gneg"],[11300000,15000000,"p15.33","gpos50"],[15000000,17700000,"p15.32","gneg"],[17700000,21300000,"p15.31","gpos75"],[21300000,27700000,"p15.2","gneg"],[27700000,35800000,"p15.1","gpos100"],[35800000,41200000,"p14","gneg"],[41200000,44600000,"p13","gpos50"],[44600000,48200000,"p12","gneg"],[48200000,50000000,"p11","acen"],[50000000,51800000,"q11","acen"],[51800000,58500000,"q12","gneg"],[58500000,65500000,"q13.1","gpos100"],[65500000,69400000,"q13.2","gneg"],[69400000,75300000,"q13.3","gpos75"],[75300000,78000000,"q21.1","gneg"],[78000000,81500000,"q21.21","gpos50"],[81500000,83200000,"q21.22","gneg"],[83200000,86000000,"q21.23","gpos25"],[86000000,87100000,"q21.3","gneg"],[87100000,92800000,"q22.1","gpos75"],[92800000,94200000,"q22.2","gneg"],[94200000,97900000,"q22.3","gpos75"],[97900000,100100000,"q23","gneg"],[100100000,106700000,"q24","gpos50"],[106700000,113200000,"q25","gneg"],[113200000,119900000,"q26","gpos75"],[119900000,122800000,"q27","gneg"],[122800000,127900000,"q28.1","gpos50"],[127900000,130100000,"q28.2","gneg"],[130100000,138500000,"q28.3","gpos100"],[138500000,140600000,"q31.1","gneg"],[140600000,145900000,"q31.21","gpos25"],[145900000,147500000,"q31.22","gneg"],[147500000,150200000,"q31.23","gpos25"],[150200000,154600000,"q31.3","gneg"],[154600000,160800000,"q32.1","gpos100"],[160800000,163600000,"q32.2","gneg"],[163600000,169200000,"q32.3","gpos100"],[169200000,171000000,"q33","gneg"],[171000000,175400000,"q34.1","gpos75"],[175400000,176600000,"q34.2","gneg"],[176600000,182300000,"q34.3","gpos100"],[182300000,186200000,"q35.1","gneg"],[186200000,190214555,"q35.2","gpos25"]],"18":[[0,2900000,"p11.32","gneg"],[2900000,7200000,"p11.31","gpos50"],[7200000,8500000,"p11.23","gneg"],[8500000,10900000,"p11.22","gpos25"],[10900000,15400000,"p11.21","gneg"],[15400000,18500000,"p11.1","acen"],[18500000,21500000,"q11.1","acen"],[21500000,27500000,"q11.2","gneg"],[27500000,35100000,"q12.1","gpos100"],[35100000,39500000,"q12.2","gneg"],[39500000,45900000,"q12.3","gpos75"],[45900000,50700000,"q21.1","gneg"],[50700000,56200000,"q21.2","gpos75"],[56200000,58600000,"q21.31","gneg"],[58600000,61300000,"q21.32","gpos50"],[61300000,63900000,"q21.33","gneg"],[63900000,69100000,"q22.1","gpos100"],[69100000,71000000,"q22.2","gneg"],[71000000,75400000,"q22.3","gpos25"],[75400000,80373285,"q23","gneg"]],"16":[[0,7800000,"p13.3","gneg"],[7800000,10400000,"p13.2","gpos50"],[10400000,12500000,"p13.13","gneg"],[12500000,14700000,"p13.12","gpos50"],[14700000,16700000,"p13.11","gneg"],[16700000,21200000,"p12.3","gpos50"],[21200000,24200000,"p12.2","gneg"],[24200000,28500000,"p12.1","gpos50"],[28500000,35300000,"p11.2","gneg"],[35300000,36800000,"p11.1","acen"],[36800000,38400000,"q11.1","acen"],[38400000,47000000,"q11.2","gvar"],[47000000,52600000,"q12.1","gneg"],[52600000,56000000,"q12.2","gpos50"],[56000000,57300000,"q13","gneg"],[57300000,66600000,"q21","gpos100"],[66600000,70800000,"q22.1","gneg"],[70800000,72800000,"q22.2","gpos50"],[72800000,74100000,"q22.3","gneg"],[74100000,79200000,"q23.1","gpos75"],[79200000,81600000,"q23.2","gneg"],[81600000,84100000,"q23.3","gpos50"],[84100000,87000000,"q24.1","gneg"],[87000000,88700000,"q24.2","gpos25"],[88700000,90338345,"q24.3","gneg"]],"8":[[0,2300000,"p23.3","gneg"],[2300000,6300000,"p23.2","gpos75"],[6300000,12800000,"p23.1","gneg"],[12800000,19200000,"p22","gpos100"],[19200000,23500000,"p21.3","gneg"],[23500000,27500000,"p21.2","gpos50"],[27500000,29000000,"p21.1","gneg"],[29000000,36700000,"p12","gpos75"],[36700000,38500000,"p11.23","gneg"],[38500000,39900000,"p11.22","gpos25"],[39900000,43200000,"p11.21","gneg"],[43200000,45200000,"p11.1","acen"],[45200000,47200000,"q11.1","acen"],[47200000,51300000,"q11.21","gneg"],[51300000,51700000,"q11.22","gpos75"],[51700000,54600000,"q11.23","gneg"],[54600000,60600000,"q12.1","gpos50"],[60600000,61300000,"q12.2","gneg"],[61300000,65100000,"q12.3","gpos50"],[65100000,67100000,"q13.1","gneg"],[67100000,69600000,"q13.2","gpos50"],[69600000,72000000,"q13.3","gneg"],[72000000,74600000,"q21.11","gpos100"],[74600000,74700000,"q21.12","gneg"],[74700000,83500000,"q21.13","gpos75"],[83500000,85900000,"q21.2","gneg"],[85900000,92300000,"q21.3","gpos100"],[92300000,97900000,"q22.1","gneg"],[97900000,100500000,"q22.2","gpos25"],[100500000,105100000,"q22.3","gneg"],[105100000,109500000,"q23.1","gpos75"],[109500000,111100000,"q23.2","gneg"],[111100000,116700000,"q23.3","gpos100"],[116700000,118300000,"q24.11","gneg"],[118300000,121500000,"q24.12","gpos50"],[121500000,126300000,"q24.13","gneg"],[126300000,130400000,"q24.21","gpos50"],[130400000,135400000,"q24.22","gneg"],[135400000,138900000,"q24.23","gpos75"],[138900000,145138636,"q24.3","gneg"]],"13":[[0,4600000,"p13","gvar"],[4600000,10100000,"p12","stalk"],[10100000,16500000,"p11.2","gvar"],[16500000,17700000,"p11.1","acen"],[17700000,18900000,"q11","acen"],[18900000,22600000,"q12.11","gneg"],[22600000,24900000,"q12.12","gpos25"],[24900000,27200000,"q12.13","gneg"],[27200000,28300000,"q12.2","gpos25"],[28300000,31600000,"q12.3","gneg"],[31600000,33400000,"q13.1","gpos50"],[33400000,34900000,"q13.2","gneg"],[34900000,39500000,"q13.3","gpos75"],[39500000,44600000,"q14.11","gneg"],[44600000,45200000,"q14.12","gpos25"],[45200000,46700000,"q14.13","gneg"],[46700000,50300000,"q14.2","gpos50"],[50300000,54700000,"q14.3","gneg"],[54700000,59000000,"q21.1","gpos100"],[59000000,61800000,"q21.2","gneg"],[61800000,65200000,"q21.31","gpos75"],[65200000,68100000,"q21.32","gneg"],[68100000,72800000,"q21.33","gpos100"],[72800000,74900000,"q22.1","gneg"],[74900000,76700000,"q22.2","gpos50"],[76700000,78500000,"q22.3","gneg"],[78500000,87100000,"q31.1","gpos100"],[87100000,89400000,"q31.2","gneg"],[89400000,94400000,"q31.3","gpos100"],[94400000,97500000,"q32.1","gneg"],[97500000,98700000,"q32.2","gpos25"],[98700000,101100000,"q32.3","gneg"],[101100000,104200000,"q33.1","gpos100"],[104200000,106400000,"q33.2","gneg"],[106400000,109600000,"q33.3","gpos100"],[109600000,114364328,"q34","gneg"]],"11":[[0,2800000,"p15.5","gneg"],[2800000,11700000,"p15.4","gpos50"],[11700000,13800000,"p15.3","gneg"],[13800000,16900000,"p15.2","gpos50"],[16900000,22000000,"p15.1","gneg"],[22000000,26200000,"p14.3","gpos100"],[26200000,27200000,"p14.2","gneg"],[27200000,31000000,"p14.1","gpos75"],[31000000,36400000,"p13","gneg"],[36400000,43400000,"p12","gpos100"],[43400000,48800000,"p11.2","gneg"],[48800000,51000000,"p11.12","gpos75"],[51000000,53400000,"p11.11","acen"],[53400000,55800000,"q11","acen"],[55800000,60100000,"q12.1","gpos75"],[60100000,61900000,"q12.2","gneg"],[61900000,63600000,"q12.3","gpos25"],[63600000,66100000,"q13.1","gneg"],[66100000,68700000,"q13.2","gpos25"],[68700000,70500000,"q13.3","gneg"],[70500000,75500000,"q13.4","gpos50"],[75500000,77400000,"q13.5","gneg"],[77400000,85900000,"q14.1","gpos100"],[85900000,88600000,"q14.2","gneg"],[88600000,93000000,"q14.3","gpos100"],[93000000,97400000,"q21","gneg"],[97400000,102300000,"q22.1","gpos100"],[102300000,103000000,"q22.2","gneg"],[103000000,110600000,"q22.3","gpos100"],[110600000,112700000,"q23.1","gneg"],[112700000,114600000,"q23.2","gpos50"],[114600000,121300000,"q23.3","gneg"],[121300000,124000000,"q24.1","gpos50"],[124000000,127900000,"q24.2","gneg"],[127900000,130900000,"q24.3","gpos50"],[130900000,135086622,"q25","gneg"]],"14":[[0,3600000,"p13","gvar"],[3600000,8000000,"p12","stalk"],[8000000,16100000,"p11.2","gvar"],[16100000,17200000,"p11.1","acen"],[17200000,18200000,"q11.1","acen"],[18200000,24100000,"q11.2","gneg"],[24100000,32900000,"q12","gpos100"],[32900000,34800000,"q13.1","gneg"],[34800000,36100000,"q13.2","gpos50"],[36100000,37400000,"q13.3","gneg"],[37400000,43000000,"q21.1","gpos100"],[43000000,46700000,"q21.2","gneg"],[46700000,50400000,"q21.3","gpos100"],[50400000,53600000,"q22.1","gneg"],[53600000,55000000,"q22.2","gpos25"],[55000000,57600000,"q22.3","gneg"],[57600000,61600000,"q23.1","gpos75"],[61600000,64300000,"q23.2","gneg"],[64300000,67400000,"q23.3","gpos50"],[67400000,69800000,"q24.1","gneg"],[69800000,73300000,"q24.2","gpos50"],[73300000,78800000,"q24.3","gneg"],[78800000,83100000,"q31.1","gpos100"],[83100000,84400000,"q31.2","gneg"],[84400000,89300000,"q31.3","gpos100"],[89300000,91400000,"q32.11","gneg"],[91400000,94200000,"q32.12","gpos25"],[94200000,95800000,"q32.13","gneg"],[95800000,100900000,"q32.2","gpos50"],[100900000,102700000,"q32.31","gneg"],[102700000,103500000,"q32.32","gpos50"],[103500000,107043718,"q32.33","gneg"]],"7":[[0,2800000,"p22.3","gneg"],[2800000,4500000,"p22.2","gpos25"],[4500000,7200000,"p22.1","gneg"],[7200000,13700000,"p21.3","gpos100"],[13700000,16500000,"p21.2","gneg"],[16500000,20900000,"p21.1","gpos100"],[20900000,25500000,"p15.3","gneg"],[25500000,27900000,"p15.2","gpos50"],[27900000,28800000,"p15.1","gneg"],[28800000,34900000,"p14.3","gpos75"],[34900000,37100000,"p14.2","gneg"],[37100000,43300000,"p14.1","gpos75"],[43300000,45400000,"p13","gneg"],[45400000,49000000,"p12.3","gpos75"],[49000000,50500000,"p12.2","gneg"],[50500000,53900000,"p12.1","gpos75"],[53900000,58100000,"p11.2","gneg"],[58100000,60100000,"p11.1","acen"],[60100000,62100000,"q11.1","acen"],[62100000,67500000,"q11.21","gneg"],[67500000,72700000,"q11.22","gpos50"],[72700000,77900000,"q11.23","gneg"],[77900000,86700000,"q21.11","gpos100"],[86700000,88500000,"q21.12","gneg"],[88500000,91500000,"q21.13","gpos75"],[91500000,93300000,"q21.2","gneg"],[93300000,98400000,"q21.3","gpos75"],[98400000,104200000,"q22.1","gneg"],[104200000,104900000,"q22.2","gpos50"],[104900000,107800000,"q22.3","gneg"],[107800000,115000000,"q31.1","gpos75"],[115000000,117700000,"q31.2","gneg"],[117700000,121400000,"q31.31","gpos75"],[121400000,124100000,"q31.32","gneg"],[124100000,127500000,"q31.33","gpos75"],[127500000,129600000,"q32.1","gneg"],[129600000,130800000,"q32.2","gpos25"],[130800000,132900000,"q32.3","gneg"],[132900000,138500000,"q33","gpos50"],[138500000,143400000,"q34","gneg"],[143400000,148200000,"q35","gpos75"],[148200000,152800000,"q36.1","gneg"],[152800000,155200000,"q36.2","gpos25"],[155200000,159345973,"q36.3","gneg"]],"10":[[0,3000000,"p15.3","gneg"],[3000000,3800000,"p15.2","gpos25"],[3800000,6600000,"p15.1","gneg"],[6600000,12200000,"p14","gpos75"],[12200000,17300000,"p13","gneg"],[17300000,18300000,"p12.33","gpos75"],[18300000,18400000,"p12.32","gneg"],[18400000,22300000,"p12.31","gpos75"],[22300000,24300000,"p12.2","gneg"],[24300000,29300000,"p12.1","gpos50"],[29300000,31100000,"p11.23","gneg"],[31100000,34200000,"p11.22","gpos25"],[34200000,38000000,"p11.21","gneg"],[38000000,39800000,"p11.1","acen"],[39800000,41600000,"q11.1","acen"],[41600000,45500000,"q11.21","gneg"],[45500000,48600000,"q11.22","gpos25"],[48600000,51100000,"q11.23","gneg"],[51100000,59400000,"q21.1","gpos100"],[59400000,62800000,"q21.2","gneg"],[62800000,68800000,"q21.3","gpos100"],[68800000,73100000,"q22.1","gneg"],[73100000,75900000,"q22.2","gpos50"],[75900000,80300000,"q22.3","gneg"],[80300000,86100000,"q23.1","gpos100"],[86100000,87700000,"q23.2","gneg"],[87700000,91100000,"q23.31","gpos75"],[91100000,92300000,"q23.32","gneg"],[92300000,95300000,"q23.33","gpos50"],[95300000,97500000,"q24.1","gneg"],[97500000,100100000,"q24.2","gpos50"],[100100000,101200000,"q24.31","gneg"],[101200000,103100000,"q24.32","gpos25"],[103100000,104000000,"q24.33","gneg"],[104000000,110100000,"q25.1","gpos100"],[110100000,113100000,"q25.2","gneg"],[113100000,117300000,"q25.3","gpos75"],[117300000,119900000,"q26.11","gneg"],[119900000,121400000,"q26.12","gpos50"],[121400000,125700000,"q26.13","gneg"],[125700000,128800000,"q26.2","gpos50"],[128800000,133797422,"q26.3","gneg"]],"X":[[0,4400000,"p22.33","gneg"],[4400000,6100000,"p22.32","gpos50"],[6100000,9600000,"p22.31","gneg"],[9600000,17400000,"p22.2","gpos50"],[17400000,19200000,"p22.13","gneg"],[19200000,21900000,"p22.12","gpos50"],[21900000,24900000,"p22.11","gneg"],[24900000,29300000,"p21.3","gpos100"],[29300000,31500000,"p21.2","gneg"],[31500000,37800000,"p21.1","gpos100"],[37800000,42500000,"p11.4","gneg"],[42500000,47600000,"p11.3","gpos75"],[47600000,50100000,"p11.23","gneg"],[50100000,54800000,"p11.22","gpos25"],[54800000,58100000,"p11.21","gneg"],[58100000,61000000,"p11.1","acen"],[61000000,63800000,"q11.1","acen"],[63800000,65400000,"q11.2","gneg"],[65400000,68500000,"q12","gpos50"],[68500000,73000000,"q13.1","gneg"],[73000000,74700000,"q13.2","gpos50"],[74700000,76800000,"q13.3","gneg"],[76800000,85400000,"q21.1","gpos100"],[85400000,87000000,"q21.2","gneg"],[87000000,92700000,"q21.31","gpos100"],[92700000,94300000,"q21.32","gneg"],[94300000,99100000,"q21.33","gpos75"],[99100000,103300000,"q22.1","gneg"],[103300000,104500000,"q22.2","gpos50"],[104500000,109400000,"q22.3","gneg"],[109400000,117400000,"q23","gpos75"],[117400000,121800000,"q24","gneg"],[121800000,129500000,"q25","gpos100"],[129500000,131300000,"q26.1","gneg"],[131300000,134500000,"q26.2","gpos25"],[134500000,138900000,"q26.3","gneg"],[138900000,141200000,"q27.1","gpos75"],[141200000,143000000,"q27.2","gneg"],[143000000,148000000,"q27.3","gpos100"],[148000000,156040895,"q28","gneg"]],"9":[[0,2200000,"p24.3","gneg"],[2200000,4600000,"p24.2","gpos25"],[4600000,9000000,"p24.1","gneg"],[9000000,14200000,"p23","gpos75"],[14200000,16600000,"p22.3","gneg"],[16600000,18500000,"p22.2","gpos25"],[18500000,19900000,"p22.1","gneg"],[19900000,25600000,"p21.3","gpos100"],[25600000,28000000,"p21.2","gneg"],[28000000,33200000,"p21.1","gpos100"],[33200000,36300000,"p13.3","gneg"],[36300000,37900000,"p13.2","gpos25"],[37900000,39000000,"p13.1","gneg"],[39000000,40000000,"p12","gpos50"],[40000000,42200000,"p11.2","gneg"],[42200000,43000000,"p11.1","acen"],[43000000,45500000,"q11","acen"],[45500000,61500000,"q12","gvar"],[61500000,65000000,"q13","gneg"],[65000000,69300000,"q21.11","gpos25"],[69300000,71300000,"q21.12","gneg"],[71300000,76600000,"q21.13","gpos50"],[76600000,78500000,"q21.2","gneg"],[78500000,81500000,"q21.31","gpos50"],[81500000,84300000,"q21.32","gneg"],[84300000,87800000,"q21.33","gpos50"],[87800000,89200000,"q22.1","gneg"],[89200000,91200000,"q22.2","gpos25"],[91200000,93900000,"q22.31","gneg"],[93900000,96500000,"q22.32","gpos25"],[96500000,99800000,"q22.33","gneg"],[99800000,105400000,"q31.1","gpos100"],[105400000,108500000,"q31.2","gneg"],[108500000,112100000,"q31.3","gpos25"],[112100000,114900000,"q32","gneg"],[114900000,119800000,"q33.1","gpos75"],[119800000,123100000,"q33.2","gneg"],[123100000,127500000,"q33.3","gpos25"],[127500000,130600000,"q34.11","gneg"],[130600000,131100000,"q34.12","gpos25"],[131100000,133100000,"q34.13","gneg"],[133100000,134500000,"q34.2","gpos25"],[134500000,138394717,"q34.3","gneg"]],"6":[[0,2300000,"p25.3","gneg"],[2300000,4200000,"p25.2","gpos25"],[4200000,7100000,"p25.1","gneg"],[7100000,10600000,"p24.3","gpos50"],[10600000,11600000,"p24.2","gneg"],[11600000,13400000,"p24.1","gpos25"],[13400000,15200000,"p23","gneg"],[15200000,25200000,"p22.3","gpos75"],[25200000,27100000,"p22.2","gneg"],[27100000,30500000,"p22.1","gpos50"],[30500000,32100000,"p21.33","gneg"],[32100000,33500000,"p21.32","gpos25"],[33500000,36600000,"p21.31","gneg"],[36600000,40500000,"p21.2","gpos25"],[40500000,46200000,"p21.1","gneg"],[46200000,51800000,"p12.3","gpos100"],[51800000,53000000,"p12.2","gneg"],[53000000,57200000,"p12.1","gpos100"],[57200000,58500000,"p11.2","gneg"],[58500000,59800000,"p11.1","acen"],[59800000,62600000,"q11.1","acen"],[62600000,62700000,"q11.2","gneg"],[62700000,69200000,"q12","gpos100"],[69200000,75200000,"q13","gneg"],[75200000,83200000,"q14.1","gpos50"],[83200000,84200000,"q14.2","gneg"],[84200000,87300000,"q14.3","gpos50"],[87300000,92500000,"q15","gneg"],[92500000,98900000,"q16.1","gpos100"],[98900000,100000000,"q16.2","gneg"],[100000000,105000000,"q16.3","gpos100"],[105000000,114200000,"q21","gneg"],[114200000,117900000,"q22.1","gpos75"],[117900000,118100000,"q22.2","gneg"],[118100000,125800000,"q22.31","gpos100"],[125800000,126800000,"q22.32","gneg"],[126800000,130000000,"q22.33","gpos75"],[130000000,130900000,"q23.1","gneg"],[130900000,134700000,"q23.2","gpos50"],[134700000,138300000,"q23.3","gneg"],[138300000,142200000,"q24.1","gpos75"],[142200000,145100000,"q24.2","gneg"],[145100000,148500000,"q24.3","gpos75"],[148500000,152100000,"q25.1","gneg"],[152100000,155200000,"q25.2","gpos50"],[155200000,160600000,"q25.3","gneg"],[160600000,164100000,"q26","gpos50"],[164100000,170805979,"q27","gneg"]],"3":[[0,2800000,"p26.3","gpos50"],[2800000,4000000,"p26.2","gneg"],[4000000,8100000,"p26.1","gpos50"],[8100000,11600000,"p25.3","gneg"],[11600000,13200000,"p25.2","gpos25"],[13200000,16300000,"p25.1","gneg"],[16300000,23800000,"p24.3","gpos100"],[23800000,26300000,"p24.2","gneg"],[26300000,30800000,"p24.1","gpos75"],[30800000,32000000,"p23","gneg"],[32000000,36400000,"p22.3","gpos50"],[36400000,39300000,"p22.2","gneg"],[39300000,43600000,"p22.1","gpos75"],[43600000,44100000,"p21.33","gneg"],[44100000,44200000,"p21.32","gpos50"],[44200000,50600000,"p21.31","gneg"],[50600000,52300000,"p21.2","gpos25"],[52300000,54400000,"p21.1","gneg"],[54400000,58600000,"p14.3","gpos50"],[58600000,63800000,"p14.2","gneg"],[63800000,69700000,"p14.1","gpos50"],[69700000,74100000,"p13","gneg"],[74100000,79800000,"p12.3","gpos75"],[79800000,83500000,"p12.2","gneg"],[83500000,87100000,"p12.1","gpos75"],[87100000,87800000,"p11.2","gneg"],[87800000,90900000,"p11.1","acen"],[90900000,94000000,"q11.1","acen"],[94000000,98600000,"q11.2","gvar"],[98600000,100300000,"q12.1","gneg"],[100300000,101200000,"q12.2","gpos25"],[101200000,103100000,"q12.3","gneg"],[103100000,106500000,"q13.11","gpos75"],[106500000,108200000,"q13.12","gneg"],[108200000,111600000,"q13.13","gpos50"],[111600000,113700000,"q13.2","gneg"],[113700000,117600000,"q13.31","gpos75"],[117600000,119300000,"q13.32","gneg"],[119300000,122200000,"q13.33","gpos75"],[122200000,124100000,"q21.1","gneg"],[124100000,126100000,"q21.2","gpos25"],[126100000,129500000,"q21.3","gneg"],[129500000,134000000,"q22.1","gpos25"],[134000000,136000000,"q22.2","gneg"],[136000000,139000000,"q22.3","gpos25"],[139000000,143100000,"q23","gneg"],[143100000,149200000,"q24","gpos100"],[149200000,152300000,"q25.1","gneg"],[152300000,155300000,"q25.2","gpos50"],[155300000,157300000,"q25.31","gneg"],[157300000,159300000,"q25.32","gpos50"],[159300000,161000000,"q25.33","gneg"],[161000000,167900000,"q26.1","gpos100"],[167900000,171200000,"q26.2","gneg"],[171200000,176000000,"q26.31","gpos75"],[176000000,179300000,"q26.32","gneg"],[179300000,183000000,"q26.33","gpos75"],[183000000,184800000,"q27.1","gneg"],[184800000,186300000,"q27.2","gpos25"],[186300000,188200000,"q27.3","gneg"],[188200000,192600000,"q28","gpos75"],[192600000,198295559,"q29","gneg"]],"19":[[0,6900000,"p13.3","gneg"],[6900000,12600000,"p13.2","gpos25"],[12600000,13800000,"p13.13","gneg"],[13800000,16100000,"p13.12","gpos25"],[16100000,19900000,"p13.11","gneg"],[19900000,24200000,"p12","gvar"],[24200000,26200000,"p11","acen"],[26200000,28100000,"q11","acen"],[28100000,31900000,"q12","gvar"],[31900000,35100000,"q13.11","gneg"],[35100000,37800000,"q13.12","gpos25"],[37800000,38200000,"q13.13","gneg"],[38200000,42900000,"q13.2","gpos25"],[42900000,44700000,"q13.31","gneg"],[44700000,47500000,"q13.32","gpos25"],[47500000,50900000,"q13.33","gneg"],[50900000,53100000,"q13.41","gpos25"],[53100000,55800000,"q13.42","gneg"],[55800000,58617616,"q13.43","gpos25"]],"17":[[0,3400000,"p13.3","gneg"],[3400000,6500000,"p13.2","gpos50"],[6500000,10800000,"p13.1","gneg"],[10800000,16100000,"p12","gpos75"],[16100000,22700000,"p11.2","gneg"],[22700000,25100000,"p11.1","acen"],[25100000,27400000,"q11.1","acen"],[27400000,33500000,"q11.2","gneg"],[33500000,39800000,"q12","gpos50"],[39800000,40200000,"q21.1","gneg"],[40200000,42800000,"q21.2","gpos25"],[42800000,46800000,"q21.31","gneg"],[46800000,49300000,"q21.32","gpos25"],[49300000,52100000,"q21.33","gneg"],[52100000,59500000,"q22","gpos75"],[59500000,60200000,"q23.1","gneg"],[60200000,63100000,"q23.2","gpos75"],[63100000,64600000,"q23.3","gneg"],[64600000,66200000,"q24.1","gpos50"],[66200000,69100000,"q24.2","gneg"],[69100000,72900000,"q24.3","gpos75"],[72900000,76800000,"q25.1","gneg"],[76800000,77200000,"q25.2","gpos25"],[77200000,83257441,"q25.3","gneg"]],"12":[[0,3200000,"p13.33","gneg"],[3200000,5300000,"p13.32","gpos25"],[5300000,10000000,"p13.31","gneg"],[10000000,12600000,"p13.2","gpos75"],[12600000,14600000,"p13.1","gneg"],[14600000,19800000,"p12.3","gpos100"],[19800000,21100000,"p12.2","gneg"],[21100000,26300000,"p12.1","gpos100"],[26300000,27600000,"p11.23","gneg"],[27600000,30500000,"p11.22","gpos50"],[30500000,33200000,"p11.21","gneg"],[33200000,35500000,"p11.1","acen"],[35500000,37800000,"q11","acen"],[37800000,46000000,"q12","gpos100"],[46000000,48700000,"q13.11","gneg"],[48700000,51100000,"q13.12","gpos25"],[51100000,54500000,"q13.13","gneg"],[54500000,56200000,"q13.2","gpos25"],[56200000,57700000,"q13.3","gneg"],[57700000,62700000,"q14.1","gpos75"],[62700000,64700000,"q14.2","gneg"],[64700000,67300000,"q14.3","gpos50"],[67300000,71100000,"q15","gneg"],[71100000,75300000,"q21.1","gpos75"],[75300000,79900000,"q21.2","gneg"],[79900000,86300000,"q21.31","gpos100"],[86300000,88600000,"q21.32","gneg"],[88600000,92200000,"q21.33","gpos100"],[92200000,95800000,"q22","gneg"],[95800000,101200000,"q23.1","gpos75"],[101200000,103500000,"q23.2","gneg"],[103500000,108600000,"q23.3","gpos50"],[108600000,111300000,"q24.11","gneg"],[111300000,111900000,"q24.12","gpos25"],[111900000,113900000,"q24.13","gneg"],[113900000,116400000,"q24.21","gpos50"],[116400000,117700000,"q24.22","gneg"],[117700000,120300000,"q24.23","gpos50"],[120300000,125400000,"q24.31","gneg"],[125400000,128700000,"q24.32","gpos50"],[128700000,133275309,"q24.33","gneg"]],"21":[[0,3100000,"p13","gvar"],[3100000,7000000,"p12","stalk"],[7000000,10900000,"p11.2","gvar"],[10900000,12000000,"p11.1","acen"],[12000000,13000000,"q11.1","acen"],[13000000,15000000,"q11.2","gneg"],[15000000,22600000,"q21.1","gpos100"],[22600000,25500000,"q21.2","gneg"],[25500000,30200000,"q21.3","gpos75"],[30200000,34400000,"q22.11","gneg"],[34400000,36400000,"q22.12","gpos50"],[36400000,38300000,"q22.13","gneg"],[38300000,41200000,"q22.2","gpos50"],[41200000,46709983,"q22.3","gneg"]],"Y":[[0,300000,"p11.32","gneg"],[300000,600000,"p11.31","gpos50"],[600000,10300000,"p11.2","gneg"],[10300000,10400000,"p11.1","acen"],[10400000,10600000,"q11.1","acen"],[10600000,12400000,"q11.21","gneg"],[12400000,17100000,"q11.221","gpos50"],[17100000,19600000,"q11.222","gneg"],[19600000,23800000,"q11.223","gpos50"],[23800000,26600000,"q11.23","gneg"],[26600000,57227415,"q12","gvar"]],"MT":[[0,16569,"","gneg"]]},"hg19":{"1":[[0,2300000,"p36.33","gneg"],[2300000,5400000,"p36.32","gpos25"],[5400000,7200000,"p36.31","gneg"],[7200000,9200000,"p36.23","gpos25"],[9200000,12700000,"p36.22","gneg"],[12700000,16200000,"p36.21","gpos50"],[16200000,20400000,"p36.13","gneg"],[20400000,23900000,"p36.12","gpos25"],[23900000,28000000,"p36.11","gneg"],[28000000,30200000,"p35.3","gpos25"],[30200000,32400000,"p35.2","gneg"],[32400000,34600000,"p35.1","gpos25"],[34600000,40100000,"p34.3","gneg"],[40100000,44100000,"p34.2","gpos25"],[44100000,46800000,"p34.1","gneg"],[46800000,50700000,"p33","gpos75"],[50700000,56100000,"p32.3","gneg"],[56100000,59000000,"p32.2","gpos50"],[59000000,61300000,"p32.1","gneg"],[61300000,68900000,"p31.3","gpos50"],[68900000,69700000,"p31.2","gneg"],[69700000,84900000,"p31.1","gpos100"],[84900000,88400000,"p22.3","gneg"],[88400000,92000000,"p22.2","gpos75"],[92000000,94700000,"p22.1","gneg"],[94700000,99700000,"p21.3","gpos75"],[99700000,102200000,"p21.2","gneg"],[102200000,107200000,"p21.1","gpos100"],[107200000,111800000,"p13.3","gneg"],[111800000,116100000,"p13.2","gpos50"],[116100000,117800000,"p13.1","gneg"],[117800000,120600000,"p12","gpos50"],[120600000,121500000,"p11.2","gneg"],[121500000,125000000,"p11.1","acen"],[125000000,128900000,"q11","acen"],[128900000,142600000,"q12","gvar"],[142600000,147000000,"q21.1","gneg"],[147000000,150300000,"q21.2","gpos50"],[150300000,155000000,"q21.3","gneg"],[155000000,156500000,"q22","gpos50"],[156500000,159100000,"q23.1","gneg"],[159100000,160500000,"q23.2","gpos50"],[160500000,165500000,"q23.3","gneg"],[165500000,167200000,"q24.1","gpos50"],[167200000,170900000,"q24.2","gneg"],[170900000,172900000,"q24.3","gpos75"],[172900000,176000000,"q25.1","gneg"],[176000000,180300000,"q25.2","gpos50"],[180300000,185800000,"q25.3","gneg"],[185800000,190800000,"q31.1","gpos100"],[190800000,193800000,"q31.2","gneg"],[193800000,198700000,"q31.3","gpos100"],[198700000,207200000,"q32.1","gneg"],[207200000,211500000,"q32.2","gpos25"],[211500000,214500000,"q32.3","gneg"],[214500000,224100000,"q41","gpos100"],[224100000,224600000,"q42.11","gneg"],[224600000,227000000,"q42.12","gpos25"],[227000000,230700000,"q42.13","gneg"],[230700000,234700000,"q42.2","gpos50"],[234700000,236600000,"q42.3","gneg"],[236600000,243700000,"q43","gpos75"],[243700000,249250621,"q44","gneg"]],"5":[[0,4500000,"p15.33","gneg"],[4500000,6300000,"p15.32","gpos25"],[6300000,9800000,"p15.31","gneg"],[9800000,15000000,"p15.2","gpos50"],[15000000,18400000,"p15.1","gneg"],[18400000,23300000,"p14.3","gpos100"],[23300000,24600000,"p14.2","gneg"],[24600000,28900000,"p14.1","gpos100"],[28900000,33800000,"p13.3","gneg"],[33800000,38400000,"p13.2","gpos25"],[38400000,42500000,"p13.1","gneg"],[42500000,46100000,"p12","gpos50"],[46100000,48400000,"p11","acen"],[48400000,50700000,"q11.1","acen"],[50700000,58900000,"q11.2","gneg"],[58900000,62900000,"q12.1","gpos75"],[62900000,63200000,"q12.2","gneg"],[63200000,66700000,"q12.3","gpos75"],[66700000,68400000,"q13.1","gneg"],[68400000,73300000,"q13.2","gpos50"],[73300000,76900000,"q13.3","gneg"],[76900000,81400000,"q14.1","gpos50"],[81400000,82800000,"q14.2","gneg"],[82800000,92300000,"q14.3","gpos100"],[92300000,98200000,"q15","gneg"],[98200000,102800000,"q21.1","gpos100"],[102800000,104500000,"q21.2","gneg"],[104500000,109600000,"q21.3","gpos100"],[109600000,111500000,"q22.1","gneg"],[111500000,113100000,"q22.2","gpos50"],[113100000,115200000,"q22.3","gneg"],[115200000,121400000,"q23.1","gpos100"],[121400000,127300000,"q23.2","gneg"],[127300000,130600000,"q23.3","gpos100"],[130600000,136200000,"q31.1","gneg"],[136200000,139500000,"q31.2","gpos25"],[139500000,144500000,"q31.3","gneg"],[144500000,149800000,"q32","gpos75"],[149800000,152700000,"q33.1","gneg"],[152700000,155700000,"q33.2","gpos50"],[155700000,159900000,"q33.3","gneg"],[159900000,168500000,"q34","gpos100"],[168500000,172800000,"q35.1","gneg"],[172800000,176600000,"q35.2","gpos25"],[176600000,180915260,"q35.3","gneg"]],"2":[[0,4400000,"p25.3","gneg"],[4400000,7100000,"p25.2","gpos50"],[7100000,12200000,"p25.1","gneg"],[12200000,16700000,"p24.3","gpos75"],[16700000,19200000,"p24.2","gneg"],[19200000,24000000,"p24.1","gpos75"],[24000000,27900000,"p23.3","gneg"],[27900000,30000000,"p23.2","gpos25"],[30000000,32100000,"p23.1","gneg"],[32100000,36600000,"p22.3","gpos75"],[36600000,38600000,"p22.2","gneg"],[38600000,41800000,"p22.1","gpos50"],[41800000,47800000,"p21","gneg"],[47800000,52900000,"p16.3","gpos100"],[52900000,55000000,"p16.2","gneg"],[55000000,61300000,"p16.1","gpos100"],[61300000,64100000,"p15","gneg"],[64100000,68600000,"p14","gpos50"],[68600000,71500000,"p13.3","gneg"],[71500000,73500000,"p13.2","gpos50"],[73500000,75000000,"p13.1","gneg"],[75000000,83300000,"p12","gpos100"],[83300000,90500000,"p11.2","gneg"],[90500000,93300000,"p11.1","acen"],[93300000,96800000,"q11.1","acen"],[96800000,102700000,"q11.2","gneg"],[102700000,106000000,"q12.1","gpos50"],[106000000,107500000,"q12.2","gneg"],[107500000,110200000,"q12.3","gpos25"],[110200000,114400000,"q13","gneg"],[114400000,118800000,"q14.1","gpos50"],[118800000,122400000,"q14.2","gneg"],[122400000,129900000,"q14.3","gpos50"],[129900000,132500000,"q21.1","gneg"],[132500000,135100000,"q21.2","gpos25"],[135100000,136800000,"q21.3","gneg"],[136800000,142200000,"q22.1","gpos100"],[142200000,144100000,"q22.2","gneg"],[144100000,148700000,"q22.3","gpos100"],[148700000,149900000,"q23.1","gneg"],[149900000,150500000,"q23.2","gpos25"],[150500000,154900000,"q23.3","gneg"],[154900000,159800000,"q24.1","gpos75"],[159800000,163700000,"q24.2","gneg"],[163700000,169700000,"q24.3","gpos75"],[169700000,178000000,"q31.1","gneg"],[178000000,180600000,"q31.2","gpos50"],[180600000,183000000,"q31.3","gneg"],[183000000,189400000,"q32.1","gpos75"],[189400000,191900000,"q32.2","gneg"],[191900000,197400000,"q32.3","gpos75"],[197400000,203300000,"q33.1","gneg"],[203300000,204900000,"q33.2","gpos50"],[204900000,209000000,"q33.3","gneg"],[209000000,215300000,"q34","gpos100"],[215300000,221500000,"q35","gneg"],[221500000,225200000,"q36.1","gpos75"],[225200000,226100000,"q36.2","gneg"],[226100000,231000000,"q36.3","gpos100"],[231000000,235600000,"q37.1","gneg"],[235600000,237300000,"q37.2","gpos50"],[237300000,243199373,"q37.3","gneg"]],"15":[[0,3900000,"p13","gvar"],[3900000,8700000,"p12","stalk"],[8700000,15800000,"p11.2","gvar"],[15800000,19000000,"p11.1","acen"],[19000000,20700000,"q11.1","acen"],[20700000,25700000,"q11.2","gneg"],[25700000,28100000,"q12","gpos50"],[28100000,30300000,"q13.1","gneg"],[30300000,31200000,"q13.2","gpos50"],[31200000,33600000,"q13.3","gneg"],[33600000,40100000,"q14","gpos75"],[40100000,42800000,"q15.1","gneg"],[42800000,43600000,"q15.2","gpos25"],[43600000,44800000,"q15.3","gneg"],[44800000,49500000,"q21.1","gpos75"],[49500000,52900000,"q21.2","gneg"],[52900000,59100000,"q21.3","gpos75"],[59100000,59300000,"q22.1","gneg"],[59300000,63700000,"q22.2","gpos25"],[63700000,67200000,"q22.31","gneg"],[67200000,67300000,"q22.32","gpos25"],[67300000,67500000,"q22.33","gneg"],[67500000,72700000,"q23","gpos25"],[72700000,75200000,"q24.1","gneg"],[75200000,76600000,"q24.2","gpos25"],[76600000,78300000,"q24.3","gneg"],[78300000,81700000,"q25.1","gpos50"],[81700000,85200000,"q25.2","gneg"],[85200000,89100000,"q25.3","gpos50"],[89100000,94300000,"q26.1","gneg"],[94300000,98500000,"q26.2","gpos50"],[98500000,102531392,"q26.3","gneg"]],"20":[[0,5100000,"p13","gneg"],[5100000,9200000,"p12.3","gpos75"],[9200000,12100000,"p12.2","gneg"],[12100000,17900000,"p12.1","gpos75"],[17900000,21300000,"p11.23","gneg"],[21300000,22300000,"p11.22","gpos25"],[22300000,25600000,"p11.21","gneg"],[25600000,27500000,"p11.1","acen"],[27500000,29400000,"q11.1","acen"],[29400000,32100000,"q11.21","gneg"],[32100000,34400000,"q11.22","gpos25"],[34400000,37600000,"q11.23","gneg"],[37600000,41700000,"q12","gpos75"],[41700000,42100000,"q13.11","gneg"],[42100000,46400000,"q13.12","gpos25"],[46400000,49800000,"q13.13","gneg"],[49800000,55000000,"q13.2","gpos75"],[55000000,56500000,"q13.31","gneg"],[56500000,58400000,"q13.32","gpos50"],[58400000,63025520,"q13.33","gneg"]],"22":[[0,3800000,"p13","gvar"],[3800000,8300000,"p12","stalk"],[8300000,12200000,"p11.2","gvar"],[12200000,14700000,"p11.1","acen"],[14700000,17900000,"q11.1","acen"],[17900000,22200000,"q11.21","gneg"],[22200000,23500000,"q11.22","gpos25"],[23500000,25900000,"q11.23","gneg"],[25900000,29600000,"q12.1","gpos50"],[29600000,32200000,"q12.2","gneg"],[32200000,37600000,"q12.3","gpos50"],[37600000,41000000,"q13.1","gneg"],[41000000,44200000,"q13.2","gpos50"],[44200000,48400000,"q13.31","gneg"],[48400000,49400000,"q13.32","gpos50"],[49400000,51304566,"q13.33","gneg"]],"4":[[0,4500000,"p16.3","gneg"],[4500000,6000000,"p16.2","gpos25"],[6000000,11300000,"p16.1","gneg"],[11300000,15200000,"p15.33","gpos50"],[15200000,17800000,"p15.32","gneg"],[17800000,21300000,"p15.31","gpos75"],[21300000,27700000,"p15.2","gneg"],[27700000,35800000,"p15.1","gpos100"],[35800000,41200000,"p14","gneg"],[41200000,44600000,"p13","gpos50"],[44600000,48200000,"p12","gneg"],[48200000,50400000,"p11","acen"],[50400000,52700000,"q11","acen"],[52700000,59500000,"q12","gneg"],[59500000,66600000,"q13.1","gpos100"],[66600000,70500000,"q13.2","gneg"],[70500000,76300000,"q13.3","gpos75"],[76300000,78900000,"q21.1","gneg"],[78900000,82400000,"q21.21","gpos50"],[82400000,84100000,"q21.22","gneg"],[84100000,86900000,"q21.23","gpos25"],[86900000,88000000,"q21.3","gneg"],[88000000,93700000,"q22.1","gpos75"],[93700000,95100000,"q22.2","gneg"],[95100000,98800000,"q22.3","gpos75"],[98800000,101100000,"q23","gneg"],[101100000,107700000,"q24","gpos50"],[107700000,114100000,"q25","gneg"],[114100000,120800000,"q26","gpos75"],[120800000,123800000,"q27","gneg"],[123800000,128800000,"q28.1","gpos50"],[128800000,131100000,"q28.2","gneg"],[131100000,139500000,"q28.3","gpos100"],[139500000,141500000,"q31.1","gneg"],[141500000,146800000,"q31.21","gpos25"],[146800000,148500000,"q31.22","gneg"],[148500000,151100000,"q31.23","gpos25"],[151100000,155600000,"q31.3","gneg"],[155600000,161800000,"q32.1","gpos100"],[161800000,164500000,"q32.2","gneg"],[164500000,170100000,"q32.3","gpos100"],[170100000,171900000,"q33","gneg"],[171900000,176300000,"q34.1","gpos75"],[176300000,177500000,"q34.2","gneg"],[177500000,183200000,"q34.3","gpos100"],[183200000,187100000,"q35.1","gneg"],[187100000,191154276,"q35.2","gpos25"]],"18":[[0,2900000,"p11.32","gneg"],[2900000,7100000,"p11.31","gpos50"],[7100000,8500000,"p11.23","gneg"],[8500000,10900000,"p11.22","gpos25"],[10900000,15400000,"p11.21","gneg"],[15400000,17200000,"p11.1","acen"],[17200000,19000000,"q11.1","acen"],[19000000,25000000,"q11.2","gneg"],[25000000,32700000,"q12.1","gpos100"],[32700000,37200000,"q12.2","gneg"],[37200000,43500000,"q12.3","gpos75"],[43500000,48200000,"q21.1","gneg"],[48200000,53800000,"q21.2","gpos75"],[53800000,56200000,"q21.31","gneg"],[56200000,59000000,"q21.32","gpos50"],[59000000,61600000,"q21.33","gneg"],[61600000,66800000,"q22.1","gpos100"],[66800000,68700000,"q22.2","gneg"],[68700000,73100000,"q22.3","gpos25"],[73100000,78077248,"q23","gneg"]],"16":[[0,7900000,"p13.3","gneg"],[7900000,10500000,"p13.2","gpos50"],[10500000,12600000,"p13.13","gneg"],[12600000,14800000,"p13.12","gpos50"],[14800000,16800000,"p13.11","gneg"],[16800000,21200000,"p12.3","gpos50"],[21200000,24200000,"p12.2","gneg"],[24200000,28100000,"p12.1","gpos50"],[28100000,34600000,"p11.2","gneg"],[34600000,36600000,"p11.1","acen"],[36600000,38600000,"q11.1","acen"],[38600000,47000000,"q11.2","gvar"],[47000000,52600000,"q12.1","gneg"],[52600000,56700000,"q12.2","gpos50"],[56700000,57400000,"q13","gneg"],[57400000,66700000,"q21","gpos100"],[66700000,70800000,"q22.1","gneg"],[70800000,72900000,"q22.2","gpos50"],[72900000,74100000,"q22.3","gneg"],[74100000,79200000,"q23.1","gpos75"],[79200000,81700000,"q23.2","gneg"],[81700000,84200000,"q23.3","gpos50"],[84200000,87100000,"q24.1","gneg"],[87100000,88700000,"q24.2","gpos25"],[88700000,90354753,"q24.3","gneg"]],"8":[[0,2200000,"p23.3","gneg"],[2200000,6200000,"p23.2","gpos75"],[6200000,12700000,"p23.1","gneg"],[12700000,19000000,"p22","gpos100"],[19000000,23300000,"p21.3","gneg"],[23300000,27400000,"p21.2","gpos50"],[27400000,28800000,"p21.1","gneg"],[28800000,36500000,"p12","gpos75"],[36500000,38300000,"p11.23","gneg"],[38300000,39700000,"p11.22","gpos25"],[39700000,43100000,"p11.21","gneg"],[43100000,45600000,"p11.1","acen"],[45600000,48100000,"q11.1","acen"],[48100000,52200000,"q11.21","gneg"],[52200000,52600000,"q11.22","gpos75"],[52600000,55500000,"q11.23","gneg"],[55500000,61600000,"q12.1","gpos50"],[61600000,62200000,"q12.2","gneg"],[62200000,66000000,"q12.3","gpos50"],[66000000,68000000,"q13.1","gneg"],[68000000,70500000,"q13.2","gpos50"],[70500000,73900000,"q13.3","gneg"],[73900000,78300000,"q21.11","gpos100"],[78300000,80100000,"q21.12","gneg"],[80100000,84600000,"q21.13","gpos75"],[84600000,86900000,"q21.2","gneg"],[86900000,93300000,"q21.3","gpos100"],[93300000,99000000,"q22.1","gneg"],[99000000,101600000,"q22.2","gpos25"],[101600000,106200000,"q22.3","gneg"],[106200000,110500000,"q23.1","gpos75"],[110500000,112100000,"q23.2","gneg"],[112100000,117700000,"q23.3","gpos100"],[117700000,119200000,"q24.11","gneg"],[119200000,122500000,"q24.12","gpos50"],[122500000,127300000,"q24.13","gneg"],[127300000,131500000,"q24.21","gpos50"],[131500000,136400000,"q24.22","gneg"],[136400000,139900000,"q24.23","gpos75"],[139900000,146364022,"q24.3","gneg"]],"13":[[0,4500000,"p13","gvar"],[4500000,10000000,"p12","stalk"],[10000000,16300000,"p11.2","gvar"],[16300000,17900000,"p11.1","acen"],[17900000,19500000,"q11","acen"],[19500000,23300000,"q12.11","gneg"],[23300000,25500000,"q12.12","gpos25"],[25500000,27800000,"q12.13","gneg"],[27800000,28900000,"q12.2","gpos25"],[28900000,32200000,"q12.3","gneg"],[32200000,34000000,"q13.1","gpos50"],[34000000,35500000,"q13.2","gneg"],[35500000,40100000,"q13.3","gpos75"],[40100000,45200000,"q14.11","gneg"],[45200000,45800000,"q14.12","gpos25"],[45800000,47300000,"q14.13","gneg"],[47300000,50900000,"q14.2","gpos50"],[50900000,55300000,"q14.3","gneg"],[55300000,59600000,"q21.1","gpos100"],[59600000,62300000,"q21.2","gneg"],[62300000,65700000,"q21.31","gpos75"],[65700000,68600000,"q21.32","gneg"],[68600000,73300000,"q21.33","gpos100"],[73300000,75400000,"q22.1","gneg"],[75400000,77200000,"q22.2","gpos50"],[77200000,79000000,"q22.3","gneg"],[79000000,87700000,"q31.1","gpos100"],[87700000,90000000,"q31.2","gneg"],[90000000,95000000,"q31.3","gpos100"],[95000000,98200000,"q32.1","gneg"],[98200000,99300000,"q32.2","gpos25"],[99300000,101700000,"q32.3","gneg"],[101700000,104800000,"q33.1","gpos100"],[104800000,107000000,"q33.2","gneg"],[107000000,110300000,"q33.3","gpos100"],[110300000,115169878,"q34","gneg"]],"11":[[0,2800000,"p15.5","gneg"],[2800000,10700000,"p15.4","gpos50"],[10700000,12700000,"p15.3","gneg"],[12700000,16200000,"p15.2","gpos50"],[16200000,21700000,"p15.1","gneg"],[21700000,26100000,"p14.3","gpos100"],[26100000,27200000,"p14.2","gneg"],[27200000,31000000,"p14.1","gpos75"],[31000000,36400000,"p13","gneg"],[36400000,43500000,"p12","gpos100"],[43500000,48800000,"p11.2","gneg"],[48800000,51600000,"p11.12","gpos75"],[51600000,53700000,"p11.11","acen"],[53700000,55700000,"q11","acen"],[55700000,59900000,"q12.1","gpos75"],[59900000,61700000,"q12.2","gneg"],[61700000,63400000,"q12.3","gpos25"],[63400000,65900000,"q13.1","gneg"],[65900000,68400000,"q13.2","gpos25"],[68400000,70400000,"q13.3","gneg"],[70400000,75200000,"q13.4","gpos50"],[75200000,77100000,"q13.5","gneg"],[77100000,85600000,"q14.1","gpos100"],[85600000,88300000,"q14.2","gneg"],[88300000,92800000,"q14.3","gpos100"],[92800000,97200000,"q21","gneg"],[97200000,102100000,"q22.1","gpos100"],[102100000,102900000,"q22.2","gneg"],[102900000,110400000,"q22.3","gpos100"],[110400000,112500000,"q23.1","gneg"],[112500000,114500000,"q23.2","gpos50"],[114500000,121200000,"q23.3","gneg"],[121200000,123900000,"q24.1","gpos50"],[123900000,127800000,"q24.2","gneg"],[127800000,130800000,"q24.3","gpos50"],[130800000,135006516,"q25","gneg"]],"14":[[0,3700000,"p13","gvar"],[3700000,8100000,"p12","stalk"],[8100000,16100000,"p11.2","gvar"],[16100000,17600000,"p11.1","acen"],[17600000,19100000,"q11.1","acen"],[19100000,24600000,"q11.2","gneg"],[24600000,33300000,"q12","gpos100"],[33300000,35300000,"q13.1","gneg"],[35300000,36600000,"q13.2","gpos50"],[36600000,37800000,"q13.3","gneg"],[37800000,43500000,"q21.1","gpos100"],[43500000,47200000,"q21.2","gneg"],[47200000,50900000,"q21.3","gpos100"],[50900000,54100000,"q22.1","gneg"],[54100000,55500000,"q22.2","gpos25"],[55500000,58100000,"q22.3","gneg"],[58100000,62100000,"q23.1","gpos75"],[62100000,64800000,"q23.2","gneg"],[64800000,67900000,"q23.3","gpos50"],[67900000,70200000,"q24.1","gneg"],[70200000,73800000,"q24.2","gpos50"],[73800000,79300000,"q24.3","gneg"],[79300000,83600000,"q31.1","gpos100"],[83600000,84900000,"q31.2","gneg"],[84900000,89800000,"q31.3","gpos100"],[89800000,91900000,"q32.11","gneg"],[91900000,94700000,"q32.12","gpos25"],[94700000,96300000,"q32.13","gneg"],[96300000,101400000,"q32.2","gpos50"],[101400000,103200000,"q32.31","gneg"],[103200000,104000000,"q32.32","gpos50"],[104000000,107349540,"q32.33","gneg"]],"7":[[0,2800000,"p22.3","gneg"],[2800000,4500000,"p22.2","gpos25"],[4500000,7300000,"p22.1","gneg"],[7300000,13800000,"p21.3","gpos100"],[13800000,16500000,"p21.2","gneg"],[16500000,20900000,"p21.1","gpos100"],[20900000,25500000,"p15.3","gneg"],[25500000,28000000,"p15.2","gpos50"],[28000000,28800000,"p15.1","gneg"],[28800000,35000000,"p14.3","gpos75"],[35000000,37200000,"p14.2","gneg"],[37200000,43300000,"p14.1","gpos75"],[43300000,45400000,"p13","gneg"],[45400000,49000000,"p12.3","gpos75"],[49000000,50500000,"p12.2","gneg"],[50500000,54000000,"p12.1","gpos75"],[54000000,58000000,"p11.2","gneg"],[58000000,59900000,"p11.1","acen"],[59900000,61700000,"q11.1","acen"],[61700000,67000000,"q11.21","gneg"],[67000000,72200000,"q11.22","gpos50"],[72200000,77500000,"q11.23","gneg"],[77500000,86400000,"q21.11","gpos100"],[86400000,88200000,"q21.12","gneg"],[88200000,91100000,"q21.13","gpos75"],[91100000,92800000,"q21.2","gneg"],[92800000,98000000,"q21.3","gpos75"],[98000000,103800000,"q22.1","gneg"],[103800000,104500000,"q22.2","gpos50"],[104500000,107400000,"q22.3","gneg"],[107400000,114600000,"q31.1","gpos75"],[114600000,117400000,"q31.2","gneg"],[117400000,121100000,"q31.31","gpos75"],[121100000,123800000,"q31.32","gneg"],[123800000,127100000,"q31.33","gpos75"],[127100000,129200000,"q32.1","gneg"],[129200000,130400000,"q32.2","gpos25"],[130400000,132600000,"q32.3","gneg"],[132600000,138200000,"q33","gpos50"],[138200000,143100000,"q34","gneg"],[143100000,147900000,"q35","gpos75"],[147900000,152600000,"q36.1","gneg"],[152600000,155100000,"q36.2","gpos25"],[155100000,159138663,"q36.3","gneg"]],"10":[[0,3000000,"p15.3","gneg"],[3000000,3800000,"p15.2","gpos25"],[3800000,6600000,"p15.1","gneg"],[6600000,12200000,"p14","gpos75"],[12200000,17300000,"p13","gneg"],[17300000,18600000,"p12.33","gpos75"],[18600000,18700000,"p12.32","gneg"],[18700000,22600000,"p12.31","gpos75"],[22600000,24600000,"p12.2","gneg"],[24600000,29600000,"p12.1","gpos50"],[29600000,31300000,"p11.23","gneg"],[31300000,34400000,"p11.22","gpos25"],[34400000,38000000,"p11.21","gneg"],[38000000,40200000,"p11.1","acen"],[40200000,42300000,"q11.1","acen"],[42300000,46100000,"q11.21","gneg"],[46100000,49900000,"q11.22","gpos25"],[49900000,52900000,"q11.23","gneg"],[52900000,61200000,"q21.1","gpos100"],[61200000,64500000,"q21.2","gneg"],[64500000,70600000,"q21.3","gpos100"],[70600000,74900000,"q22.1","gneg"],[74900000,77700000,"q22.2","gpos50"],[77700000,82000000,"q22.3","gneg"],[82000000,87900000,"q23.1","gpos100"],[87900000,89500000,"q23.2","gneg"],[89500000,92900000,"q23.31","gpos75"],[92900000,94100000,"q23.32","gneg"],[94100000,97000000,"q23.33","gpos50"],[97000000,99300000,"q24.1","gneg"],[99300000,101900000,"q24.2","gpos50"],[101900000,103000000,"q24.31","gneg"],[103000000,104900000,"q24.32","gpos25"],[104900000,105800000,"q24.33","gneg"],[105800000,111900000,"q25.1","gpos100"],[111900000,114900000,"q25.2","gneg"],[114900000,119100000,"q25.3","gpos75"],[119100000,121700000,"q26.11","gneg"],[121700000,123100000,"q26.12","gpos50"],[123100000,127500000,"q26.13","gneg"],[127500000,130600000,"q26.2","gpos50"],[130600000,135534747,"q26.3","gneg"]],"X":[[0,4300000,"p22.33","gneg"],[4300000,6000000,"p22.32","gpos50"],[6000000,9500000,"p22.31","gneg"],[9500000,17100000,"p22.2","gpos50"],[17100000,19300000,"p22.13","gneg"],[19300000,21900000,"p22.12","gpos50"],[21900000,24900000,"p22.11","gneg"],[24900000,29300000,"p21.3","gpos100"],[29300000,31500000,"p21.2","gneg"],[31500000,37600000,"p21.1","gpos100"],[37600000,42400000,"p11.4","gneg"],[42400000,46400000,"p11.3","gpos75"],[46400000,49800000,"p11.23","gneg"],[49800000,54800000,"p11.22","gpos25"],[54800000,58100000,"p11.21","gneg"],[58100000,60600000,"p11.1","acen"],[60600000,63000000,"q11.1","acen"],[63000000,64600000,"q11.2","gneg"],[64600000,67800000,"q12","gpos50"],[67800000,71800000,"q13.1","gneg"],[71800000,73900000,"q13.2","gpos50"],[73900000,76000000,"q13.3","gneg"],[76000000,84600000,"q21.1","gpos100"],[84600000,86200000,"q21.2","gneg"],[86200000,91800000,"q21.31","gpos100"],[91800000,93500000,"q21.32","gneg"],[93500000,98300000,"q21.33","gpos75"],[98300000,102600000,"q22.1","gneg"],[102600000,103700000,"q22.2","gpos50"],[103700000,108700000,"q22.3","gneg"],[108700000,116500000,"q23","gpos75"],[116500000,120900000,"q24","gneg"],[120900000,128700000,"q25","gpos100"],[128700000,130400000,"q26.1","gneg"],[130400000,133600000,"q26.2","gpos25"],[133600000,138000000,"q26.3","gneg"],[138000000,140300000,"q27.1","gpos75"],[140300000,142100000,"q27.2","gneg"],[142100000,147100000,"q27.3","gpos100"],[147100000,155270560,"q28","gneg"]],"9":[[0,2200000,"p24.3","gneg"],[2200000,4600000,"p24.2","gpos25"],[4600000,9000000,"p24.1","gneg"],[9000000,14200000,"p23","gpos75"],[14200000,16600000,"p22.3","gneg"],[16600000,18500000,"p22.2","gpos25"],[18500000,19900000,"p22.1","gneg"],[19900000,25600000,"p21.3","gpos100"],[25600000,28000000,"p21.2","gneg"],[28000000,33200000,"p21.1","gpos100"],[33200000,36300000,"p13.3","gneg"],[36300000,38400000,"p13.2","gpos25"],[38400000,41000000,"p13.1","gneg"],[41000000,43600000,"p12","gpos50"],[43600000,47300000,"p11.2","gneg"],[47300000,49000000,"p11.1","acen"],[49000000,50700000,"q11","acen"],[50700000,65900000,"q12","gvar"],[65900000,68700000,"q13","gneg"],[68700000,72200000,"q21.11","gpos25"],[72200000,74000000,"q21.12","gneg"],[74000000,79200000,"q21.13","gpos50"],[79200000,81100000,"q21.2","gneg"],[81100000,84100000,"q21.31","gpos50"],[84100000,86900000,"q21.32","gneg"],[86900000,90400000,"q21.33","gpos50"],[90400000,91800000,"q22.1","gneg"],[91800000,93900000,"q22.2","gpos25"],[93900000,96600000,"q22.31","gneg"],[96600000,99300000,"q22.32","gpos25"],[99300000,102600000,"q22.33","gneg"],[102600000,108200000,"q31.1","gpos100"],[108200000,111300000,"q31.2","gneg"],[111300000,114900000,"q31.3","gpos25"],[114900000,117700000,"q32","gneg"],[117700000,122500000,"q33.1","gpos75"],[122500000,125800000,"q33.2","gneg"],[125800000,130300000,"q33.3","gpos25"],[130300000,133500000,"q34.11","gneg"],[133500000,134000000,"q34.12","gpos25"],[134000000,135900000,"q34.13","gneg"],[135900000,137400000,"q34.2","gpos25"],[137400000,141213431,"q34.3","gneg"]],"6":[[0,2300000,"p25.3","gneg"],[2300000,4200000,"p25.2","gpos25"],[4200000,7100000,"p25.1","gneg"],[7100000,10600000,"p24.3","gpos50"],[10600000,11600000,"p24.2","gneg"],[11600000,13400000,"p24.1","gpos25"],[13400000,15200000,"p23","gneg"],[15200000,25200000,"p22.3","gpos75"],[25200000,27000000,"p22.2","gneg"],[27000000,30400000,"p22.1","gpos50"],[30400000,32100000,"p21.33","gneg"],[32100000,33500000,"p21.32","gpos25"],[33500000,36600000,"p21.31","gneg"],[36600000,40500000,"p21.2","gpos25"],[40500000,46200000,"p21.1","gneg"],[46200000,51800000,"p12.3","gpos100"],[51800000,52900000,"p12.2","gneg"],[52900000,57000000,"p12.1","gpos100"],[57000000,58700000,"p11.2","gneg"],[58700000,61000000,"p11.1","acen"],[61000000,63300000,"q11.1","acen"],[63300000,63400000,"q11.2","gneg"],[63400000,70000000,"q12","gpos100"],[70000000,75900000,"q13","gneg"],[75900000,83900000,"q14.1","gpos50"],[83900000,84900000,"q14.2","gneg"],[84900000,88000000,"q14.3","gpos50"],[88000000,93100000,"q15","gneg"],[93100000,99500000,"q16.1","gpos100"],[99500000,100600000,"q16.2","gneg"],[100600000,105500000,"q16.3","gpos100"],[105500000,114600000,"q21","gneg"],[114600000,118300000,"q22.1","gpos75"],[118300000,118500000,"q22.2","gneg"],[118500000,126100000,"q22.31","gpos100"],[126100000,127100000,"q22.32","gneg"],[127100000,130300000,"q22.33","gpos75"],[130300000,131200000,"q23.1","gneg"],[131200000,135200000,"q23.2","gpos50"],[135200000,139000000,"q23.3","gneg"],[139000000,142800000,"q24.1","gpos75"],[142800000,145600000,"q24.2","gneg"],[145600000,149000000,"q24.3","gpos75"],[149000000,152500000,"q25.1","gneg"],[152500000,155500000,"q25.2","gpos50"],[155500000,161000000,"q25.3","gneg"],[161000000,164500000,"q26","gpos50"],[164500000,171115067,"q27","gneg"]],"3":[[0,2800000,"p26.3","gpos50"],[2800000,4000000,"p26.2","gneg"],[4000000,8700000,"p26.1","gpos50"],[8700000,11800000,"p25.3","gneg"],[11800000,13300000,"p25.2","gpos25"],[13300000,16400000,"p25.1","gneg"],[16400000,23900000,"p24.3","gpos100"],[23900000,26400000,"p24.2","gneg"],[26400000,30900000,"p24.1","gpos75"],[30900000,32100000,"p23","gneg"],[32100000,36500000,"p22.3","gpos50"],[36500000,39400000,"p22.2","gneg"],[39400000,43700000,"p22.1","gpos75"],[43700000,44100000,"p21.33","gneg"],[44100000,44200000,"p21.32","gpos50"],[44200000,50600000,"p21.31","gneg"],[50600000,52300000,"p21.2","gpos25"],[52300000,54400000,"p21.1","gneg"],[54400000,58600000,"p14.3","gpos50"],[58600000,63700000,"p14.2","gneg"],[63700000,69800000,"p14.1","gpos50"],[69800000,74200000,"p13","gneg"],[74200000,79800000,"p12.3","gpos75"],[79800000,83500000,"p12.2","gneg"],[83500000,87200000,"p12.1","gpos75"],[87200000,87900000,"p11.2","gneg"],[87900000,91000000,"p11.1","acen"],[91000000,93900000,"q11.1","acen"],[93900000,98300000,"q11.2","gvar"],[98300000,100000000,"q12.1","gneg"],[100000000,100900000,"q12.2","gpos25"],[100900000,102800000,"q12.3","gneg"],[102800000,106200000,"q13.11","gpos75"],[106200000,107900000,"q13.12","gneg"],[107900000,111300000,"q13.13","gpos50"],[111300000,113500000,"q13.2","gneg"],[113500000,117300000,"q13.31","gpos75"],[117300000,119000000,"q13.32","gneg"],[119000000,121900000,"q13.33","gpos75"],[121900000,123800000,"q21.1","gneg"],[123800000,125800000,"q21.2","gpos25"],[125800000,129200000,"q21.3","gneg"],[129200000,133700000,"q22.1","gpos25"],[133700000,135700000,"q22.2","gneg"],[135700000,138700000,"q22.3","gpos25"],[138700000,142800000,"q23","gneg"],[142800000,148900000,"q24","gpos100"],[148900000,152100000,"q25.1","gneg"],[152100000,155000000,"q25.2","gpos50"],[155000000,157000000,"q25.31","gneg"],[157000000,159000000,"q25.32","gpos50"],[159000000,160700000,"q25.33","gneg"],[160700000,167600000,"q26.1","gpos100"],[167600000,170900000,"q26.2","gneg"],[170900000,175700000,"q26.31","gpos75"],[175700000,179000000,"q26.32","gneg"],[179000000,182700000,"q26.33","gpos75"],[182700000,184500000,"q27.1","gneg"],[184500000,186000000,"q27.2","gpos25"],[186000000,187900000,"q27.3","gneg"],[187900000,192300000,"q28","gpos75"],[192300000,198022430,"q29","gneg"]],"19":[[0,6900000,"p13.3","gneg"],[6900000,13900000,"p13.2","gpos25"],[13900000,14000000,"p13.13","gneg"],[14000000,16300000,"p13.12","gpos25"],[16300000,20000000,"p13.11","gneg"],[20000000,24400000,"p12","gvar"],[24400000,26500000,"p11","acen"],[26500000,28600000,"q11","acen"],[28600000,32400000,"q12","gvar"],[32400000,35500000,"q13.11","gneg"],[35500000,38300000,"q13.12","gpos25"],[38300000,38700000,"q13.13","gneg"],[38700000,43400000,"q13.2","gpos25"],[43400000,45200000,"q13.31","gneg"],[45200000,48000000,"q13.32","gpos25"],[48000000,51400000,"q13.33","gneg"],[51400000,53600000,"q13.41","gpos25"],[53600000,56300000,"q13.42","gneg"],[56300000,59128983,"q13.43","gpos25"]],"17":[[0,3300000,"p13.3","gneg"],[3300000,6500000,"p13.2","gpos50"],[6500000,10700000,"p13.1","gneg"],[10700000,16000000,"p12","gpos75"],[16000000,22200000,"p11.2","gneg"],[22200000,24000000,"p11.1","acen"],[24000000,25800000,"q11.1","acen"],[25800000,31800000,"q11.2","gneg"],[31800000,38100000,"q12","gpos50"],[38100000,38400000,"q21.1","gneg"],[38400000,40900000,"q21.2","gpos25"],[40900000,44900000,"q21.31","gneg"],[44900000,47400000,"q21.32","gpos25"],[47400000,50200000,"q21.33","gneg"],[50200000,57600000,"q22","gpos75"],[57600000,58300000,"q23.1","gneg"],[58300000,61100000,"q23.2","gpos75"],[61100000,62600000,"q23.3","gneg"],[62600000,64200000,"q24.1","gpos50"],[64200000,67100000,"q24.2","gneg"],[67100000,70900000,"q24.3","gpos75"],[70900000,74800000,"q25.1","gneg"],[74800000,75300000,"q25.2","gpos25"],[75300000,81195210,"q25.3","gneg"]],"12":[[0,3300000,"p13.33","gneg"],[3300000,5400000,"p13.32","gpos25"],[5400000,10100000,"p13.31","gneg"],[10100000,12800000,"p13.2","gpos75"],[12800000,14800000,"p13.1","gneg"],[14800000,20000000,"p12.3","gpos100"],[20000000,21300000,"p12.2","gneg"],[21300000,26500000,"p12.1","gpos100"],[26500000,27800000,"p11.23","gneg"],[27800000,30700000,"p11.22","gpos50"],[30700000,33300000,"p11.21","gneg"],[33300000,35800000,"p11.1","acen"],[35800000,38200000,"q11","acen"],[38200000,46400000,"q12","gpos100"],[46400000,49100000,"q13.11","gneg"],[49100000,51500000,"q13.12","gpos25"],[51500000,54900000,"q13.13","gneg"],[54900000,56600000,"q13.2","gpos25"],[56600000,58100000,"q13.3","gneg"],[58100000,63100000,"q14.1","gpos75"],[63100000,65100000,"q14.2","gneg"],[65100000,67700000,"q14.3","gpos50"],[67700000,71500000,"q15","gneg"],[71500000,75700000,"q21.1","gpos75"],[75700000,80300000,"q21.2","gneg"],[80300000,86700000,"q21.31","gpos100"],[86700000,89000000,"q21.32","gneg"],[89000000,92600000,"q21.33","gpos100"],[92600000,96200000,"q22","gneg"],[96200000,101600000,"q23.1","gpos75"],[101600000,103800000,"q23.2","gneg"],[103800000,109000000,"q23.3","gpos50"],[109000000,111700000,"q24.11","gneg"],[111700000,112300000,"q24.12","gpos25"],[112300000,114300000,"q24.13","gneg"],[114300000,116800000,"q24.21","gpos50"],[116800000,118100000,"q24.22","gneg"],[118100000,120700000,"q24.23","gpos50"],[120700000,125900000,"q24.31","gneg"],[125900000,129300000,"q24.32","gpos50"],[129300000,133851895,"q24.33","gneg"]],"21":[[0,2800000,"p13","gvar"],[2800000,6800000,"p12","stalk"],[6800000,10900000,"p11.2","gvar"],[10900000,13200000,"p11.1","acen"],[13200000,14300000,"q11.1","acen"],[14300000,16400000,"q11.2","gneg"],[16400000,24000000,"q21.1","gpos100"],[24000000,26800000,"q21.2","gneg"],[26800000,31500000,"q21.3","gpos75"],[31500000,35800000,"q22.11","gneg"],[35800000,37800000,"q22.12","gpos50"],[37800000,39700000,"q22.13","gneg"],[39700000,42600000,"q22.2","gpos50"],[42600000,48129895,"q22.3","gneg"]],"Y":[[0,2500000,"p11.32","gneg"],[2500000,3000000,"p11.31","gpos50"],[3000000,11600000,"p11.2","gneg"],[11600000,12500000,"p11.1","acen"],[12500000,13400000,"q11.1","acen"],[13400000,15100000,"q11.21","gneg"],[15100000,19800000,"q11.221","gpos50"],[19800000,22100000,"q11.222","gneg"],[22100000,26200000,"q11.223","gpos50"],[26200000,28800000,"q11.23","gneg"],[28800000,59373566,"q12","gvar"]]}};

const CYTOBAND_COLOUR_PALETTES = {
  light: {
    gneg: '#f6f8fc',
    gpos25: '#e0e6f5',
    gpos50: '#c7cee6',
    gpos75: '#aab4d4',
    gpos100: '#8b98c1',
    gvar: '#6d7ca8',
    stalk: '#566593',
    acen: '#000000',
    other: '#d2d9eb'
  },
  dark: {
    gneg: '#1b2536',
    gpos25: '#242f45',
    gpos50: '#2f3c5b',
    gpos75: '#3a4a72',
    gpos100: '#455889',
    gvar: '#50649f',
    stalk: '#5a71b4',
    acen: '#000000',
    other: '#283555'
  }
};

function getCurrentTheme() {
  return document.documentElement?.dataset?.theme === 'dark' ? 'dark' : 'light';
}

function getGenomeBuildLabel(build) {
  const normalized = normalizeGenomeBuildValue(build);
  if (normalized && GENOME_BUILD_LABELS[normalized]) {
    return GENOME_BUILD_LABELS[normalized];
  }
  if (normalized) {
    return normalized.toUpperCase();
  }
  return 'ukendt reference';
}

function getCytobandBands(build, chromosome) {
  const normalizedBuild = normalizeGenomeBuildValue(build) || DEFAULT_GENOME_BUILD;
  const normalizedChromosome = normalizeChromosomeValue(chromosome);
  if (!normalizedChromosome) return [];
  const buildData = CYTOBAND_DATA[normalizedBuild];
  const rawBands = buildData ? buildData[normalizedChromosome] : null;
  if (!rawBands || !rawBands.length) return [];
  return rawBands.map(([start, end, name, stain]) => ({
    start,
    end,
    name,
    stain
  }));
}

function getCytobandChromosomeLength(build, chromosome) {
  const bands = getCytobandBands(build, chromosome);
  if (!bands.length) return 0;
  return bands[bands.length - 1].end || 0;
}

function getCytobandFill(stain, theme = getCurrentTheme()) {
  const palette = CYTOBAND_COLOUR_PALETTES[theme] || CYTOBAND_COLOUR_PALETTES.light;
  const key = String(stain || '').toLowerCase();
  return palette[key] || palette.other;
}

function normalizeGenomeBuildValue(value) {
  if (value == null) return '';
  const normalized = String(value).trim().toLowerCase();
  if (!normalized) return '';
  const compact = normalized.replace(/[^a-z0-9]/g, '');
  if (!compact) return '';
  if (compact.includes('hg38') || compact.includes('grch38') || compact === '38') {
    return 'hg38';
  }
  if (compact.includes('hg19') || compact.includes('grch37') || compact === '37' || compact === '19') {
    return 'hg19';
  }
  return '';
}

function normalizeChromosomeValue(value) {
  if (value == null) return '';
  const trimmed = String(value).trim();
  if (!trimmed) return '';
  const withoutPrefix = trimmed.replace(/^chr/i, '');
  const cleaned = withoutPrefix.replace(/[^0-9a-z]/gi, '');
  if (!cleaned) return '';
  if (/^\d+$/.test(cleaned)) {
    return String(Number(cleaned));
  }
  const upper = cleaned.toUpperCase();
  if (upper === 'M') return 'MT';
  if (['X', 'Y', 'MT'].includes(upper)) return upper;
  return '';
}

function ensureChrPrefix(chromosome) {
  const normalized = normalizeChromosomeValue(chromosome);
  if (!normalized) return '';
  return `chr${normalized}`;
}

function sanitizePositionValue(value) {
  if (value == null) return '';
  const matches = String(value).match(/\d+/g);
  if (!matches) return '';
  return matches.join('');
}

function parseVariantCoordinates(variant) {
  if (!variant) {
    return {chromosome: '', start: '', end: '', alleles: [], build: ''};
  }
  const rawPosition = variant.genomic_position
    || variant.genomicPosition
    || variant.position
    || variant.pos
    || variant.genomicpos
    || '';
  const tokens = [];
  const trimmed = String(rawPosition).trim();
  if (trimmed) {
    trimmed.split(/[^A-Za-z0-9]+/).forEach(token => {
      if (token) tokens.push(token);
    });
  }
  const alleles = tokens.filter(token => /^[ACGT]+$/i.test(token)).map(token => token.toUpperCase());
  let chromosome = '';
  for (const token of tokens) {
    const normalized = normalizeChromosomeValue(token);
    if (normalized) {
      chromosome = normalized;
      break;
    }
  }
  if (!chromosome) {
    chromosome = normalizeChromosomeValue(variant.chromosome || variant.chrom);
  }
  let numericTokens = tokens.filter(token => /^\d+$/.test(token));
  if (chromosome && /^\d+$/.test(chromosome) && numericTokens.length > 1 && numericTokens[0] === chromosome) {
    numericTokens = numericTokens.slice(1);
  }
  let start = numericTokens[0] || sanitizePositionValue(variant.start || variant.position_start || variant.begin);
  let end = numericTokens[1] || sanitizePositionValue(variant.end || variant.position_end || variant.finish);
  if (!end && start) {
    end = start;
  }
  if (start && end) {
    const startNum = Number(start);
    const endNum = Number(end);
    if (Number.isFinite(startNum) && Number.isFinite(endNum) && endNum < startNum) {
      [start, end] = [end, start];
    }
  }
  let build = '';
  for (const token of tokens) {
    const normalized = normalizeGenomeBuildValue(token);
    if (normalized) {
      build = normalized;
      break;
    }
  }
  return {
    chromosome: chromosome || '',
    start: start || '',
    end: end || '',
    alleles,
    build
  };
}

function resolveVariantField(variant, keys) {
  for (const key of keys) {
    const value = variant?.[key];
    if (value == null) continue;
    const text = String(value).trim();
    if (text) return text;
  }
  return '';
}

function parseVariantAlleleInfo(variant, coordinates) {
  const result = {type: '', ref: '', alt: ''};
  if (!variant) return result;
  let ref = resolveVariantField(variant, ['ref', 'reference', 'ref_allele', 'reference_allele', 'refAllele', 'referenceAllele']);
  let alt = resolveVariantField(variant, ['alt', 'alternate', 'alt_allele', 'alternate_allele', 'altAllele', 'alternateAllele']);
  const hgvs = resolveVariantField(variant, ['hgvs_c', 'hgvs', 'hgvs_cdna']);
  const substitutionMatch = hgvs.match(/([ACGT]+)>([ACGT]+)/i);
  if (substitutionMatch) {
    if (!ref) ref = substitutionMatch[1].toUpperCase();
    if (!alt) alt = substitutionMatch[2].toUpperCase();
  }
  if ((!ref || !alt) && coordinates?.alleles?.length >= 2) {
    if (!ref) ref = coordinates.alleles[0];
    if (!alt) alt = coordinates.alleles[1];
  }
  ref = ref ? ref.toUpperCase() : '';
  alt = alt ? alt.toUpperCase() : '';
  result.ref = ref;
  result.alt = alt;
  let type = '';
  const lowerHgvs = hgvs.toLowerCase();
  if (lowerHgvs.includes('delins')) {
    type = 'DELINS';
  } else if (lowerHgvs.includes('del')) {
    type = 'DEL';
  } else if (lowerHgvs.includes('dup')) {
    type = 'DUP';
  } else if (lowerHgvs.includes('ins')) {
    type = 'INS';
  }
  const subtype = resolveVariantField(variant, ['sv_subtype', 'structural_type', 'variant_subtype']).toLowerCase();
  if (!type && subtype) {
    if (/(del|loss)/.test(subtype)) {
      type = 'DEL';
    } else if (/(dup|gain|amp)/.test(subtype)) {
      type = 'DUP';
    } else if (/ins/.test(subtype)) {
      type = 'INS';
    }
  }
  const copyNumber = resolveVariantField(variant, ['copy_number', 'copies', 'copynumber', 'cn']).toLowerCase();
  if (!type && copyNumber) {
    if (/(x0|x1|loss|del)/.test(copyNumber)) {
      type = 'DEL';
    } else if (/(x[3-9]|gain|dup|amp)/.test(copyNumber)) {
      type = 'DUP';
    }
  }
  const normalizedType = normalizeVariantType(variant.variant_type);
  if (!type && normalizedType === 'snv' && ref && alt) {
    type = 'SNP';
  }
  result.type = type;
  return result;
}

function inferGenomeBuildCode(variant, coordinates, fallbackBuild = '') {
  if (!variant) {
    const fallbackNormalized = normalizeGenomeBuildValue(fallbackBuild);
    return fallbackNormalized || '';
  }
  const candidateFields = [
    resolveVariantField(variant, ['genome_build', 'genomeBuild', 'genome', 'reference_genome', 'referenceGenome', 'build', 'assembly']),
    coordinates?.build || '',
    resolveVariantField(variant, ['genomic_position', 'genomicPosition']),
    resolveVariantField(variant, ['iscn', 'cytogenetic']),
    resolveVariantField(variant, ['annotations', 'notes', 'comments', 'description'])
  ];
  for (const field of candidateFields) {
    const normalized = normalizeGenomeBuildValue(field);
    if (normalized) return normalized;
  }
  const fallbackNormalized = normalizeGenomeBuildValue(fallbackBuild);
  const hasCoordinates = Boolean(coordinates && coordinates.chromosome && coordinates.start);
  if (fallbackNormalized && hasCoordinates) {
    return fallbackNormalized;
  }
  if (hasCoordinates) {
    return DEFAULT_GENOME_BUILD;
  }
  return fallbackNormalized || '';
}

function determineDefaultGenomeBuild(variants = [], orders = [], variantLibrary = []) {
  const counts = new Map();
  const registerValue = value => {
    const normalized = normalizeGenomeBuildValue(value);
    if (!normalized) return;
    counts.set(normalized, (counts.get(normalized) || 0) + 1);
  };
  const registerVariant = variant => {
    if (!variant) return;
    registerValue(resolveVariantField(variant, ['genome_build', 'genomeBuild', 'genome', 'reference_genome', 'referenceGenome', 'build', 'assembly']));
    registerValue(resolveVariantField(variant, ['genomic_position', 'genomicPosition']));
    registerValue(resolveVariantField(variant, ['iscn', 'cytogenetic']));
    const coordinates = parseVariantCoordinates(variant);
    if (coordinates.build) registerValue(coordinates.build);
  };
  variants.forEach(registerVariant);
  variantLibrary.forEach(registerVariant);
  orders.forEach(order => {
    registerValue(resolveVariantField(order, ['genome_build', 'genomeBuild', 'genome', 'reference_genome', 'referenceGenome', 'build', 'assembly']));
  });
  if (!counts.size) {
    return DEFAULT_GENOME_BUILD;
  }
  const [topEntry] = [...counts.entries()].sort((a, b) => b[1] - a[1]);
  return topEntry?.[0] || DEFAULT_GENOME_BUILD;
}

function pickPrimaryGeneName(value) {
  if (!value) return '';
  const text = String(value).trim();
  if (!text) return '';
  const first = text.split(/[;,]/)[0].trim();
  return first;
}

function buildVariantLookupUrls(variant, coordinates, genomeBuild) {
  if (!variant) {
    return {franklin: '', gencc: '', ucsc: '', gnomad: ''};
  }
  const normalizedChromosome = normalizeChromosomeValue(coordinates?.chromosome || variant.chromosome || variant.chrom);
  const chrPart = ensureChrPrefix(normalizedChromosome || (variant.chromosome || variant.chrom));
  const start = coordinates?.start || sanitizePositionValue(variant.start);
  const end = coordinates?.end || sanitizePositionValue(variant.end);
  const alleleInfo = parseVariantAlleleInfo(variant, coordinates);
  const suffix = genomeBuild ? `-${genomeBuild}` : '';
  let franklin = '';
  if (alleleInfo.type === 'SNP' && chrPart && start && alleleInfo.ref && alleleInfo.alt) {
    franklin = `https://franklin.genoox.com/clinical-db/variant/snp/${chrPart}-${start}-${alleleInfo.ref}-${alleleInfo.alt}${suffix}`;
  } else if (alleleInfo.type && alleleInfo.type !== 'SNP' && chrPart && start) {
    const endPart = end || start;
    const range = endPart ? `${chrPart}-${start}-${endPart}` : `${chrPart}-${start}`;
    franklin = `https://franklin.genoox.com/clinical-db/variant/sv/${range}-${alleleInfo.type}${suffix}`;
  }
  let gnomad = '';
  const gnomadChromosome = normalizedChromosome ? normalizedChromosome.toUpperCase() : '';
  const normalizedType = normalizeVariantType(variant.variant_type);
  const isSmallVariant = ['SNP', 'DEL', 'INS', 'DELINS'].includes(alleleInfo.type) || normalizedType === 'snv';
  if (isSmallVariant && gnomadChromosome && start && alleleInfo.ref && alleleInfo.alt) {
    gnomad = `https://gnomad.broadinstitute.org/variant/${gnomadChromosome}-${start}-${alleleInfo.ref}-${alleleInfo.alt}?dataset=gnomad_r4`;
  }
  const gene = pickPrimaryGeneName(resolveVariantField(variant, ['gene', 'genes', 'gene_symbol', 'geneSymbol']));
  const gencc = gene ? `https://search.thegencc.org/genes?title=${encodeURIComponent(gene)}` : '';
  let ucsc = '';
  if (genomeBuild && chrPart && start) {
    const endPart = end || start;
    const range = endPart ? `${chrPart}:${start}-${endPart}` : `${chrPart}:${start}`;
    ucsc = `https://genome.ucsc.edu/cgi-bin/hgTracks?db=${genomeBuild}&position=${range}`;
  }
  return {franklin, gencc, ucsc, gnomad};
}

function formatVariantLookupCell(variant, fallbackGenomeBuild = '', orderMap = null) {
  if (!variant) return '';
  const coordinates = parseVariantCoordinates(variant);
  let preferredBuild = fallbackGenomeBuild;
  if (orderMap && variant.order_id != null) {
    const order = orderMap.get(Number(variant.order_id));
    if (order) {
      const orderBuild = resolveVariantField(order, ['genome_build', 'genomeBuild', 'genome', 'reference_genome', 'referenceGenome', 'build', 'assembly']);
      if (orderBuild) {
        preferredBuild = orderBuild;
      }
    }
  }
  const genomeBuild = inferGenomeBuildCode(variant, coordinates, preferredBuild);
  const urls = buildVariantLookupUrls(variant, coordinates, genomeBuild);
  const parts = [];
  if (urls.franklin) {
    parts.push(`<a class="variant-lookup-link" href="${urls.franklin}" target="_blank" rel="noopener noreferrer" title="Åbn varianten i Franklin by Genoox" aria-label="Åbn varianten i Franklin by Genoox">F</a>`);
  }
  if (urls.gnomad) {
    parts.push(`<a class="variant-lookup-link" href="${urls.gnomad}" target="_blank" rel="noopener noreferrer" title="Åbn varianten i gnomAD" aria-label="Åbn varianten i gnomAD">G</a>`);
  }
  if (urls.gencc) {
    parts.push(`<a class="variant-lookup-link" href="${urls.gencc}" target="_blank" rel="noopener noreferrer" title="Slå genet op i GenCC" aria-label="Slå genet op i GenCC">C</a>`);
  }
  if (urls.ucsc) {
    parts.push(`<a class="variant-lookup-link" href="${urls.ucsc}" target="_blank" rel="noopener noreferrer" title="Åbn den genomiske position i UCSC Genome Browser" aria-label="Åbn den genomiske position i UCSC Genome Browser">U</a>`);
  }
  if (!parts.length) return '';
  return `<span class="variant-lookup-links">${parts.join('')}</span>`;
}

function setupVariantTypeForm(form, {defaultType = 'snv', disableInactiveGroups = false} = {}) {
  if (!form) {
    return {
      updateVariantTypeFields: () => {},
      variantTypeSelect: null
    };
  }
  const select = form.elements?.variant_type
    || form.querySelector('[name="variant_type"]')
    || form.querySelector('[data-field="variant_type"]')
    || null;
  const groups = Array.from(form.querySelectorAll('[data-variant-types]'));
  const typeRequiredFields = Array.from(form.querySelectorAll('[data-type-required]'));
  const initialRequired = new Map(typeRequiredFields.map(field => [field, field.required]));
  const normalizedDefault = normalizeVariantType(defaultType);
  const update = () => {
    const type = normalizeVariantType(select?.value || normalizedDefault);
    if (select && select.value !== type) {
      select.value = type;
    }
    groups.forEach(group => {
      const types = (group.dataset.variantTypes || '')
        .split(/\s+/)
        .filter(Boolean)
        .map(normalizeVariantType);
      const active = types.length ? types.includes(type) : true;
      group.hidden = !active;
      group.classList.toggle('variant-type-hidden', !active);
      if (disableInactiveGroups) {
        const fields = group.querySelectorAll('input, select, textarea, button');
        fields.forEach(field => {
          if (field.matches('[name="variant_type"],[data-field="variant_type"]')) return;
          field.disabled = !active;
        });
      }
    });
    typeRequiredFields.forEach(field => {
      const requiredFor = (field.dataset.typeRequired || '')
        .split(/\s+/)
        .filter(Boolean)
        .map(normalizeVariantType);
      const defaultRequired = initialRequired.get(field) ?? field.required;
      const shouldRequire = requiredFor.length ? requiredFor.includes(type) : defaultRequired;
      field.required = shouldRequire;
      const label = field.closest('label');
      if (label) {
        label.classList.toggle('required', shouldRequire);
      }
    });
  };
  if (select) {
    select.addEventListener('change', update);
  }
  update();
  return {
    updateVariantTypeFields: update,
    variantTypeSelect: select
  };
}

function formatVariantGenomicRange(variant) {
  if (!variant) return '';
  const rawPosition = variant.genomic_position
    || variant.genomicPosition
    || variant.position
    || variant.pos
    || variant.genomicpos;
  if (rawPosition) {
    const value = String(rawPosition).trim();
    if (value) return value;
  }
  const chromosome = variant.chromosome || variant.chrom;
  const start = variant.start || variant.position_start || variant.begin;
  const end = variant.end || variant.position_end || variant.finish;
  if (!chromosome) return '';
  if (start && end) return `${chromosome}:${start}-${end}`;
  if (start) return `${chromosome}:${start}`;
  return String(chromosome);
}

function formatVariantCopyNumber(variant) {
  if (!variant) return '';
  const copyNumber = variant.copy_number ?? variant.copynumber ?? variant.copies;
  if (copyNumber === '' || copyNumber === null || copyNumber === undefined) return '';
  return `Kopital: ${copyNumber}`;
}

function normalizeVariantKeyPart(value) {
  if (value == null) return '';
  return String(value).trim().toLowerCase();
}

function createVariantComparisonKey(variant) {
  if (!variant) return '';
  const type = normalizeVariantType(variant.variant_type);
  const parts = [`type:${type}`];
  const seen = new Set(parts);
  const addPart = (label, rawValue) => {
    const value = normalizeVariantKeyPart(rawValue);
    if (!value) return;
    const part = `${label}:${value}`;
    if (seen.has(part)) return;
    seen.add(part);
    parts.push(part);
  };
  const gene = variant.gene || variant.region;
  const transcript = variant.transcript;
  const hgvsC = variant.hgvs_c;
  const hgvsP = variant.hgvs_p;
  const rsid = getVariantRsId(variant);
  const iscn = variant.iscn || variant.cytogenetic;
  const chromosome = variant.chromosome || variant.chr;
  const start = variant.start || variant.begin || variant.position_start;
  const end = variant.end || variant.finish || variant.position_end;
  const copyNumber = variant.copy_number || variant.copynumber || variant.copies;
  const svSubtype = normalizeStructureTypeValue(variant.sv_subtype || variant.structural_type || variant.variant_subtype);
  const description = variant.description;
  const affectedGenes = variant.affected_genes || variant.genes;
  const genomicPosition = variant.genomic_position
    || variant.genomicPosition
    || variant.position
    || variant.pos
    || variant.genomicpos;
  if (type === 'snv') {
    if (hgvsC || hgvsP || rsid) {
      addPart('hgvs_c', hgvsC);
      addPart('hgvs_p', hgvsP);
      addPart('rsid', rsid);
      addPart('genomic_position', genomicPosition);
    } else {
      if (transcript) addPart('transcript', transcript);
      addPart('gene', gene);
      addPart('genomic_position', genomicPosition);
    }
  } else {
    addPart('iscn', iscn);
    addPart('chromosome', chromosome);
    addPart('start', start);
    addPart('end', end);
    addPart('copy_number', copyNumber);
    addPart('sv_subtype', svSubtype);
    if (!iscn && !start && !end) {
      addPart('description', description);
    }
    if (!iscn && !description) {
      if (gene) {
        addPart('gene', gene);
      } else {
        addPart('affected_genes', affectedGenes);
      }
    }
  }
  if (parts.length <= 1) {
    addPart('gene', gene);
    addPart('description', description);
    addPart('affected_genes', affectedGenes);
  }
  return parts.length > 1 ? parts.join('|') : '';
}

function computeVariantFrequencyData() {
  const variants = getCached('variants') || [];
  const patients = getCached('patients') || [];
  const countMap = new Map();
  let maxCount = 0;
  variants.forEach(variant => {
    const key = createVariantComparisonKey(variant);
    if (!key) return;
    const updatedCount = (countMap.get(key) || 0) + 1;
    countMap.set(key, updatedCount);
    if (updatedCount > maxCount) {
      maxCount = updatedCount;
    }
  });
  return {countMap, patientCount: patients.length, maxCount};
}

function getPatientIdsForVariantKey(variantKey) {
  const key = (variantKey || '').toString();
  if (!key) return [];
  const variants = getCached('variants') || [];
  const orders = getCached('orders') || [];
  const orderToPatient = new Map();
  orders.forEach(order => {
    if (!order) return;
    const orderId = Number(order.id);
    const patientId = Number(order.patient_id);
    if (Number.isFinite(orderId) && Number.isFinite(patientId)) {
      orderToPatient.set(orderId, patientId);
    }
  });
  const patientIds = new Set();
  variants.forEach(variant => {
    if (!variant) return;
    const currentKey = createVariantComparisonKey(variant);
    if (!currentKey || currentKey !== key) return;
    const directPatientId = variant.patient_id != null ? Number(variant.patient_id) : NaN;
    if (Number.isFinite(directPatientId)) {
      patientIds.add(directPatientId);
      return;
    }
    const orderId = Number(variant.order_id);
    const mappedPatientId = orderToPatient.get(orderId);
    if (Number.isFinite(mappedPatientId)) {
      patientIds.add(mappedPatientId);
    }
  });
  return Array.from(patientIds).sort((a, b) => a - b);
}

function getPatientIdsForVariant(variant) {
  const key = createVariantComparisonKey(variant);
  if (!key) return [];
  return getPatientIdsForVariantKey(key);
}

function formatVariantFrequencyLabel(count, patientCount) {
  const registrations = Number(count) || 0;
  const patientsTotal = Number(patientCount) || 0;
  if (!patientsTotal) {
    return String(registrations);
  }
  const percent = (registrations / patientsTotal) * 100;
  const formattedPercent = percent.toLocaleString('da-DK', {
    minimumFractionDigits: percent > 0 && percent < 1 ? 2 : percent > 0 && percent < 10 ? 1 : 0,
    maximumFractionDigits: percent >= 10 ? 1 : 2
  });
  return `${registrations}/${patientsTotal} (${formattedPercent}%)`;
}

function formatVariantTitle(variant) {
  if (!variant) return '';
  const type = normalizeVariantType(variant.variant_type);
  const rsid = getVariantRsId(variant);
  if (type === 'snv') {
    const parts = [
      variant.gene,
      variant.hgvs_c,
      variant.genomic_position || formatVariantGenomicRange(variant),
      variant.hgvs_p,
      rsid
    ].filter(Boolean);
    if (parts.length) return parts.join(' · ');
  }
  const iscn = variant.iscn || variant.cytogenetic || '';
  const genomic = formatVariantGenomicRange(variant);
  const subtype = getStructureTypeLabel(variant.sv_subtype || variant.structural_type || variant.variant_subtype || '');
  const affectedGenes = variant.affected_genes || variant.genes || '';
  const gene = variant.gene || variant.region || '';
  const parts = [gene, iscn, genomic, subtype, affectedGenes, rsid];
  const seen = new Set();
  const uniqueParts = parts
    .map(part => (part == null ? '' : String(part).trim()))
    .filter(part => {
      if (!part) return false;
      const key = part.toLowerCase();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  if (uniqueParts.length) return uniqueParts.join(' · ');
  if (variant.description) return variant.description;
  return variant.gene || subtype || getVariantTypeLabel(type);
}

function truncateVariantTitleSegments(title, segments = 2) {
  const text = String(title ?? '');
  const normalized = text.trim();
  if (!normalized) return normalized;
  if (!Number.isFinite(segments) || segments <= 0) return normalized;
  const bullet = '·';
  let searchIndex = -1;
  for (let i = 0; i < segments; i++) {
    searchIndex = normalized.indexOf(bullet, searchIndex + 1);
    if (searchIndex === -1) {
      return normalized;
    }
  }
  return normalized.slice(0, searchIndex).trim();
}

function truncateConditionDisplay(condition) {
  const text = String(condition ?? '').trim();
  if (!text) return '';
  const firstLine = text
    .split(/\r?\n+/)
    .map(line => collapseSpaces(line))
    .find(Boolean);
  if (!firstLine) return '';
  const MAX_LENGTH = 20;
  const bulletParts = firstLine
    .split(/·+/)
    .map(part => collapseSpaces(part))
    .filter(Boolean);
  let candidate = bulletParts.length > 1 ? bulletParts[0] : (bulletParts[0] || firstLine);
  if (candidate === firstLine) {
    const semicolonParts = firstLine
      .split(/\s*[;|]\s*/)
      .map(part => collapseSpaces(part))
      .filter(Boolean);
    if (semicolonParts.length > 1) {
      candidate = semicolonParts[0];
    }
  }
  const normalized = collapseSpaces(candidate);
  if (normalized.length > MAX_LENGTH) {
    return normalized.slice(0, MAX_LENGTH - 1).trimEnd() + '…';
  }
  return normalized;
}

function truncateInheritanceDisplay(inheritance) {
  const text = String(inheritance ?? '').trim();
  if (!text) return '';
  const firstLine = text
    .split(/\r?\n+/)
    .map(line => collapseSpaces(line))
    .find(Boolean);
  if (!firstLine) return '';
  const MAX_LENGTH = 20;
  const normalized = collapseSpaces(firstLine);
  if (normalized.length > MAX_LENGTH) {
    return normalized.slice(0, MAX_LENGTH - 1).trimEnd() + '…';
  }
  return normalized;
}

function formatVariantDetailLines(variant) {
  if (!variant) return [];
  const type = normalizeVariantType(variant.variant_type);
  const details = [];
  if (type !== 'snv') {
    if (variant.gene) details.push(`Gen/region: ${variant.gene}`);
    const genomeBuild = variant.genome_build || '';
    const range = formatVariantGenomicRange(variant);
    if (genomeBuild || range) {
      const buildRange = [genomeBuild, range].filter(Boolean).join(' ');
      if (buildRange) details.push(`Genomisk position: ${buildRange}`);
    }
    const subtype = getStructureTypeLabel(variant.sv_subtype || variant.structural_type || variant.variant_subtype);
    if (subtype) details.push(`Type: ${subtype}`);
    const cn = formatVariantCopyNumber(variant);
    if (cn) details.push(cn);
    if (variant.size_bp) details.push(`Størrelse: ${variant.size_bp}`);
    if (variant.affected_genes) details.push(`Berørte gener: ${variant.affected_genes}`);
    if (variant.iscn) details.push(`ISCN: ${variant.iscn}`);
  } else {
    const range = formatVariantGenomicRange(variant);
    const genomeBuild = variant.genome_build || '';
    if (range) {
      const label = genomeBuild ? `${genomeBuild} ${range}` : range;
      details.push(`Genomisk position: ${label}`);
    }
  }
  if (variant.hgvs_c) details.push(`HGVS c.: ${variant.hgvs_c}`);
  if (variant.hgvs_p) details.push(`HGVS p.: ${variant.hgvs_p}`);
  const rsid = getVariantRsId(variant);
  if (rsid) details.push(`dbSNP: ${rsid}`);
  if (variant.transcript) details.push(`Transkript: ${variant.transcript}`);
  if (variant.zygosity) details.push(`Zygositet: ${variant.zygosity}`);
  if (variant.classification) details.push(`ACMG-klasse: ${variant.classification}`);
  if (variant.criteria) details.push(`Kriterier: ${variant.criteria}`);
  if (variant.af !== undefined && variant.af !== null && variant.af !== '') details.push(`AF: ${variant.af}`);
  if (variant.description) details.push(`Beskrivelse: ${variant.description}`);
  return details;
}

function openVariantLibraryPicker(onSelect) {
  const library = (getCached('variant_library') || []).slice();
  if (!library.length) {
    alert('Variantbiblioteket er tomt.');
    return;
  }
  const existing = document.querySelector('.variant-picker-overlay');
  if (existing) existing.remove();
  const sorted = library.sort((a, b) => {
    const titleA = formatVariantTitle(a) || '';
    const titleB = formatVariantTitle(b) || '';
    const compareTitle = titleA.localeCompare(titleB, 'da');
    if (compareTitle) return compareTitle;
    const compareType = normalizeVariantType(a.variant_type).localeCompare(normalizeVariantType(b.variant_type));
    if (compareType) return compareType;
    return (a.id || 0) - (b.id || 0);
  });
  const overlay = document.createElement('div');
  overlay.className = 'variant-picker-overlay';
  overlay.innerHTML = `
    <div class="variant-picker" role="dialog" aria-modal="true" aria-label="Vælg variant fra bibliotek">
      <header>
        <h3>Vælg variant fra bibliotek</h3>
        <button type="button" class="secondary" data-action="close">Luk</button>
      </header>
      <div class="picker-body">
        <label class="inline">Søg
          <input type="search" placeholder="Filtrer på variant, gen, ISCN eller HGVS">
        </label>
        <p class="form-hint">Klik på en variant for at kopiere oplysningerne til formularen.</p>
        <table>
          <thead>
            <tr><th>ID</th><th>Variant</th><th>Type</th><th>Genomisk position</th><th>Gen</th><th>HGVS c.</th><th>rsID</th><th>ISCN</th><th>Klasse</th><th>Kriterier</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>`;
  const previousOverflow = document.body.style.overflow;
  document.body.style.overflow = 'hidden';
  document.body.appendChild(overlay);
  const dialog = overlay.querySelector('.variant-picker');
  const searchInput = overlay.querySelector('input[type="search"]');
  const tbody = overlay.querySelector('tbody');
  const closeBtn = overlay.querySelector('[data-action="close"]');
  const cleanup = () => {
    document.body.style.overflow = previousOverflow;
    overlay.remove();
    document.removeEventListener('keydown', onKeyDown, true);
  };
  const onKeyDown = evt => {
    if (evt.key === 'Escape') {
      evt.preventDefault();
      cleanup();
    }
  };
  document.addEventListener('keydown', onKeyDown, true);
  const handleSelect = id => {
    const variant = sorted.find(item => item.id === id);
    if (!variant) return;
    const rsid = getVariantRsId(variant);
    const normalized = {...variant, variant_type: normalizeVariantType(variant.variant_type)};
    if (rsid) normalized.rsid = rsid;
    if (onSelect) onSelect(normalized);
    cleanup();
  };
  const renderRows = () => {
    const term = (searchInput?.value || '').trim().toLowerCase();
    const filtered = sorted.filter(item => {
      if (!term) return true;
      const rsid = getVariantRsId(item);
      return [
        item.gene,
        item.transcript,
        item.hgvs_c,
        item.hgvs_p,
        rsid,
        item.iscn,
        item.criteria,
        item.evidence,
        formatVariantTitle(item),
        formatVariantGenomicRange(item),
        getVariantTypeLabel(item.variant_type)
      ].some(value => (value || '').toLowerCase().includes(term));
    });
    if (!filtered.length) {
      tbody.innerHTML = '<tr><td colspan="10"><div class="variant-picker-empty">Ingen varianter matcher søgningen.</div></td></tr>';
      return;
    }
    tbody.innerHTML = filtered.map(item => {
      const title = formatVariantTitle(item);
      const typeLabel = getVariantTypeLabel(item.variant_type);
      const genomic = formatVariantGenomicRange(item);
      const rsid = getVariantRsId(item);
      return `
      <tr tabindex="0" data-id="${item.id}">
        <td>${esc(item.id)}</td>
        <td>${esc(title)}</td>
        <td>${esc(typeLabel)}</td>
        <td>${esc(genomic)}</td>
        <td>${esc(item.gene || '')}</td>
        <td>${esc(item.hgvs_c || '')}</td>
        <td>${formatRsIdCell(rsid)}</td>
        <td>${esc(item.iscn || '')}</td>
        <td>${esc(item.classification || '')}</td>
        <td>${esc(item.criteria || '')}</td>
      </tr>`;
    }).join('');
    annotateTableCells(dialog);
  };
  renderRows();
  annotateHeaders(dialog);
  applyButtonTooltips(dialog);
  overlay.addEventListener('click', evt => {
    if (evt.target === overlay) cleanup();
  });
  closeBtn?.addEventListener('click', cleanup);
  searchInput?.addEventListener('input', renderRows);
  tbody.addEventListener('click', evt => {
    const tr = evt.target.closest('tr[data-id]');
    if (!tr) return;
    handleSelect(Number(tr.dataset.id));
  });
  tbody.addEventListener('keydown', evt => {
    if (evt.key === 'Enter' || evt.key === ' ') {
      evt.preventDefault();
      const tr = evt.target.closest('tr[data-id]');
      if (tr) handleSelect(Number(tr.dataset.id));
    }
  });
  setTimeout(() => searchInput?.focus(), 50);
}
function initCollapsibleFieldsets(root) {
  if (!root) return;
  const toggleState = (fieldset, toggle, body, collapsed) => {
    const labelOpen = toggle.dataset.labelOpen || 'Minimér';
    const labelClosed = toggle.dataset.labelClosed || 'Udvid';
    fieldset.classList.toggle('collapsed', collapsed);
    if (collapsed) {
      fieldset.dataset.collapsed = 'true';
    } else {
      delete fieldset.dataset.collapsed;
    }
    toggle.setAttribute('aria-expanded', String(!collapsed));
    toggle.textContent = collapsed ? labelClosed : labelOpen;
    const title = fieldset.querySelector('.fieldset-title');
    const sectionName = title?.textContent?.trim();
    if (typeof setTooltip === 'function') {
      const tip = collapsed
        ? sectionName ? `Udvid sektionen “${sectionName}”` : 'Udvid denne sektion'
        : sectionName ? `Minimér sektionen “${sectionName}”` : 'Minimér denne sektion';
      setTooltip(toggle, tip);
    }
    if (body) {
      body.hidden = collapsed;
    }
  };
  root.querySelectorAll('fieldset[data-collapsible]').forEach((fieldset, index) => {
    if (fieldset.dataset.collapsibleInit) return;
    const toggle = fieldset.querySelector('.fieldset-toggle');
    if (!toggle) return;
    if (!fieldset.id) {
      fieldset.id = `collapsible-${Date.now()}-${index}`;
    }
    const body = fieldset.querySelector('.fieldset-body');
    if (body && !body.id) {
      body.id = `${fieldset.id}-body`;
    }
    const controlsId = body?.id || fieldset.id;
    toggle.setAttribute('aria-controls', controlsId);
    toggle.addEventListener('click', () => {
      const collapsed = !fieldset.classList.contains('collapsed');
      toggleState(fieldset, toggle, body, collapsed);
    });
    const defaultCollapsed = fieldset.dataset.collapsed === 'true';
    toggleState(fieldset, toggle, body, defaultCollapsed);
    fieldset.dataset.collapsibleInit = 'true';
  });
}
function initFamilyCombos(root) {
  if (!root) return;
  root.querySelectorAll('.family-combo').forEach(combo => {
    if (combo.dataset.familyInit) return;
    const select = combo.querySelector('[data-family-select]');
    const input = combo.querySelector('[data-family-input]');
    if (!select || !input) return;
    const syncSelect = () => {
      const value = input.value.trim();
      if (!value) {
        select.value = '';
        return;
      }
      const match = Array.from(select.options).find(opt => opt.value === value);
      select.value = match ? value : '__custom__';
    };
    select.addEventListener('change', () => {
      if (!select.value) {
        input.value = '';
      } else if (select.value !== '__custom__') {
        input.value = select.value;
      }
      if (select.value === '__custom__') {
        input.focus();
      } else {
        input.dispatchEvent(new Event('input', {bubbles: false}));
      }
    });
    input.addEventListener('input', () => syncSelect());
    combo.dataset.familyInit = 'true';
    const form = combo.closest('form');
    if (form && !form.dataset.familyResetInit) {
      form.addEventListener('reset', () => {
        setTimeout(() => {
          form.querySelectorAll('[data-family-input]').forEach(field => {
            field.dispatchEvent(new Event('input', {bubbles: false}));
          });
        }, 0);
      });
      form.dataset.familyResetInit = 'true';
    }
    syncSelect();
  });
}
function hasWriteRole(user) {
  if (!user) return false;
  const role = normaliseRoleValue(user.role).toLowerCase();
  if (WRITE_ROLE_KEYS.has(role)) return true;
  return ['admin', 'skriver', 'redakt', 'editor', 'bio', 'write', 'leder'].some(key => role.includes(key));
}
function currentCanWrite() {
  if (state.currentUser?.internal) return true;
  return hasWriteRole(state.currentUser);
}
function ensureWrite(storeName) {
  if (state.currentUser?.internal) return true;
  if (storeName === 'users') {
    const existing = state.cache.get('users');
    if (!existing || existing.length === 0) {
      return true;
    }
  }
  if (currentCanWrite()) return true;
  alert('Handling kræver skriveadgang. Log ind med en bruger der har rollen "Administrator" eller "Skriver".');
  return false;
}
function updateWriteBanner() {
  const hasWrite = currentCanWrite();
  let banner = document.getElementById('writeLockBanner');
  if (!hasWrite) {
    if (!banner) {
      banner = document.createElement('div');
      banner.id = 'writeLockBanner';
      banner.className = 'read-only-banner';
      banner.textContent = 'Skriveadgang er låst. Log ind med skrivetilladelse for at redigere eller oprette data.';
      const main = document.getElementById('tabContent');
      if (main) {
        main.prepend(banner);
      }
    }
  } else if (banner) {
    banner.remove();
  }
}
function refreshLoginOptions() {
  const select = document.getElementById('loginUser');
  if (!select) return;
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const currentId = state.currentUser?.id ? String(state.currentUser.id) : '';
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = users.length ? 'Vælg bruger' : 'Opret en bruger for at logge ind';
  placeholder.disabled = true;
  select.appendChild(placeholder);
  users.forEach(user => {
    const opt = document.createElement('option');
    opt.value = String(user.id);
    opt.textContent = `${user.name} (${roleWithDescription(user.role) || 'rolle ukendt'})`;
    select.appendChild(opt);
  });
  if (currentId) {
    select.value = currentId;
    placeholder.selected = false;
  } else {
    placeholder.selected = true;
  }
}
function updateAuthUi() {
  const form = document.getElementById('loginForm');
  const info = document.getElementById('userInfo');
  const label = document.getElementById('currentUserLabel');
  const select = document.getElementById('loginUser');
  if (!form || !info || !label || !select) return;
  const user = state.currentUser;
  if (user) {
    form.style.display = 'none';
    info.hidden = false;
    label.textContent = `${user.name} – ${roleWithDescription(user.role) || 'rolle ukendt'}`;
  } else {
    info.hidden = true;
    form.style.display = '';
    form.reset();
    refreshLoginOptions();
  }
  updateWriteBanner();
}
function applyTheme() {
  if (!['light', 'dark'].includes(state.theme)) {
    state.theme = 'light';
  }
  document.documentElement.dataset.theme = state.theme;
  storage.setItem('glimr-theme', state.theme);
  const btn = document.getElementById('themeToggle');
  if (btn) {
    const toDark = state.theme !== 'dark';
    const label = btn.querySelector('span:not(.icon-slot)');
    if (label) {
      label.textContent = toDark ? 'Skift til mørkt tema' : 'Skift til lyst tema';
    } else {
      btn.textContent = toDark ? 'Skift til mørkt tema' : 'Skift til lyst tema';
    }
    const iconSlot = btn.querySelector('.icon-slot');
    if (iconSlot) {
      setIcon(iconSlot, toDark ? 'moon' : 'sun');
    }
    setTooltip(btn, tooltipCatalog.buttons.themeToggle);
  }
}
function toggleTheme() {
  state.theme = state.theme === 'dark' ? 'light' : 'dark';
  applyTheme();
}
function restoreUserSession() {
  const storedId = storage.getItem('glimr-user-id');
  if (storedId) {
    const user = findById('users', Number(storedId));
    if (user) {
      state.currentUser = {...user};
    } else {
      state.currentUser = null;
      storage.removeItem('glimr-user-id');
    }
  } else if (!state.currentUser || !state.currentUser.internal) {
    state.currentUser = null;
  }
  refreshLoginOptions();
  updateAuthUi();
}
function logoutUser() {
  state.currentUser = null;
  storage.removeItem('glimr-user-id');
  updateAuthUi();
  setStatus('Logget ud. Systemet er skrivebeskyttet.');
  const dashboardSection = document.querySelector('section[data-tab="dashboard"]');
  if (dashboardSection) renderDashboard(dashboardSection);
}
function handleLogin(event) {
  event.preventDefault();
  const select = document.getElementById('loginUser');
  const pass = document.getElementById('loginPass');
  if (!select || !pass) return;
  const id = Number(select.value);
  if (!id) {
    alert('Vælg en bruger for at logge ind.');
    return;
  }
  const user = findById('users', id);
  if (!user) {
    alert('Brugeren findes ikke længere.');
    refreshLoginOptions();
    return;
  }
  const pin = pass.value.trim();
  if (user.pin && user.pin !== pin) {
    alert('Forkert adgangskode.');
    return;
  }
  state.currentUser = {...user};
  storage.setItem('glimr-user-id', String(user.id));
  pass.value = '';
  updateAuthUi();
  setStatus(`Logget ind som ${user.name}.`);
  const dashboardSection = document.querySelector('section[data-tab="dashboard"]');
  if (dashboardSection) renderDashboard(dashboardSection);
}
function esc(str) {
  return String(str ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}

function collapseSpaces(value) {
  return String(value ?? '').replace(/\s+/g, ' ').trim();
}

function formatMultilineCell(value) {
  const text = String(value ?? '').trim();
  if (!text) return '';
  return esc(text).replace(/\n/g, '<br>');
}

function splitHpoInput(value) {
  const raw = String(value ?? '');
  if (!raw.trim()) return [];
  const hasPreferredDelimiter = /[\n;]/.test(raw);
  const parts = hasPreferredDelimiter ? raw.split(/[\n;]+/) : raw.split(/,+/);
  return parts.map(part => collapseSpaces(part)).filter(Boolean);
}

function normalizeHpoTerms(value) {
  const seen = new Set();
  const terms = [];
  for (const term of splitHpoInput(value)) {
    const key = term.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    terms.push(term);
  }
  return terms.join('\n');
}

function parseHpoTerms(value) {
  const normalized = normalizeHpoTerms(value);
  if (!normalized) return [];
  return normalized.split('\n');
}

function formatHpoList(value, separator = ', ') {
  return parseHpoTerms(value).join(separator);
}

function formatHpoHtml(value) {
  const terms = parseHpoTerms(value);
  if (!terms.length) return '';
  return terms.map(term => esc(term)).join('<br>');
}

function formatIndicationForList(value) {
  return collapseSpaces(value);
}

const PRIORITY_ICON_PATH = '<path fill="currentColor" d="M12 3.172 2.322 20.5h19.356L12 3.172zm1 13.828h-2v2h2v-2zm0-8h-2v6h2v-6z"></path>';

function renderOrderPriorityIcon(label, modifierClass) {
  return `<span class="priority-indicator ${modifierClass}" role="img" aria-label="${label}"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">${PRIORITY_ICON_PATH}</svg></span>`;
}

function setupExclusivePriorityControls(primary, secondary, {preferPrimary = true} = {}) {
  if (!primary || !secondary) {
    return () => {};
  }
  const enforce = () => {
    if (primary.checked && secondary.checked) {
      if (preferPrimary) {
        secondary.checked = false;
      } else {
        primary.checked = false;
      }
    }
  };
  primary.addEventListener('change', () => {
    if (primary.checked) {
      secondary.checked = false;
    }
  });
  secondary.addEventListener('change', () => {
    if (secondary.checked) {
      primary.checked = false;
    }
  });
  enforce();
  return enforce;
}

function renderOrderPriorityIcons(order) {
  if (!order) return '';
  if (order.acute) return renderOrderPriorityIcon('Akut', 'acute-indicator');
  if (order.urgent) return renderOrderPriorityIcon('Haster', 'urgent-indicator');
  return '';
}

function orderPriorityAttributes(order) {
  if (!order) return '';
  if (order.acute) return ' data-acute="true"';
  if (order.urgent) return ' data-urgent="true"';
  return '';
}

function truncateForListDisplay(value, maxLength = 120) {
  const text = collapseSpaces(value);
  if (!text) return '';
  if (text.length <= maxLength) return text;
  const ellipsis = '...';
  if (maxLength <= ellipsis.length) return ellipsis;
  const cut = maxLength - ellipsis.length;
  let truncated = text.slice(0, cut).trimEnd();
  truncated = truncated.replace(/[,;:.]$/, '');
  if (!truncated) return ellipsis;
  return truncated + ellipsis;
}
function setStatus(msg) {
  state.lastStatus = msg;
  const bar = document.getElementById('statusBar');
  if (!bar) return;
  bar.textContent = msg;
  setTooltip(bar, msg);
}
window.addEventListener('error', event => {
  if (!event) return;
  const hasDetails = Boolean(event.message) || Boolean(event.error && event.error.message);
  if (!hasDetails) return;
  const detail = event.message || (event.error && event.error.message) || 'Ukendt fejl';
  console.error('Ubehandlet fejl i GlimR:', event.error || detail, event);
  setStatus('Fejl: ' + detail);
});
window.addEventListener('unhandledrejection', event => {
  if (!event) return;
  const reason = event.reason;
  const detail = reason && (reason.message || String(reason)) || 'Ukendt asynkron fejl';
  console.error('Ubehandlet promise-fejl i GlimR:', reason || event);
  setStatus('Fejl: ' + detail);
});
function currentUserName() {
  return state.currentUser?.name || 'System';
}
function ensureTabContainers() {
  let nav = document.getElementById('tabNav');
  let main = document.getElementById('tabContent');
  if (!nav) {
    nav = document.createElement('nav');
    nav.id = 'tabNav';
    const header = document.querySelector('header');
    if (header && header.parentNode) {
      header.parentNode.insertBefore(nav, header.nextSibling);
    } else if (document.body.firstChild) {
      document.body.insertBefore(nav, document.body.firstChild);
    } else {
      document.body.appendChild(nav);
    }
  }
  if (!main) {
    main = document.createElement('main');
    main.id = 'tabContent';
    document.body.appendChild(main);
  }
  return {nav, main};
}
function initTabs() {
  const {nav, main} = ensureTabContainers();
  if (!nav || !main) {
    console.error('Kunne ikke initialisere tabvisning: mangler containere.');
    setStatus('Fejl: Tabvisning kunne ikke initialiseres.');
    return;
  }
  nav.innerHTML = '';
  main.innerHTML = '';
  tabs.forEach(tab => {
    const btn = document.createElement('button');
    const iconName = tabIcons[tab.id];
    if (iconName) {
      btn.classList.add('with-icon');
      const iconSlot = document.createElement('span');
      iconSlot.className = 'icon-slot';
      iconSlot.dataset.icon = iconName;
      btn.appendChild(iconSlot);
      setIcon(iconSlot, iconName);
      const span = document.createElement('span');
      span.textContent = tab.label;
      btn.appendChild(span);
    } else {
      btn.textContent = tab.label;
    }
    btn.dataset.tab = tab.id;
    setTooltip(btn, tooltipCatalog.tabs[tab.id]);
    btn.addEventListener('click', () => activateTab(tab.id));
    nav.appendChild(btn);
    const section = document.createElement('section');
    section.dataset.tab = tab.id;
    main.appendChild(section);
  });
}
async function activateTab(id) {
  const previousTab = state.currentTab;
  if (previousTab === 'planner' && typeof state.flushPlannerChanges === 'function') {
    try {
      await state.flushPlannerChanges({reason: 'tab-change'});
    } catch (err) {
      console.warn('Kunne ikke gemme arbejdsplan før faneskift:', err);
    }
  }
  state.currentTab = id;
  document.querySelectorAll('nav button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === id);
  });
  document.querySelectorAll('section[data-tab]').forEach(sec => {
    sec.classList.toggle('active', sec.dataset.tab === id);
  });
  if (state.boundHandle) {
    try {
      await reloadBoundFileData({silent: true, refreshUi: false});
    } catch (err) {
      console.warn('Kunne ikke genindlæse data ved navigation', err);
    }
  }
  renderTab(id);
}

function openOrderDetails(orderId, options = {}) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId)) return;
  const showAll = Boolean(options.showAll);
  const applyFilter = options.filter !== false;
  state.pendingOrderId = numericId;
  state.pendingOrderShowAll = showAll;
  if (applyFilter) {
    state.pendingOrderFilterId = numericId;
    state.pendingOrderFilterSampleId = null;
    state.pendingOrderFilterSampleExact = false;
  }
  activateTab('orders');
}
function openSamplesForOrder(orderId) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId)) return;
  const order = findById('orders', numericId);
  const sampleId = order?.sample_id != null ? Number(order.sample_id) : null;
  state.pendingSampleId = Number.isFinite(sampleId) ? sampleId : null;
  state.pendingSampleShowAll = true;
  activateTab('samples');
}
function openReportsForOrder(orderId) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId)) return;
  state.pendingReportFilterOrderId = numericId;
  state.pendingReportFilterOrderExact = true;
  state.pendingReportFilterSampleId = null;
  state.pendingReportFilterSampleExact = false;
  state.pendingReportSelectOrderId = numericId;
  state.pendingReportSelectReportId = null;
  state.pendingReportShowAll = true;
  activateTab('reports');
}

function openOrdersForSample(sampleId) {
  const numericId = Number(sampleId);
  if (!Number.isFinite(numericId)) return;
  const orders = getCached('orders') || [];
  const matching = orders.filter(o => Number(o.sample_id) === numericId);
  matching.sort((a, b) => {
    const timeA = (a.ordered_at || a.updated_at || a.created_at || '');
    const timeB = (b.ordered_at || b.updated_at || b.created_at || '');
    return timeB.localeCompare(timeA);
  });
  const first = matching[0] || null;
  const selectedId = first ? Number(first.id) : null;
  state.pendingOrderFilterSampleId = numericId;
  state.pendingOrderFilterSampleExact = true;
  state.pendingOrderFilterId = null;
  state.pendingOrderId = Number.isFinite(selectedId) ? selectedId : null;
  state.pendingOrderShowAll = true;
  activateTab('orders');
}

function openReportsForSample(sampleId) {
  const numericId = Number(sampleId);
  if (!Number.isFinite(numericId)) return;
  const orders = getCached('orders') || [];
  const reports = getCached('reports') || [];
  const orderIds = new Set(orders.filter(o => Number(o.sample_id) === numericId).map(o => Number(o.id)));
  const matchingReports = reports.filter(r => orderIds.has(Number(r.order_id)));
  matchingReports.sort((a, b) => {
    const timeA = (a.issued_at || a.updated_at || a.created_at || '');
    const timeB = (b.issued_at || b.updated_at || b.created_at || '');
    return timeB.localeCompare(timeA);
  });
  const firstReport = matchingReports[0] || null;
  const firstReportId = firstReport ? Number(firstReport.id) : null;
  const firstOrderId = firstReport ? Number(firstReport.order_id) : (orderIds.size === 1 ? Array.from(orderIds)[0] : null);
  state.pendingReportFilterSampleId = numericId;
  state.pendingReportFilterSampleExact = true;
  state.pendingReportFilterOrderExact = false;
  state.pendingReportFilterOrderId = null;
  state.pendingReportSelectOrderId = Number.isFinite(firstOrderId) ? firstOrderId : null;
  state.pendingReportSelectReportId = Number.isFinite(firstReportId) ? firstReportId : null;
  state.pendingReportShowAll = true;
  activateTab('reports');
}

function openOrdersForReport(reportId) {
  const numericId = Number(reportId);
  if (!Number.isFinite(numericId)) return;
  const report = findById('reports', numericId);
  const orderId = report?.order_id != null ? Number(report.order_id) : null;
  if (!Number.isFinite(orderId)) return;
  state.pendingOrderFilterId = orderId;
  state.pendingOrderFilterSampleId = null;
  state.pendingOrderId = orderId;
  state.pendingOrderShowAll = true;
  activateTab('orders');
}

function openSamplesForReport(reportId) {
  const numericId = Number(reportId);
  if (!Number.isFinite(numericId)) return;
  const report = findById('reports', numericId);
  if (!report) return;
  const orderId = report.order_id != null ? Number(report.order_id) : null;
  const order = Number.isFinite(orderId) ? findById('orders', orderId) : null;
  const sampleId = order?.sample_id != null ? Number(order.sample_id) : null;
  if (!Number.isFinite(sampleId)) return;
  state.pendingSampleId = sampleId;
  state.pendingSampleShowAll = true;
  activateTab('samples');
}

function openPatientsForVariant(variant) {
  if (!variant) return;
  const key = createVariantComparisonKey(variant);
  if (!key) {
    alert('Varianten mangler tilstrækkelige oplysninger til at filtrere patienter.');
    return;
  }
  const fallbackLabel = variant.id != null ? `Variant ${variant.id}` : 'den valgte variant';
  const label = (formatVariantTitle(variant) || fallbackLabel).trim() || fallbackLabel;
  const patientIds = getPatientIdsForVariantKey(key);
  state.pendingPatientVariantFilter = {key, label, patientIds};
  activateTab('patients');
  setStatus(`Viser patienter for ${label}.`);
}
function openMemoryDb(fallbackError) {
  if (fallbackError) {
    console.warn('IndexedDB utilgængelig, bruger midlertidig hukommelse.', fallbackError);
  } else {
    console.warn('IndexedDB utilgængelig, bruger midlertidig hukommelse.');
  }
  state.usingMemoryDb = true;
  const snapshot = readMemoryDbSnapshot();
  return createMemoryDb(snapshot || {});
}

async function openDb() {
  try {
    const db = await openIndexedDb();
    state.usingMemoryDb = false;
    return db;
  } catch (err) {
    return openMemoryDb(err);
  }
}

function openIndexedDb() {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) {
      reject(new Error('Browseren understøtter ikke IndexedDB. GlimR kræver lokal databaseadgang.'));
      return;
    }
    const req = indexedDB.open(DB_NAME, DB_VER);
    let settled = false;
    const finish = (action) => {
      if (settled) return;
      settled = true;
      if (action) action();
    };
    req.onupgradeneeded = event => {
      setStatus('Opgraderer lokal database...');
      const db = event.target.result;
      const ensureStore = (name, options) => {
        if (!db.objectStoreNames.contains(name)) {
          const store = db.createObjectStore(name, options);
          return store;
        }
        return event.target.transaction.objectStore(name);
      };
      const withTimestamps = store => {
        ['created_at','updated_at'].forEach(field => {
          if (!store.indexNames.contains(field)) {
            try { store.createIndex(field, field); } catch (e) {}
          }
        });
        return store;
      };
      withTimestamps(ensureStore('patients', {keyPath:'id', autoIncrement:true}));
      const samplesStore = withTimestamps(ensureStore('samples',{keyPath:'id',autoIncrement:true}));
      if (!samplesStore.indexNames.contains('pmb_number')) {
        try { samplesStore.createIndex('pmb_number','pmb_number',{unique:true}); } catch (e) {}
      }
      if (!samplesStore.indexNames.contains('patient_id')) samplesStore.createIndex('patient_id','patient_id');
      const ordersStore = withTimestamps(ensureStore('orders',{keyPath:'id',autoIncrement:true}));
      ['patient_id','sample_id','panel_id','analysis_responsible_id','interpreter_id','approver_id','patient_group_id'].forEach(idx => {
        if (!ordersStore.indexNames.contains(idx)) ordersStore.createIndex(idx, idx);
      });
      withTimestamps(ensureStore('patient_groups',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('panels',{keyPath:'id',autoIncrement:true}));
      const variantsStore = withTimestamps(ensureStore('variants',{keyPath:'id',autoIncrement:true}));
      if (!variantsStore.indexNames.contains('order_id')) variantsStore.createIndex('order_id','order_id');
      const qcStore = withTimestamps(ensureStore('qc',{keyPath:'id',autoIncrement:true}));
      if (!qcStore.indexNames.contains('sample_id')) qcStore.createIndex('sample_id','sample_id');
      const qcPresetStore = withTimestamps(ensureStore('qc_presets',{keyPath:'id',autoIncrement:true}));
      if (!qcPresetStore.indexNames.contains('kind')) {
        try { qcPresetStore.createIndex('kind','kind',{unique:false}); } catch (e) {}
      }
      const reportsStore = withTimestamps(ensureStore('reports',{keyPath:'id',autoIncrement:true}));
      if (!reportsStore.indexNames.contains('order_id')) reportsStore.createIndex('order_id','order_id');
      withTimestamps(ensureStore('users',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('audit',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('variant_library',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('responses',{keyPath:'id',autoIncrement:true}));
      const fhirTemplateStore = withTimestamps(ensureStore('fhir_templates',{keyPath:'id',autoIncrement:true}));
      ['target_system','name'].forEach(idx => {
        if (!fhirTemplateStore.indexNames.contains(idx)) {
          try { fhirTemplateStore.createIndex(idx, idx); } catch (e) {}
        }
      });
      withTimestamps(ensureStore('conclusion_library',{keyPath:'id',autoIncrement:true}));
      const plannerStore = withTimestamps(ensureStore('planner',{keyPath:'id'}));
      if (!plannerStore.indexNames.contains('user_id')) {
        try { plannerStore.createIndex('user_id','user_id',{unique:true}); } catch (e) {}
      }
      ensureStore(SETTINGS_STORE, {keyPath:'key'});
    };
    req.onblocked = () => {
      finish(() => {
        console.warn('Databaseopgradering blokeret af en anden åben GlimR-fane.');
        reject(new Error('Kan ikke opgradere databasen fordi en anden GlimR-fane stadig er åben. Luk andre faner og prøv igen.'));
      });
    };
    req.onerror = () => {
      finish(() => reject(req.error || new Error('Ukendt IndexedDB-fejl.')));
    };
    req.onsuccess = () => {
      if (settled) {
        try { req.result?.close(); } catch (err) { console.warn('Kunne ikke lukke overflødig databaseforbindelse:', err); }
        return;
      }
      finish(() => {
        const db = req.result;
        if (db) {
          db.onversionchange = () => {
            console.warn('Databaseversion ændres, lukker eksisterende forbindelse.');
            try { db.close(); } catch (err) { console.warn('Kunne ikke lukke database:', err); }
            setStatus('Databaseversion ændret. Genindlæs GlimR for at fortsætte.');
          };
        }
        resolve(db);
      });
    };
  });
}
function requestToPromise(req) {
  if (!req) {
    return Promise.resolve(undefined);
  }
  if (typeof req.then === 'function') {
    return req;
  }
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function transactionToPromise(tx) {
  if (!tx) {
    return Promise.resolve();
  }
  if (tx.done && typeof tx.done.then === 'function') {
    return tx.done;
  }
  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
    tx.onabort = () => reject(tx.error);
  });
}

async function setSetting(key, value) {
  if (!state.db) return;
  try {
    const tx = state.db.transaction(SETTINGS_STORE, 'readwrite');
    tx.objectStore(SETTINGS_STORE).put({key, value});
    await transactionToPromise(tx);
  } catch (err) {
    console.warn('Kunne ikke gemme indstilling', key, err);
    throw err;
  }
}

async function getSetting(key) {
  if (!state.db) return undefined;
  try {
    const tx = state.db.transaction(SETTINGS_STORE, 'readonly');
    const store = tx.objectStore(SETTINGS_STORE);
    const req = store.get(key);
    const result = await requestToPromise(req);
    await transactionToPromise(tx).catch(() => {});
    return result?.value;
  } catch (err) {
    console.warn('Kunne ikke læse indstilling', key, err);
    return undefined;
  }
}

async function deleteSetting(key) {
  if (!state.db) return;
  try {
    const tx = state.db.transaction(SETTINGS_STORE, 'readwrite');
    tx.objectStore(SETTINGS_STORE).delete(key);
    await transactionToPromise(tx);
  } catch (err) {
    console.warn('Kunne ikke slette indstilling', key, err);
  }
}

async function persistBoundHandle(handle) {
  state.boundHandle = handle;
  if (handle && handle.name) {
    storage.setItem(BOUND_HANDLE_NAME_KEY, handle.name);
  } else if (typeof storage.removeItem === 'function') {
    storage.removeItem(BOUND_HANDLE_NAME_KEY);
  }
  try {
    await setSetting(BOUND_HANDLE_SETTING_KEY, handle ?? null);
  } catch (err) {
    console.warn('Kunne ikke gemme filbinding', err);
    setStatus('Fil tilknyttet, men browseren kan ikke huske forbindelsen automatisk.');
  }
  renderDbTab();
}

async function clearBoundHandle() {
  state.boundHandle = null;
  if (typeof storage.removeItem === 'function') {
    storage.removeItem(BOUND_HANDLE_NAME_KEY);
  }
  try {
    await deleteSetting(BOUND_HANDLE_SETTING_KEY);
  } catch (err) {
    console.warn('Kunne ikke rydde filbinding', err);
  }
  renderDbTab();
  await captureSyncedSnapshot();
}

async function restoreBoundHandle() {
  if (!state.db) return;
  try {
    const handle = await getSetting(BOUND_HANDLE_SETTING_KEY);
    if (handle) {
      state.boundHandle = handle;
    } else {
      const remembered = storage.getItem(BOUND_HANDLE_NAME_KEY);
      if (remembered) {
        setStatus(`Filbinding kræver ny godkendelse: ${remembered}`);
      }
    }
  } catch (err) {
    console.warn('Kunne ikke gendanne filbinding', err);
  }
}

async function ensureBoundHandlePermission(interactive = false) {
  if (!state.boundHandle || typeof state.boundHandle.queryPermission !== 'function') {
    return Boolean(state.boundHandle);
  }
  try {
    let status = await state.boundHandle.queryPermission({mode: 'readwrite'});
    if (status === 'granted') return true;
    if (status === 'prompt' && interactive && typeof state.boundHandle.requestPermission === 'function') {
      status = await state.boundHandle.requestPermission({mode: 'readwrite'});
      return status === 'granted';
    }
    return status === 'granted';
  } catch (err) {
    console.warn('Tilladelsestjek for fil mislykkedes', err);
    return false;
  }
}
async function loadStore(name) {
  const tx = state.db.transaction(name, 'readonly');
  const store = tx.objectStore(name);
  const req = store.getAll();
  const rows = await requestToPromise(req);
  state.cache.set(name, rows);
  if (name === 'orders') {
    clearOrderDisplayNameCache();
  }
  if (name === 'audit') {
    rebuildCreationLookup();
  }
  return rows;
}
async function loadAllStores() {
  for (const name of STORES) {
    await loadStore(name);
  }
  rebuildCreationLookup();
}
function getCached(name) {
  return state.cache.get(name) ?? [];
}
function findById(store, id) {
  return getCached(store).find(item => item.id === id);
}

function getLatestFamilyNumber() {
  let bestFamily = '';
  let bestTime = null;
  let bestId = null;
  for (const patient of getCached('patients')) {
    if (!patient) continue;
    const family = (patient.family_number || '').trim();
    if (!family) continue;
    const parsedTime = Date.parse(patient.created_at);
    const time = Number.isFinite(parsedTime) ? parsedTime : null;
    const numericId = Number(patient.id);
    const id = Number.isFinite(numericId) ? numericId : null;
    if (!bestFamily) {
      bestFamily = family;
      bestTime = time;
      bestId = id;
      continue;
    }
    if (time != null) {
      if (bestTime == null || time > bestTime) {
        bestFamily = family;
        bestTime = time;
        bestId = id;
        continue;
      }
      if (bestTime != null && time === bestTime) {
        const candidateId = id ?? -Infinity;
        const currentId = bestId ?? -Infinity;
        if (candidateId > currentId) {
          bestFamily = family;
          bestTime = time;
          bestId = id;
          continue;
        }
        if (candidateId === currentId && family.localeCompare(bestFamily, 'da') > 0) {
          bestFamily = family;
          bestTime = time;
          bestId = id;
        }
      }
      continue;
    }
    if (bestTime != null) {
      continue;
    }
    const candidateId = id ?? -Infinity;
    const currentId = bestId ?? -Infinity;
    if (candidateId > currentId) {
      bestFamily = family;
      bestTime = time;
      bestId = id;
      continue;
    }
    if (candidateId === currentId && family.localeCompare(bestFamily, 'da') > 0) {
      bestFamily = family;
      bestTime = time;
      bestId = id;
    }
  }
  return bestFamily;
}

function getFamilyNumberPlaceholder() {
  const latest = getLatestFamilyNumber().trim();
  if (latest) {
    return latest.startsWith('Fx') ? latest : `Fx ${latest}`;
  }
  return 'Fx FAM-001';
}

const orderDisplayNameCache = new Map();
function clearOrderDisplayNameCache() {
  orderDisplayNameCache.clear();
}
function getOrderDisplayName(orderId) {
  const numericId = Number(orderId);
  if (!Number.isFinite(numericId) || numericId === 0) return '';
  if (orderDisplayNameCache.has(numericId)) {
    return orderDisplayNameCache.get(numericId);
  }
  const order = findById('orders', numericId);
  let display = '';
  if (order) {
    for (const key of ['name', 'title', 'display_name', 'displayName', 'label']) {
      const value = order?.[key];
      if (typeof value === 'string' && value.trim()) {
        display = value.trim();
        break;
      }
    }
    if (!display) {
      const patientId = Number(order.patient_id);
      const panelId = Number(order.panel_id);
      const sampleId = Number(order.sample_id);
      const patientName = Number.isFinite(patientId) && patientId > 0 ? getName('patients', patientId) : '';
      const panel = Number.isFinite(panelId) && panelId > 0 ? findById('panels', panelId) : null;
      const sample = Number.isFinite(sampleId) && sampleId > 0 ? findById('samples', sampleId) : null;
      const sampleLabel = sample?.pmb_number || '';
      const parts = [patientName, sampleLabel, panel?.name].filter(part => part && String(part).trim());
      if (parts.length) {
        display = parts.join(' • ');
      } else if (order.id != null) {
        display = `Ordination #${order.id}`;
      }
    }
  }
  if (!display && Number.isFinite(numericId)) {
    display = `Ordination #${numericId}`;
  }
  orderDisplayNameCache.set(numericId, display);
  return display;
}
async function addRecord(store, record) {
  const now = new Date().toISOString();
  if (CREATED_BY_STORES.has(store) && !record.created_by) {
    record.created_by = currentUserName();
  }
  if (UPDATED_BY_STORES.has(store)) {
    record.updated_by = currentUserName();
  }
  record.created_at = now;
  record.updated_at = now;
  const tx = state.db.transaction(store, 'readwrite');
  const req = tx.objectStore(store).add(record);
  const id = await requestToPromise(req);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('CREATE', store, id, null, record);
  scheduleAutosave();
  return id;
}
async function updateRecord(store, record, before) {
  record.updated_at = new Date().toISOString();
  if (UPDATED_BY_STORES.has(store)) {
    record.updated_by = currentUserName();
  }
  const tx = state.db.transaction(store, 'readwrite');
  tx.objectStore(store).put(record);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('UPDATE', store, record.id, before, record);
  scheduleAutosave();
}
async function deleteRecord(store, id) {
  const existing = findById(store, id);
  if (!existing) return;
  const tx = state.db.transaction(store, 'readwrite');
  tx.objectStore(store).delete(id);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('DELETE', store, id, existing, null);
  scheduleAutosave();
}
async function logAudit(action, entity, entityId, before, after) {
  const entry = {
    ts: new Date().toISOString(),
    user: currentUserName(),
    action,
    entity,
    entity_id: entityId ?? null,
    before: before ? JSON.stringify(before) : null,
    after: after ? JSON.stringify(after) : null
  };
  const tx = state.db.transaction('audit','readwrite');
  tx.objectStore('audit').add({...entry, created_at:new Date().toISOString(), updated_at:new Date().toISOString()});
  await tx.done?.catch(() => {});
  await loadStore('audit');
}

function registerManualExport(entity, details = {}) {
  try {
    const exportEntity = entity || 'export';
    const payload = details && typeof details === 'object' ? {...details} : {value: details};
    logAudit('EXPORT', exportEntity, null, null, payload).catch(err => console.warn('Kunne ikke logge eksport', err));
  } catch (err) {
    console.warn('Kunne ikke registrere manuel eksport', err);
  }
}
function scheduleAutosave() {
  if (!state.autosave || !state.boundHandle) return;
  if (state.autosaveTimer) clearTimeout(state.autosaveTimer);
  state.autosaveTimer = setTimeout(() => {
    state.autosaveTimer = null;
    saveBoundFile({reason: 'auto'}).catch(err => console.error(err));
  }, 1200);
}
async function exportData() {
  const data = {};
  for (const store of STORES) {
    data[store] = cloneWithCreatedBy(store, getCached(store));
  }
  return data;
}

function summarizeStoreCounts(data) {
  if (!data || typeof data !== 'object') return {};
  const counts = {};
  for (const [key, value] of Object.entries(data)) {
    if (Array.isArray(value)) {
      counts[key] = value.length;
    } else if (value && typeof value === 'object' && typeof value.length === 'number') {
      counts[key] = Number.isFinite(value.length) ? value.length : 0;
    } else if (value && typeof value === 'object') {
      counts[key] = Object.keys(value).length;
    } else if (value != null) {
      counts[key] = 1;
    } else {
      counts[key] = 0;
    }
  }
  return counts;
}

function deepClone(value) {
  if (value === null || typeof value !== 'object') {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(item => deepClone(item));
  }
  const clone = {};
  for (const key of Object.keys(value)) {
    clone[key] = deepClone(value[key]);
  }
  return clone;
}

function normaliseForComparison(value) {
  if (value === null || typeof value !== 'object') {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(item => normaliseForComparison(item));
  }
  const result = {};
  const keys = Object.keys(value).sort();
  for (const key of keys) {
    result[key] = normaliseForComparison(value[key]);
  }
  return result;
}

function recordsEqual(a, b) {
  if (a === b) return true;
  if (!a || !b) return false;
  return JSON.stringify(normaliseForComparison(a)) === JSON.stringify(normaliseForComparison(b));
}

function mapRecordsById(list) {
  const map = new Map();
  if (!Array.isArray(list)) return map;
  for (const item of list) {
    if (!item || typeof item !== 'object') continue;
    const id = item.id;
    if (id === undefined || id === null) continue;
    map.set(String(id), item);
  }
  return map;
}

function computeLocalChanges(previousData, currentData) {
  const changes = {
    upserts: new Map(),
    deletions: new Map(),
    hasChanges: false
  };
  const previous = previousData && typeof previousData === 'object' ? previousData : {};
  const current = currentData && typeof currentData === 'object' ? currentData : {};
  for (const store of STORES) {
    const prevList = Array.isArray(previous[store]) ? previous[store] : [];
    const currList = Array.isArray(current[store]) ? current[store] : [];
    const prevMap = mapRecordsById(prevList);
    const currMap = mapRecordsById(currList);
    const storeUpserts = [];
    const storeDeletes = [];
    for (const [id, record] of currMap.entries()) {
      const prevRecord = prevMap.get(id);
      if (!prevRecord) {
        storeUpserts.push({record, previous: null});
        continue;
      }
      if (!recordsEqual(prevRecord, record)) {
        storeUpserts.push({record, previous: prevRecord});
      }
    }
    for (const [id, prevRecord] of prevMap.entries()) {
      if (!currMap.has(id)) {
        storeDeletes.push({id, previous: prevRecord});
      }
    }
    if (storeUpserts.length) {
      changes.upserts.set(store, storeUpserts);
      changes.hasChanges = true;
    }
    if (storeDeletes.length) {
      changes.deletions.set(store, storeDeletes);
      changes.hasChanges = true;
    }
  }
  return changes;
}

function toTimestamp(record) {
  if (!record || typeof record !== 'object') return null;
  const candidates = ['updated_at', 'updatedAt', 'ts', 'timestamp'];
  for (const key of candidates) {
    const value = record[key];
    if (!value) continue;
    const parsed = Date.parse(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return null;
}

function shouldApplyLocalChange(localRecord, remoteRecord, previousRecord) {
  if (!remoteRecord) return true;
  const localTs = toTimestamp(localRecord);
  const remoteTs = toTimestamp(remoteRecord);
  if (localTs == null && remoteTs == null) {
    return !recordsEqual(remoteRecord, localRecord);
  }
  if (localTs == null) return false;
  if (remoteTs == null) return true;
  if (remoteTs > localTs) {
    if (previousRecord) {
      const prevTs = toTimestamp(previousRecord);
      if (prevTs != null && prevTs === remoteTs && prevTs === localTs) {
        return !recordsEqual(remoteRecord, localRecord);
      }
    }
    return false;
  }
  return true;
}

function mergeRemoteData(remoteData, changes) {
  const merged = remoteData && typeof remoteData === 'object' ? deepClone(remoteData) : {};
  let appliedChanges = 0;
  let skippedConflicts = 0;
  for (const store of STORES) {
    const remoteList = Array.isArray(merged[store]) ? merged[store].map(item => deepClone(item)) : [];
    const deletions = changes.deletions.get(store) || [];
    const upserts = changes.upserts.get(store) || [];
    if (!deletions.length && !upserts.length) {
      if (!(store in merged)) {
        merged[store] = remoteList;
      }
      continue;
    }
    const deletionSet = new Set(deletions.map(entry => String(entry.id)));
    const retained = [];
    const indexById = new Map();
    for (const item of remoteList) {
      const id = item && item.id != null ? String(item.id) : null;
      if (id && deletionSet.has(id)) {
        appliedChanges++;
        continue;
      }
      if (id) {
        indexById.set(id, retained.length);
      }
      retained.push(item);
    }
    for (const entry of upserts) {
      if (!entry || !entry.record) continue;
      const record = entry.record;
      if (record.id == null) continue;
      const key = String(record.id);
      const clone = deepClone(record);
      if (indexById.has(key)) {
        const idx = indexById.get(key);
        const remoteRecord = retained[idx];
        if (shouldApplyLocalChange(clone, remoteRecord, entry.previous)) {
          retained[idx] = clone;
          appliedChanges++;
        } else {
          skippedConflicts++;
        }
      } else {
        indexById.set(key, retained.length);
        retained.push(clone);
        appliedChanges++;
      }
    }
    merged[store] = retained;
  }
  return {merged, appliedChanges, skippedConflicts};
}

async function readBoundFileData() {
  if (!state.boundHandle) return {};
  try {
    const file = await state.boundHandle.getFile();
    if (!file) return {};
    if (file.size === 0) return {};
    const text = await file.text();
    if (!text.trim()) return {};
    const data = JSON.parse(text);
    return data && typeof data === 'object' ? data : {};
  } catch (err) {
    console.warn('Kunne ikke læse data fra fil', err);
    throw err;
  }
}

async function captureSyncedSnapshot() {
  try {
    const snapshot = await exportData();
    state.lastSyncedData = deepClone(snapshot);
  } catch (err) {
    console.warn('Kunne ikke opdatere synkroniseringssnapshot', err);
  }
}
async function saveBoundFile({interactive = false, reason = 'auto'} = {}) {
  if (!state.boundHandle) {
    setStatus('Ingen fil tilknyttet.');
    return;
  }
  if (state.reloadFromFilePromise) {
    try {
      await state.reloadFromFilePromise;
    } catch (err) {
      console.warn('Gemning fortsætter trods fejl i igangværende genindlæsning', err);
    }
  }
  const localData = await exportData();
  const changes = computeLocalChanges(state.lastSyncedData, localData);
  if (!changes.hasChanges) {
    const message = reason === 'manual'
      ? 'Ingen ændringer at gemme. Henter seneste data fra fil.'
      : 'Autogem sprang over: ingen lokale ændringer.';
    setStatus(message);
    await reloadBoundFileData({silent: true, refreshUi: true});
    return;
  }
  const hasPermission = await ensureBoundHandlePermission(interactive);
  if (!hasPermission) {
    const message = interactive ? 'Adgang til filen blev ikke givet.' : 'Autogemning sprang over: mangler filadgang.';
    setStatus(message);
    if (interactive) {
      throw new Error(message);
    }
    return;
  }
  let remoteData = {};
  try {
    remoteData = await readBoundFileData();
  } catch (err) {
    const message = 'Kunne ikke læse eksisterende data fra filen: ' + (err?.message || err);
    console.error(message);
    setStatus(message);
    if (interactive) {
      throw err;
    }
    return;
  }
  const {merged, appliedChanges, skippedConflicts} = mergeRemoteData(remoteData, changes);
  if (!appliedChanges) {
    if (skippedConflicts) {
      const message = 'Ændringer kunne ikke gemmes fordi filen har nyere data.';
      setStatus(message);
      await reloadBoundFileData({silent: true, refreshUi: true});
      if (interactive) {
        throw new Error(message);
      }
      return;
    }
    setStatus('Ingen nye ændringer at skrive til fil.');
    await reloadBoundFileData({silent: true, refreshUi: true});
    return;
  }
  try {
    const writable = await state.boundHandle.createWritable({keepExistingData: false});
    await writable.write(JSON.stringify(merged, null, 2));
    await writable.close();
    const timestamp = new Date().toLocaleTimeString();
    let message = reason === 'manual'
      ? 'Data gemt til fil kl. ' + timestamp
      : 'Autogemt kl. ' + timestamp;
    if (skippedConflicts) {
      message += ` (${skippedConflicts} ændring${skippedConflicts === 1 ? '' : 'er'} afvist pga. nyere filversion)`;
    }
    setStatus(message);
  } catch (err) {
    console.error('Fejl ved skrivning til fil', err);
    setStatus('Kunne ikke gemme: ' + (err?.message || err));
    if (err?.name === 'NotFoundError') {
      await clearBoundHandle();
    }
    if (interactive) {
      throw err;
    }
    return;
  }
  await reloadBoundFileData({silent: true, refreshUi: true});
  if (reason !== 'auto') {
    const filename = state.boundHandle?.name || '';
    registerManualExport('bound_file_save', {
      filename,
      reason,
      appliedChanges,
      skippedConflicts
    });
  }
}
async function manualSave() {
  try {
    await saveBoundFile({interactive: true, reason: 'manual'});
  } catch (err) {
    console.error(err);
    alert('Kunne ikke gemme: ' + err.message);
  }
}

async function reloadBoundFileData({silent = false, refreshUi = false} = {}) {
  if (!state.boundHandle) return false;
  if (state.reloadFromFilePromise) {
    try {
      return await state.reloadFromFilePromise;
    } catch (err) {
      return false;
    }
  }
  const performReload = (async () => {
    try {
      const data = await readBoundFileData();
      await replaceAllData(data, {markSynced: true});
      if (refreshUi) {
        renderAll();
      }
      if (!silent) {
        setStatus('Data genindlæst fra fil.');
      }
      return true;
    } catch (err) {
      console.error('Fejl ved genindlæsning af data fra fil', err);
      if (!silent) {
        setStatus('Kunne ikke genindlæse data fra fil: ' + (err?.message || err));
      }
      return false;
    } finally {
      state.reloadFromFilePromise = null;
    }
  })();
  state.reloadFromFilePromise = performReload;
  return performReload;
}
async function bindDbFile() {
  try {
    const [handle] = await window.showOpenFilePicker({multiple:false, types:[{description:'GlimR-data', accept:{'application/json':['.json']}}]});
    await persistBoundHandle(handle);
    setStatus('Fil tilknyttet: ' + handle.name);
    if (navigator.storage?.persist) {
      try { await navigator.storage.persist(); } catch (err) { console.warn('Kunne ikke anmode om vedvarende lager', err); }
    }
    const granted = await ensureBoundHandlePermission(true);
    if (!granted) {
      setStatus('Fil tilknyttet, men skrivning kræver godkendelse.');
    }
    const file = await handle.getFile();
    if (file.size > 0) {
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        await importData(data, {skipConfirm: true, markSynced: true});
      } catch (err) {
        console.error(err);
        alert('Kunne ikke læse filen: ' + err.message);
      }
    }
  } catch (err) {
    if (err && err.name !== 'AbortError') {
      console.error(err);
      alert('Filtilknytning fejlede: ' + err.message);
    }
  }
  if (state.autosave && state.boundHandle) {
    scheduleAutosave();
  }
}
async function replaceAllData(data, options = {}) {
  const markSynced = Boolean(options.markSynced);
  const timestamp = new Date().toISOString();
  for (const store of STORES) {
    const tx = state.db.transaction(store, 'readwrite');
    const objectStore = tx.objectStore(store);
    const clearReq = objectStore.clear();
    await requestToPromise(clearReq);
    const rows = data[store] ?? [];
    for (const row of rows) {
      if (!row.created_at) row.created_at = timestamp;
      if (!row.updated_at) row.updated_at = timestamp;
      objectStore.add(row);
    }
    await tx.done?.catch(() => {});
  }
  await loadAllStores();
  if (markSynced) {
    await captureSyncedSnapshot();
  }
}
async function importData(data, options = {}) {
  let skipConfirm = false;
  let markSynced = false;
  if (typeof options === 'boolean') {
    skipConfirm = options;
  } else if (options && typeof options === 'object') {
    skipConfirm = Boolean(options.skipConfirm);
    markSynced = Boolean(options.markSynced);
  }
  if (!currentCanWrite()) {
    alert('Import kræver login med skrivetilladelse.');
    return;
  }
  const proceed = skipConfirm || confirm('Dette vil overskrive eksisterende data. Fortsæt?');
  if (!proceed) return;
  await replaceAllData(data, {markSynced});
  setStatus('Data indlæst.');
  renderAll();
}
async function downloadBackup() {
  const data = await exportData();
  const filename = downloadJsonFile(data, 'glimr-backup.json', {
    entity: 'backup',
    storeCounts: summarizeStoreCounts(data),
    summary: 'Fuld backup'
  });
  setStatus(`Fuld backup downloadet som ${filename}.`);
}
const CSV_BOOLEAN_FIELDS = new Set(['acute','urgent','healthy_family_member']);
const CSV_INTEGER_FIELDS = new Set(['gene_count','sort_order','variant_count']);
const CSV_FLOAT_FIELDS = new Set(['af','value','copy_number','size_bp']);
const CSV_JSON_FIELDS = new Set(['variant_details','variants','tasks','view','__serialized__']);
function buildStoreCsvColumns(store, rows) {
  const list = Array.isArray(rows) ? rows : [];
  const fields = schemaFields[store];
  if (Array.isArray(fields) && fields.length) {
    return fields.map(field => {
      if (CSV_JSON_FIELDS.has(field)) {
        return {key: field, label: field, value: row => formatJsonCell(row?.[field])};
      }
      return {key: field, label: field};
    });
  }
  const inferred = inferCsvColumns(list);
  return inferred.map(col => {
    if (CSV_JSON_FIELDS.has(col.key)) {
      return {...col, value: row => formatJsonCell(row?.[col.key])};
    }
    return col;
  });
}
async function downloadCsvBackup() {
  const data = await exportData();
  const files = [];
  const storeCounts = {};
  for (const store of STORES) {
    const rows = Array.isArray(data[store]) ? data[store] : [];
    storeCounts[store] = rows.length;
    const columns = buildStoreCsvColumns(store, rows);
    const {encoded} = buildCsvExport(rows, columns, ';');
    files.push({name: `${store}.csv`, data: encoded});
  }
  const zipBytes = createZip(files);
  const blob = new Blob([zipBytes], {type: 'application/zip'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp('glimr-backup-csv.zip');
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  registerManualExport('csv_backup', {
    baseName: 'glimr-backup-csv.zip',
    filename,
    storeCounts,
    byteSize: blob.size
  });
  setStatus(`CSV-backup downloadet som ${filename}.`);
}
function decodeWindows1252Bytes(bytes) {
  const data = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes || []);
  if (typeof TextDecoder !== 'undefined') {
    const candidates = ['windows-1252', 'iso-8859-1'];
    for (const label of candidates) {
      try {
        return new TextDecoder(label).decode(data);
      } catch (err) {
        /* prøv næste encoder */
      }
    }
  }
  let result = '';
  for (let i = 0; i < data.length; i++) {
    result += String.fromCharCode(data[i]);
  }
  return result;
}
function decodeUtf8(bytes) {
  const data = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes || []);
  if (typeof TextDecoder !== 'undefined') {
    try {
      return new TextDecoder('utf-8').decode(data);
    } catch (err) {
      /* ignore */
    }
  }
  let result = '';
  for (let i = 0; i < data.length; i++) {
    result += String.fromCharCode(data[i]);
  }
  try {
    return decodeURIComponent(escape(result));
  } catch (err) {
    return result;
  }
}
function parseZipEntries(bytes) {
  const data = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes || []);
  if (!data.length) return [];
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  let offset = data.byteLength - 22;
  while (offset >= 0 && view.getUint32(offset, true) !== 0x06054b50) {
    offset--;
  }
  if (offset < 0) {
    throw new Error('Ugyldigt ZIP-arkiv.');
  }
  const entryCount = view.getUint16(offset + 10, true);
  const centralOffset = view.getUint32(offset + 16, true);
  const entries = [];
  let cursor = centralOffset;
  for (let i = 0; i < entryCount; i++) {
    if (view.getUint32(cursor, true) !== 0x02014b50) {
      throw new Error('Ugyldigt ZIP-arkiv (central directory).');
    }
    const compression = view.getUint16(cursor + 10, true);
    const uncompressedSize = view.getUint32(cursor + 24, true);
    const nameLength = view.getUint16(cursor + 28, true);
    const extraLength = view.getUint16(cursor + 30, true);
    const commentLength = view.getUint16(cursor + 32, true);
    const localHeaderOffset = view.getUint32(cursor + 42, true);
    const nameBytes = data.slice(cursor + 46, cursor + 46 + nameLength);
    const name = decodeUtf8(nameBytes);
    if (compression !== 0) {
      throw new Error('ZIP-arkivet anvender komprimering, som ikke understøttes.');
    }
    const localView = new DataView(data.buffer, data.byteOffset + localHeaderOffset, data.byteLength - localHeaderOffset);
    if (localView.getUint32(0, true) !== 0x04034b50) {
      throw new Error('Ugyldigt ZIP-arkiv (lokal filheader).');
    }
    const localNameLength = localView.getUint16(26, true);
    const localExtraLength = localView.getUint16(28, true);
    const dataStart = localHeaderOffset + 30 + localNameLength + localExtraLength;
    const fileBytes = data.slice(dataStart, dataStart + uncompressedSize);
    entries.push({name, data: fileBytes});
    cursor += 46 + nameLength + extraLength + commentLength;
  }
  return entries;
}
function normaliseStoreFilename(name) {
  if (!name) return '';
  const base = name.replace(/^.*[\\/]/, '');
  const withoutExt = base.replace(/\.csv$/i, '');
  return withoutExt.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
}
function mapFilenameToStore(name) {
  const normalized = normaliseStoreFilename(name);
  if (!normalized) return null;
  const candidates = new Set([normalized]);
  candidates.add(normalized.replace(/^glimr_/, ''));
  candidates.add(normalized.replace(/^data_/, ''));
  candidates.add(normalized.replace(/^backup_/, ''));
  candidates.add(normalized.replace(/^export_/, ''));
  candidates.add(normalized.replace(/_backup$/, ''));
  candidates.add(normalized.replace(/_export$/, ''));
  for (const candidate of Array.from(candidates).filter(Boolean)) {
    if (STORES.includes(candidate)) return candidate;
    const singular = candidate.endsWith('s') ? candidate.slice(0, -1) : candidate;
    if (STORES.includes(singular)) return singular;
    const plural = candidate.endsWith('s') ? candidate : `${candidate}s`;
    if (STORES.includes(plural)) return plural;
  }
  return null;
}
function parseCsvFieldValue(store, field, raw) {
  if (raw == null) return undefined;
  const text = String(raw);
  const trimmed = text.trim();
  if (!trimmed) {
    if (CSV_BOOLEAN_FIELDS.has(field)) return false;
    if (field === 'id' || field.endsWith('_id') || CSV_INTEGER_FIELDS.has(field) || CSV_FLOAT_FIELDS.has(field)) return null;
    if (CSV_JSON_FIELDS.has(field)) return null;
    return '';
  }
  if (CSV_BOOLEAN_FIELDS.has(field)) {
    const lower = trimmed.toLowerCase();
    if (['1','true','ja','yes','y','on'].includes(lower)) return true;
    if (['0','false','nej','no','n','off'].includes(lower)) return false;
    if (/^[0-9]+$/.test(lower)) return Number(lower) !== 0;
    return lower === 'sand';
  }
  if (field === 'id' || field.endsWith('_id') || CSV_INTEGER_FIELDS.has(field)) {
    const num = Number(trimmed.replace(',', '.'));
    return Number.isFinite(num) ? num : trimmed;
  }
  if (CSV_FLOAT_FIELDS.has(field)) {
    const num = Number(trimmed.replace(',', '.'));
    return Number.isFinite(num) ? num : trimmed;
  }
  if (CSV_JSON_FIELDS.has(field)) {
    try {
      return JSON.parse(trimmed);
    } catch (err) {
      return trimmed;
    }
  }
  return trimmed;
}
function parseCsvRecordsForStore(store, text) {
  const {headers, rows} = parseCsv(text);
  if (!headers.length) return [];
  const schema = schemaFields[store];
  const schemaMap = new Map();
  if (Array.isArray(schema)) {
    schema.forEach(field => {
      schemaMap.set(normaliseHeader(field), field);
    });
  }
  const columnKeys = headers.map(header => {
    const normalized = normaliseHeader(header);
    if (schemaMap.has(normalized)) return schemaMap.get(normalized);
    return normalized || null;
  });
  const records = [];
  for (const rowValues of rows) {
    if (!rowValues || rowValues.every(cell => !cell || !String(cell).trim())) continue;
    const record = {};
    let hasValue = false;
    columnKeys.forEach((key, idx) => {
      if (!key) return;
      const raw = rowValues[idx];
      if (key === '__serialized__') {
        const payload = typeof raw === 'string' ? raw.trim() : (raw == null ? '' : String(raw).trim());
        if (payload) {
          try {
            const parsed = JSON.parse(payload);
            if (parsed && typeof parsed === 'object') {
              Object.assign(record, parsed);
              if (Object.keys(parsed).length) {
                hasValue = true;
              }
            } else {
              record[key] = parsed;
              if (parsed !== null && parsed !== '') {
                hasValue = true;
              }
            }
          } catch (err) {
            record[key] = payload;
            hasValue = true;
          }
        }
        return;
      }
      const value = parseCsvFieldValue(store, key, raw);
      if (value === undefined) return;
      if (value !== '' && value !== null && !(typeof value === 'object' && Object.keys(value).length === 0)) {
        hasValue = true;
      }
      record[key] = value;
    });
    if (!hasValue && record.id == null) continue;
    records.push(record);
  }
  return records;
}
async function restoreFromCsvFile(file) {
  if (!file) throw new Error('Ingen fil valgt.');
  const nameLower = (file.name || '').toLowerCase();
  let rawEntries = [];
  if (nameLower.endsWith('.zip')) {
    const bytes = new Uint8Array(await file.arrayBuffer());
    rawEntries = parseZipEntries(bytes).map(entry => ({name: entry.name, text: decodeWindows1252Bytes(entry.data)}));
  } else {
    rawEntries = [{name: file.name || 'data.csv', text: await file.text()}];
  }
  const parsedEntries = [];
  for (const entry of rawEntries) {
    const store = mapFilenameToStore(entry.name || '');
    if (!store) {
      continue;
    }
    parsedEntries.push({store, text: entry.text});
  }
  if (!parsedEntries.length) {
    const hint = rawEntries[0]?.name ? ` (${rawEntries[0].name})` : '';
    throw new Error(`Kunne ikke identificere datatabeller ud fra filnavn${hint}.`);
  }
  const storeMap = new Map();
  for (const entry of parsedEntries) {
    const rows = parseCsvRecordsForStore(entry.store, entry.text);
    storeMap.set(entry.store, rows);
  }
  const data = {};
  const summary = [];
  for (const store of STORES) {
    const rows = storeMap.get(store) || [];
    data[store] = rows;
    if (storeMap.has(store)) {
      summary.push(`${store} (${rows.length})`);
    }
  }
  await importData(data);
  if (summary.length) {
    setStatus(`CSV-data importeret for ${summary.join(', ')}.`);
  } else {
    setStatus('CSV-data importeret.');
  }
}
async function backupAndResetData() {
  if (!ensureWrite('patients')) return;
  const confirmReset = confirm('Dette vil hente en fuld backup og derefter slette alle data undtagen brugere. Fortsæt?');
  if (!confirmReset) return;
  const data = await exportData();
  const filename = downloadJsonFile(data, 'glimr-backup-pre-reset.json', {
    entity: 'backup',
    storeCounts: summarizeStoreCounts(data),
    summary: 'Backup før nulstilling'
  });
  const storesToClear = STORES.filter(store => store !== 'users');
  const preservedUsers = JSON.parse(JSON.stringify(getCached('users') || []));
  try {
    if (state.db) {
      state.db.close();
      state.db = null;
    }
    const idbFactory = (typeof indexedDB !== 'undefined') ? indexedDB : (typeof window !== 'undefined' ? window.indexedDB : null);
    if (idbFactory) {
      await new Promise((resolve, reject) => {
        const req = idbFactory.deleteDatabase(DB_NAME);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
        req.onblocked = () => {
          alert('Databasen kunne ikke nulstilles, fordi den er åben i en anden fane. Luk andre GlimR-vinduer og prøv igen.');
        };
      });
    } else {
      writeMemoryDbSnapshot({});
    }
    state.cache.clear();
    state.db = await openDb();
    await loadAllStores();
    if (preservedUsers.length) {
      const tx = state.db.transaction('users', 'readwrite');
      const store = tx.objectStore('users');
      const now = new Date().toISOString();
      for (const user of preservedUsers) {
        if (!user.created_at) user.created_at = now;
        if (!user.updated_at) user.updated_at = now;
        store.put(user);
      }
      await tx.done?.catch(() => {});
    }
    await loadAllStores();
    await logAudit('RESET', 'system', null, null, {clearedStores: storesToClear});
    renderAll();
    restoreUserSession();
    scheduleAutosave();
    setStatus(`Data ryddet (undtagen brugere). Backup: ${filename}.`);
    alert(`Alle data undtagen brugere er nu ryddet. Backup er downloadet som ${filename}.`);
  } catch (err) {
    console.error(err);
    setStatus('Kunne ikke nulstille databasen: ' + err.message);
    alert('Kunne ikke nulstille databasen: ' + err.message);
    if (!state.db) {
      try {
        state.db = await openDb();
        await loadAllStores();
        restoreUserSession();
      } catch (reopenErr) {
        console.error(reopenErr);
      }
    }
  }
}
const CSV_LABEL_OVERRIDES = {
  id: 'ID',
  mrn: 'MRN',
  extra_id: 'Ekstra ID',
  family_number: 'Familienummer',
  name: 'Navn',
  gender: 'Køn (kode)',
  birth_date: 'Fødselsdato',
  notes: 'Noter',
  created_by: 'Oprettet af',
  created_at: 'Oprettet (ISO)',
  updated_at: 'Opdateret (ISO)',
  patient_id: 'Patient-ID',
  sample_id: 'Prøve-ID',
  panel_id: 'Panel-ID',
  pmb_number: 'PMB-nummer',
  sample_type: 'Prøvetype',
  collected_at: 'Opsamlet (ISO)',
  status: 'Status (kode)',
  ordered_at: 'Bestilt (ISO)',
  variant_type: 'Varianttype (kode)',
  hgvs_c: 'HGVS c.',
  hgvs_p: 'HGVS p.',
  rsid: 'rsID',
  af: 'VAF',
  genome_build: 'Genom reference',
  sv_subtype: 'Strukturtype (kode)',
  size_bp: 'Størrelse (bp)',
  copy_number: 'Kopital',
  affected_genes: 'Berørte gener',
  order_id: 'Ordination-ID',
  summary: 'Konklusion',
  issued_at: 'Udstedt (ISO)',
  findings: 'Fund',
  variant_ids: 'Variant-ID\'er',
  variant_details: 'Variantdetaljer',
  annotations: 'Annoteringer',
  interpretation: 'Tolkning',
  genomic_position: 'Genomisk position',
  clinician: 'Rekvirent',
  analysis_responsible_id: 'Analyseansvarlig-ID',
  interpreter_id: 'Tolker-ID',
  approver_id: 'Godkender-ID',
  gene: 'Gen/Region',
  transcript: 'Transkript',
  zygosity: 'Zygositet',
  chromosome: 'Kromosom',
  start: 'Start',
  end: 'Slut',
  description: 'Beskrivelse'
};
function getCsvLabel(key) {
  if (!key) return '';
  if (CSV_LABEL_OVERRIDES[key]) return CSV_LABEL_OVERRIDES[key];
  const parts = key.split('_').map(part => {
    if (!part) return '';
    if (part.length <= 3) return part.toUpperCase();
    return part.charAt(0).toUpperCase() + part.slice(1);
  });
  return parts.join(' ');
}
function inferCsvColumns(rows) {
  const keys = Array.from(new Set(rows.flatMap(row => row ? Object.keys(row) : [])));
  if (!keys.length) {
    return [{
      key: '__serialized__',
      label: 'Data',
      value: row => {
        try {
          return JSON.stringify(row ?? {});
        } catch (err) {
          return '';
        }
      }
    }];
  }
  return keys.map(key => ({key, label: getCsvLabel(key)}));
}
function formatJsonCell(value) {
  if (value == null || value === '') return '';
  if (typeof value === 'string') return value;
  try {
    return JSON.stringify(value);
  } catch (err) {
    return String(value);
  }
}
function buildCsvExport(rows, columns, delimiter = ';') {
  const data = Array.isArray(rows) ? rows : [];
  const sourceColumns = Array.isArray(columns) && columns.length ? columns : inferCsvColumns(data);
  const cols = sourceColumns.map(col => {
    if (typeof col === 'string') {
      return {key: col, label: col};
    }
    const normalised = {...col};
    if (!Object.prototype.hasOwnProperty.call(normalised, 'label')) {
      normalised.label = normalised.key ?? '';
    }
    return normalised;
  });
  const header = cols.map((col, index) => {
    const label = index === 0
      ? sanitizeFirstCsvHeaderLabel(col.label ?? col.key)
      : (col.label ?? col.key);
    return escapeCsvValue(label, delimiter);
  }).join(delimiter);
  const lines = data.map(row => cols.map(col => {
    const raw = typeof col.value === 'function' ? col.value(row) : (row ? row[col.key] : undefined);
    return escapeCsvValue(raw, delimiter);
  }).join(delimiter));
  const csv = [header, ...lines].join('\r\n');
  return {columns: cols, csv, encoded: encodeWindows1252(csv), rowCount: data.length};
}
function exportFilteredCsv(baseName, rows, columns, meta = {}) {
  const data = Array.isArray(rows) ? rows : [];
  const cols = Array.isArray(columns) && columns.length ? columns : inferCsvColumns(data);
  const auditDetails = meta.auditMeta && typeof meta.auditMeta === 'object' ? {...meta.auditMeta} : {};
  auditDetails.baseName = baseName;
  auditDetails.rowCount = data.length;
  if (meta.auditContext) {
    auditDetails.filters = meta.auditContext;
  }
  if (meta.entity && !auditDetails.source) {
    auditDetails.source = meta.entity;
  }
  const filename = downloadCsvFile(
    data,
    cols,
    baseName,
    meta.delimiter || ';',
    {entity: meta.auditEntity || meta.entity || 'export', details: auditDetails}
  );
  const plural = meta.plural || meta.entity || 'poster';
  setStatus(`Eksporterede ${data.length} ${plural} til ${filename}.`);
}
function triggerDownload(url, filename) {
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
function downloadJsonFile(data, baseName, auditMeta = {}) {
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  const details = (auditMeta && typeof auditMeta === 'object' && auditMeta.details && typeof auditMeta.details === 'object')
    ? {...auditMeta.details}
    : {};
  details.baseName = baseName;
  details.filename = filename;
  details.byteSize = blob.size;
  if (auditMeta && typeof auditMeta === 'object') {
    if (auditMeta.summary != null && details.summary == null) details.summary = auditMeta.summary;
    if (auditMeta.storeCounts && !details.storeCounts) details.storeCounts = auditMeta.storeCounts;
  }
  registerManualExport((auditMeta && auditMeta.entity) || 'json_export', details);
  return filename;
}
const WINDOWS_1252_EXTENDED = {
  0x20ac: 0x80,
  0x201a: 0x82,
  0x0192: 0x83,
  0x201e: 0x84,
  0x2026: 0x85,
  0x2020: 0x86,
  0x2021: 0x87,
  0x02c6: 0x88,
  0x2030: 0x89,
  0x0160: 0x8a,
  0x2039: 0x8b,
  0x0152: 0x8c,
  0x017d: 0x8e,
  0x2018: 0x91,
  0x2019: 0x92,
  0x201c: 0x93,
  0x201d: 0x94,
  0x2022: 0x95,
  0x2013: 0x96,
  0x2014: 0x97,
  0x02dc: 0x98,
  0x2122: 0x99,
  0x0161: 0x9a,
  0x203a: 0x9b,
  0x0153: 0x9c,
  0x017e: 0x9e,
  0x0178: 0x9f
};
function encodeWindows1252(str) {
  const bytes = [];
  for (let i = 0; i < str.length; i++) {
    let codePoint = str.codePointAt(i);
    if (codePoint > 0xffff) {
      i++;
    }
    if (codePoint <= 0xff) {
      bytes.push(codePoint);
      continue;
    }
    const mapped = WINDOWS_1252_EXTENDED[codePoint];
    if (mapped != null) {
      bytes.push(mapped);
    } else {
      bytes.push(0x3f);
    }
  }
  return new Uint8Array(bytes);
}
function sanitizeFirstCsvHeaderLabel(label) {
  if (label == null) return '';
  const text = String(label);
  const trimmedUpper = text.trim().toUpperCase();
  if (trimmedUpper === 'ID') {
    return 'Id';
  }
  return text;
}
function downloadCsvFile(rows, columns, baseName, delimiter = ';', auditMeta = {}) {
  const {encoded, rowCount} = buildCsvExport(rows, columns, delimiter);
  const blob = new Blob([encoded], {type: 'text/csv;charset=windows-1252;'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  const details = (auditMeta && typeof auditMeta === 'object' && auditMeta.details && typeof auditMeta.details === 'object')
    ? {...auditMeta.details}
    : {};
  details.baseName = baseName;
  details.filename = filename;
  details.rowCount = rowCount;
  details.delimiter = delimiter;
  registerManualExport((auditMeta && auditMeta.entity) || 'csv_export', details);
  return filename;
}
function downloadTextFile(text, baseName, auditMeta = {}) {
  if (typeof text !== 'string') text = '';
  const normalised = text.replace(/\r?\n|\r/g, '\r\n');
  const encoded = encodeWindows1252(normalised);
  const blob = new Blob([encoded], {type: 'text/plain;charset=windows-1252;'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  const details = (auditMeta && typeof auditMeta === 'object' && auditMeta.details && typeof auditMeta.details === 'object')
    ? {...auditMeta.details}
    : {};
  details.baseName = baseName;
  details.filename = filename;
  details.byteSize = blob.size;
  registerManualExport((auditMeta && auditMeta.entity) || 'text_export', details);
  return filename;
}
function escapeCsvValue(value, delimiter) {
  if (value == null) value = '';
  if (value instanceof Date) value = value.toISOString();
  let str = String(value);
  if (!str) return '';
  str = str.replace(/\r?\n|\r/g, ' ');
  const needsQuotes = str.includes(delimiter) || str.includes('"') || /[\t]/.test(str) || /^\s|\s$/.test(str);
  let escaped = str.replace(/"/g, '""');
  if (needsQuotes) {
    escaped = `"${escaped}"`;
  }
  return escaped;
}
function withDateStamp(filename) {
  const stamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0].replace('T', '-');
  const dot = filename.lastIndexOf('.');
  if (dot === -1) return `${filename}-${stamp}`;
  return `${filename.slice(0, dot)}-${stamp}${filename.slice(dot)}`;
}
function detectCsvDelimiter(text) {
  const sample = (text || '').slice(0, 1024);
  const counts = {',': 0, ';': 0, '\t': 0};
  let inQuotes = false;
  for (let i = 0; i < sample.length; i++) {
    const char = sample[i];
    if (char === '"') {
      if (inQuotes && sample[i + 1] === '"') {
        i++;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }
    if (!inQuotes && (char === ',' || char === ';' || char === '\t')) {
      counts[char]++;
    }
    if (char === '\n' && !inQuotes) {
      break;
    }
  }
  if (counts[';'] >= counts[','] && counts[';'] >= counts['\t'] && counts[';'] > 0) return ';';
  if (counts[','] >= counts['\t'] && counts[','] > 0) return ',';
  if (counts['\t'] > 0) return '\t';
  return ';';
}
function parseCsv(text) {
  if (!text) return {headers: [], rows: [], delimiter: ';'};
  const cleaned = text.replace(/^\ufeff/, '');
  const delimiter = detectCsvDelimiter(cleaned);
  const rows = [];
  let field = '';
  let row = [];
  let inQuotes = false;
  for (let i = 0; i < cleaned.length; i++) {
    const char = cleaned[i];
    if (inQuotes) {
      if (char === '"') {
        if (cleaned[i + 1] === '"') {
          field += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        field += char;
      }
      continue;
    }
    if (char === '"') {
      inQuotes = true;
      continue;
    }
    if (char === '\r') {
      continue;
    }
    if (char === '\n') {
      row.push(field);
      rows.push(row);
      row = [];
      field = '';
      continue;
    }
    if (char === delimiter) {
      row.push(field);
      field = '';
      continue;
    }
    field += char;
  }
  if (inQuotes) {
    row.push(field);
  } else if (field !== '' || row.length) {
    row.push(field);
  }
  if (row.length) {
    rows.push(row);
  }
  while (rows.length && rows[rows.length - 1].every(cell => cell.trim() === '')) {
    rows.pop();
  }
  const headers = rows.shift() || [];
  return {headers: headers.map(h => h.trim()), rows, delimiter};
}
function normaliseHeader(header) {
  if (header == null) return '';
  let value = String(header).trim().toLowerCase();
  if (typeof value.normalize === 'function') {
    value = value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }
  return value.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
}
function mapVarSeqClassification(value) {
  if (value == null) return '';
  const raw = String(value).trim();
  if (!raw) return '';
  if (/^[1-5]$/.test(raw)) return raw;
  const digit = raw.match(/[1-5]/);
  if (digit) return digit[0];
  const lower = raw.toLowerCase();
  const compact = lower.replace(/[^a-z0-9]+/g, '');
  if (compact === 'lp' || compact === 'likelypathogenic') return '4';
  if (compact === 'p' || compact === 'pathogenic') return '5';
  if (compact === 'lb' || compact === 'likelybenign') return '2';
  if (compact === 'b' || compact === 'benign') return '1';
  if (compact === 'vus' || compact === 'v' || compact === 'uncertain' || compact === 'unknown') return '3';
  if (lower.includes('pathogenic')) {
    return lower.includes('likely') ? '4' : '5';
  }
  if (lower.includes('benign')) {
    return lower.includes('likely') ? '2' : '1';
  }
  if (lower.includes('vus') || lower.includes('uncertain') || lower.includes('ukendt')) {
    return '3';
  }
  if (lower.includes('risk')) return '3';
  return '';
}
function parseVarSeqVariants(text) {
  const {headers, rows} = parseCsv(text);
  if (!headers.length) throw new Error('CSV-filen mangler kolonneoverskrifter.');
  const headerMap = {
    gene: 'gene',
    gen: 'gene',
    gene_name: 'gene',
    gene_symbol: 'gene',
    transcript: 'transcript',
    transcript_id: 'transcript',
    transcript_accession: 'transcript',
    refseq_transcript: 'transcript',
    refseq: 'transcript',
    ensembl_transcript: 'transcript',
    cdna_change: 'hgvs_c',
    cdna_change_hgvs: 'hgvs_c',
    cdna: 'hgvs_c',
    c_hgvs: 'hgvs_c',
    hgvs_c: 'hgvs_c',
    coding_hgvs: 'hgvs_c',
    coding_dna_change: 'hgvs_c',
    protein_change: 'hgvs_p',
    protein_change_hgvs: 'hgvs_p',
    protein: 'hgvs_p',
    hgvs_p: 'hgvs_p',
    rsid: 'rsid',
    dbsnp: 'rsid',
    dbsnp_id: 'rsid',
    dbsnpid: 'rsid',
    dbsnp_rs: 'rsid',
    rs_id: 'rsid',
    genomic_position: 'genomic_position',
    genomicpos: 'genomic_position',
    genomic_pos: 'genomic_position',
    position: 'genomic_position',
    pos: 'genomic_position',
    amino_acid_change: 'hgvs_p',
    effect: 'hgvs_p',
    protein_effect: 'hgvs_p',
    zygosity: 'zygosity',
    genotype: 'zygosity',
    sample_zygosity: 'zygosity',
    classification: 'classification',
    classification_short: 'classification',
    acmg_classification: 'classification',
    acmg_class: 'classification',
    acmg_score: 'classification',
    acmg: 'criteria',
    acmg_evidence: 'criteria',
    acmg_criteria: 'criteria',
    acmg_codes: 'criteria',
    acmg_rule: 'criteria',
    allele_fraction: 'af',
    allele_frequency: 'af',
    allele_balance: 'af',
    allele_ratio: 'af',
    af: 'af',
    af_percent: 'af',
    variant_af: 'af',
    allel_frekvens: 'af',
    allelfrekvens: 'af',
    variant_type: 'variant_type',
    varianttype: 'variant_type',
    variant_class: 'variant_type',
    variant_category: 'variant_type',
    genome_build: 'genome_build',
    genome: 'genome_build',
    assembly: 'genome_build',
    chrom: 'chromosome',
    chromosome: 'chromosome',
    chr: 'chromosome',
    locus: 'chromosome',
    start: 'start',
    begin: 'start',
    position_start: 'start',
    end: 'end',
    stop: 'end',
    finish: 'end',
    position_end: 'end',
    copy_number: 'copy_number',
    copynumber: 'copy_number',
    cn: 'copy_number',
    copies: 'copy_number',
    cn_state: 'copy_number',
    sv_type: 'sv_subtype',
    sv_subtype: 'sv_subtype',
    structural_type: 'sv_subtype',
    cnv_type: 'sv_subtype',
    event_type: 'sv_subtype',
    size: 'size_bp',
    size_bp: 'size_bp',
    length: 'size_bp',
    span: 'size_bp',
    iscn: 'iscn',
    cytogenetic: 'iscn',
    cytogenetic_location: 'iscn',
    cytogenetic_band: 'iscn',
    description: 'description',
    notes: 'description',
    comment: 'description',
    comments: 'description',
    affected_genes: 'affected_genes',
    genes: 'affected_genes',
    gene_list: 'affected_genes'
  };
  const columnKeys = headers.map(header => headerMap[normaliseHeader(header)] || null);
  if (!columnKeys.some(key => key === 'gene' || key === 'hgvs_c' || key === 'hgvs_p' || key === 'iscn' || key === 'description')) {
    throw new Error('CSV-filen skal indeholde mindst én kolonne for gen eller HGVS.');
  }
  const variants = [];
  let skipped = 0;
  const warnings = [];
  const seenAnnotations = new Set();
  const toNumber = value => {
    if (value == null) return null;
    const trimmed = String(value).trim();
    if (!trimmed) return null;
    const hasPercent = /%/.test(trimmed);
    const normalised = trimmed.replace(/%/g, '').replace(/\s+/g, '').replace(',', '.');
    const parsed = Number(normalised);
    if (!Number.isFinite(parsed)) return null;
    const result = hasPercent ? parsed / 100 : parsed;
    return result;
  };
  rows.forEach((rowValues, index) => {
    if (!rowValues || rowValues.every(cell => !cell || !cell.trim())) {
      skipped++;
      return;
    }
    const entry = {};
    const annotations = [];
    columnKeys.forEach((key, idx) => {
      const rawValue = rowValues[idx];
      if (rawValue == null) return;
      const value = String(rawValue).trim();
      if (!value) return;
      if (!key) {
        const header = headers[idx] ?? `Kolonne ${idx + 1}`;
        const label = String(header).trim() || `Kolonne ${idx + 1}`;
        annotations.push(`${label}: ${value}`);
        seenAnnotations.add(label);
        return;
      }
      switch (key) {
        case 'gene':
          entry.gene = value;
          break;
        case 'transcript':
          entry.transcript = value;
          break;
        case 'hgvs_c':
          entry.hgvs_c = value;
          break;
        case 'hgvs_p':
          entry.hgvs_p = value;
          break;
        case 'rsid':
          entry.rsid = normalizeRsId(value);
          break;
        case 'genomic_position':
          entry.genomic_position = value;
          break;
        case 'zygosity':
          entry.zygosity = value;
          break;
        case 'classification':
          entry.classification = mapVarSeqClassification(value);
          if (!entry.classification && value) {
            warnings.push(`Række ${index + 2}: Ukendt klassifikation "${value}".`);
          }
          break;
        case 'criteria':
          entry.criteria = entry.criteria ? `${entry.criteria}; ${value}` : value;
          break;
        case 'af':
          const afValue = toNumber(value);
          if (afValue != null) {
            entry.af = afValue;
          } else {
            warnings.push(`Række ${index + 2}: Kunne ikke tolke allelfrekvens "${value}".`);
          }
          break;
        case 'variant_type':
          entry.variant_type = normalizeVariantType(value);
          break;
        case 'genome_build':
          entry.genome_build = value;
          break;
        case 'chromosome':
          entry.chromosome = value;
          break;
        case 'start':
          entry.start = value;
          break;
        case 'end':
          entry.end = value;
          break;
        case 'copy_number':
          entry.copy_number = value;
          break;
        case 'sv_subtype':
          entry.sv_subtype = normalizeStructureTypeValue(value);
          break;
        case 'size_bp':
          entry.size_bp = value;
          break;
        case 'iscn':
          entry.iscn = value;
          break;
        case 'description':
          entry.description = entry.description ? `${entry.description}; ${value}` : value;
          break;
        case 'affected_genes':
          entry.affected_genes = entry.affected_genes ? `${entry.affected_genes}; ${value}` : value;
          break;
        default:
          break;
      }
    });
    if (!entry.gene && !entry.hgvs_c && !entry.hgvs_p && !entry.genomic_position && !entry.iscn && !entry.description && !(entry.chromosome && (entry.start || entry.end))) {
      skipped++;
      return;
    }
    if (!entry.variant_type) {
      const hasStructuralMarkers = entry.iscn || entry.description || entry.copy_number || entry.sv_subtype || (entry.chromosome && (entry.start || entry.end));
      entry.variant_type = normalizeVariantType(hasStructuralMarkers ? 'cnv' : 'snv');
    }
    if (annotations.length) {
      entry.annotations = annotations.join(' | ');
    }
    variants.push(entry);
  });
  return {
    variants,
    warnings,
    summary: {
      total: rows.length,
      imported: variants.length,
      skipped,
      annotationColumns: Array.from(seenAnnotations)
    }
  };
}
async function parseVarSeqFile(file) {
  if (!file) throw new Error('Ingen fil valgt.');
  const text = await file.text();
  return parseVarSeqVariants(text);
}
async function restoreFromFile(file) {
  const text = await file.text();
  const data = JSON.parse(text);
  await importData(data);
}
function renderAll() {
  tabs.forEach(tab => renderTab(tab.id));
}
function renderTab(id) {
  const section = document.querySelector(`section[data-tab="${id}"]`);
  if (!section) return;
  switch(id) {
    case 'dashboard': return renderDashboard(section);
    case 'planner': return renderPlanner(section);
    case 'case_create': return renderCreateCase(section);
    case 'patients': return renderPatients(section);
    case 'samples': return renderSamples(section);
    case 'orders': return renderOrders(section);
    case 'panels': return renderPanels(section);
    case 'variants': return renderVariants(section);
    case 'variant_library': return renderVariantLibrary(section);
    case 'conclusion_library': return renderConclusionLibrary(section);
    case 'reports': return renderReports(section);
    case 'qc': return renderQC(section);
    case 'responses': return renderResponses(section);
    case 'tools': return renderTools(section);
    case 'users': return renderUsers(section);
    case 'audit': return renderAudit(section);
    case 'db': return renderDbTab(section);
    case 'admin': return renderAdmin(section);
    default:
      section.innerHTML = '<p>Ingen data.</p>';
  }
}
function renderDashboard(section) {
  const patients = getCached('patients').length;
  const samples = getCached('samples');
  const primarySamples = samples.filter(sample => !isLikelyControlSample(sample));
  const sampleCount = primarySamples.length;
  const orders = getCached('orders');
  const reports = getCached('reports');
  const variants = getCached('variants');
  const statusCounts = primarySamples.reduce((acc, sample) => {
    const status = (sample.status || '').toLowerCase();
    if (status === 'modtaget') acc.received += 1;
    else if (status === 'qc') acc.qc += 1;
    else if (status === 'analyse') acc.analysis += 1;
    else if (status === 'tolkning' || status === 'godkendelse') acc.interpretation += 1;
    else if (status === 'rapport') acc.report += 1;
    else if (status === 'biobank') acc.biobank += 1;
    return acc;
  }, {received: 0, qc: 0, analysis: 0, interpretation: 0, report: 0, biobank: 0});
  const ordersForStats = orders.filter(order => !isControlOrder(order));
  const variantsForStats = variants.filter(variant => {
    const sampleId = Number(variant.sample_id);
    if (Number.isFinite(sampleId)) {
      const sample = findById('samples', sampleId);
      if (sample && isLikelyControlSample(sample)) return false;
    }
    const orderId = Number(variant.order_id);
    if (!Number.isFinite(orderId)) return true;
    const order = findById('orders', orderId);
    return !isControlOrder(order);
  });
  const reportsForStats = reports.filter(report => {
    const sampleId = Number(report.sample_id);
    if (Number.isFinite(sampleId)) {
      const sample = findById('samples', sampleId);
      if (sample && isLikelyControlSample(sample)) return false;
    }
    const orderId = Number(report.order_id);
    if (!Number.isFinite(orderId)) return true;
    const order = findById('orders', orderId);
    return !isControlOrder(order);
  });
  const recentOrders = orders.slice().sort((a,b)=> (b.updated_at||'').localeCompare(a.updated_at||'' )).slice(0,5);
  const activeOrders = orders.filter(order => {
    const sample = findById('samples', Number(order.sample_id));
    const status = (sample?.status || order.status || '').toLowerCase();
    return isActiveStatus(status);
  });
  const activeOrdersForStats = activeOrders.filter(order => !isControlOrder(order));
  const priorityOrdersCount = activeOrdersForStats.filter(order => order.acute || order.urgent).length;
  const MS_PER_DAY = 86400000;
  const MS_PER_WEEK = MS_PER_DAY * 7;
  const now = new Date();
  const weekAgo = new Date(now.getTime() - MS_PER_WEEK);
  const monthAgo = new Date(now.getTime() - MS_PER_DAY * 30);
  const responseDurations = [];
  reportsForStats.forEach(report => {
    const order = findById('orders', Number(report.order_id));
    if (!order) return;
    const sample = order.sample_id ? findById('samples', Number(order.sample_id)) : null;
    const receivedAt = parseDateTimeValue(sample?.created_at || sample?.collected_at || sample?.updated_at);
    const answeredAt = parseDateTimeValue(report.issued_at || report.updated_at || report.created_at);
    if (!receivedAt || !answeredAt) return;
    const diffDays = (answeredAt.getTime() - receivedAt.getTime()) / MS_PER_DAY;
    if (Number.isFinite(diffDays) && diffDays >= 0) {
      responseDurations.push(diffDays);
    }
  });
  const responseTimeP90 = calculatePercentile(responseDurations, 0.9);
  const samplesLastWeek = primarySamples.filter(sample => {
    const receivedAt = parseDateTimeValue(sample.created_at || sample.collected_at || sample.updated_at);
    return receivedAt && receivedAt >= weekAgo;
  }).length;
  const samplesLastMonth = primarySamples.filter(sample => {
    const receivedAt = parseDateTimeValue(sample.created_at || sample.collected_at || sample.updated_at);
    return receivedAt && receivedAt >= monthAgo;
  }).length;
  const ordersLastMonth = ordersForStats.filter(order => {
    const orderedAt = parseDateTimeValue(order.ordered_at || order.created_at || order.updated_at);
    return orderedAt && orderedAt >= monthAgo;
  });
  const ordersLastMonthCount = ordersLastMonth.length;
  const weeksCovered = Math.max((now.getTime() - monthAgo.getTime()) / MS_PER_WEEK, 1 / 52);
  const avgOrdersPerWeek = ordersLastMonthCount ? ordersLastMonthCount / weeksCovered : 0;
  const reportsLastMonth = reportsForStats.filter(report => {
    const issuedAt = parseDateTimeValue(report.issued_at || report.updated_at || report.created_at);
    return issuedAt && issuedAt >= monthAgo;
  });
  const reportsLastMonthCount = reportsLastMonth.length;
  const avgReportsPerWeek = reportsLastMonthCount ? reportsLastMonthCount / weeksCovered : 0;
  const avgOrdersPerWeekRounded = Math.round(avgOrdersPerWeek);
  const avgOrdersPerWeekDisplay = `${formatNumberDa(avgOrdersPerWeekRounded)} pr. uge`;
  const netOrdersPerWeek = avgOrdersPerWeek - avgReportsPerWeek;
  const netOrdersPerWeekRounded = Math.round(netOrdersPerWeek);
  const netOrdersPerWeekSign = netOrdersPerWeekRounded > 0 ? '+' : netOrdersPerWeekRounded < 0 ? '-' : '';
  const netOrdersDisplay = `${netOrdersPerWeekSign}${formatNumberDa(Math.abs(netOrdersPerWeekRounded))} pr. uge`;
  const metrics = [
    {icon: 'user-group', badge: 'Patienter', value: formatNumberDa(patients)},
    {icon: 'beaker', badge: 'Prøver', value: formatNumberDa(sampleCount)},
    {icon: 'clipboard-document-list', badge: 'Ordinationer', value: formatNumberDa(ordersForStats.length)},
    {icon: 'inbox', badge: 'Modtaget', value: formatNumberDa(statusCounts.received)},
    {icon: 'exclamation-triangle', badge: 'Akutte/Haster', value: formatNumberDa(priorityOrdersCount)},
    {icon: 'wrench-screwdriver', badge: 'Analyse', value: formatNumberDa(statusCounts.analysis)},
    {icon: 'book-open', badge: 'Tolkning', value: formatNumberDa(statusCounts.interpretation)},
    {icon: 'document-text', badge: 'Rapport', value: formatNumberDa(statusCounts.report)},
    {icon: 'dna', badge: 'Varianter', value: formatNumberDa(variantsForStats.length)},
    {icon: 'circle-stack', badge: 'Biobank', value: formatNumberDa(statusCounts.biobank)}
  ];
  const metricsHtml = metrics.map(metric => `
      <div class="dashboard-metric">
        <span class="icon-slot" data-icon="${metric.icon}"></span>
        <div><div class="badge">${esc(metric.badge)}</div><h3>${esc(metric.value)}</h3></div>
      </div>
    `).join('');
  const statsCards = [
    {icon: 'clock', label: "Svarstid (90%-fraktil)", value: formatDurationDays(responseTimeP90)},
    {icon: 'arrows-up-down', label: 'Nettoflow (30 dage)', value: netOrdersDisplay},
    {icon: 'inbox', label: 'Prøver modtaget (7 dage)', value: formatNumberDa(samplesLastWeek)},
    {icon: 'beaker', label: 'Prøver modtaget (30 dage)', value: formatNumberDa(samplesLastMonth)},
    {icon: 'document-chart-bar', label: 'Gns. ordinationer (30 dage)', value: avgOrdersPerWeekDisplay},
    {icon: 'clipboard-document-check', label: 'Rapporter udstedt (30 dage)', value: formatNumberDa(reportsLastMonthCount)}
  ];
  const statsCardsHtml = statsCards.map(stat => `
      <div class="dashboard-stat">
        <span class="icon-slot" data-icon="${stat.icon}"></span>
        <div>
          <div class="stat-label">${esc(stat.label)}</div>
          <div class="stat-value">${esc(stat.value)}</div>
        </div>
      </div>
    `).join('');
  const oldestActiveOrders = activeOrders
    .slice()
    .sort((a, b) => (a.updated_at || '').localeCompare(b.updated_at || ''))
    .slice(0, 5);
  const currentUserId = state.currentUser?.id ? String(state.currentUser.id) : '';
  let myActiveOrdersHtml = '';
  if (currentUserId) {
    const myActiveOrders = activeOrders.filter(order => {
      const analysisMatch = order.analysis_responsible_id !== undefined && order.analysis_responsible_id !== null && String(order.analysis_responsible_id) === currentUserId;
      const interpreterMatch = order.interpreter_id !== undefined && order.interpreter_id !== null && String(order.interpreter_id) === currentUserId;
      const approverMatch = order.approver_id !== undefined && order.approver_id !== null && String(order.approver_id) === currentUserId;
      return analysisMatch || interpreterMatch || approverMatch;
    });
    const sortedMyActiveOrders = myActiveOrders.slice().sort((a, b) => {
      const acuteA = a.acute ? 1 : 0;
      const acuteB = b.acute ? 1 : 0;
      if (acuteA !== acuteB) return acuteB - acuteA;
      const urgentA = a.urgent ? 1 : 0;
      const urgentB = b.urgent ? 1 : 0;
      if (urgentA !== urgentB) return urgentB - urgentA;
      const sampleA = findById('samples', Number(a.sample_id));
      const sampleB = findById('samples', Number(b.sample_id));
      const dateA = parseDateTimeValue(sampleA?.collected_at || sampleA?.created_at || a.created_at || a.ordered_at);
      const dateB = parseDateTimeValue(sampleB?.collected_at || sampleB?.created_at || b.created_at || b.ordered_at);
      const timeA = dateA ? dateA.getTime() : Number.POSITIVE_INFINITY;
      const timeB = dateB ? dateB.getTime() : Number.POSITIVE_INFINITY;
      if (timeA !== timeB) return timeA - timeB;
      const idA = Number(a.id);
      const idB = Number(b.id);
      if (Number.isFinite(idA) && Number.isFinite(idB)) return idA - idB;
      return String(a.id || '').localeCompare(String(b.id || ''));
    });
    myActiveOrdersHtml = sortedMyActiveOrders.map(o => {
      const sample = findById('samples', Number(o.sample_id));
      const isAnalysisResponsible = o.analysis_responsible_id !== undefined && o.analysis_responsible_id !== null && String(o.analysis_responsible_id) === currentUserId;
      const isInterpreter = o.interpreter_id !== undefined && o.interpreter_id !== null && String(o.interpreter_id) === currentUserId;
      const isApprover = o.approver_id !== undefined && o.approver_id !== null && String(o.approver_id) === currentUserId;
      const roleLabels = [];
      if (isAnalysisResponsible) {
        roleLabels.push('Analyseansvarlig');
      }
      if (isInterpreter) {
        roleLabels.push('Tolker');
      }
      if (isApprover) {
        roleLabels.push('Godkender');
      }
      const statusDisplay = sample?.status || o.status || '';
      const normalizedStatus = (statusDisplay || '').toString().trim().toLowerCase();
      const statusMatches = (...expected) => expected.some(status => normalizedStatus === status || normalizedStatus.startsWith(`${status} `));
      const roleStatusMatch = (
        (isApprover && statusMatches('godkendelse', 'rapport')) ||
        (isInterpreter && statusMatches('tolkning', 'rapport')) ||
        (isAnalysisResponsible && statusMatches('qc', 'analyse'))
      );
      const roleStatusIndicator = roleStatusMatch
        ? '<span class="role-status-indicator" role="img" aria-label="Rolle matcher status" title="Rolle matcher status"></span>'
        : '';
      const collectedValue = sample?.collected_at || sample?.created_at || o.ordered_at || o.created_at;
      const collectedAt = formatDanishDate(collectedValue);
      const priorityIcons = renderOrderPriorityIcons(o);
      const priorityAttr = orderPriorityAttributes(o);
      const sampleDisplay = sample?.pmb_number || sample?.id || o.sample_id || '';
      const rolesDisplay = roleLabels.length ? roleLabels.join(', ') : '—';
      return `<tr data-order-id="${esc(o.id)}"${priorityAttr}><td>${roleStatusIndicator}${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td>${esc(rolesDisplay)}</td><td>${esc(getName('patients', o.patient_id))}</td><td>${esc(sampleDisplay)}</td><td>${getName('panels', o.panel_id)}</td><td>${esc(statusDisplay)}</td><td>${esc(collectedAt)}</td></tr>`;
    }).join('') || '<tr><td colspan="7">Ingen aktive ordrer</td></tr>';
  }
  const audit = getCached('audit').slice(-5).reverse();
  const recentOrdersHtml = recentOrders.map(o => {
    const sample = findById('samples', Number(o.sample_id));
    const statusDisplay = sample?.status || o.status || '';
    const updatedAt = formatDanishDate(o.updated_at);
    const priorityIcons = renderOrderPriorityIcons(o);
    const priorityAttr = orderPriorityAttributes(o);
    return `<tr data-order-id="${esc(o.id)}"${priorityAttr}><td>${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td>${esc(getName('patients', o.patient_id))}</td><td>${esc(o.sample_id || '')}</td><td>${getName('panels', o.panel_id)}</td><td>${esc(statusDisplay)}</td><td>${esc(updatedAt)}</td></tr>`;
  }).join('') || '<tr><td colspan="6">Ingen</td></tr>';
  const oldestOrdersHtml = oldestActiveOrders.map(o => {
    const sample = findById('samples', Number(o.sample_id));
    const statusDisplay = sample?.status || o.status || '';
    const updatedAt = formatDanishDate(o.updated_at);
    const priorityIcons = renderOrderPriorityIcons(o);
    const priorityAttr = orderPriorityAttributes(o);
    return `<tr data-order-id="${esc(o.id)}"${priorityAttr}><td>${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td>${esc(getName('patients', o.patient_id))}</td><td>${esc(o.sample_id || '')}</td><td>${getName('panels', o.panel_id)}</td><td>${esc(statusDisplay)}</td><td>${esc(updatedAt)}</td></tr>`;
  }).join('') || '<tr><td colspan="6">Ingen aktive ordrer</td></tr>';
  const printableMetrics = metrics.map(item => ({badge: item.badge, value: item.value}));
  const printableStats = statsCards.map(item => ({label: item.label, value: item.value}));
  section.innerHTML = `
  <div class="panel">
    <div class="panel-header">
      <h2>KPI'er</h2>
      <button class="secondary with-icon" id="dashboardPrintButton" type="button">
        <span class="icon-slot" data-icon="document-chart-bar"></span>
        <span>Udskriv KPI'er og statistik</span>
      </button>
    </div>
    <div class="dashboard-metrics">
      ${metricsHtml}
    </div>
  </div>
  <div class="panel">
    <h2>Statistik</h2>
    <div class="dashboard-stats">
      ${statsCardsHtml}
    </div>
  </div>
  <div class="panel">
    <h2>Seneste ordrer</h2>
    <table>
      <thead><tr><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Status</th><th>Opdateret</th></tr></thead>
      <tbody>
        ${recentOrdersHtml}
      </tbody>
    </table>
  </div>
  <div class="panel">
    <h2>Ældste aktive ordrer</h2>
    <table>
      <thead><tr><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Status</th><th>Opdateret</th></tr></thead>
      <tbody>
        ${oldestOrdersHtml}
      </tbody>
    </table>
  </div>
  ${currentUserId ? `
  <div class="panel">
    <h2>Mine aktive ordrer</h2>
    <table>
      <thead><tr><th>ID</th><th>Rolle</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Status</th><th>Opsamlet</th></tr></thead>
      <tbody>
        ${myActiveOrdersHtml}
      </tbody>
    </table>
  </div>` : ''}
  <div class="panel">
    <h2>Revision</h2>
    <table>
      <thead><tr><th>Tid</th><th>Bruger</th><th>Handling</th><th>Entitet</th><th>ID</th></tr></thead>
      <tbody>
        ${audit.map(a => `<tr><td>${esc(a.ts)}</td><td>${esc(a.user)}</td><td>${esc(a.action)}</td><td>${esc(a.entity)}</td><td>${esc(a.entity_id??'')}</td></tr>`).join('') || '<tr><td colspan="5">Ingen</td></tr>'}
      </tbody>
    </table>
  </div>`;
  const printButton = section.querySelector('#dashboardPrintButton');
  if (printButton) {
    printButton.addEventListener('click', () => {
      openDashboardPrintView(printableMetrics, printableStats);
    });
  }
  applyIconSlots(section);
  applyMetricTooltips(section);
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  if (section._orderClickHandler) {
    section.removeEventListener('click', section._orderClickHandler);
  }
  const handleOrderClick = event => {
    const row = event.target.closest('tr[data-order-id]');
    if (!row || !section.contains(row)) return;
    const orderId = row.dataset.orderId;
    if (!orderId) return;
    openOrderDetails(orderId, {showAll: true});
  };
  section._orderClickHandler = handleOrderClick;
  section.addEventListener('click', handleOrderClick);
}

function openDashboardPrintView(metrics, stats) {
  if (!Array.isArray(metrics) || !Array.isArray(stats)) return;
  const metricsRows = metrics.length
    ? metrics.map(item => `<tr><th scope="row">${esc(item.badge)}</th><td>${esc(String(item.value ?? ''))}</td></tr>`).join('')
    : '<tr><td colspan="2">Ingen data</td></tr>';
  const statsRows = stats.length
    ? stats.map(item => `<tr><th scope="row">${esc(item.label)}</th><td>${esc(String(item.value ?? ''))}</td></tr>`).join('')
    : '<tr><td colspan="2">Ingen data</td></tr>';
  const generatedAt = new Date().toLocaleString('da-DK', {dateStyle: 'long', timeStyle: 'short'});
  const safeGeneratedAt = esc(generatedAt);
  const html = `<!DOCTYPE html>
  <html lang="da">
  <head>
    <meta charset="utf-8">
    <title>GlimR – KPI'er og statistik</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: "Segoe UI", Arial, sans-serif; margin: 2rem; color: #0f172a; background: #ffffff; }
      h1 { margin-top: 0; font-size: 1.75rem; }
      h2 { margin-top: 2rem; font-size: 1.2rem; }
      table { width: 100%; border-collapse: collapse; margin-top: 0.75rem; }
      th, td { text-align: left; padding: 0.6rem 0.75rem; border-bottom: 1px solid #d0d7e1; font-size: 1rem; }
      th { width: 55%; font-weight: 600; }
      .print-meta { color: #475569; margin-top: 0.5rem; font-size: 0.95rem; }
      @media print {
        body { margin: 1.5cm; }
        .print-meta { font-size: 0.85rem; }
      }
    </style>
  </head>
  <body>
    <h1>GlimR – KPI'er og statistik</h1>
    <p class="print-meta">Genereret ${safeGeneratedAt}</p>
    <section>
      <h2>KPI'er</h2>
      <table>
        <tbody>
          ${metricsRows}
        </tbody>
      </table>
    </section>
    <section>
      <h2>Statistik</h2>
      <table>
        <tbody>
          ${statsRows}
        </tbody>
      </table>
    </section>
  </body>
  </html>`;
  let printWindow = null;
  try {
    printWindow = window.open('about:blank', 'glimr-dashboard-print', 'popup=yes,width=900,height=700');
  } catch (error) {
    printWindow = null;
  }
  if (printWindow && !printWindow.closed) {
    const doc = printWindow.document;
    doc.open('text/html');
    doc.write(html);
    doc.close();
    printWindow.focus();
    setTimeout(() => {
      try {
        printWindow.print();
      } catch (err) {
        console.error('Udskrivning mislykkedes', err);
      }
    }, 50);
    return;
  }
  const iframe = document.createElement('iframe');
  iframe.setAttribute('title', 'Udskriftsvisning af KPI\'er og statistik');
  iframe.setAttribute('aria-hidden', 'true');
  iframe.style.position = 'fixed';
  iframe.style.width = '0';
  iframe.style.height = '0';
  iframe.style.border = '0';
  iframe.style.visibility = 'hidden';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument;
  if (!iframeDoc) {
    iframe.remove();
    return;
  }
  iframeDoc.open('text/html');
  iframeDoc.write(html);
  iframeDoc.close();
  const iframeWindow = iframe.contentWindow;
  if (!iframeWindow) {
    iframe.remove();
    return;
  }
  setTimeout(() => {
    try {
      iframeWindow.focus();
      iframeWindow.print();
    } catch (err) {
      console.error('Udskrivning mislykkedes', err);
    } finally {
      setTimeout(() => {
        iframe.remove();
      }, 400);
    }
  }, 50);
}

function renderCreateCase(section) {
  const panels = getCached('panels').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const patientGroups = getCached('patient_groups').slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'da'));
  const families = Array.from(new Set(getCached('patients').map(p => (p.family_number || '').trim()).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const familySelectOptions = ['<option value="">Vælg familienummer</option>']
    .concat(families.map(num => `<option value="${esc(num)}">${esc(num)}</option>`))
    .concat('<option value="__custom__">Tilføj nyt familienummer…</option>')
    .join('');
  const familyPlaceholder = getFamilyNumberPlaceholder();
  const panelOptions = panels.length
    ? panels.map(p => `<option value="${p.id}">${esc(p.name || `Panel #${p.id}`)}</option>`).join('')
    : '<option value="" disabled>Ingen paneler tilgængelige</option>';
  const userOptions = users.map(u => `<option value="${u.id}">${esc(u.name || `Bruger #${u.id}`)}</option>`).join('');
  const patientGroupOptions = patientGroups.map(group => `<option value="${group.id}">${esc(group.name || `Patientgruppe #${group.id}`)}</option>`).join('');
  const typeOptions = SAMPLE_TYPES.map(type => `<option value="${type}">${type}</option>`).join('');
  const controlTypeOptions = SAMPLE_TYPES.map(type => {
    const selected = type.toLowerCase() === 'kontrol' ? ' selected' : '';
    return `<option value="${type}"${selected}>${type}</option>`;
  }).join('');
  const statusOptions = SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <h2>Opret komplet sag</h2>
    <form id="createCaseForm" class="case-form">
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Patient</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <div class="inline-group">
            <label class="inline">MRN<input name="patient_mrn" required placeholder="Fx 010170-1234"></label>
            <label class="inline">ID<input name="patient_extra_id" placeholder="Fx intern ID"></label>
            <label class="inline">Navn<input name="patient_name" required placeholder="Patientnavn"></label>
            <label class="inline" for="createCasePatientFamily">Familienummer
              <div class="family-combo">
                <select data-family-select>
                  ${familySelectOptions}
                </select>
                <input id="createCasePatientFamily" name="patient_family" data-family-input placeholder="${esc(familyPlaceholder)}">
                <div class="family-healthy-group">
                  <input type="checkbox" id="createCasePatientHealthy" name="patient_healthy">
                  <label class="family-healthy" for="createCasePatientHealthy">Rask familiemedlem</label>
                </div>
              </div>
            </label>
          </div>
          <div class="inline-group">
            <label class="inline">Køn<select name="patient_gender"><option value="">-</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
            <label class="inline">Fødselsdato<input type="date" name="patient_birth"></label>
          </div>
          <label class="inline">Noter<textarea name="patient_notes" class="small" placeholder="Valgfrit"></textarea></label>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Prøve</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <div class="inline-group">
            <label class="inline">PMB-nummer<input name="sample_pmb" required placeholder="PMB-12345"></label>
            <label class="inline">Prøvetype<select name="sample_type" required><option value="" selected>Vælg type</option>${typeOptions}</select></label>
          </div>
          <div class="inline-group">
            <label class="inline">Status<select name="sample_status" required><option value="" selected>Vælg status</option>${statusOptions}</select></label>
            <label class="inline">Opsamlet<input type="datetime-local" name="sample_collected"></label>
          </div>
          <label class="inline">Noter<textarea name="sample_notes" class="small" placeholder="Valgfrit"></textarea></label>
          <label class="toggle"><input type="checkbox" id="includeControlSample"> Tilføj kontrolprøve</label>
          <div id="controlSampleFields" hidden>
            <div class="inline-group">
              <label class="inline">PMB-nummer<input name="control_pmb" placeholder="PMB-KONTROL"></label>
              <label class="inline">Prøvetype<select name="control_type">${controlTypeOptions}</select></label>
            </div>
            <div class="inline-group">
              <label class="inline">Status<select name="control_status"><option value="" selected>Vælg status</option>${statusOptions}</select></label>
              <label class="inline">Opsamlet<input type="datetime-local" name="control_collected"></label>
            </div>
            <label class="inline">Noter<textarea name="control_notes" class="small" placeholder="Valgfrit"></textarea></label>
          </div>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Ordination</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <div class="inline-group">
            <label class="inline">Panel
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer paneler">
                <select name="order_panel_id" ${panels.length ? 'required' : ''}>
                  <option value="" selected>Vælg panel</option>
                  ${panelOptions}
                </select>
              </div>
            </label>
            <label class="inline">Familietype
              <select name="order_family_type" data-allow-legacy-option>
                ${FAMILY_TYPES.map(type => `<option value="${type.value}"${type.value === 'singleton' ? ' selected' : ''}>${type.label}</option>`).join('')}
              </select>
            </label>
          </div>
          <div class="inline-group">
            <label class="inline">Rekvirent<input name="order_clinician" placeholder="Afdeling/Læge"></label>
            <label class="inline">Patientgruppe
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer patientgrupper">
                <select name="order_patient_group">
                  <option value="" selected>Ingen</option>
                  ${patientGroupOptions}
                </select>
              </div>
            </label>
          </div>
          <div class="inline-group">
            <label class="inline">Analyseansvarlig
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="order_analysis_responsible">
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label class="inline">Tolker
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="order_interpreter">
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
          </div>
          <label>Indikation<textarea name="order_indication" rows="3" placeholder="Beskriv klinisk indikation"></textarea></label>
          <label>HPO-termer<textarea name="order_hpo_terms" class="small" placeholder="HP:0001250; HP:0004321"></textarea></label>
          <label class="toggle"><input type="checkbox" name="order_acute"> Markér ordinationen som akut</label>
          <label class="toggle"><input type="checkbox" name="order_urgent"> Markér ordinationen som haster</label>
          <div class="inline-group">
            <label class="inline">Godkender
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="order_approver">
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label class="inline">Bestilt<input type="datetime-local" name="order_ordered_at"></label>
          </div>
          <p class="form-hint" id="orderStatusPreview">Ordinationsstatus følger prøven: <strong id="orderStatusValue">–</strong></p>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Kvalitetskontrol</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <p class="form-hint">Tilføj QC-målinger for prøven (valgfrit).</p>
          <div id="qcList" class="repeater"></div>
          <button type="button" class="secondary" id="addQcRow">Tilføj måling</button>
        </div>
      </fieldset>
      <fieldset data-collapsible data-collapsed="true">
        <legend>
          <span class="fieldset-title">Varianter</span>
          <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
        </legend>
        <div class="fieldset-body" hidden>
          <p class="form-hint" id="caseVariantHint">Registrer varianter fundet ved analysen. Tomme rækker ignoreres.</p>
          <div id="variantList" class="repeater"></div>
          <div class="btn-row">
            <button type="button" class="secondary" id="addVariantRow">Tilføj variant</button>
            <button type="button" class="secondary" id="caseImportVarSeq">Importér VarSeq CSV</button>
            <input type="file" id="caseImportVarSeqInput" accept=".csv,text/csv" hidden>
          </div>
        </div>
      </fieldset>
      <div class="btn-row">
        <button type="submit" class="primary" id="createCaseSubmit">Opret sag</button>
        <button type="reset" class="secondary" id="createCaseReset">Ryd formular</button>
      </div>
    </form>
    <div id="createCaseMessage" class="form-hint" role="status" aria-live="polite"></div>
  </div>`;
  const form = section.querySelector('#createCaseForm');
  const message = section.querySelector('#createCaseMessage');
  if (!form) return;
  const controlToggle = form.querySelector('#includeControlSample');
  const controlFields = form.querySelector('#controlSampleFields');
  const controlTypeSelect = form.elements.control_type;
  const controlStatusSelect = form.elements.control_status;
  const sampleStatusSelect = form.elements.sample_status;
  const orderedAtInput = form.elements.order_ordered_at;
  const orderAcuteToggle = form.elements.order_acute;
  const orderUrgentToggle = form.elements.order_urgent;
  const addQcBtn = section.querySelector('#addQcRow');
  const qcList = section.querySelector('#qcList');
  const addVariantBtn = section.querySelector('#addVariantRow');
  const importVariantBtn = section.querySelector('#caseImportVarSeq');
  const importVariantInput = section.querySelector('#caseImportVarSeqInput');
  const variantList = section.querySelector('#variantList');
  const submitBtn = section.querySelector('#createCaseSubmit');
  const resetBtn = section.querySelector('#createCaseReset');
  const statusPreviewValue = section.querySelector('#orderStatusValue');
  const enforcePrioritySelection = setupExclusivePriorityControls(orderAcuteToggle, orderUrgentToggle);
  const setMessage = (text, tone = 'info') => {
    if (!message) return;
    message.textContent = text;
    const color = tone === 'success' ? 'var(--accent-strong)' : tone === 'error' ? 'var(--danger)' : 'var(--muted-text)';
    message.style.color = color;
  };
  const toLocalDateTimeValue = (date = new Date()) => {
    const pad = value => String(value).padStart(2, '0');
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
  };
  const disableButtons = disabled => {
    if (submitBtn) submitBtn.disabled = disabled;
    if (resetBtn) resetBtn.disabled = disabled;
  };
  const updateControlVisibility = () => {
    if (!controlFields) return;
    const enabled = Boolean(controlToggle?.checked);
    controlFields.hidden = !enabled;
    controlFields.querySelectorAll('input, select, textarea').forEach(el => {
      el.disabled = !enabled;
    });
    if (enabled) {
      if (controlTypeSelect && !controlTypeSelect.value) {
        const defaultType = SAMPLE_TYPES.find(type => type.toLowerCase() === 'kontrol') || SAMPLE_TYPES[0] || '';
        if (defaultType) controlTypeSelect.value = defaultType;
      }
      if (controlStatusSelect && !controlStatusSelect.value && sampleStatusSelect) {
        controlStatusSelect.value = sampleStatusSelect.value;
      }
    }
  };
  const updateStatusPreview = () => {
    const value = sampleStatusSelect?.value || '';
    if (statusPreviewValue) statusPreviewValue.textContent = value || '–';
    if (controlStatusSelect && controlToggle?.checked && !controlStatusSelect.value) {
      controlStatusSelect.value = value;
    }
  };
  controlToggle?.addEventListener('change', updateControlVisibility);
  sampleStatusSelect?.addEventListener('change', updateStatusPreview);
  const addQcRow = (values = {}) => {
    if (!qcList) return;
    const row = document.createElement('div');
    row.className = 'case-row qc-row';
    const metricOptions = buildQcPresetOptions('metric', values.metric, 'Vælg måling');
    const unitOptions = buildQcPresetOptions('unit', values.unit, 'Vælg enhed');
    row.innerHTML = `
      <label class="inline">Måling<select data-field="metric">${metricOptions}</select></label>
      <label class="inline">Værdi<input type="number" step="0.0001" data-field="value" placeholder="42.0"></label>
      <label class="inline">Enhed<select data-field="unit">${unitOptions}</select></label>
      <label class="inline wide">Noter<input type="text" data-field="notes" placeholder="Valgfrit"></label>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const metricInput = row.querySelector('[data-field="metric"]');
    const valueInput = row.querySelector('[data-field="value"]');
    const unitInput = row.querySelector('[data-field="unit"]');
    const notesInput = row.querySelector('[data-field="notes"]');
    if (metricInput) metricInput.value = values.metric || '';
    if (valueInput) valueInput.value = values.value != null ? values.value : '';
    if (unitInput) unitInput.value = values.unit || '';
    if (notesInput) notesInput.value = values.notes || '';
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern denne måling');
    qcList.appendChild(row);
    applyButtonTooltips(row);
  };
  const addVariantRow = (values = {}) => {
    if (!variantList) return;
    const defaultClass = values.classification != null ? String(values.classification) : '3';
    const classificationOptions = ['1','2','3','4','5'].map(v => `<option value="${v}"${defaultClass === String(v) ? ' selected' : ''}>${v}</option>`).join('');
    const row = document.createElement('div');
    row.className = 'case-row variant-row';
    row.innerHTML = `
      <label class="inline">Varianttype<select data-field="variant_type">${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}</select></label>
      <label class="inline">Gen / region<input type="text" data-field="gene" data-type-required="snv" placeholder="BRCA1"></label>
      <div class="variant-batch-group variant-field-group" data-variant-types="snv">
        <label class="inline">Transkript<input type="text" data-field="transcript" data-type-required="snv" placeholder="NM_007294.3"></label>
        <label class="inline">HGVS c.<input type="text" data-field="hgvs_c" data-type-required="snv" placeholder="c.5266dupC"></label>
        <label class="inline">HGVS p.<input type="text" data-field="hgvs_p" placeholder="p.(Gln1756Profs*74)"></label>
        <label class="inline">Genomisk position<input type="text" data-field="genomic_position" placeholder="chr19-11105362"></label>
        <label class="inline">dbSNP rsID<input type="text" data-field="rsid" placeholder="rs123456"></label>
        <label class="inline">Zygositet<input type="text" data-field="zygosity" placeholder="Heterozygot"></label>
      </div>
      <div class="variant-batch-group variant-field-group" data-variant-types="cnv sv cyto">
        <div class="variant-structure-grid">
          <label class="inline">Genom ref.<input type="text" data-field="genome_build" placeholder="GRCh38"></label>
          <label class="inline">Kromosom<input type="text" data-field="chromosome" placeholder="17p"></label>
          <label class="inline">Start<input type="text" data-field="start" placeholder="16287000"></label>
          <label class="inline">Slut<input type="text" data-field="end" placeholder="21100000"></label>
          <label class="inline">Kopital<input type="text" data-field="copy_number" placeholder="x1"></label>
          <label class="inline">Strukturtype<select data-field="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
          <label class="inline">Størrelse<input type="text" data-field="size_bp" placeholder="4.8 Mb"></label>
        </div>
        <label class="inline wide">ISCN<textarea class="small" data-field="iscn" placeholder="arr[GRCh38] 17p11.2p12(16287000_21100000)x1"></textarea></label>
        <label class="inline wide">Berørte gener<textarea class="small" data-field="affected_genes" placeholder="RAI1; PMP22"></textarea></label>
      </div>
      <label class="inline wide">Beskrivelse<textarea class="small" data-field="description" placeholder="Fri tekst"></textarea></label>
      <label class="inline">ACMG<select data-field="classification">${classificationOptions}</select></label>
      <label class="inline">Kriterier<input type="text" data-field="criteria" placeholder="PM1,PP3"></label>
      <label class="inline">VAF<input type="number" step="0.0001" data-field="af" placeholder="0,500"></label>
      <label class="inline wide">Annoteringer<textarea class="small" data-field="annotations" placeholder="VarSeq-annoteringer og noter"></textarea></label>
      <label class="inline wide">Tolkning<textarea class="small" data-field="interpretation" placeholder="Kort tolkning"></textarea></label>
      <button type="button" class="secondary case-choose-library">Vælg fra bibliotek</button>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const setValue = (selector, value) => {
      const el = row.querySelector(selector);
      if (!el) return;
      if (selector.includes('sv_subtype') && el.tagName === 'SELECT') {
        const normalized = normalizeStructureTypeValue(value);
        const asString = normalized ? String(normalized) : '';
        if (el.dataset.allowLegacyOption !== undefined && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
          const opt = document.createElement('option');
          opt.value = asString;
          opt.textContent = getStructureTypeLabel(asString);
          opt.dataset.legacy = 'true';
          el.appendChild(opt);
        }
        el.value = asString;
        return;
      }
      if (selector.includes('rsid')) {
        el.value = normalizeRsId(value);
        return;
      }
      el.value = value || '';
    };
    setValue('[data-field="variant_type"]', normalizeVariantType(values.variant_type));
    setValue('[data-field="gene"]', values.gene);
    setValue('[data-field="transcript"]', values.transcript);
    setValue('[data-field="hgvs_c"]', values.hgvs_c);
    setValue('[data-field="hgvs_p"]', values.hgvs_p);
    setValue('[data-field="rsid"]', values.rsid || getVariantRsId(values));
    setValue('[data-field="zygosity"]', values.zygosity);
    setValue('[data-field="criteria"]', values.criteria);
    setValue('[data-field="genome_build"]', values.genome_build);
    setValue('[data-field="chromosome"]', values.chromosome);
    setValue('[data-field="start"]', values.start);
    setValue('[data-field="end"]', values.end);
    setValue('[data-field="copy_number"]', values.copy_number);
    setValue('[data-field="sv_subtype"]', values.sv_subtype);
    setValue('[data-field="size_bp"]', values.size_bp);
    setValue('[data-field="iscn"]', values.iscn);
    setValue('[data-field="affected_genes"]', values.affected_genes);
    setValue('[data-field="description"]', values.description);
    const afField = row.querySelector('[data-field="af"]');
    if (afField) {
      if (values.af !== undefined && values.af !== null && values.af !== '') {
        afField.value = values.af;
      } else {
        afField.value = '';
      }
    }
    const interpretationField = row.querySelector('[data-field="interpretation"]');
    if (interpretationField) interpretationField.value = values.interpretation || '';
    const annotationsField = row.querySelector('[data-field="annotations"]');
    if (annotationsField) annotationsField.value = values.annotations || '';
    const {updateVariantTypeFields} = setupVariantTypeForm(row, {
      defaultType: row.querySelector('[data-field="variant_type"]')?.value || 'snv',
      disableInactiveGroups: true
    });
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern varianten fra oprettelsen.');
    const libraryBtn = row.querySelector('.case-choose-library');
    libraryBtn?.addEventListener('click', () => {
      openVariantLibraryPicker(variant => {
        setValue('[data-field="variant_type"]', normalizeVariantType(variant.variant_type));
        setValue('[data-field="gene"]', variant.gene);
        setValue('[data-field="transcript"]', variant.transcript);
        setValue('[data-field="hgvs_c"]', variant.hgvs_c);
        setValue('[data-field="hgvs_p"]', variant.hgvs_p);
        setValue('[data-field="genomic_position"]', variant.genomic_position);
        setValue('[data-field="rsid"]', getVariantRsId(variant));
        setValue('[data-field="zygosity"]', variant.zygosity);
        setValue('[data-field="criteria"]', variant.criteria);
        setValue('[data-field="genome_build"]', variant.genome_build);
        setValue('[data-field="chromosome"]', variant.chromosome);
        setValue('[data-field="start"]', variant.start);
        setValue('[data-field="end"]', variant.end);
        setValue('[data-field="copy_number"]', variant.copy_number);
        setValue('[data-field="sv_subtype"]', variant.sv_subtype);
        setValue('[data-field="size_bp"]', variant.size_bp);
        setValue('[data-field="iscn"]', variant.iscn);
        setValue('[data-field="affected_genes"]', variant.affected_genes);
        setValue('[data-field="description"]', variant.description);
        const classField = row.querySelector('[data-field="classification"]');
        if (classField && variant.classification != null && variant.classification !== '') {
          classField.value = String(variant.classification);
        }
        const interpretationField = row.querySelector('[data-field="interpretation"]');
        if (interpretationField) interpretationField.value = variant.evidence || variant.interpretation || '';
        const annotationsField = row.querySelector('[data-field="annotations"]');
        if (annotationsField) annotationsField.value = variant.annotations || variant.annotation_summary || '';
        updateVariantTypeFields();
      });
    });
    if (libraryBtn) setTooltip(libraryBtn, 'Vælg en variant fra biblioteket.');
    variantList.appendChild(row);
    applyButtonTooltips(row);
    const genomicField = row.querySelector('[data-field="genomic_position"]');
    if (genomicField) setTooltip(genomicField, tooltipCatalog.forms.variantForm.genomic_position);
    const rsidField = row.querySelector('[data-field="rsid"]');
    if (rsidField) setTooltip(rsidField, tooltipCatalog.forms.variantForm.rsid);
    const subtypeSelect = row.querySelector('[data-field="sv_subtype"]');
    if (subtypeSelect) setTooltip(subtypeSelect, tooltipCatalog.forms.variantForm.sv_subtype);
  };
  const isVariantRowEmpty = row => {
    if (!row) return true;
    const get = field => {
      const el = row.querySelector(`[data-field="${field}"]`);
      if (!el) return '';
      if (el.disabled) return '';
      const group = el.closest('[data-variant-types]');
      if (group && (group.hidden || group.classList.contains('variant-type-hidden'))) {
        return '';
      }
      if (el.type === 'number') return el.value.trim();
      return (el.value || '').trim();
    };
    const gene = get('gene');
    const transcript = get('transcript');
    const hgvsC = get('hgvs_c');
    const hgvsP = get('hgvs_p');
    const genomicPosition = get('genomic_position');
    const rsid = get('rsid');
    const zygosity = get('zygosity');
    const criteria = get('criteria');
    const af = get('af');
    const interpretation = get('interpretation');
    const annotations = get('annotations');
    const genomeBuild = get('genome_build');
    const chromosome = get('chromosome');
    const start = get('start');
    const end = get('end');
    const copyNumber = get('copy_number');
    const svSubtype = get('sv_subtype');
    const sizeBp = get('size_bp');
    const iscn = get('iscn');
    const description = get('description');
    const affectedGenes = get('affected_genes');
    return !gene && !transcript && !hgvsC && !hgvsP && !genomicPosition && !rsid && !zygosity && !criteria && !af && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
  };
  const removeEmptyVariantRows = () => {
    if (!variantList) return;
    const rows = Array.from(variantList.querySelectorAll('.variant-row'));
    if (!rows.length) return;
    const filled = rows.filter(row => !isVariantRowEmpty(row));
    if (!filled.length) {
      variantList.innerHTML = '';
      return;
    }
    rows.forEach(row => {
      if (isVariantRowEmpty(row)) row.remove();
    });
  };
  addQcBtn?.addEventListener('click', () => addQcRow());
  addVariantBtn?.addEventListener('click', () => addVariantRow());
  importVariantBtn?.addEventListener('click', () => importVariantInput?.click());
  importVariantInput?.addEventListener('change', async () => {
    const file = importVariantInput?.files?.[0];
    if (!file) return;
    try {
      const {variants: importedVariants, warnings, summary} = await parseVarSeqFile(file);
      if (!importedVariants.length) {
        setMessage('Ingen varianter blev fundet i filen.', 'error');
        return;
      }
      removeEmptyVariantRows();
      importedVariants.forEach(variant => addVariantRow(variant));
      const parts = [`Tilføjede ${importedVariants.length} varianter fra ${file.name}.`];
      if (summary.skipped) parts.push(`${summary.skipped} rækker blev ignoreret.`);
      if (warnings.length) parts.push(`${warnings.length} advarsler blev logget i konsollen.`);
      const messageText = parts.join(' ');
      setMessage(messageText, 'success');
      setStatus(`VarSeq import til oprettelse: ${importedVariants.length} varianter klar.`);
      if (warnings.length) console.warn('VarSeq import advarsler', warnings);
    } catch (err) {
      console.error(err);
      setMessage('Kunne ikke importere VarSeq CSV: ' + (err?.message || err), 'error');
    } finally {
      if (importVariantInput) importVariantInput.value = '';
    }
  });
  addQcRow();
  addVariantRow();
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  initCollapsibleFieldsets(form);
  initFamilyCombos(form);
  applySelectFilters(section);
  updateControlVisibility();
  updateStatusPreview();
  if (orderedAtInput && !orderedAtInput.value) {
    orderedAtInput.value = toLocalDateTimeValue();
  }
  form.addEventListener('reset', () => {
    setTimeout(() => {
      setMessage('');
      updateControlVisibility();
      updateStatusPreview();
      enforcePrioritySelection();
      if (qcList) {
        qcList.innerHTML = '';
        addQcRow();
      }
      if (variantList) {
        variantList.innerHTML = '';
        addVariantRow();
      }
      if (orderedAtInput) orderedAtInput.value = toLocalDateTimeValue();
    }, 0);
  });
  let submitting = false;
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (submitting) return;
    submitting = true;
    disableButtons(true);
    setMessage('');
    const patientMrn = form.elements.patient_mrn.value.trim();
    if (!patientMrn) {
      setMessage('Angiv patientens MRN.', 'error');
      form.elements.patient_mrn.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const patientName = form.elements.patient_name.value.trim();
    if (!patientName) {
      setMessage('Angiv patientens navn.', 'error');
      form.elements.patient_name.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const patient = {
      mrn: patientMrn,
      extra_id: form.elements.patient_extra_id?.value.trim() || '',
      family_number: form.elements.patient_family?.value.trim() || '',
      healthy_family_member: Boolean(form.elements.patient_healthy?.checked),
      name: patientName,
      gender: form.elements.patient_gender.value || '',
      birth_date: form.elements.patient_birth.value || '',
      notes: form.elements.patient_notes.value.trim()
    };
    const samplePmb = form.elements.sample_pmb.value.trim();
    if (!samplePmb) {
      setMessage('Angiv et PMB-nummer for prøven.', 'error');
      form.elements.sample_pmb.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sampleTypeValue = form.elements.sample_type.value.trim();
    if (!sampleTypeValue) {
      setMessage('Vælg prøvetype.', 'error');
      form.elements.sample_type.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sampleStatusValue = form.elements.sample_status.value.trim();
    if (!sampleStatusValue) {
      setMessage('Vælg prøvens status.', 'error');
      form.elements.sample_status.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sample = {
      pmb_number: samplePmb,
      sample_type: sampleTypeValue,
      status: sampleStatusValue,
      collected_at: form.elements.sample_collected.value || '',
      notes: form.elements.sample_notes.value.trim()
    };
    let controlSample = null;
    if (controlToggle?.checked) {
      const controlPmb = form.elements.control_pmb.value.trim();
      if (!controlPmb) {
        setMessage('Angiv PMB-nummer for kontrolprøven.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
      const controlTypeValue = (form.elements.control_type?.value || '').trim();
      const controlStatusValue = (form.elements.control_status?.value || '').trim();
      controlSample = {
        pmb_number: controlPmb,
        sample_type: controlTypeValue || (SAMPLE_TYPES.find(type => type.toLowerCase() === 'kontrol') || sample.sample_type),
        status: controlStatusValue || sample.status,
        collected_at: form.elements.control_collected.value || '',
        notes: form.elements.control_notes.value.trim()
      };
    }
    const panelIdValue = form.elements.order_panel_id.value;
    if (!panelIdValue) {
      setMessage('Vælg panel til ordinationen.', 'error');
      form.elements.order_panel_id.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    let orderedAt = form.elements.order_ordered_at.value;
    if (!orderedAt) orderedAt = toLocalDateTimeValue();
    const orderIndication = form.elements.order_indication.value.trim();
    const orderHpoTerms = normalizeHpoTerms(form.elements.order_hpo_terms.value);
    enforcePrioritySelection();
    const isAcute = Boolean(orderAcuteToggle?.checked);
    const isUrgent = !isAcute && Boolean(orderUrgentToggle?.checked);
    const orderFamilyType = normalizeFamilyType(form.elements.order_family_type?.value || 'singleton');
    const order = {
      panel_id: Number(panelIdValue),
      analysis_responsible_id: form.elements.order_analysis_responsible.value ? Number(form.elements.order_analysis_responsible.value) : null,
      interpreter_id: form.elements.order_interpreter.value ? Number(form.elements.order_interpreter.value) : null,
      approver_id: form.elements.order_approver.value ? Number(form.elements.order_approver.value) : null,
      clinician: form.elements.order_clinician.value.trim(),
      indication: orderIndication,
      patient_group_id: form.elements.order_patient_group.value ? Number(form.elements.order_patient_group.value) : null,
      family_type: orderFamilyType,
      hpo_terms: orderHpoTerms,
      status: sample.status,
      acute: isAcute,
      urgent: isUrgent,
      ordered_at: orderedAt
    };
    const qcEntries = [];
    if (qcList) {
      for (const row of qcList.querySelectorAll('.qc-row')) {
        const metric = row.querySelector('[data-field="metric"]')?.value.trim() || '';
        const value = row.querySelector('[data-field="value"]')?.value.trim() || '';
        const unit = row.querySelector('[data-field="unit"]')?.value.trim() || '';
        const notes = row.querySelector('[data-field="notes"]')?.value.trim() || '';
        if (!metric && !value && !unit && !notes) continue;
        if (!metric || !value) {
          setMessage('Angiv både måling og værdi for QC-poster.', 'error');
          row.querySelector('[data-field="metric"]')?.focus();
          disableButtons(false);
          submitting = false;
          return;
        }
        qcEntries.push({metric, value, unit, notes});
      }
    }
    const variantEntries = [];
    if (variantList) {
      for (const row of variantList.querySelectorAll('.variant-row')) {
        const variantType = normalizeVariantType(row.querySelector('[data-field="variant_type"]')?.value || 'snv');
        const getFieldValue = fieldName => {
          const el = row.querySelector(`[data-field="${fieldName}"]`);
          if (!el) return '';
          if (el.disabled) return '';
          const group = el.closest('[data-variant-types]');
          if (group && (group.hidden || group.classList.contains('variant-type-hidden'))) {
            return '';
          }
          if (el.type === 'number') {
            return el.value.trim();
          }
          return (el.value || '').trim();
        };
        const gene = getFieldValue('gene');
        const transcript = getFieldValue('transcript');
        const hgvsC = getFieldValue('hgvs_c');
        const hgvsP = getFieldValue('hgvs_p');
        const genomicPosition = getFieldValue('genomic_position');
        const rsid = getFieldValue('rsid');
        const zygosity = getFieldValue('zygosity');
        const classification = row.querySelector('[data-field="classification"]')?.value || '3';
        const criteria = getFieldValue('criteria');
        const afRaw = getFieldValue('af');
        const interpretation = getFieldValue('interpretation');
        const annotations = getFieldValue('annotations');
        const genomeBuild = getFieldValue('genome_build');
        const chromosome = getFieldValue('chromosome');
        const start = getFieldValue('start');
        const end = getFieldValue('end');
        const copyNumber = getFieldValue('copy_number');
        const svSubtype = normalizeStructureTypeValue(getFieldValue('sv_subtype'));
        const sizeBp = getFieldValue('size_bp');
        const iscn = getFieldValue('iscn');
        const description = getFieldValue('description');
        const affectedGenes = getFieldValue('affected_genes');
        const isEmpty = !gene && !transcript && !hgvsC && !hgvsP && !genomicPosition && !rsid && !zygosity && !criteria && !afRaw && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
        if (isEmpty) continue;
        if (variantType === 'snv') {
          if (!gene) {
            setMessage('Angiv gen for hver SNV/indel.', 'error');
            row.querySelector('[data-field="gene"]')?.focus();
            disableButtons(false);
            submitting = false;
            return;
          }
        } else {
          if (!iscn && !description && !chromosome) {
            setMessage('Angiv ISCN, kromosom eller beskrivelse for strukturelle varianter.', 'error');
            (row.querySelector('[data-field="iscn"]') || row.querySelector('[data-field="description"]') || row.querySelector('[data-field="chromosome"]'))?.focus();
            disableButtons(false);
            submitting = false;
            return;
          }
        }
        const variant = {
          variant_type: variantType,
          gene,
          transcript,
          hgvs_c: hgvsC,
          hgvs_p: hgvsP,
          genomic_position: genomicPosition,
          rsid: normalizeRsId(rsid),
          zygosity,
          classification: String(classification || '3'),
          criteria,
          interpretation,
          genome_build: genomeBuild,
          chromosome,
          start,
          end,
          copy_number: copyNumber,
          sv_subtype: svSubtype,
          size_bp: sizeBp,
          iscn,
          description,
          affected_genes: affectedGenes
        };
        if (afRaw) {
          const afNumber = Number(afRaw);
          if (!Number.isFinite(afNumber)) {
            setMessage('VAF skal være et tal.', 'error');
            row.querySelector('[data-field="af"]')?.focus();
            disableButtons(false);
            submitting = false;
            return;
          }
          variant.af = afNumber;
        }
        if (annotations) {
          variant.annotations = annotations;
        }
        variantEntries.push(variant);
      }
    }
    const requiredStores = new Set(['patients','samples','orders']);
    if (qcEntries.length) requiredStores.add('qc');
    if (variantEntries.length) requiredStores.add('variants');
    for (const store of requiredStores) {
      if (!ensureWrite(store)) {
        setMessage('Handling kræver skriveadgang. Kontakt en administrator.', 'error');
        disableButtons(false);
        submitting = false;
        return;
      }
    }
    const existingSamples = getCached('samples');
    const primaryPmbLower = sample.pmb_number.toLowerCase();
    if (existingSamples.some(s => (s.pmb_number || '').toLowerCase() === primaryPmbLower)) {
      setMessage('PMB-nummeret for hovedprøven er allerede i brug.', 'error');
      form.elements.sample_pmb.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    if (controlSample) {
      const controlPmbLower = controlSample.pmb_number.toLowerCase();
      if (controlPmbLower === primaryPmbLower) {
        setMessage('Kontrolprøven skal have et andet PMB-nummer end hovedprøven.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
      if (existingSamples.some(s => (s.pmb_number || '').toLowerCase() === controlPmbLower)) {
        setMessage('Kontrolprøvens PMB-nummer er allerede i brug.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
    }
    try {
      setMessage('Opretter sag...', 'info');
      const patientId = await addRecord('patients', patient);
      const sampleId = await addRecord('samples', {...sample, patient_id: patientId});
      if (controlSample) {
        await addRecord('samples', {...controlSample, patient_id: patientId});
      }
      const orderId = await addRecord('orders', {...order, patient_id: patientId, sample_id: sampleId});
      for (const qc of qcEntries) {
        await addRecord('qc', {...qc, sample_id: sampleId});
      }
      for (const variant of variantEntries) {
        await addRecord('variants', {...variant, order_id: orderId});
      }
      form.reset();
      setMessage(`Sag ${orderId} oprettet for ${patient.name} med PMB ${sample.pmb_number}.`, 'success');
      setStatus(`Sag ${orderId} oprettet for ${patient.name}.`);
      const dashboardSection = document.querySelector('section[data-tab="dashboard"]');
      if (dashboardSection) renderDashboard(dashboardSection);
      ['patients','samples','orders','qc','variants'].forEach(id => {
        const target = document.querySelector(`section[data-tab="${id}"]`);
        if (target && target.classList.contains('active')) {
          renderTab(id);
        }
      });
    } catch (err) {
      console.error(err);
      setMessage('Kunne ikke oprette sag: ' + (err?.message || err), 'error');
      setStatus('Fejl under oprettelse: ' + (err?.message || err));
    } finally {
      disableButtons(false);
      submitting = false;
    }
  });
  if (!panels.length) {
    setMessage('Opret først et panel under "Paneler" for at kunne oprette en sag.', 'error');
    disableButtons(true);
  } else {
    setMessage('');
    disableButtons(false);
  }
}
function getName(store, id) {
  if (!id) return '';
  const row = findById(store, typeof id === 'string' ? Number(id) : id);
  if (!row) return '';
  if (store === 'patients') {
    const name = row.name || '';
    const details = [row.mrn, row.extra_id, row.family_number].filter(Boolean).join(' • ');
    if (name && details) return `${name} (${details})`;
    if (name) return name;
    if (details) return details;
  }
  return row.pmb_number || row.name || row.mrn || row.extra_id || `#${id}`;
}

function getPatientGroupName(id) {
  if (!id) return '';
  const numericId = typeof id === 'string' ? Number(id) : id;
  if (!Number.isFinite(numericId) || numericId <= 0) return '';
  const group = findById('patient_groups', numericId);
  return group?.name || '';
}

async function ensureDefaultPatientGroups() {
  const existing = getCached('patient_groups');
  if (existing && existing.length) return;
  for (const name of DEFAULT_PATIENT_GROUPS) {
    await addRecord('patient_groups', {name});
  }
  await loadStore('patient_groups');
}

async function ensureDefaultQcPresets() {
  const existing = getCached('qc_presets');
  if (existing && existing.length) return;
  for (const [kind, values] of [
    ['metric', DEFAULT_QC_METRICS],
    ['unit', DEFAULT_QC_UNITS]
  ]) {
    for (const [index, value] of values.entries()) {
      const trimmed = String(value ?? '').trim();
      if (!trimmed) continue;
      await addRecord('qc_presets', {kind, value: trimmed, sort_order: index});
    }
  }
  await loadStore('qc_presets');
}

async function ensureDefaultFhirTemplates() {
  const existing = getCached('fhir_templates');
  if (existing && existing.length) return;
  for (const template of DEFAULT_FHIR_TEMPLATES) {
    await addRecord('fhir_templates', {...template});
  }
  await loadStore('fhir_templates');
}
function creationKey(entity, id) {
  if (!entity || id === undefined || id === null) return null;
  return `${entity}:${id}`;
}
function rebuildCreationLookup() {
  const auditEntries = getCached('audit') || [];
  const map = new Map();
  for (const entry of auditEntries) {
    if (!entry || entry.action !== 'CREATE') continue;
    const key = creationKey(entry.entity, entry.entity_id);
    if (!key || map.has(key)) continue;
    let creator = entry.user || '';
    if ((!creator || creator === 'System') && entry.after) {
      try {
        const after = JSON.parse(entry.after);
        if (after?.created_by) creator = after.created_by;
      } catch (err) {
        /* ignore parse errors */
      }
    }
    if (creator) {
      map.set(key, creator);
    }
  }
  state.creationLookup = map;
}
function determineCreatedBy(store, record) {
  if (!record) return 'Ukendt';
  if (record.created_by) return record.created_by;
  const key = creationKey(store, record.id);
  if (key && state.creationLookup?.has(key)) {
    return state.creationLookup.get(key) || 'Ukendt';
  }
  return 'Ukendt';
}
function cloneWithCreatedBy(store, rows) {
  if (!Array.isArray(rows)) return [];
  if (!CREATED_BY_STORES.has(store)) {
    return rows.map(row => ({...row}));
  }
  return rows.map(row => {
    const clone = {...row};
    const creator = determineCreatedBy(store, row);
    if (creator && creator !== clone.created_by) {
      clone.created_by = creator;
    }
    return clone;
  });
}
async function ensureCreationMetadata() {
  if (!state.db) return;
  const stores = Array.from(CREATED_BY_STORES);
  const toReload = [];
  for (const store of stores) {
    const list = getCached(store) || [];
    const pending = [];
    for (const row of list) {
      if (!row) continue;
      const creator = determineCreatedBy(store, row);
      if (creator && creator !== 'Ukendt' && creator !== row.created_by) {
        pending.push({...row, created_by: creator});
      }
    }
    if (!pending.length) continue;
    const tx = state.db.transaction(store, 'readwrite');
    const objectStore = tx.objectStore(store);
    for (const record of pending) {
      objectStore.put(record);
    }
    await tx.done?.catch(() => {});
    toReload.push(store);
  }
  if (toReload.length) {
    for (const store of toReload) {
      await loadStore(store);
    }
  }
}
function fillForm(form, record) {
  if (!form || !record) return;
  Array.from(form.elements).forEach(el => {
    if (!el.name) return;
    if (!(el.name in record)) {
      return;
    }
    let value = record[el.name];
    if (el.name === 'sv_subtype') {
      value = normalizeStructureTypeValue(value);
    }
    if (el.type === 'checkbox') {
      el.checked = Boolean(value);
      return;
    }
    if (el.type === 'password') {
      el.value = '';
      return;
    }
    if (el.tagName === 'SELECT') {
      const asString = value == null ? '' : String(value);
      if (el.name === 'role' && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
        const opt = document.createElement('option');
        opt.value = asString;
        opt.textContent = roleWithDescription(asString);
        opt.dataset.legacy = 'true';
        el.appendChild(opt);
      }
      if (el.dataset.allowLegacyOption !== undefined && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
        const opt = document.createElement('option');
        opt.value = asString;
        opt.textContent = el.name === 'sv_subtype' ? getStructureTypeLabel(asString) : asString;
        opt.dataset.legacy = 'true';
        el.appendChild(opt);
      }
      el.value = asString;
      return;
    }
    el.value = value ?? '';
    if (el.dataset.familyInput !== undefined) {
      el.dispatchEvent(new Event('input', {bubbles: false}));
    }
  });
}

function clearFormIdentifier(form, fieldName = 'id') {
  if (!form) return;
  const field = form.elements[fieldName];
  if (!field) return;
  field.value = '';
  if ('defaultValue' in field) {
    field.defaultValue = '';
  }
}
function renderPatients(section) {
  const list = getCached('patients');
  const orders = getCached('orders');
  const patientIndicationSets = new Map();
  for (const order of orders) {
    if (!order) continue;
    const patientId = Number(order.patient_id);
    if (!Number.isFinite(patientId) || patientId <= 0) continue;
    const indication = formatIndicationForList(order.indication);
    if (!indication) continue;
    if (!patientIndicationSets.has(patientId)) {
      patientIndicationSets.set(patientId, new Set());
    }
    patientIndicationSets.get(patientId).add(indication);
  }
  const getPatientIndications = id => {
    const set = patientIndicationSets.get(Number(id));
    if (!set || !set.size) return '';
    return Array.from(set).join(', ');
  };
  const existingFamilyNumbers = Array.from(new Set(list.map(p => (p.family_number || '').trim()).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const familySelectOptions = ['<option value="">Vælg familienummer</option>']
    .concat(existingFamilyNumbers.map(num => `<option value="${esc(num)}">${esc(num)}</option>`))
    .concat('<option value="__custom__">Tilføj nyt familienummer…</option>')
    .join('');
  const familyPlaceholder = getFamilyNumberPlaceholder();
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="patientSearch">Søg</label>
        <input id="patientSearch" type="search" placeholder="Navn/MRN/ID/familie...">
        <details class="advanced-filter" id="patientsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-patients="id" placeholder="Fx 152"></label>
            <label>MRN<input type="search" data-filter-patients="mrn" placeholder="MRN eller CPR"></label>
            <label>ID<input type="search" data-filter-patients="extra" placeholder="Fx lokalt ID"></label>
            <label>Familienummer<input type="search" data-filter-patients="family" placeholder="${esc(familyPlaceholder)}"></label>
            <label>Navn<input type="search" data-filter-patients="name" placeholder="Patientnavn"></label>
            <label>Køn<select data-filter-patients="gender"><option value="">Alle</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
            <label>Fødselsår<input type="search" data-filter-patients="birth" placeholder="ÅÅÅÅ"></label>
            <label>Indikation<input type="search" data-filter-patients="indication" placeholder="Indikation"></label>
          </div>
        </details>
        <div class="filter-banner" id="patientVariantFilterNotice" data-visible="false" hidden>
          <span data-variant-filter-text></span>
          <button type="button" class="secondary" id="patientVariantFilterClear">Ryd variantfilter</button>
        </div>
        <table id="patientsTable"><thead><tr><th>ID</th><th>MRN</th><th>ID</th><th>Familienummer</th><th>Navn</th><th>Køn</th><th>Født</th><th>Indikationer</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="patientsExport">Eksportér filtrerede patienter</button>
        </div>
      </div>
      <div>
        <h2>Patient</h2>
        <form id="patientForm">
          <input type="hidden" name="id">
          <label>MRN<input name="mrn" required></label>
          <label>ID<input name="extra_id" placeholder="Fx lokalt ID"></label>
          <label for="patientFamilyNumber">Familienummer
            <div class="family-combo">
              <select data-family-select>
                ${familySelectOptions}
              </select>
              <input id="patientFamilyNumber" name="family_number" data-family-input placeholder="${esc(familyPlaceholder)}">
              <div class="family-healthy-group">
                <input type="checkbox" id="patientHealthyMember" name="healthy_family_member">
                <label class="family-healthy" for="patientHealthyMember">Rask familiemedlem</label>
              </div>
            </div>
          </label>
          <label>Navn<input name="name" required></label>
          <label>Køn<select name="gender"><option value="">-</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
          <label>Fødselsdato<span class="label-note" data-patient-age hidden></span><input type="date" name="birth_date"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button type="submit" class="primary action-button action-save with-icon">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button type="button" id="patientClear" class="secondary action-button action-new with-icon">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button type="button" id="patientDelete" class="danger action-button action-delete with-icon">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('#patientsTable tbody');
  const form = section.querySelector('#patientForm');
  const searchInput = section.querySelector('#patientSearch');
  const deleteBtn = section.querySelector('#patientDelete');
  const clearBtn = section.querySelector('#patientClear');
  const filterInputs = {
    id: section.querySelector('[data-filter-patients="id"]'),
    mrn: section.querySelector('[data-filter-patients="mrn"]'),
    extra: section.querySelector('[data-filter-patients="extra"]'),
    family: section.querySelector('[data-filter-patients="family"]'),
    name: section.querySelector('[data-filter-patients="name"]'),
    gender: section.querySelector('[data-filter-patients="gender"]'),
    birth: section.querySelector('[data-filter-patients="birth"]'),
    indication: section.querySelector('[data-filter-patients="indication"]')
  };
  const variantFilterNotice = section.querySelector('#patientVariantFilterNotice');
  const variantFilterText = section.querySelector('[data-variant-filter-text]');
  const variantFilterClearButton = section.querySelector('#patientVariantFilterClear');
  if (variantFilterClearButton) {
    setTooltip(variantFilterClearButton, 'Fjern filtreringen på varianten.');
  }
  const birthDateInput = form?.elements.birth_date;
  const ageNote = form?.querySelector('[data-patient-age]');
  const updateAgeNote = () => {
    if (!ageNote) return;
    const ageText = birthDateInput ? formatAgeFromBirthDate(birthDateInput.value) : '';
    if (ageText) {
      ageNote.textContent = `(${ageText})`;
      ageNote.hidden = false;
    } else {
      ageNote.textContent = '';
      ageNote.hidden = true;
    }
  };
  birthDateInput?.addEventListener('input', updateAgeNote);
  let filteredPatients = list.slice();
  let activeFilters = {};
  let selectedPatientId = null;
  let variantFilterKey = null;
  let variantFilterLabel = '';
  let variantFilterPatientIds = null;
  if (state.pendingPatientVariantFilter && state.pendingPatientVariantFilter.key) {
    variantFilterKey = state.pendingPatientVariantFilter.key;
    variantFilterLabel = (state.pendingPatientVariantFilter.label || '').trim();
    const patientIds = getPatientIdsForVariantKey(variantFilterKey);
    variantFilterPatientIds = new Set(patientIds);
    if (searchInput) {
      searchInput.value = '';
    }
    Object.values(filterInputs).forEach(input => {
      if (input) input.value = '';
    });
    if (variantFilterPatientIds.size) {
      const [firstId] = patientIds;
      if (Number.isFinite(firstId)) {
        selectedPatientId = Number(firstId);
      }
    }
  }
  const normalizedVariantFilterLabel = variantFilterLabel || 'den valgte variant';
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  initFamilyCombos(form);
  const genderMap = {male:'Mand', female:'Kvinde', other:'Andet'};
  const updateVariantFilterNotice = (visibleCount = filteredPatients.length) => {
    if (!variantFilterNotice || !variantFilterText) return;
    if (!variantFilterKey) {
      variantFilterNotice.hidden = true;
      variantFilterNotice.dataset.visible = 'false';
      variantFilterText.textContent = '';
      return;
    }
    const registeredCount = variantFilterPatientIds ? variantFilterPatientIds.size : 0;
    const label = normalizedVariantFilterLabel;
    const registeredWord = registeredCount === 1 ? 'patient' : 'patienter';
    const visibleWord = visibleCount === 1 ? 'patient' : 'patienter';
    const messageParts = [`Filtreret på varianten ${label}.`];
    if (registeredCount === 0) {
      messageParts.push('Ingen registrerede patienter har varianten.');
    } else {
      messageParts.push(`Registreret hos ${registeredCount} ${registeredWord}.`);
    }
    if (visibleCount !== registeredCount) {
      if (visibleCount === 0) {
        messageParts.push('Ingen patienter matcher de øvrige filtre.');
      } else {
        messageParts.push(`${visibleCount} ${visibleWord} matcher de aktive filtre.`);
      }
    }
    variantFilterText.textContent = messageParts.join(' ');
    variantFilterNotice.hidden = false;
    variantFilterNotice.dataset.visible = 'true';
  };
  const renderRows = () => {
    const term = searchInput.value.trim().toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      mrn: filterInputs.mrn?.value.trim().toLowerCase() || '',
      extra: filterInputs.extra?.value.trim().toLowerCase() || '',
      family: filterInputs.family?.value.trim().toLowerCase() || '',
      name: filterInputs.name?.value.trim().toLowerCase() || '',
      gender: filterInputs.gender?.value || '',
      birth: filterInputs.birth?.value.trim().toLowerCase() || '',
      indication: filterInputs.indication?.value.trim().toLowerCase() || ''
    };
    const filterSummary = {...filters};
    if (filters.indication) filterSummary.indikation = filters.indication;
    delete filterSummary.indication;
    if (term) filterSummary.fritekst = term;
    if (variantFilterKey) {
      filterSummary.variant = normalizedVariantFilterLabel;
      filterSummary.variant_patienter = variantFilterPatientIds ? `${variantFilterPatientIds.size}` : '0';
    }
    activeFilters = filterSummary;
    filteredPatients = list.filter(p => {
      if (!term) return true;
      const displayGender = genderMap[p.gender];
      const creator = determineCreatedBy('patients', p);
      const indications = getPatientIndications(p.id);
      return [p.name, p.mrn, p.extra_id, p.family_number, p.gender, displayGender, creator, indications].some(v => (v||'').toLowerCase().includes(term));
    }).filter(p => {
      const indicationText = getPatientIndications(p.id).toLowerCase();
      if (filters.id && !String(p.id).includes(filters.id)) return false;
      if (filters.mrn && !(p.mrn||'').toLowerCase().includes(filters.mrn)) return false;
      if (filters.extra && !(p.extra_id||'').toLowerCase().includes(filters.extra)) return false;
      if (filters.family && !(p.family_number||'').toLowerCase().includes(filters.family)) return false;
      if (filters.name && !(p.name||'').toLowerCase().includes(filters.name)) return false;
      if (filters.gender && (p.gender||'') !== filters.gender) return false;
      if (filters.birth && !(p.birth_date||'').toLowerCase().startsWith(filters.birth)) return false;
      if (filters.indication && !indicationText.includes(filters.indication)) return false;
      return true;
    });
    if (variantFilterKey) {
      if (variantFilterPatientIds && variantFilterPatientIds.size) {
        filteredPatients = filteredPatients.filter(p => variantFilterPatientIds.has(Number(p.id)));
      } else {
        filteredPatients = [];
      }
    }
    updateVariantFilterNotice(filteredPatients.length);
    if (selectedPatientId != null && !filteredPatients.some(p => p.id === selectedPatientId)) {
      selectedPatientId = null;
    }
    tbody.innerHTML = filteredPatients.map(p => {
      const gender = genderMap[p.gender] || p.gender || '';
      const createdBy = determineCreatedBy('patients', p);
      const rawBirth = p.birth_date;
      const formattedBirth = formatDanishDate(rawBirth) || (rawBirth || '');
      const ageDisplay = formatAgeFromBirthDate(rawBirth);
      const birthDisplay = formattedBirth && ageDisplay ? `${formattedBirth} (${ageDisplay})` : formattedBirth;
      const indicationsList = getPatientIndications(p.id);
      const indicationDisplay = truncateForListDisplay(indicationsList, 140);
      const indicationAttr = indicationsList
        ? ` class="truncate-cell" data-full-text="${esc(indicationsList)}"`
        : ' class="truncate-cell"';
      const indicationContent = indicationDisplay ? `<span class="truncate-text truncate-text--wide">${esc(indicationDisplay)}</span>` : '';
      const selectedAttr = p.id === selectedPatientId ? ' data-selected="true"' : '';
      return `<tr data-id="${p.id}"${selectedAttr}><td>${p.id}</td><td>${esc(p.mrn)}</td><td>${esc(p.extra_id||'')}</td><td>${esc(p.family_number||'')}</td><td>${esc(p.name)}</td><td>${esc(gender)}</td><td>${esc(birthDisplay)}</td><td${indicationAttr}>${indicationContent}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  variantFilterClearButton?.addEventListener('click', () => {
    variantFilterKey = null;
    variantFilterLabel = '';
    variantFilterPatientIds = null;
    updateVariantFilterNotice(0);
    renderRows();
  });
  searchInput.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  const patientExportColumns = [
    {key:'id', label:'ID'},
    {key:'mrn', label:'MRN'},
    {key:'extra_id', label:'Ekstra ID'},
    {key:'family_number', label:'Familienummer'},
    {key:'name', label:'Navn'},
    {key:'gender', label:'Køn (kode)'},
    {key:'gender_label', label:'Køn', value: row => genderMap[row.gender] || row.gender || ''},
    {key:'birth_date', label:'Fødselsdato'},
    {key:'birth_date_formatted', label:'Fødselsdato (formateret)', value: row => formatDanishDate(row.birth_date)},
    {key:'notes', label:'Noter'},
    {key:'indications', label:'Indikationer', value: row => getPatientIndications(row.id)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#patientsExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('patients', filteredPatients);
    exportFilteredCsv('glimr-patienter-filtreret.csv', rows, patientExportColumns, {
      entity: 'patienter',
      plural: 'patienter'
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const patient = list.find(p => p.id === id);
    if (!patient) return;
    selectedPatientId = id;
    fillForm(form, patient);
    updateAgeNote();
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('patients')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.healthy_family_member = Boolean(form.elements.healthy_family_member?.checked);
    data.variant_type = normalizeVariantType(data.variant_type);
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('patients', id)};
      const updated = {...before, ...data, id};
      await updateRecord('patients', updated, before);
    } else {
      delete data.id;
      await addRecord('patients', data);
    }
    await loadStore('patients');
    renderTab('patients');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
  });
  deleteBtn.addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg en patient');
    if (!ensureWrite('patients')) return;
    if (confirm('Slet patient?')) {
      await deleteRecord('patients', id);
      form.reset();
      renderTab('patients');
      renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedPatientId = null;
    updateAgeNote();
    renderRows();
  });
  clearBtn.addEventListener('click', () => form.reset());
  state.pendingPatientVariantFilter = null;
  updateAgeNote();
}
function renderSamples(section) {
  const list = getCached('samples');
  const patients = getCached('patients');
  const orders = getCached('orders') || [];
  const reports = getCached('reports') || [];
  const patientMap = new Map(patients.map(p => [p.id, p]));
  const ordersBySample = new Map();
  orders.forEach(order => {
    const sampleId = Number(order.sample_id);
    if (!Number.isFinite(sampleId)) return;
    ordersBySample.set(sampleId, (ordersBySample.get(sampleId) || 0) + 1);
  });
  const orderLookup = new Map(orders.map(order => [Number(order.id), order]));
  const reportsBySample = new Map();
  reports.forEach(report => {
    const order = orderLookup.get(Number(report.order_id));
    if (!order) return;
    const sampleId = Number(order.sample_id);
    if (!Number.isFinite(sampleId)) return;
    reportsBySample.set(sampleId, (reportsBySample.get(sampleId) || 0) + 1);
  });
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="sampleSearch">Søg</label>
        <input id="sampleSearch" type="search" placeholder="ID/PMB/status...">
        <label class="list-toggle"><input type="checkbox" id="samplesActiveOnly" checked> Vis kun aktive</label>
        <details class="advanced-filter" id="samplesFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-samples="id" placeholder="Sample-ID"></label>
            <label>PMB-nummer<input type="search" data-filter-samples="pmb" placeholder="PMB"></label>
            <label>Patient<input type="search" data-filter-samples="patient" placeholder="Patientnavn/MRN/ID/familie"></label>
            <label>Prøvetype<input type="search" data-filter-samples="type" placeholder="Type"></label>
            <label>Status<input type="search" data-filter-samples="status" placeholder="Status"></label>
            <label>Opsamlet fra<input type="date" data-filter-samples="collected_from"></label>
            <label>Opsamlet til<input type="date" data-filter-samples="collected_to"></label>
          </div>
        </details>
        <table><thead><tr><th class="table-shortcuts"><span class="sr-only">Genveje</span></th><th>ID</th><th>PMB-nummer</th><th>Patient</th><th>Prøvetype</th><th>Status</th><th>Opsamlet</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="samplesExport">Eksportér filtrerede prøver</button>
        </div>
      </div>
      <div>
        <h2>Prøve</h2>
        <form id="sampleForm">
          <input type="hidden" name="id">
          <label>Patient
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer patienter">
              <select name="patient_id" required>
                <option value="" selected>Vælg patient</option>
                ${patients.map(p => {
                  const details = [p.mrn, p.extra_id, p.family_number].filter(Boolean).map(esc).join(' • ');
                  return `<option value="${p.id}">${esc(p.name)}${details ? ` (${details})` : ''}</option>`;
                }).join('')}
              </select>
            </div>
          </label>
          <label>PMB-nummer<input name="pmb_number" required></label>
          <label>Prøvetype
            <select name="sample_type" required data-allow-legacy-option>
              <option value="">Vælg prøvetype</option>
              ${SAMPLE_TYPES.map(type => `<option value="${type}">${type}</option>`).join('')}
            </select>
          </label>
          <label>Status
            <select name="status" data-allow-legacy-option>
              <option value="">Vælg status</option>
              ${SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('')}
            </select>
          </label>
          <label>Opsamlet<input type="datetime-local" name="collected_at"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="sampleClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="sampleDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#sampleSearch');
  const form = section.querySelector('#sampleForm');
  const filterInputs = {
    id: section.querySelector('[data-filter-samples="id"]'),
    pmb: section.querySelector('[data-filter-samples="pmb"]'),
    patient: section.querySelector('[data-filter-samples="patient"]'),
    type: section.querySelector('[data-filter-samples="type"]'),
    status: section.querySelector('[data-filter-samples="status"]'),
    collected_from: section.querySelector('[data-filter-samples="collected_from"]'),
    collected_to: section.querySelector('[data-filter-samples="collected_to"]')
  };
  const activeToggle = section.querySelector('#samplesActiveOnly');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  let filteredSamples = list.slice();
  let activeFilters = {};
  let selectedSampleId = state.pendingSampleId != null ? Number(state.pendingSampleId) : null;
  if (!Number.isFinite(selectedSampleId)) selectedSampleId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  if (selectedSampleId != null) {
    if (filterInputs.id) filterInputs.id.value = String(selectedSampleId);
    if (search) search.value = '';
    if (state.pendingSampleShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
  }
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      pmb: filterInputs.pmb?.value.trim().toLowerCase() || '',
      patient: filterInputs.patient?.value.trim().toLowerCase() || '',
      type: filterInputs.type?.value.trim().toLowerCase() || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      collected_from: filterInputs.collected_from?.value || '',
      collected_to: filterInputs.collected_to?.value || ''
    };
    const fromDate = filters.collected_from ? new Date(filters.collected_from) : null;
    const toDate = filters.collected_to ? new Date(filters.collected_to) : null;
    if (toDate) {
      toDate.setHours(23, 59, 59, 999);
    }
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    filterSummary.visning = showActiveOnly ? 'Kun aktive' : 'Alle';
    activeFilters = filterSummary;
    filteredSamples = list.filter(s => {
      if (!term) return true;
      const creator = determineCreatedBy('samples', s);
      return [s.id, s.pmb_number, s.status, s.sample_type, creator].some(v => (v ?? '').toString().toLowerCase().includes(term));
    }).filter(s => {
      const patient = patientMap.get(Number(s.patient_id));
      const patientString = [patient?.name, patient?.mrn, patient?.extra_id, patient?.family_number].filter(Boolean).join(' ').toLowerCase();
      if (filters.id && !String(s.id).includes(filters.id)) return false;
      if (filters.pmb && !(s.pmb_number || '').toLowerCase().includes(filters.pmb)) return false;
      if (filters.patient && !patientString.includes(filters.patient)) return false;
      if (filters.type && !(s.sample_type || '').toLowerCase().includes(filters.type)) return false;
      if (filters.status && !(s.status || '').toLowerCase().includes(filters.status)) return false;
      if (showActiveOnly && !isActiveStatus(s.status)) return false;
      if (fromDate || toDate) {
        if (!s.collected_at) return false;
        const collectedAt = new Date(s.collected_at);
        if (Number.isNaN(collectedAt.getTime())) return false;
        if (fromDate && collectedAt < fromDate) return false;
        if (toDate && collectedAt > toDate) return false;
      }
      return true;
    });
    if (selectedSampleId != null && !filteredSamples.some(s => s.id === selectedSampleId)) {
      selectedSampleId = null;
    }
    tbody.innerHTML = filteredSamples.map(s => {
      const createdBy = determineCreatedBy('samples', s);
      const collectedAt = formatDanishDate(s.collected_at);
      const collectedMeta = formatDaysSince(s.collected_at);
      const collectedCell = collectedAt
        ? `${esc(collectedAt)}${collectedMeta ? ` <span class="table-meta">(${esc(collectedMeta)})</span>` : ''}`
        : '';
      const selectedAttr = s.id === selectedSampleId ? ' data-selected="true"' : '';
      const orderCount = ordersBySample.get(Number(s.id)) || 0;
      const reportCount = reportsBySample.get(Number(s.id)) || 0;
      const hasOrders = orderCount > 0;
      const hasReports = reportCount > 0;
      const orderTip = hasOrders
        ? 'Åbn Ordinationer-fanen med filter for denne prøve.'
        : 'Ingen ordinationer er knyttet til denne prøve endnu.';
      const reportTip = hasReports
        ? 'Åbn Rapporter-fanen med filter for denne prøve.'
        : 'Ingen rapporter er knyttet til denne prøve endnu.';
      const orderDisabledAttr = hasOrders ? '' : ' disabled';
      const reportDisabledAttr = hasReports ? '' : ' disabled';
      const shortcutsCell = `<td class="table-actions-cell"><div class="table-shortcut-actions"><button type="button" class="icon-button" data-sample-action="orders" data-sample-id="${s.id}" data-tooltip="${esc(orderTip)}"${orderDisabledAttr}><span class="icon-slot" data-icon="clipboard-document-list"></span></button><button type="button" class="icon-button" data-sample-action="reports" data-sample-id="${s.id}" data-tooltip="${esc(reportTip)}"${reportDisabledAttr}><span class="icon-slot" data-icon="document-chart-bar"></span></button></div></td>`;
      return `<tr data-id="${s.id}"${selectedAttr}>${shortcutsCell}<td>${s.id}</td><td>${esc(s.pmb_number||'')}</td><td>${esc(getName('patients', Number(s.patient_id)))}</td><td>${esc(s.sample_type)}</td><td>${esc(s.status||'')}</td><td>${collectedCell}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    applyIconSlots(tbody);
    tbody.querySelectorAll('button[data-sample-action]').forEach(btn => {
      const tip = btn.dataset.tooltip || btn.getAttribute('title') || '';
      if (tip) setTooltip(btn, tip);
    });
    annotateTableCells(section);
  };
  renderRows();
  if (selectedSampleId != null) {
    const pendingSample = list.find(s => s.id === selectedSampleId);
    if (pendingSample) {
      fillForm(form, pendingSample);
      const pendingRow = tbody?.querySelector(`tr[data-id="${pendingSample.id}"]`);
      if (pendingRow) {
        pendingRow.scrollIntoView({block: 'nearest'});
      }
    }
  }
  state.pendingSampleId = null;
  state.pendingSampleShowAll = false;
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  const sampleExportColumns = [
    {key:'id', label:'ID'},
    {key:'pmb_number', label:'PMB-nummer'},
    {key:'patient_id', label:'Patient-ID'},
    {key:'patient_name', label:'Patient', value: row => getName('patients', Number(row.patient_id))},
    {key:'sample_type', label:'Prøvetype'},
    {key:'status', label:'Status (kode)'},
    {key:'status_display', label:'Status', value: row => row.status || ''},
    {key:'collected_at', label:'Opsamlet (ISO)'},
    {key:'collected_at_formatted', label:'Opsamlet', value: row => formatDanishDate(row.collected_at, true)},
    {key:'notes', label:'Noter'},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#samplesExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('samples', filteredSamples);
    exportFilteredCsv('glimr-proever-filtreret.csv', rows, sampleExportColumns, {
      entity: 'prøver',
      plural: 'prøver'
    });
  });
  tbody.addEventListener('click', e => {
    const actionButton = e.target.closest('button[data-sample-action]');
    if (actionButton) {
      if (actionButton.disabled) return;
      const {sampleId, sampleAction} = actionButton.dataset;
      if (sampleAction === 'orders') {
        openOrdersForSample(sampleId);
      } else if (sampleAction === 'reports') {
        openReportsForSample(sampleId);
      }
      return;
    }
    const tr = e.target.closest('tr');
    if (!tr) return;
    const sample = list.find(s => s.id === Number(tr.dataset.id));
    if (!sample) return;
    selectedSampleId = sample.id;
    fillForm(form, sample);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('samples')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    const currentId = data.id ? Number(data.id) : null;
    data.patient_id = Number(data.patient_id);
    data.pmb_number = (data.pmb_number || '').trim();
    if (!data.pmb_number) {
      alert('Angiv et PMB-nummer.');
      return;
    }
    const existingSamples = getCached('samples');
    const conflict = existingSamples.find(s => (s.pmb_number || '').toLowerCase() === data.pmb_number.toLowerCase() && s.id !== currentId);
    if (conflict) {
      alert('PMB-nummeret er allerede i brug.');
      return;
    }
    if (data.sample_type) data.sample_type = data.sample_type.trim();
    if (data.status) data.status = data.status.trim();
    if (data.notes) data.notes = data.notes.trim();
    let sampleId;
    let controlSyncResult = {updated: false, ordersUpdated: false};
    if (currentId) {
      const id = currentId;
      const before = {...findById('samples', id)};
      const updated = {...before, ...data, id};
      await updateRecord('samples', updated, before);
      sampleId = id;
    } else {
      delete data.id;
      sampleId = await addRecord('samples', data);
    }
    const sampleStatus = data.status || '';
    if (sampleId) {
      const relatedOrders = getCached('orders').filter(o => Number(o.sample_id) === sampleId);
      let ordersUpdated = false;
      for (const order of relatedOrders) {
        if ((order.status || '') !== sampleStatus) {
          const beforeOrder = {...order};
          const updatedOrder = {...order, status: sampleStatus};
          await updateRecord('orders', updatedOrder, beforeOrder);
          ordersUpdated = true;
        }
      }
      const existingSample = findById('samples', sampleId) || {};
      const sampleRecord = {...existingSample, ...data, id: sampleId, status: sampleStatus};
      controlSyncResult = await syncControlSampleStatus(sampleRecord, sampleStatus);
      if ((ordersUpdated || controlSyncResult.ordersUpdated) && state.currentTab === 'orders') {
        renderTab('orders');
      }
    }
    await loadStore('samples');
    renderTab('samples');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
  });
  section.querySelector('#sampleDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg sample');
    if (!ensureWrite('samples')) return;
    if (confirm('Slet sample?')) {
      await deleteRecord('samples', id);
      renderTab('samples');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedSampleId = null;
    renderRows();
  });
  section.querySelector('#sampleClear').addEventListener('click', () => form.reset());
}
function renderPanels(section) {
  const list = getCached('panels');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="panelSearch">Søg</label>
        <input id="panelSearch" type="search" placeholder="Navn, version, dato, bruger eller gener...">
        <table><thead><tr><th>ID</th><th>Navn</th><th>Version</th><th>Oprettet</th><th>Opdateret</th><th>Opdateret af</th><th>Beskrivelse</th><th>Antal gener</th><th>Genliste</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="panelsExport">Eksportér filtrerede paneler</button>
        </div>
      </div>
      <div>
        <h2>Panel</h2>
        <form id="panelForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <label>Version<input name="version" type="number" min="1" step="1" inputmode="numeric"></label>
          <label>Beskrivelse<textarea name="description"></textarea></label>
          <label>Genliste<textarea name="gene_list" placeholder="GEN1, GEN2, GEN3"></textarea></label>
          <div class="form-meta">
            <p class="form-hint">Oprettet: <span data-panel-created>–</span></p>
            <p class="form-hint">Senest ændret: <span data-panel-updated>–</span></p>
            <p class="form-hint">Opdateret af: <span data-panel-updated-by>–</span></p>
            <p class="form-hint">Antal gener: <span data-panel-gene-count>0</span></p>
          </div>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="panelClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="panelDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#panelSearch');
  const form = section.querySelector('#panelForm');
  const exportButton = section.querySelector('#panelsExport');
  const versionInput = form?.elements?.version || null;
  const geneListInput = form?.elements?.gene_list || null;
  const createdMeta = section.querySelector('[data-panel-created]');
  const updatedMeta = section.querySelector('[data-panel-updated]');
  const updatedByMeta = section.querySelector('[data-panel-updated-by]');
  const geneCountMeta = section.querySelector('[data-panel-gene-count]');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  const normaliseVersionNumber = value => {
    if (value == null) return null;
    const numeric = Number.parseInt(String(value).trim(), 10);
    return Number.isFinite(numeric) && numeric > 0 ? numeric : null;
  };
  const formatPanelDate = value => formatDanishDate(value, true) || '';
  const displayPanelDate = value => {
    const formatted = formatPanelDate(value);
    return formatted || '–';
  };
  const parseGeneList = value => {
    if (value == null) return [];
    return String(value)
      .split(/[\n;,]/)
      .map(token => token.trim())
      .filter(Boolean);
  };
  const normaliseGeneList = value => parseGeneList(value).join(', ');
  const geneListPreviewLimit = 80;
  const formatGeneListPreview = (value, limit = geneListPreviewLimit) => {
    const text = (value ?? '').toString().trim();
    if (!text) return '';
    if (text.length <= limit) return text;
    const truncated = text.slice(0, Math.max(0, limit - 1)).trimEnd();
    return `${truncated}…`;
  };
  const geneCountFromValue = value => parseGeneList(value).length;
  const setVersionTouched = touched => {
    if (!form) return;
    form.dataset.versionTouched = touched ? 'true' : 'false';
  };
  const isVersionTouched = () => form?.dataset?.versionTouched === 'true';
  const updatePanelMetaDisplay = panel => {
    if (createdMeta) createdMeta.textContent = panel ? displayPanelDate(panel.created_at) : '–';
    if (updatedMeta) updatedMeta.textContent = panel ? displayPanelDate(panel.updated_at) : '–';
    if (updatedByMeta) updatedByMeta.textContent = panel?.updated_by ? panel.updated_by : '–';
    if (geneCountMeta) {
      const count = panel ? (Number.isFinite(Number(panel.gene_count)) ? Number(panel.gene_count) : geneCountFromValue(panel.gene_list)) : 0;
      geneCountMeta.textContent = count ? String(count) : '0';
    }
  };
  const prepareFormForPanel = panel => {
    const baseVersion = normaliseVersionNumber(panel?.version);
    setVersionTouched(false);
    if (versionInput) {
      versionInput.value = baseVersion ?? 1;
    }
    if (geneListInput) {
      geneListInput.value = panel?.gene_list ?? '';
    }
    updatePanelMetaDisplay(panel || null);
  };
  const resetPanelFormState = () => {
    setVersionTouched(false);
    if (versionInput) {
      versionInput.value = 1;
    }
    if (geneListInput) {
      geneListInput.value = '';
    }
    updatePanelMetaDisplay(null);
  };
  resetPanelFormState();
  versionInput?.addEventListener('input', () => setVersionTouched(true));
  geneListInput?.addEventListener('input', () => {
    if (geneCountMeta) {
      const count = geneCountFromValue(geneListInput.value);
      geneCountMeta.textContent = count ? String(count) : '0';
    }
  });
  let selectedPanelId = null;
  let filteredPanels = list.slice();
  const renderRows = () => {
    const term = search.value.trim().toLowerCase();
    filteredPanels = list.filter(p => {
      if (!term) return true;
      const values = [
        p.name,
        p.description,
        normaliseVersionNumber(p.version)?.toString() || '',
        formatPanelDate(p.created_at),
        formatPanelDate(p.updated_at),
        p.updated_by,
        geneCountFromValue(p.gene_list).toString(),
        p.gene_list
      ];
      return values.some(value => (value || '').toString().toLowerCase().includes(term));
    });
    if (selectedPanelId != null && !filteredPanels.some(p => p.id === selectedPanelId)) {
      selectedPanelId = null;
    }
    tbody.innerHTML = filteredPanels.map(p => {
      const selectedAttr = p.id === selectedPanelId ? ' data-selected="true"' : '';
      const versionValue = normaliseVersionNumber(p.version);
      const versionDisplay = versionValue != null ? esc(versionValue) : '–';
      const createdDisplay = esc(displayPanelDate(p.created_at));
      const updatedDisplay = esc(displayPanelDate(p.updated_at));
      const updatedByDisplay = esc(p.updated_by || '–');
      const geneCountValue = Number.isFinite(Number(p.gene_count)) ? Number(p.gene_count) : geneCountFromValue(p.gene_list);
      const geneCountDisplay = geneCountValue ? esc(geneCountValue) : '0';
      const geneListFull = (p.gene_list ?? '').toString();
      const geneListPreview = formatGeneListPreview(geneListFull);
      const geneListDisplay = geneListPreview ? esc(geneListPreview) : '–';
      const geneListTitle = geneListFull ? ` title="${esc(geneListFull)}"` : '';
      return `<tr data-id="${p.id}"${selectedAttr}><td>${p.id}</td><td>${esc(p.name)}</td><td>${versionDisplay}</td><td>${createdDisplay}</td><td>${updatedDisplay}</td><td>${updatedByDisplay}</td><td>${esc(p.description||'')}</td><td>${geneCountDisplay}</td><td${geneListTitle}>${geneListDisplay}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  exportButton?.addEventListener('click', () => {
    if (!filteredPanels.length) {
      alert('Ingen paneler matcher filtreringen.');
      return;
    }
    const entries = filteredPanels.map(p => {
      const name = (p.name ?? '').toString().trim() || '(uden navn)';
      const desc = (p.description ?? '').toString().replace(/\r?\n|\r/g, ' ').trim();
      const versionValue = normaliseVersionNumber(p.version);
      const label = versionValue != null ? `${name}_v${versionValue}` : name;
      const genes = parseGeneList(p.gene_list);
      const geneList = genes.join(', ');
      const geneCount = genes.length;
      const geneLine = `${label} (${geneCount}): ${geneList || '(ingen gener)'}.`;
      let descriptionLine = desc;
      if (descriptionLine) {
        if (!/[.!?]$/.test(descriptionLine)) {
          descriptionLine = `${descriptionLine}.`;
        }
      } else {
        descriptionLine = '.';
      }
      return `${geneLine}\r\n${descriptionLine}`;
    });
    const text = entries.join('\r\n\r\n');
    const filename = downloadTextFile(text, 'glimr-paneler.txt', {
      entity: 'panel_export',
      details: {panelCount: filteredPanels.length}
    });
    setStatus(`Eksporterede ${filteredPanels.length} paneler til ${filename}.`);
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const panel = list.find(p => p.id === Number(tr.dataset.id));
    if (!panel) return;
    selectedPanelId = panel.id;
    fillForm(form, panel);
    prepareFormForPanel(panel);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('panels')) return;
    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());
    const hasId = Boolean(data.id);
    const id = hasId ? Number(data.id) : null;
    const existingRecord = hasId && Number.isFinite(id) ? findById('panels', id) : null;
    const existing = existingRecord ? {...existingRecord} : null;
    if (hasId && (!Number.isFinite(id) || !existing)) {
      alert('Panelet blev ikke fundet.');
      return;
    }
    const existingVersion = existing ? normaliseVersionNumber(existing.version) : null;
    let versionNumber = normaliseVersionNumber(formData.get('version'));
    if (hasId) {
      if (!isVersionTouched()) {
        versionNumber = (existingVersion ?? 0) + 1;
      } else if (versionNumber == null) {
        versionNumber = existingVersion ?? 1;
      }
    } else if (!isVersionTouched() || versionNumber == null) {
      versionNumber = 1;
    }
    const rawGeneList = formData.get('gene_list');
    const normalisedGeneListValue = normaliseGeneList(rawGeneList);
    const geneCountValue = geneCountFromValue(normalisedGeneListValue);
    if (geneListInput) {
      geneListInput.value = normalisedGeneListValue;
    }
    if (geneCountMeta) {
      geneCountMeta.textContent = geneCountValue ? String(geneCountValue) : '0';
    }
    const payload = {
      ...data,
      version: versionNumber,
      gene_list: normalisedGeneListValue,
      gene_count: geneCountValue
    };
    if (hasId) {
      payload.id = id;
      const before = existing || {};
      const updated = {...before, ...payload, id};
      await updateRecord('panels', updated, before);
    } else {
      delete payload.id;
      await addRecord('panels', payload);
    }
    if (versionInput) {
      versionInput.value = versionNumber;
    }
    setVersionTouched(false);
    await loadStore('panels');
    renderTab('panels');
  });
  section.querySelector('#panelDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg panel');
    if (!ensureWrite('panels')) return;
    if (confirm('Slet panel?')) {
      await deleteRecord('panels', id);
      renderTab('panels');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedPanelId = null;
    resetPanelFormState();
    renderRows();
  });
  section.querySelector('#panelClear').addEventListener('click', () => form.reset());
}
function renderOrders(section) {
  const list = getCached('orders');
  const patients = getCached('patients');
  const samples = getCached('samples');
  const panels = getCached('panels');
  const reports = getCached('reports') || [];
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const patientGroups = getCached('patient_groups').slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'da'));
  const patientMap = new Map(patients.map(p => [p.id, p]));
  const sampleMap = new Map(samples.map(s => [s.id, s]));
  const panelMap = new Map(panels.map(p => [p.id, p]));
  const userMap = new Map(users.map(u => [u.id, u]));
  const reportsByOrder = new Map();
  reports.forEach(report => {
    const orderId = Number(report.order_id);
    if (!Number.isFinite(orderId)) return;
    reportsByOrder.set(orderId, (reportsByOrder.get(orderId) || 0) + 1);
  });
  const resolveUserName = id => userMap.get(Number(id))?.name || '';
  const userOptions = users.map(u => `<option value="${u.id}">${esc(u.name || `Bruger #${u.id}`)}</option>`).join('');
  const patientGroupOptions = patientGroups.map(group => `<option value="${group.id}">${esc(group.name || `Patientgruppe #${group.id}`)}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="orderSearch">Søg</label>
        <input id="orderSearch" type="search" placeholder="Status/ID/PMB...">
        <label class="list-toggle"><input type="checkbox" id="ordersActiveOnly" checked> Vis kun aktive</label>
        <details class="advanced-filter" id="ordersFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-orders="id" placeholder="Ordination-ID"></label>
            <label>Patient<input type="search" data-filter-orders="patient" placeholder="Patientnavn/MRN/ID/familie"></label>
            <label>Prøve<input type="search" data-filter-orders="sample" placeholder="Prøve-ID eller PMB"></label>
            <label>Panel<input type="search" data-filter-orders="panel" placeholder="Panelnavn"></label>
            <label>Indikation<input type="search" data-filter-orders="indication" placeholder="Indikation"></label>
            <label>HPO-termer<input type="search" data-filter-orders="hpo" placeholder="HP:0001250"></label>
            <label>Patientgruppe
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer patientgrupper">
                <select data-filter-orders="patient_group">
                  <option value="" selected>Alle</option>
                  ${patientGroupOptions}
                </select>
              </div>
            </label>
            <label>Analyseansvarlig
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="analysis_responsible">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Tolker
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="interpreter">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Godkender
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="approver">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Status<input type="search" data-filter-orders="status" placeholder="Status"></label>
            <label>Bestilt fra<input type="date" data-filter-orders="ordered_from"></label>
            <label>Bestilt til<input type="date" data-filter-orders="ordered_to"></label>
          </div>
        </details>
        <table class="orders-table">
          <colgroup>
            <col class="col-shortcuts">
            <col>
            <col class="col-patient">
            <col>
            <col class="col-panel">
            <col>
            <col>
            <col>
            <col>
            <col class="col-indication">
            <col class="col-hpo">
            <col>
            <col>
            <col>
          </colgroup>
          <thead><tr><th class="table-shortcuts"><span class="sr-only">Genveje</span></th><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Analyseansvarlig</th><th>Tolker</th><th>Godkender</th><th>Patientgruppe</th><th>Indikation</th><th>HPO-termer</th><th>Status</th><th>Oprettet af</th><th>Bestilt</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="ordersExport">Eksportér filtrerede ordinationer</button>
        </div>
      </div>
      <div>
        <h2>Ordination</h2>
        <form id="orderForm">
          <input type="hidden" name="id">
          <label>Patient
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer patienter">
              <select name="patient_id" required>
                <option value="" selected>Vælg patient</option>
                ${patients.map(p => {
                  const details = [p.mrn, p.extra_id, p.family_number].filter(Boolean).map(esc).join(' • ');
                  return `<option value="${p.id}">${esc(p.name)}${details ? ` (${details})` : ''}</option>`;
                }).join('')}
              </select>
            </div>
          </label>
          <label>Prøve
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer prøver">
              <select name="sample_id" required>
                <option value="" selected>Vælg prøve</option>
                ${samples.map(s => `<option value="${s.id}">${s.id} (${esc(s.pmb_number||'–')}) – ${esc(getName('patients', s.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Familietype
            <select name="family_type" data-allow-legacy-option>
              ${FAMILY_TYPES.map(type => `<option value="${type.value}"${type.value === 'singleton' ? ' selected' : ''}>${type.label}</option>`).join('')}
            </select>
          </label>
          <label>Panel
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer paneler">
              <select name="panel_id"><option value="">-</option>${panels.map(p => `<option value="${p.id}">${esc(p.name)}</option>`).join('')}</select>
            </div>
          </label>
          <label>Analyseansvarlig
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="analysis_responsible_id" data-allow-legacy-option>
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
          <label>Tolker
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="interpreter_id" data-allow-legacy-option>
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
            <label>Godkender
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select name="approver_id" data-allow-legacy-option>
                  <option value="" selected>Vælg bruger</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Patientgruppe
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer patientgrupper">
                <select name="patient_group_id" data-allow-legacy-option>
                  <option value="">-</option>
                  ${patientGroupOptions}
                </select>
              </div>
            </label>
            <label>Rekvirent<input name="clinician"></label>
            <label>Indikation<textarea name="indication" rows="3" placeholder="Beskriv klinisk indikation"></textarea></label>
          <label>HPO-termer<textarea name="hpo_terms" class="small" placeholder="HP:0001250; HP:0004321"></textarea></label>
          <div class="inline-field-group">
            <label>Status
              <select name="status" required data-allow-legacy-option>
                <option value="" selected>Vælg status</option>
                ${SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('')}
              </select>
            </label>
            <label class="checkbox-field"><input type="checkbox" name="acute"> Markér ordinationen som akut</label>
            <label class="checkbox-field"><input type="checkbox" name="urgent"> Markér ordinationen som haster</label>
          </div>
          <label>Bestillingstidspunkt<input type="datetime-local" name="ordered_at"></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="orderClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="orderDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#orderSearch');
  const form = section.querySelector('#orderForm');
  const filterInputs = {
    id: section.querySelector('[data-filter-orders="id"]'),
    patient: section.querySelector('[data-filter-orders="patient"]'),
    sample: section.querySelector('[data-filter-orders="sample"]'),
    panel: section.querySelector('[data-filter-orders="panel"]'),
    indication: section.querySelector('[data-filter-orders="indication"]'),
    hpo: section.querySelector('[data-filter-orders="hpo"]'),
    patient_group: section.querySelector('[data-filter-orders="patient_group"]'),
    analysis_responsible: section.querySelector('[data-filter-orders="analysis_responsible"]'),
    interpreter: section.querySelector('[data-filter-orders="interpreter"]'),
    approver: section.querySelector('[data-filter-orders="approver"]'),
    status: section.querySelector('[data-filter-orders="status"]'),
    ordered_from: section.querySelector('[data-filter-orders="ordered_from"]'),
    ordered_to: section.querySelector('[data-filter-orders="ordered_to"]')
  };
  const activeToggle = section.querySelector('#ordersActiveOnly');
  const orderAcuteCheckbox = form?.elements?.acute || null;
  const orderUrgentCheckbox = form?.elements?.urgent || null;
  const enforcePrioritySelection = setupExclusivePriorityControls(orderAcuteCheckbox, orderUrgentCheckbox);
  applyIconSlots(section);
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  const statusSelect = form?.elements?.status;
  const sampleSelect = form?.elements?.sample_id;
  const patientSelect = form?.elements?.patient_id;
  const ensureStatusOption = value => {
    if (!statusSelect || !value) return;
    if (!Array.from(statusSelect.options).some(opt => opt.value === value)) {
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = value;
      statusSelect.appendChild(opt);
    }
  };
  const syncStatusFromSample = sampleId => {
    if (!statusSelect) return;
    if (!sampleId) {
      statusSelect.value = '';
      return;
    }
    const sample = sampleMap.get(Number(sampleId));
    if (sample?.status) {
      ensureStatusOption(sample.status);
      statusSelect.value = sample.status;
    }
  };
  const getSamplePatientId = sampleId => {
    if (!sampleId) return null;
    const sample = sampleMap.get(Number(sampleId));
    const patientId = Number(sample?.patient_id);
    return Number.isFinite(patientId) && patientId > 0 ? patientId : null;
  };
  const updateSampleOptions = () => {
    if (!sampleSelect) return;
    const selectedPatientId = Number(patientSelect?.value || 0);
    const enforcePatient = Number.isFinite(selectedPatientId) && selectedPatientId > 0;
    const currentSampleId = Number(sampleSelect.value || 0);
    Array.from(sampleSelect.options).forEach(opt => {
      if (!opt.value) {
        opt.disabled = false;
        opt.hidden = false;
        return;
      }
      const optionPatientId = getSamplePatientId(opt.value);
      const matches = !enforcePatient || optionPatientId === selectedPatientId;
      opt.disabled = !matches;
      opt.hidden = !matches;
    });
    if (enforcePatient && currentSampleId) {
      const currentPatientId = getSamplePatientId(currentSampleId);
      if (currentPatientId !== selectedPatientId) {
        sampleSelect.value = '';
        if (statusSelect) statusSelect.value = '';
      }
    }
  };
  const updatePatientOptions = () => {
    if (!patientSelect) return;
    const selectedSampleId = Number(sampleSelect?.value || 0);
    const samplePatientId = getSamplePatientId(selectedSampleId);
    const enforceSample = Number.isFinite(samplePatientId);
    Array.from(patientSelect.options).forEach(opt => {
      if (!opt.value) {
        opt.disabled = enforceSample;
        opt.hidden = false;
        return;
      }
      if (!enforceSample) {
        opt.disabled = false;
        opt.hidden = false;
        return;
      }
      const optionPatientId = Number(opt.value);
      const matches = Number.isFinite(optionPatientId) && optionPatientId === samplePatientId;
      opt.disabled = !matches;
      opt.hidden = !matches;
    });
    if (enforceSample && samplePatientId != null) {
      const desiredValue = String(samplePatientId);
      if (patientSelect.value !== desiredValue) {
        patientSelect.value = desiredValue;
      }
    }
  };
  const applyPatientSampleConstraints = () => {
    updatePatientOptions();
    updateSampleOptions();
  };
  patientSelect?.addEventListener('change', () => {
    updateSampleOptions();
    updatePatientOptions();
  });
  const handleSampleChange = () => {
    const sampleId = Number(sampleSelect?.value || 0);
    if (sampleId) {
      syncStatusFromSample(sampleId);
      const samplePatientId = getSamplePatientId(sampleId);
      if (samplePatientId != null && patientSelect) {
        const value = String(samplePatientId);
        if (patientSelect.value !== value) {
          patientSelect.value = value;
        }
      }
    } else if (statusSelect) {
      statusSelect.value = '';
    }
    updatePatientOptions();
    updateSampleOptions();
  };
  sampleSelect?.addEventListener('change', handleSampleChange);
  applyPatientSampleConstraints();
  let filteredOrders = list.slice();
  let activeFilters = {};
  let selectedOrderId = state.pendingOrderId != null ? Number(state.pendingOrderId) : null;
  if (!Number.isFinite(selectedOrderId)) selectedOrderId = null;
  let pendingFilterSampleId = state.pendingOrderFilterSampleId != null ? Number(state.pendingOrderFilterSampleId) : null;
  if (!Number.isFinite(pendingFilterSampleId)) pendingFilterSampleId = null;
  let requireExactSample = Boolean(state.pendingOrderFilterSampleExact && pendingFilterSampleId != null);
  let pendingFilterOrderId = state.pendingOrderFilterId != null ? Number(state.pendingOrderFilterId) : null;
  if (!Number.isFinite(pendingFilterOrderId)) pendingFilterOrderId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  if (selectedOrderId != null && state.pendingOrderShowAll && activeToggle) {
    showActiveOnly = false;
    activeToggle.checked = false;
  }
  if (pendingFilterSampleId != null) {
    if (filterInputs.sample) filterInputs.sample.value = String(pendingFilterSampleId);
    if (search) search.value = '';
    if (state.pendingOrderShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    const sampleOrders = list.filter(o => Number(o.sample_id) === pendingFilterSampleId);
    if (sampleOrders.length && selectedOrderId == null) {
      sampleOrders.sort((a, b) => {
        const timeA = (a.ordered_at || a.updated_at || a.created_at || '');
        const timeB = (b.ordered_at || b.updated_at || b.created_at || '');
        return timeB.localeCompare(timeA);
      });
      selectedOrderId = sampleOrders[0].id;
    }
  }
  if (pendingFilterOrderId != null) {
    if (filterInputs.id) filterInputs.id.value = String(pendingFilterOrderId);
    if (search) search.value = '';
    if (state.pendingOrderShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    selectedOrderId = pendingFilterOrderId;
  }
  const renderRows = () => {
    const term = (search?.value || '').trim().toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      patient: filterInputs.patient?.value.trim().toLowerCase() || '',
      sample: filterInputs.sample?.value.trim().toLowerCase() || '',
      panel: filterInputs.panel?.value.trim().toLowerCase() || '',
      indication: filterInputs.indication?.value.trim().toLowerCase() || '',
      hpo: filterInputs.hpo?.value.trim().toLowerCase() || '',
      patient_group: filterInputs.patient_group?.value || '',
      analysis_responsible: filterInputs.analysis_responsible?.value || '',
      interpreter: filterInputs.interpreter?.value || '',
      approver: filterInputs.approver?.value || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      ordered_from: filterInputs.ordered_from?.value || '',
      ordered_to: filterInputs.ordered_to?.value || ''
    };
    const fromDate = filters.ordered_from ? new Date(filters.ordered_from) : null;
    const toDate = filters.ordered_to ? new Date(filters.ordered_to) : null;
    if (toDate) toDate.setHours(23, 59, 59, 999);
    const filterSummary = {...filters};
    const numericFilterSample = Number(filters.sample || '');
    const matchExactSample = requireExactSample && filters.sample !== '' && Number.isFinite(numericFilterSample) && numericFilterSample === pendingFilterSampleId;
      if (filters.indication) filterSummary.indikation = filters.indication;
      if (filters.hpo) filterSummary['hpo-termer'] = filters.hpo;
      if (filters.sample) {
        const sample = sampleMap.get(Number(filters.sample));
        filterSummary.prøve = sample ? `${sample.id} (${sample.pmb_number || '–'})` : filters.sample;
      }
      if (filters.patient_group) {
        const groupLabel = getPatientGroupName(filters.patient_group);
        filterSummary.patient_group = groupLabel || filters.patient_group;
      }
      delete filterSummary.indication;
      delete filterSummary.hpo;
      delete filterSummary.sample;
    if (filters.analysis_responsible) filterSummary.analysis_responsible = getName('users', Number(filters.analysis_responsible));
    if (filters.interpreter) filterSummary.interpreter = getName('users', Number(filters.interpreter));
    if (filters.approver) filterSummary.approver = getName('users', Number(filters.approver));
    if (term) filterSummary.fritekst = term;
    filterSummary.visning = showActiveOnly ? 'Kun aktive' : 'Alle';
    activeFilters = filterSummary;
    filteredOrders = list.filter(o => {
      if (!term) return true;
      const sample = sampleMap.get(Number(o.sample_id));
      const analysisUser = userMap.get(Number(o.analysis_responsible_id));
      const interpreterUser = userMap.get(Number(o.interpreter_id));
      const approverUser = userMap.get(Number(o.approver_id));
      const creator = determineCreatedBy('orders', o);
      const indicationText = formatIndicationForList(o.indication);
      const hpoText = formatHpoList(o.hpo_terms);
      const patientGroupName = getPatientGroupName(o.patient_group_id);
      return [
        o.status,
        o.id,
        o.patient_id,
        o.sample_id,
        o.panel_id,
        sample?.pmb_number,
        sample?.status,
        analysisUser?.name,
        interpreterUser?.name,
        approverUser?.name,
        creator,
        indicationText,
        hpoText,
        patientGroupName,
        o.acute ? 'akut' : '',
        o.urgent ? 'haster' : ''
      ].some(v => (v ?? '').toString().toLowerCase().includes(term));
    }).filter(o => {
      const patient = patientMap.get(Number(o.patient_id));
      const sample = sampleMap.get(Number(o.sample_id));
      const panel = panelMap.get(Number(o.panel_id));
      const patientString = [patient?.name, patient?.mrn, patient?.extra_id, patient?.family_number].filter(Boolean).join(' ').toLowerCase();
      const sampleString = [o.sample_id, sample?.pmb_number, sample?.sample_type, getName('patients', sample?.patient_id)].filter(Boolean).join(' ').toLowerCase();
      const indicationString = formatIndicationForList(o.indication).toLowerCase();
      const hpoString = formatHpoList(o.hpo_terms).toLowerCase();
      if (filters.id && !String(o.id).includes(filters.id)) return false;
      if (filters.patient && !patientString.includes(filters.patient)) return false;
      if (filters.sample) {
        if (matchExactSample) {
          if (Number(o.sample_id) !== pendingFilterSampleId) return false;
        } else if (!sampleString.includes(filters.sample)) {
          return false;
        }
      }
      if (filters.panel) {
        const panelString = (panel?.name || String(o.panel_id || '')).toLowerCase();
        if (!panelString.includes(filters.panel)) return false;
      }
      if (filters.indication && !indicationString.includes(filters.indication)) return false;
      if (filters.hpo && !hpoString.includes(filters.hpo)) return false;
      if (filters.patient_group && String(o.patient_group_id || '') !== filters.patient_group) return false;
      if (filters.analysis_responsible && String(o.analysis_responsible_id || '') !== filters.analysis_responsible) return false;
      if (filters.interpreter && String(o.interpreter_id || '') !== filters.interpreter) return false;
      if (filters.approver && String(o.approver_id || '') !== filters.approver) return false;
      const statusValue = (sample?.status || o.status || '').toLowerCase();
      if (filters.status && !statusValue.includes(filters.status)) return false;
      if (showActiveOnly && !isActiveStatus(statusValue)) return false;
      if (fromDate || toDate) {
        if (!o.ordered_at) return false;
        const ordered = new Date(o.ordered_at);
        if (Number.isNaN(ordered.getTime())) return false;
        if (fromDate && ordered < fromDate) return false;
        if (toDate && ordered > toDate) return false;
      }
      return true;
    });
    const userName = id => resolveUserName(id);
    if (selectedOrderId != null && !filteredOrders.some(o => o.id === selectedOrderId)) {
      selectedOrderId = null;
    }
    tbody.innerHTML = filteredOrders.map(o => {
      const sample = sampleMap.get(Number(o.sample_id));
      const panel = panelMap.get(Number(o.panel_id));
      const statusDisplay = sample?.status || o.status || '';
      const createdBy = determineCreatedBy('orders', o);
      const orderedDate = parseDateTimeValue(o.ordered_at);
      const orderedAt = orderedDate ? formatDanishDate(orderedDate, false) : '';
      const orderedMeta = formatDaysSince(orderedDate);
      const orderedCell = orderedAt
        ? `${esc(orderedAt)}${orderedMeta ? ` <span class="table-meta">(${esc(orderedMeta)})</span>` : ''}`
        : '';
      const indicationFull = formatIndicationForList(o.indication);
      const indicationDisplay = truncateForListDisplay(indicationFull, 160);
      const indicationAttr = indicationFull ? ` class="truncate-cell" data-full-text="${esc(indicationFull)}"` : ' class="truncate-cell"';
      const indicationCell = indicationDisplay ? `<span class="truncate-text truncate-text--order-indication">${esc(indicationDisplay)}</span>` : '';
      const panelName = getName('panels', Number(o.panel_id));
      const panelFull = panel?.name || panelName;
      const panelAttr = panelFull ? ` class="truncate-cell" data-full-text="${esc(panelFull)}"` : ' class="truncate-cell"';
      const panelCell = panelName ? `<span class="truncate-text">${esc(panelName)}</span>` : '';
      const patientGroupName = getPatientGroupName(o.patient_group_id);
      const patientGroupDisplay = truncateForListDisplay(patientGroupName, 120);
      const patientGroupAttr = patientGroupName ? ` class="truncate-cell" data-full-text="${esc(patientGroupName)}"` : ' class="truncate-cell"';
      const patientGroupCell = patientGroupDisplay ? `<span class="truncate-text truncate-text--narrow">${esc(patientGroupDisplay)}</span>` : '';
      const hpoFull = formatHpoList(o.hpo_terms);
      const hpoDisplay = truncateForListDisplay(hpoFull, 120);
      const hpoAttr = hpoFull ? ` class="truncate-cell" data-full-text="${esc(hpoFull)}"` : ' class="truncate-cell"';
      const hpoCell = hpoDisplay ? `<span class="truncate-text truncate-text--narrow">${esc(hpoDisplay)}</span>` : '';
      const selectedAttr = o.id === selectedOrderId ? ' data-selected="true"' : '';
      const priorityAttr = orderPriorityAttributes(o);
      const priorityIcons = renderOrderPriorityIcons(o);
      const sampleId = Number(o.sample_id);
      const hasSample = Number.isFinite(sampleId);
      const reportCount = reportsByOrder.get(Number(o.id)) || 0;
      const hasReports = reportCount > 0;
      const sampleTip = hasSample
        ? 'Åbn Prøver-fanen med filter for denne ordination.'
        : 'Ordinationen er ikke knyttet til en prøve.';
      const reportTip = hasReports
        ? 'Åbn Rapporter-fanen med filter for denne ordination.'
        : 'Ingen rapporter er knyttet til denne ordination endnu.';
      const sampleButtonDisabledAttr = hasSample ? '' : ' disabled';
      const reportButtonDisabledAttr = hasReports ? '' : ' disabled';
      const shortcutsCell = `<td class="table-actions-cell"><div class="table-shortcut-actions"><button type="button" class="icon-button" data-order-action="samples" data-order-id="${o.id}" data-tooltip="${esc(sampleTip)}"${sampleButtonDisabledAttr}><span class="icon-slot" data-icon="beaker"></span></button><button type="button" class="icon-button" data-order-action="reports" data-order-id="${o.id}" data-tooltip="${esc(reportTip)}"${reportButtonDisabledAttr}><span class="icon-slot" data-icon="document-chart-bar"></span></button></div></td>`;
      const patientName = getName('patients', Number(o.patient_id));
      const patientAttr = patientName ? ` class="truncate-cell" data-full-text="${esc(patientName)}"` : ' class="truncate-cell"';
      const patientCell = patientName ? `<span class="truncate-text">${esc(patientName)}</span>` : '';
      return `<tr data-id="${o.id}"${selectedAttr}${priorityAttr}>${shortcutsCell}<td>${priorityIcons}<span class="order-id">${esc(o.id)}</span></td><td${patientAttr}>${patientCell}</td><td>${esc(getName('samples', Number(o.sample_id)))}</td><td${panelAttr}>${panelCell}</td><td>${esc(userName(o.analysis_responsible_id))}</td><td>${esc(userName(o.interpreter_id))}</td><td>${esc(userName(o.approver_id))}</td><td${patientGroupAttr}>${patientGroupCell}</td><td${indicationAttr}>${indicationCell}</td><td${hpoAttr}>${hpoCell}</td><td>${esc(statusDisplay)}</td><td>${esc(createdBy)}</td><td>${orderedCell}</td></tr>`;
    }).join('');
    applyIconSlots(tbody);
    tbody.querySelectorAll('button[data-order-action]').forEach(btn => {
      const tip = btn.dataset.tooltip || btn.getAttribute('title') || '';
      if (tip) setTooltip(btn, tip);
    });
    annotateTableCells(section);
  };
  renderRows();
  if (selectedOrderId != null) {
    const pendingOrder = list.find(o => o.id === selectedOrderId);
    if (pendingOrder) {
      fillForm(form, pendingOrder);
      syncStatusFromSample(pendingOrder.sample_id);
      enforcePrioritySelection();
      applyPatientSampleConstraints();
      const pendingRow = tbody?.querySelector(`tr[data-id="${pendingOrder.id}"]`);
      if (pendingRow) {
        pendingRow.scrollIntoView({block: 'nearest'});
      }
    }
  }
  state.pendingOrderId = null;
  state.pendingOrderShowAll = false;
  state.pendingOrderFilterSampleId = null;
  state.pendingOrderFilterSampleExact = false;
  state.pendingOrderFilterId = null;
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  search.addEventListener('input', renderRows);
  const handleFilterChange = event => {
    if (event?.currentTarget === filterInputs.sample) {
      requireExactSample = false;
    }
    renderRows();
  };
  Object.values(filterInputs).forEach(input => {
    if (!input) return;
    const isSelect = input.tagName === 'SELECT';
    input.addEventListener(isSelect ? 'change' : 'input', handleFilterChange);
    if (isSelect) {
      input.addEventListener('input', handleFilterChange);
    }
  });
  const orderExportColumns = [
    {key:'id', label:'ID'},
    {key:'patient_id', label:'Patient-ID'},
    {key:'patient_name', label:'Patient', value: row => getName('patients', Number(row.patient_id))},
    {key:'sample_id', label:'Prøve-ID'},
    {key:'sample_label', label:'Prøve', value: row => getName('samples', Number(row.sample_id))},
    {key:'panel_id', label:'Panel-ID'},
    {key:'panel_name', label:'Panel', value: row => getName('panels', Number(row.panel_id))},
    {key:'family_type', label:'Familietype (kode)', value: row => normalizeFamilyType(row.family_type)},
    {key:'family_type_display', label:'Familietype', value: row => getFamilyTypeLabel(row.family_type)},
    {key:'status', label:'Status (kode)'},
    {key:'status_display', label:'Status', value: row => {
      const sample = sampleMap.get(Number(row.sample_id));
      return sample?.status || row.status || '';
    }},
    {key:'acute', label:'Akut', value: row => row.acute ? 'Ja' : 'Nej'},
    {key:'urgent', label:'Haster', value: row => row.urgent ? 'Ja' : 'Nej'},
    {key:'analysis_responsible_id', label:'Analyseansvarlig-ID'},
    {key:'analysis_responsible', label:'Analyseansvarlig', value: row => resolveUserName(row.analysis_responsible_id)},
    {key:'interpreter_id', label:'Tolker-ID'},
    {key:'interpreter', label:'Tolker', value: row => resolveUserName(row.interpreter_id)},
    {key:'approver_id', label:'Godkender-ID'},
    {key:'approver', label:'Godkender', value: row => resolveUserName(row.approver_id)},
    {key:'clinician', label:'Rekvirent'},
    {key:'patient_group_id', label:'Patientgruppe-ID'},
    {key:'patient_group', label:'Patientgruppe', value: row => getPatientGroupName(row.patient_group_id)},
    {key:'indication', label:'Indikation'},
    {key:'hpo_terms', label:'HPO-termer', value: row => formatHpoList(row.hpo_terms)},
    {key:'ordered_at', label:'Bestilt (ISO)'},
    {key:'ordered_at_formatted', label:'Bestilt', value: row => formatDanishDate(row.ordered_at, true)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#ordersExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('orders', filteredOrders);
    exportFilteredCsv('glimr-ordinationer-filtreret.csv', rows, orderExportColumns, {
      entity: 'ordinationer',
      plural: 'ordinationer'
    });
  });
  tbody.addEventListener('click', e => {
    const actionButton = e.target.closest('button[data-order-action]');
    if (actionButton) {
      if (actionButton.disabled) return;
      const {orderId, orderAction} = actionButton.dataset;
      if (orderAction === 'samples') {
        openSamplesForOrder(orderId);
      } else if (orderAction === 'reports') {
        openReportsForOrder(orderId);
      }
      return;
    }
    const tr = e.target.closest('tr');
    if (!tr) return;
    const order = list.find(o => o.id === Number(tr.dataset.id));
    if (!order) return;
    selectedOrderId = order.id;
    fillForm(form, order);
    syncStatusFromSample(order.sample_id);
    enforcePrioritySelection();
    applyPatientSampleConstraints();
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('orders')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    enforcePrioritySelection();
    const isAcute = Boolean(form.elements.acute?.checked);
    const isUrgent = !isAcute && Boolean(form.elements.urgent?.checked);
    data.acute = isAcute;
    data.urgent = isUrgent;
    data.patient_id = Number(data.patient_id);
    data.sample_id = Number(data.sample_id);
    data.family_type = normalizeFamilyType(data.family_type);
    data.panel_id = data.panel_id ? Number(data.panel_id) : null;
    data.analysis_responsible_id = data.analysis_responsible_id ? Number(data.analysis_responsible_id) : null;
    data.interpreter_id = data.interpreter_id ? Number(data.interpreter_id) : null;
    data.approver_id = data.approver_id ? Number(data.approver_id) : null;
    data.patient_group_id = data.patient_group_id ? Number(data.patient_group_id) : null;
    if (data.clinician) data.clinician = data.clinician.trim();
    if (data.indication) {
      data.indication = data.indication.trim();
    } else {
      data.indication = '';
    }
    data.hpo_terms = normalizeHpoTerms(data.hpo_terms);
    if (data.status) data.status = data.status.trim();
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('orders', id)};
      const updated = {...before, ...data, id};
      await updateRecord('orders', updated, before);
    } else {
      delete data.id;
      await addRecord('orders', data);
    }
    const sampleBefore = findById('samples', data.sample_id);
    if (sampleBefore && (sampleBefore.status || '') !== (data.status || '')) {
      const updatedSample = {...sampleBefore, status: data.status || ''};
      await updateRecord('samples', updatedSample, sampleBefore);
      await syncControlSampleStatus(updatedSample, data.status || '');
      if (state.currentTab === 'samples') {
        renderTab('samples');
      }
    }
    await loadStore('orders');
    renderTab('orders');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    const patientsSection = document.querySelector('section[data-tab="patients"]');
    if (patientsSection && patientsSection.classList.contains('active')) {
      renderTab('patients');
    }
  });
  section.querySelector('#orderDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg ordre');
    if (!ensureWrite('orders')) return;
    if (confirm('Slet ordre?')) {
      await deleteRecord('orders', id);
      renderTab('orders');
      renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedOrderId = null;
    enforcePrioritySelection();
    renderRows();
    setTimeout(() => applyPatientSampleConstraints(), 0);
  });
  section.querySelector('#orderClear').addEventListener('click', () => form.reset());
}
function renderVariants(section) {
  let list = getCached('variants') || [];
  list = list.map(entry => {
    if (!entry || typeof entry !== 'object') return entry;
    const item = {...entry};
    const resolvedRsid = getVariantRsId(item);
    if (resolvedRsid) {
      item.rsid = resolvedRsid;
    } else {
      delete item.rsid;
    }
    return item;
  });
  const orders = getCached('orders') || [];
  const variantLibrary = getCached('variant_library') || [];
  const orderMap = new Map(orders.map(order => [Number(order.id), order]));
  const defaultGenomeBuild = determineDefaultGenomeBuild(list, orders, variantLibrary);
  const orderNameCache = new Map();
  const getOrderDisplayName = orderId => {
    const numericId = Number(orderId);
    if (!Number.isFinite(numericId) || numericId === 0) return '';
    if (orderNameCache.has(numericId)) {
      return orderNameCache.get(numericId);
    }
    const order = orderMap.get(numericId);
    let display = '';
    if (order) {
      for (const key of ['name', 'title', 'display_name', 'displayName', 'label']) {
        const value = order?.[key];
        if (typeof value === 'string' && value.trim()) {
          display = value.trim();
          break;
        }
      }
      if (!display) {
        const patientId = Number(order.patient_id);
        const panelId = Number(order.panel_id);
        const sampleId = Number(order.sample_id);
        const patientName = Number.isFinite(patientId) && patientId > 0 ? getName('patients', patientId) : '';
        const panel = Number.isFinite(panelId) && panelId > 0 ? findById('panels', panelId) : null;
        const sample = Number.isFinite(sampleId) && sampleId > 0 ? findById('samples', sampleId) : null;
        const sampleLabel = sample?.pmb_number || '';
        const parts = [patientName, sampleLabel, panel?.name].filter(part => part && String(part).trim());
        if (parts.length) {
          display = parts.join(' • ');
        } else if (order.id != null) {
          display = `Ordination #${order.id}`;
        }
      }
    }
    if (!display && Number.isFinite(numericId)) {
      display = `Ordination #${numericId}`;
    }
    orderNameCache.set(numericId, display);
    return display;
  };
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="variantSearch">Søg</label>
        <input id="variantSearch" type="search" placeholder="Gen/HGVS...">
        <details class="advanced-filter" id="variantsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-variants="id" placeholder="Variant-ID"></label>
            <label>Ordination<input type="search" data-filter-variants="order" placeholder="Ordinations-ID"></label>
            <label>Gen<input type="search" data-filter-variants="gene" placeholder="Gen"></label>
            <label>Transkript<input type="search" data-filter-variants="transcript" placeholder="RefSeq/ENST"></label>
            <label>rsID<input type="search" data-filter-variants="rsid" placeholder="rs123456"></label>
            <label>Genomisk position<input type="search" data-filter-variants="genomic_position" placeholder="chr19-11105362"></label>
            <label>ACMG<input type="search" data-filter-variants="classification" placeholder="1-5"></label>
            <label>Kriterier<input type="search" data-filter-variants="criteria" placeholder="PM1,PP3..."></label>
            <label>Varianttype
              <select data-filter-variants="variant_type">
                <option value="">Alle</option>
                ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
              </select>
            </label>
            <label>ISCN<input type="search" data-filter-variants="iscn" placeholder="arr[GRCh38]..."></label>
            <label>Kromosom<input type="search" data-filter-variants="chromosome" placeholder="Chr/arm"></label>
          </div>
        </details>
        <table><thead><tr><th>ID</th><th>Ordination</th><th>Variant</th><th>rsID</th><th>Opslag</th><th>Type</th><th>Klasse</th><th>Kriterier</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="variantsExport">Eksportér filtrerede varianter</button>
        </div>
      </div>
      <div>
        <h2>Variant</h2>
        <form id="variantForm">
          <input type="hidden" name="id">
          <label>Ordination
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer ordinationer">
              <select name="order_id" required>
                <option value="" selected>Vælg ordination</option>
                ${orders.map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Varianttype
            <select name="variant_type">
              ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
            </select>
          </label>
          <label>Gen / region<input name="gene" data-type-required="snv"></label>
          <div class="variant-field-group" data-variant-types="snv">
            <label>Transkript<input name="transcript" data-type-required="snv"></label>
            <label>HGVS c.<input name="hgvs_c" data-type-required="snv"></label>
            <label>HGVS p.<input name="hgvs_p"></label>
            <label>Genomisk position<input name="genomic_position" placeholder="chr19-11105362"></label>
            <label>dbSNP rsID<input name="rsid" placeholder="rs123456"></label>
            <label>Zygositet<input name="zygosity"></label>
          </div>
          <div class="variant-field-group" data-variant-types="cnv sv cyto">
            <div class="variant-structure-grid">
              <label>Genom reference<input name="genome_build"></label>
              <label>Kromosom<input name="chromosome"></label>
              <label>Start<input name="start"></label>
              <label>Slut<input name="end"></label>
              <label>Kopital<input name="copy_number"></label>
              <label>Strukturtype<select name="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
              <label>Størrelse<input name="size_bp"></label>
            </div>
            <label>ISCN<input name="iscn"></label>
            <label>Berørte gener<textarea name="affected_genes" class="small"></textarea></label>
            <label>Beskrivelse<textarea name="description" class="small"></textarea></label>
          </div>
          <label>ACMG-klasse<select name="classification" required><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option></select></label>
          <label>Kriterier<input name="criteria" placeholder="PM1,PP3..."></label>
          <label>VAF<input name="af" type="number" step="0.0001" placeholder="0,500"></label>
          <label>Annoteringer<textarea name="annotations" placeholder="Importerede annoteringer fra VarSeq og andre værktøjer."></textarea></label>
          <label>Tolkning<textarea name="interpretation"></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit" id="variantSave" data-action="save">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-save-new with-icon" type="submit" id="variantSaveNew" data-action="create" hidden>
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                  <path d="M15 14h6" />
                  <path d="M18 11v6" />
                </svg>
              </span>
              <span class="label">Gem som ny</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="variantClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="variantDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
            <button class="secondary" type="button" id="variantFromLibrary">Fra bibliotek</button>
            <button class="secondary" type="button" id="variantToLibrary">Til bibliotek</button>
          </div>
        </form>
      </div>
    </div>
  </div>
  <div class="panel">
    <fieldset data-collapsible data-collapsed="true" class="panel-fieldset">
      <legend>
        <span class="fieldset-title">Massetilføj varianter</span>
        <button type="button" class="fieldset-toggle" data-label-open="Minimér" data-label-closed="Udvid" aria-expanded="false">Udvid</button>
      </legend>
      <div class="fieldset-body" hidden>
        <div class="variant-batch-form">
          <p class="panel-hint">Tilføj flere varianter til en eksisterende ordination via import eller manuel indtastning.</p>
          <label class="stacked-control">Ordination
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer ordinationer">
              <select id="variantBatchOrder">
                <option value="" selected>Vælg ordination</option>
                ${orders.map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <div id="variantBatchList" class="repeater variant-batch-list"></div>
          <div class="variant-batch-actions">
            <button type="button" class="secondary" id="variantBatchAdd">Tilføj variant</button>
            <button type="button" class="secondary" id="variantBatchImport">Importér VarSeq CSV</button>
            <input type="file" id="variantBatchFile" accept=".csv,text/csv" hidden>
            <button type="button" class="primary" id="variantBatchSave">Gem varianter</button>
            <button type="button" class="secondary" id="variantBatchClear">Ryd rækker</button>
          </div>
          <div class="form-hint" id="variantBatchMessage" role="status" aria-live="polite"></div>
        </div>
      </div>
    </fieldset>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#variantSearch');
  const form = section.querySelector('#variantForm');
  const saveButton = form.querySelector('#variantSave');
  const saveButtonLabel = saveButton?.querySelector('.label');
  const saveNewButton = form.querySelector('#variantSaveNew');
  const defaultSaveLabel = saveButtonLabel?.textContent?.trim() || saveButton?.textContent?.trim() || 'Gem';
  const {updateVariantTypeFields, variantTypeSelect} = setupVariantTypeForm(form);
  const batchList = section.querySelector('#variantBatchList');
  const batchAddBtn = section.querySelector('#variantBatchAdd');
  const batchImportBtn = section.querySelector('#variantBatchImport');
  const batchFileInput = section.querySelector('#variantBatchFile');
  const batchSaveBtn = section.querySelector('#variantBatchSave');
  const batchClearBtn = section.querySelector('#variantBatchClear');
  const batchMessage = section.querySelector('#variantBatchMessage');
  const batchOrderSelect = section.querySelector('#variantBatchOrder');
  const setBatchMessage = (text, tone = 'info') => {
    if (!batchMessage) return;
    batchMessage.textContent = text ?? '';
    const color = tone === 'success' ? 'var(--accent-strong)' : tone === 'error' ? 'var(--danger)' : 'var(--muted-text)';
    batchMessage.style.color = color;
  };
  const addBatchVariantRow = (values = {}) => {
    if (!batchList) return;
    const defaultClass = values.classification != null ? String(values.classification) : '3';
    const classificationOptions = ['1','2','3','4','5'].map(v => `<option value="${v}"${defaultClass === String(v) ? ' selected' : ''}>${v}</option>`).join('');
    const row = document.createElement('div');
    row.className = 'case-row variant-row';
    row.innerHTML = `
      <label class="inline">Varianttype<select data-field="variant_type">${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}</select></label>
      <label class="inline">Gen / region<input type="text" data-field="gene" placeholder="BRCA1"></label>
      <div class="variant-batch-group" data-variant-types="snv">
        <label class="inline">Transkript<input type="text" data-field="transcript" placeholder="NM_007294.3"></label>
        <label class="inline">HGVS c.<input type="text" data-field="hgvs_c" placeholder="c.5266dupC"></label>
        <label class="inline">HGVS p.<input type="text" data-field="hgvs_p" placeholder="p.(Gln1756Profs*74)"></label>
        <label class="inline">Genomisk position<input type="text" data-field="genomic_position" placeholder="chr19-11105362"></label>
        <label class="inline">dbSNP rsID<input type="text" data-field="rsid" placeholder="rs123456"></label>
        <label class="inline">Zygositet<input type="text" data-field="zygosity" placeholder="Heterozygot"></label>
      </div>
      <div class="variant-batch-group" data-variant-types="cnv sv cyto">
        <label class="inline">Genom ref.<input type="text" data-field="genome_build" placeholder="GRCh38"></label>
        <label class="inline">Kromosom<input type="text" data-field="chromosome" placeholder="17p"></label>
        <label class="inline">Start<input type="text" data-field="start" placeholder="16287000"></label>
        <label class="inline">Slut<input type="text" data-field="end" placeholder="21100000"></label>
        <label class="inline">Kopital<input type="text" data-field="copy_number" placeholder="x1"></label>
        <label class="inline">Strukturtype<select data-field="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
        <label class="inline">Størrelse<input type="text" data-field="size_bp" placeholder="4.8 Mb"></label>
        <label class="inline wide">ISCN<textarea class="small" data-field="iscn" placeholder="arr[GRCh38] 17p11.2p12(16287000_21100000)x1"></textarea></label>
        <label class="inline wide">Berørte gener<textarea class="small" data-field="affected_genes" placeholder="RAI1; PMP22"></textarea></label>
      </div>
      <label class="inline wide">Beskrivelse<textarea class="small" data-field="description" placeholder="Fri tekst"></textarea></label>
      <label class="inline">ACMG<select data-field="classification">${classificationOptions}</select></label>
      <label class="inline">Kriterier<input type="text" data-field="criteria" placeholder="PM1,PP3"></label>
      <label class="inline">VAF<input type="number" step="0.0001" data-field="af" placeholder="0,500"></label>
      <label class="inline wide">Annoteringer<textarea class="small" data-field="annotations" placeholder="VarSeq-annoteringer og noter"></textarea></label>
      <label class="inline wide">Tolkning<textarea class="small" data-field="interpretation" placeholder="Valgfrit"></textarea></label>
      <button type="button" class="secondary case-choose-library">Vælg fra bibliotek</button>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const setValue = (selector, value) => {
      const el = row.querySelector(selector);
      if (!el) return;
      if (selector.includes('sv_subtype') && el.tagName === 'SELECT') {
        const normalized = normalizeStructureTypeValue(value);
        const asString = normalized ? String(normalized) : '';
        if (el.dataset.allowLegacyOption !== undefined && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
          const opt = document.createElement('option');
          opt.value = asString;
          opt.textContent = getStructureTypeLabel(asString);
          opt.dataset.legacy = 'true';
          el.appendChild(opt);
        }
        el.value = asString;
        return;
      }
      el.value = value || '';
    };
    setValue('[data-field="variant_type"]', normalizeVariantType(values.variant_type));
    setValue('[data-field="gene"]', values.gene);
    setValue('[data-field="transcript"]', values.transcript);
    setValue('[data-field="hgvs_c"]', values.hgvs_c);
    setValue('[data-field="hgvs_p"]', values.hgvs_p);
    setValue('[data-field="genomic_position"]', values.genomic_position);
    const resolvedRsid = values.rsid || getVariantRsId(values);
    setValue('[data-field="rsid"]', resolvedRsid);
    setValue('[data-field="zygosity"]', values.zygosity);
    setValue('[data-field="criteria"]', values.criteria);
    setValue('[data-field="genome_build"]', values.genome_build);
    setValue('[data-field="chromosome"]', values.chromosome);
    setValue('[data-field="start"]', values.start);
    setValue('[data-field="end"]', values.end);
    setValue('[data-field="copy_number"]', values.copy_number);
    setValue('[data-field="sv_subtype"]', values.sv_subtype);
    setValue('[data-field="size_bp"]', values.size_bp);
    setValue('[data-field="iscn"]', values.iscn);
    setValue('[data-field="affected_genes"]', values.affected_genes);
    setValue('[data-field="description"]', values.description);
    const afField = row.querySelector('[data-field="af"]');
    if (afField) {
      if (values.af !== undefined && values.af !== null && values.af !== '') {
        afField.value = values.af;
      } else {
        afField.value = '';
      }
    }
    const interpretationField = row.querySelector('[data-field="interpretation"]');
    if (interpretationField) interpretationField.value = values.interpretation || '';
    const annotationsField = row.querySelector('[data-field="annotations"]');
    if (annotationsField) annotationsField.value = values.annotations || '';
    const typeSelect = row.querySelector('[data-field="variant_type"]');
    const typeGroups = row.querySelectorAll('[data-variant-types]');
    const updateRowVariantType = () => {
      const type = normalizeVariantType(typeSelect?.value || 'snv');
      if (typeSelect && typeSelect.value !== type) typeSelect.value = type;
      typeGroups.forEach(group => {
        const allowed = (group.dataset.variantTypes || '').split(/\s+/).filter(Boolean).map(normalizeVariantType);
        group.hidden = allowed.length ? !allowed.includes(type) : false;
      });
    };
    updateRowVariantType();
    typeSelect?.addEventListener('change', updateRowVariantType);
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern varianten fra batch-listen.');
    const libraryBtn = row.querySelector('.case-choose-library');
    libraryBtn?.addEventListener('click', () => {
      openVariantLibraryPicker(variant => {
        setValue('[data-field="variant_type"]', normalizeVariantType(variant.variant_type));
        setValue('[data-field="gene"]', variant.gene);
        setValue('[data-field="transcript"]', variant.transcript);
        setValue('[data-field="hgvs_c"]', variant.hgvs_c);
        setValue('[data-field="hgvs_p"]', variant.hgvs_p);
        setValue('[data-field="genomic_position"]', variant.genomic_position);
        setValue('[data-field="rsid"]', getVariantRsId(variant));
        setValue('[data-field="criteria"]', variant.criteria);
        setValue('[data-field="genome_build"]', variant.genome_build);
        setValue('[data-field="chromosome"]', variant.chromosome);
        setValue('[data-field="start"]', variant.start);
        setValue('[data-field="end"]', variant.end);
        setValue('[data-field="copy_number"]', variant.copy_number);
        setValue('[data-field="sv_subtype"]', variant.sv_subtype);
        setValue('[data-field="size_bp"]', variant.size_bp);
        setValue('[data-field="iscn"]', variant.iscn);
        setValue('[data-field="affected_genes"]', variant.affected_genes);
        setValue('[data-field="description"]', variant.description);
        const classField = row.querySelector('[data-field="classification"]');
        if (classField && variant.classification != null && variant.classification !== '') {
          classField.value = String(variant.classification);
        }
        const interpretationField = row.querySelector('[data-field="interpretation"]');
        if (interpretationField) interpretationField.value = variant.evidence || variant.interpretation || '';
        const annotationsField = row.querySelector('[data-field="annotations"]');
        if (annotationsField) annotationsField.value = variant.annotations || variant.annotation_summary || '';
        updateRowVariantType();
      });
    });
    if (libraryBtn) setTooltip(libraryBtn, 'Vælg en variant fra biblioteket.');
    batchList.appendChild(row);
    applyButtonTooltips(row);
    const genomicField = row.querySelector('[data-field="genomic_position"]');
    if (genomicField) setTooltip(genomicField, tooltipCatalog.forms.variantForm.genomic_position);
    const rsidField = row.querySelector('[data-field="rsid"]');
    if (rsidField) setTooltip(rsidField, tooltipCatalog.forms.variantForm.rsid);
    const subtypeSelect = row.querySelector('[data-field="sv_subtype"]');
    if (subtypeSelect) setTooltip(subtypeSelect, tooltipCatalog.forms.variantForm.sv_subtype);
  };
  const getBatchValue = (row, field) => {
    const el = row?.querySelector(`[data-field="${field}"]`);
    if (!el) return '';
    return (el.value || '').trim();
  };
  const isBatchVariantRowEmpty = row => {
    if (!row) return true;
    const gene = getBatchValue(row, 'gene');
    const transcript = getBatchValue(row, 'transcript');
    const hgvsC = getBatchValue(row, 'hgvs_c');
    const hgvsP = getBatchValue(row, 'hgvs_p');
    const genomicPosition = getBatchValue(row, 'genomic_position');
    const rsid = getBatchValue(row, 'rsid');
    const zygosity = getBatchValue(row, 'zygosity');
    const criteria = getBatchValue(row, 'criteria');
    const af = getBatchValue(row, 'af');
    const interpretation = getBatchValue(row, 'interpretation');
    const annotations = getBatchValue(row, 'annotations');
    const genomeBuild = getBatchValue(row, 'genome_build');
    const chromosome = getBatchValue(row, 'chromosome');
    const start = getBatchValue(row, 'start');
    const end = getBatchValue(row, 'end');
    const copyNumber = getBatchValue(row, 'copy_number');
    const svSubtype = getBatchValue(row, 'sv_subtype');
    const sizeBp = getBatchValue(row, 'size_bp');
    const iscn = getBatchValue(row, 'iscn');
    const description = getBatchValue(row, 'description');
    const affectedGenes = getBatchValue(row, 'affected_genes');
    return !gene && !transcript && !hgvsC && !hgvsP && !genomicPosition && !rsid && !zygosity && !criteria && !af && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
  };
  const collectBatchVariants = () => {
    if (!batchList) return [];
    const rows = Array.from(batchList.querySelectorAll('.variant-row'));
    const variants = [];
    rows.forEach((row, idx) => {
      const variantType = normalizeVariantType(getBatchValue(row, 'variant_type') || 'snv');
      const gene = getBatchValue(row, 'gene');
      const transcript = getBatchValue(row, 'transcript');
      const hgvsC = getBatchValue(row, 'hgvs_c');
      const hgvsP = getBatchValue(row, 'hgvs_p');
      const genomicPosition = getBatchValue(row, 'genomic_position');
      const rsid = getBatchValue(row, 'rsid');
      const zygosity = getBatchValue(row, 'zygosity');
      const criteria = getBatchValue(row, 'criteria');
      const afRaw = getBatchValue(row, 'af');
      const interpretation = getBatchValue(row, 'interpretation');
      const annotations = getBatchValue(row, 'annotations');
      const genomeBuild = getBatchValue(row, 'genome_build');
      const chromosome = getBatchValue(row, 'chromosome');
      const start = getBatchValue(row, 'start');
      const end = getBatchValue(row, 'end');
      const copyNumber = getBatchValue(row, 'copy_number');
      const svSubtype = normalizeStructureTypeValue(getBatchValue(row, 'sv_subtype'));
      const sizeBp = getBatchValue(row, 'size_bp');
      const iscn = getBatchValue(row, 'iscn');
      const description = getBatchValue(row, 'description');
      const affectedGenes = getBatchValue(row, 'affected_genes');
      const classification = row.querySelector('[data-field="classification"]')?.value || '3';
      const isEmpty = !gene && !transcript && !hgvsC && !hgvsP && !genomicPosition && !rsid && !zygosity && !criteria && !afRaw && !interpretation && !annotations && !genomeBuild && !chromosome && !start && !end && !copyNumber && !svSubtype && !sizeBp && !iscn && !description && !affectedGenes;
      if (isEmpty) return;
      if (variantType === 'snv') {
        if (!gene) {
          const err = new Error(`Angiv gen for række ${idx + 1}.`);
          err.focus = row.querySelector('[data-field="gene"]');
          throw err;
        }
      } else {
        if (!iscn && !description && !chromosome) {
          const err = new Error(`Angiv ISCN, kromosom eller beskrivelse for række ${idx + 1}.`);
          err.focus = row.querySelector('[data-field="iscn"]') || row.querySelector('[data-field="description"]');
          throw err;
        }
      }
      const variant = {
        variant_type: variantType,
        gene,
        transcript,
        hgvs_c: hgvsC,
        hgvs_p: hgvsP,
        genomic_position: genomicPosition,
        rsid: normalizeRsId(rsid),
        zygosity,
        classification: String(classification || '3'),
        criteria,
        interpretation,
        genome_build: genomeBuild,
        chromosome,
        start,
        end,
        copy_number: copyNumber,
        sv_subtype: svSubtype,
        size_bp: sizeBp,
        iscn,
        description,
        affected_genes: affectedGenes
      };
      if (afRaw) {
        const afNumber = Number(afRaw);
        if (!Number.isFinite(afNumber)) {
          const err = new Error(`VAF skal være et tal i række ${idx + 1}.`);
          err.focus = row.querySelector('[data-field="af"]');
          throw err;
        }
        variant.af = afNumber;
      }
      if (annotations) {
        variant.annotations = annotations;
      }
      variants.push(variant);
    });
    return variants;
  };
  const removeEmptyBatchRows = () => {
    if (!batchList) return;
    const rows = Array.from(batchList.querySelectorAll('.variant-row'));
    if (!rows.length) return;
    const filled = rows.filter(row => !isBatchVariantRowEmpty(row));
    if (!filled.length) {
      batchList.innerHTML = '';
      return;
    }
    rows.forEach(row => {
      if (isBatchVariantRowEmpty(row)) row.remove();
    });
  };
  const enterEditMode = id => {
    if (!form) return;
    form.dataset.mode = 'edit';
    form.dataset.editingId = id != null ? String(id) : '';
    if (saveButtonLabel) {
      saveButtonLabel.textContent = 'Opdater variant';
    } else if (saveButton) {
      saveButton.textContent = 'Opdater variant';
    }
    if (saveNewButton) saveNewButton.hidden = false;
  };
  const exitEditMode = () => {
    if (!form) return;
    form.dataset.mode = 'create';
    form.dataset.editingId = '';
    clearFormIdentifier(form);
    if (saveButtonLabel) {
      saveButtonLabel.textContent = defaultSaveLabel;
    } else if (saveButton) {
      saveButton.textContent = defaultSaveLabel;
    }
    if (saveNewButton) saveNewButton.hidden = true;
  };
  exitEditMode();
  const filterInputs = {
    id: section.querySelector('[data-filter-variants="id"]'),
    order: section.querySelector('[data-filter-variants="order"]'),
    gene: section.querySelector('[data-filter-variants="gene"]'),
    transcript: section.querySelector('[data-filter-variants="transcript"]'),
    rsid: section.querySelector('[data-filter-variants="rsid"]'),
    genomic_position: section.querySelector('[data-filter-variants="genomic_position"]'),
    classification: section.querySelector('[data-filter-variants="classification"]'),
    criteria: section.querySelector('[data-filter-variants="criteria"]'),
    variant_type: section.querySelector('[data-filter-variants="variant_type"]'),
    iscn: section.querySelector('[data-filter-variants="iscn"]'),
    chromosome: section.querySelector('[data-filter-variants="chromosome"]')
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  initCollapsibleFieldsets(section);
  let filteredVariants = list.slice();
  let activeFilters = {};
  let selectedVariantId = null;
  const renderRows = () => {
    const term = (search.value || '').trim().toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      order: filterInputs.order?.value.trim().toLowerCase() || '',
      gene: filterInputs.gene?.value.trim().toLowerCase() || '',
      transcript: filterInputs.transcript?.value.trim().toLowerCase() || '',
      rsid: filterInputs.rsid?.value.trim().toLowerCase() || '',
      genomic_position: filterInputs.genomic_position?.value.trim().toLowerCase() || '',
      classification: filterInputs.classification?.value.trim().toLowerCase() || '',
      criteria: filterInputs.criteria?.value.trim().toLowerCase() || '',
      variant_type: filterInputs.variant_type?.value.trim().toLowerCase() || '',
      iscn: filterInputs.iscn?.value.trim().toLowerCase() || '',
      chromosome: filterInputs.chromosome?.value.trim().toLowerCase() || ''
    };
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredVariants = list.filter(v => {
      if (!term) return true;
      const creator = determineCreatedBy('variants', v);
      const orderName = getOrderDisplayName(v.order_id);
      const searchValues = [
        v.gene,
        v.transcript,
        v.hgvs_c,
        v.hgvs_p,
        getVariantRsId(v),
        v.genomic_position,
        v.criteria,
        v.zygosity,
        v.iscn,
        v.chromosome,
        getStructureTypeLabel(v.sv_subtype),
        v.description,
        v.affected_genes,
        formatVariantGenomicRange(v),
        formatVariantTitle(v),
        getVariantTypeLabel(v.variant_type),
        creator,
        orderName,
        String(v.order_id || '')
      ];
      return searchValues.some(val => (val || '').toString().toLowerCase().includes(term));
    }).filter(v => {
      if (filters.id && !String(v.id).includes(filters.id)) return false;
      if (filters.order) {
        const orderIdString = (String(v.order_id || '')).toLowerCase();
        const orderName = getOrderDisplayName(v.order_id).toLowerCase();
        if (!orderIdString.includes(filters.order) && !orderName.includes(filters.order)) return false;
      }
      if (filters.gene && !(v.gene || '').toLowerCase().includes(filters.gene)) return false;
      if (filters.transcript && !(v.transcript || '').toLowerCase().includes(filters.transcript)) return false;
      if (filters.rsid && !getVariantRsId(v).toLowerCase().includes(filters.rsid)) return false;
      if (filters.genomic_position && !(v.genomic_position || formatVariantGenomicRange(v) || '').toLowerCase().includes(filters.genomic_position)) return false;
      if (filters.classification && !(String(v.classification || '')).toLowerCase().includes(filters.classification)) return false;
      if (filters.criteria && !(v.criteria || '').toLowerCase().includes(filters.criteria)) return false;
      if (filters.variant_type && normalizeVariantType(v.variant_type) !== normalizeVariantType(filters.variant_type)) return false;
      if (filters.iscn && !(v.iscn || '').toLowerCase().includes(filters.iscn)) return false;
      if (filters.chromosome) {
        const chromo = (v.chromosome || '').toLowerCase();
        if (!chromo.includes(filters.chromosome)) return false;
      }
      return true;
    });
    if (selectedVariantId != null && !filteredVariants.some(v => v.id === selectedVariantId)) {
      selectedVariantId = null;
    }
    tbody.innerHTML = filteredVariants.map(v => {
      const createdBy = determineCreatedBy('variants', v);
      const selectedAttr = v.id === selectedVariantId ? ' data-selected="true"' : '';
      const title = formatVariantTitle(v);
      const typeLabel = getVariantTypeLabel(v.variant_type);
      const orderName = getOrderDisplayName(v.order_id);
      const orderTitle = v.order_id != null ? ` title="Ordination #${v.order_id}"` : '';
      return `<tr data-id="${v.id}"${selectedAttr}><td>${v.id}</td><td${orderTitle}>${esc(orderName)}</td><td>${esc(title)}</td><td>${formatRsIdCell(getVariantRsId(v))}</td><td>${formatVariantLookupCell(v, defaultGenomeBuild, orderMap)}</td><td>${esc(typeLabel)}</td><td>${esc(v.classification||'')}</td><td>${esc(v.criteria||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  const variantExportColumns = [
    {key:'id', label:'ID'},
    {key:'order_id', label:'Ordination-ID'},
    {key:'order_name', label:'Ordination', value: row => getOrderDisplayName(row.order_id)},
    {key:'variant_type', label:'Varianttype (kode)'},
    {key:'variant_type_label', label:'Varianttype', value: row => getVariantTypeLabel(row.variant_type)},
    {key:'gene', label:'Gen/Region'},
    {key:'transcript', label:'Transkript'},
    {key:'hgvs_c', label:'HGVS c.'},
    {key:'hgvs_p', label:'HGVS p.'},
    {key:'rsid', label:'rsID'},
    {key:'zygosity', label:'Zygositet'},
    {key:'classification', label:'Klasse'},
    {key:'classification_label', label:'Klasse (tekst)', value: row => {
      const key = String(row.classification ?? '');
      return classificationMap?.[key]?.display || '';
    }},
    {key:'criteria', label:'Kriterier'},
    {key:'af', label:'VAF'},
    {key:'genomic_position', label:'Genomisk position'},
    {key:'genome_build', label:'Genom reference'},
    {key:'chromosome', label:'Kromosom'},
    {key:'start', label:'Start'},
    {key:'end', label:'Slut'},
    {key:'copy_number', label:'Kopital'},
    {key:'sv_subtype', label:'Strukturtype (kode)'},
    {key:'sv_subtype_label', label:'Strukturtype', value: row => getStructureTypeLabel(row.sv_subtype)},
    {key:'size_bp', label:'Størrelse (bp)'},
    {key:'iscn', label:'ISCN'},
    {key:'description', label:'Beskrivelse'},
    {key:'affected_genes', label:'Berørte gener'},
    {key:'annotations', label:'Annoteringer'},
    {key:'interpretation', label:'Tolkning'},
    {key:'variant_title', label:'Varianttitel', value: row => formatVariantTitle(row)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];
  section.querySelector('#variantsExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('variants', filteredVariants);
    exportFilteredCsv('glimr-varianter-filtreret.csv', rows, variantExportColumns, {
      entity: 'varianter',
      plural: 'varianter'
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const variant = list.find(v => v.id === Number(tr.dataset.id));
    if (!variant) return;
    selectedVariantId = variant.id;
    fillForm(form, variant);
    updateVariantTypeFields();
    enterEditMode(variant.id);
    if (batchOrderSelect && variant.order_id) {
      batchOrderSelect.value = String(variant.order_id);
    }
    renderRows();
  });
  batchAddBtn?.addEventListener('click', () => addBatchVariantRow());
  batchClearBtn?.addEventListener('click', () => {
    if (batchList) {
      batchList.innerHTML = '';
      addBatchVariantRow();
    }
    setBatchMessage('Batch-liste ryddet.', 'info');
  });
  batchImportBtn?.addEventListener('click', () => batchFileInput?.click());
  batchFileInput?.addEventListener('change', async () => {
    const file = batchFileInput?.files?.[0];
    if (!file) return;
    try {
      const {variants: importedVariants, warnings, summary} = await parseVarSeqFile(file);
      if (!importedVariants.length) {
        setBatchMessage('Ingen varianter blev fundet i filen.', 'error');
        return;
      }
      removeEmptyBatchRows();
      importedVariants.forEach(variant => addBatchVariantRow(variant));
      const parts = [`Tilføjede ${importedVariants.length} varianter fra ${file.name}.`];
      if (summary.skipped) parts.push(`${summary.skipped} rækker ignoreret.`);
      if (warnings.length) parts.push(`${warnings.length} advarsler logget i konsollen.`);
      setBatchMessage(parts.join(' '), 'success');
      setStatus(`VarSeq import til masseoprettelse: ${importedVariants.length} varianter klar.`);
      if (warnings.length) console.warn('VarSeq import advarsler', warnings);
    } catch (err) {
      console.error(err);
      setBatchMessage('Kunne ikke importere VarSeq CSV: ' + (err?.message || err), 'error');
    } finally {
      if (batchFileInput) batchFileInput.value = '';
    }
  });
  batchSaveBtn?.addEventListener('click', async () => {
    if (!ensureWrite('variants')) {
      setBatchMessage('Handling kræver skriveadgang. Log ind med en bruger der kan redigere varianter.', 'error');
      return;
    }
    const orderId = Number(batchOrderSelect?.value || 0);
    if (!orderId) {
      setBatchMessage('Vælg en ordination for at gemme varianterne.', 'error');
      batchOrderSelect?.focus();
      return;
    }
    let variants;
    try {
      variants = collectBatchVariants();
    } catch (err) {
      setBatchMessage(err.message || 'Kunne ikke fortolke batch-rækkerne.', 'error');
      if (err.focus) err.focus.focus();
      return;
    }
    if (!variants.length) {
      setBatchMessage('Udfyld mindst én variant før du gemmer.', 'error');
      return;
    }
    batchSaveBtn.disabled = true;
    if (batchAddBtn) batchAddBtn.disabled = true;
    if (batchImportBtn) batchImportBtn.disabled = true;
    if (batchClearBtn) batchClearBtn.disabled = true;
    try {
      setBatchMessage('Gemmer varianter...', 'info');
      const createdIds = [];
      for (const variant of variants) {
        const id = await addRecord('variants', {...variant, order_id: orderId});
        createdIds.push(id);
      }
      list = getCached('variants');
      filteredVariants = list.slice();
      renderRows();
      if (batchList) {
        batchList.innerHTML = '';
        addBatchVariantRow();
      }
      setBatchMessage(`Tilføjede ${createdIds.length} varianter til ordination ${orderId}.`, 'success');
      setStatus(`Tilføjede ${createdIds.length} varianter til ordination ${orderId}.`);
    } catch (err) {
      console.error(err);
      setBatchMessage('Kunne ikke gemme varianter: ' + (err?.message || err), 'error');
    } finally {
      batchSaveBtn.disabled = false;
      if (batchAddBtn) batchAddBtn.disabled = false;
      if (batchImportBtn) batchImportBtn.disabled = false;
      if (batchClearBtn) batchClearBtn.disabled = false;
    }
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('variants')) return;
    const action = e.submitter?.dataset.action || 'save';
    const data = Object.fromEntries(new FormData(form).entries());
    Object.keys(data).forEach(key => {
      if (typeof data[key] === 'string') {
        data[key] = data[key].trim();
      }
    });
    data.variant_type = normalizeVariantType(data.variant_type);
    data.rsid = normalizeRsId(data.rsid);
    data.sv_subtype = normalizeStructureTypeValue(data.sv_subtype);
    data.order_id = Number(data.order_id);
    data.classification = String(data.classification);
    if (data.af) data.af = Number(data.af);
    const editingId = Number(form.dataset.editingId || data.id || 0);
    const creatingNew = action === 'create' || !editingId;
    if (!creatingNew) {
      const id = editingId;
      const before = {...findById('variants', id)};
      const updated = {...before, ...data, id};
      await updateRecord('variants', updated, before);
    } else {
      delete data.id;
      await addRecord('variants', data);
    }
    await loadStore('variants');
    renderTab('variants');
  });
  section.querySelector('#variantDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg variant');
    if (!ensureWrite('variants')) return;
    if (confirm('Slet variant?')) {
      await deleteRecord('variants', id);
      renderTab('variants');
    }
  });
  section.querySelector('#variantFromLibrary').addEventListener('click', () => {
    openVariantLibraryPicker(variant => {
      if (!form) return;
      if (form.elements.variant_type) form.elements.variant_type.value = normalizeVariantType(variant.variant_type);
      if (form.elements.gene) form.elements.gene.value = variant.gene || '';
      if (form.elements.transcript) form.elements.transcript.value = variant.transcript || '';
      if (form.elements.hgvs_c) form.elements.hgvs_c.value = variant.hgvs_c || '';
      if (form.elements.hgvs_p) form.elements.hgvs_p.value = variant.hgvs_p || '';
      if (form.elements.genomic_position) form.elements.genomic_position.value = variant.genomic_position || formatVariantGenomicRange(variant) || '';
      if (form.elements.rsid) form.elements.rsid.value = getVariantRsId(variant) || '';
      if (form.elements.criteria) form.elements.criteria.value = variant.criteria || '';
      if (form.elements.genome_build) form.elements.genome_build.value = variant.genome_build || '';
      if (form.elements.chromosome) form.elements.chromosome.value = variant.chromosome || '';
      if (form.elements.start) form.elements.start.value = variant.start || '';
      if (form.elements.end) form.elements.end.value = variant.end || '';
      if (form.elements.copy_number) form.elements.copy_number.value = variant.copy_number || '';
      if (form.elements.sv_subtype) form.elements.sv_subtype.value = variant.sv_subtype || '';
      if (form.elements.size_bp) form.elements.size_bp.value = variant.size_bp || '';
      if (form.elements.iscn) form.elements.iscn.value = variant.iscn || '';
      if (form.elements.affected_genes) form.elements.affected_genes.value = variant.affected_genes || '';
      if (form.elements.description) form.elements.description.value = variant.description || '';
      if (form.elements.annotations) form.elements.annotations.value = variant.annotations || variant.annotation_summary || '';
      if (form.elements.interpretation) form.elements.interpretation.value = variant.evidence || variant.interpretation || '';
      if (form.elements.classification && variant.classification != null && variant.classification !== '') {
        form.elements.classification.value = String(variant.classification);
      }
      updateVariantTypeFields();
    });
  });
  if (batchList && !batchList.children.length) {
    addBatchVariantRow();
    setBatchMessage('Importer eller udfyld varianter for at gemme dem på den valgte ordination.', 'info');
  }
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedVariantId = null;
    updateVariantTypeFields();
    exitEditMode();
    renderRows();
  });
  section.querySelector('#variantClear').addEventListener('click', () => {
    const orderValue = form.elements.order_id.value;
    const classificationValue = form.elements.classification.value;
    form.reset();
    if (orderValue) form.elements.order_id.value = orderValue;
    if (classificationValue) form.elements.classification.value = classificationValue;
    updateVariantTypeFields();
    exitEditMode();
  });
  section.querySelector('#variantToLibrary').addEventListener('click', async () => {
    if (!ensureWrite('variant_library')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    Object.keys(data).forEach(key => {
      if (typeof data[key] === 'string') {
        data[key] = data[key].trim();
      }
    });
    data.variant_type = normalizeVariantType(data.variant_type);
    data.rsid = normalizeRsId(data.rsid);
    if (!data.gene && !data.hgvs_c && !data.hgvs_p && !data.iscn && !data.description) {
      return alert('Udfyld mindst ét kendetegn (gen, HGVS eller ISCN).');
    }
    const evidenceParts = [];
    if (data.interpretation) evidenceParts.push(data.interpretation);
    if (data.annotations) evidenceParts.push(data.annotations);
    const libraryEntry = {
      variant_type: data.variant_type,
      gene: data.gene,
      transcript: data.transcript,
      hgvs_c: data.hgvs_c,
      hgvs_p: data.hgvs_p,
      rsid: data.rsid,
      genomic_position: data.genomic_position,
      classification: String(data.classification || ''),
      criteria: data.criteria,
      evidence: evidenceParts.join('\n').trim(),
      condition: '',
      inheritance: '',
      genome_build: data.genome_build,
      chromosome: data.chromosome,
      start: data.start,
      end: data.end,
      copy_number: data.copy_number,
      sv_subtype: data.sv_subtype,
      size_bp: data.size_bp,
      iscn: data.iscn,
      description: data.description,
      affected_genes: data.affected_genes,
      curated_by: currentUserName(),
      last_review: new Date().toISOString().split('T')[0]
    };
    await addRecord('variant_library', libraryEntry);
    await loadStore('variant_library');
    renderTab('variant_library');
    alert('Variant tilføjet til biblioteket');
  });
}
function renderVariantLibrary(section) {
  const rawLibrary = getCached('variant_library') || [];
  const list = rawLibrary.map(entry => {
    if (!entry || typeof entry !== 'object') return entry;
    const item = {...entry};
    const resolvedRsid = getVariantRsId(item);
    if (resolvedRsid) {
      item.rsid = resolvedRsid;
    } else {
      delete item.rsid;
    }
    const normalizedClass = mapVarSeqClassification(item.classification);
    if (normalizedClass) {
      item.classification = normalizedClass;
    } else if (item.classification == null) {
      item.classification = '';
    }
    return item;
  }).sort((a, b) => {
    const titleA = formatVariantTitle(a) || '';
    const titleB = formatVariantTitle(b) || '';
    const titleCompare = titleA.localeCompare(titleB, 'da');
    if (titleCompare) return titleCompare;
    const typeCompare = normalizeVariantType(a.variant_type).localeCompare(normalizeVariantType(b.variant_type));
    if (typeCompare) return typeCompare;
    return (a.id || 0) - (b.id || 0);
  });
  const initialGenomeBuild = determineDefaultGenomeBuild([], [], list) || DEFAULT_GENOME_BUILD;
  let selectedGenomeBuild = normalizeGenomeBuildValue(initialGenomeBuild) || DEFAULT_GENOME_BUILD;
  const classificationOptions = ['1','2','3','4','5'].map(value => `<option value="${value}">${value}</option>`).join('');
  section.innerHTML = `
  <div class="panel variant-library-panel">
    <div class="variant-hotspot" data-collapsed="true">
      <div class="variant-hotspot__header">
        <div class="variant-hotspot__title">
          <h2>Genomiske hotspots</h2>
          <span class="variant-hotspot__summary" data-hotspot-summary></span>
        </div>
        <button type="button" class="variant-hotspot__toggle" data-hotspot-toggle aria-expanded="false" aria-controls="variantHotspotContent">Vis hotspots</button>
      </div>
      <div id="variantHotspotContent" class="variant-hotspot__body" data-hotspot-content hidden>
        <div id="variantHotspotChart" class="variant-hotspot__chart" role="img" aria-live="polite" aria-label="Hotspot over varianter fordelt på kromosomer"></div>
        <p class="variant-hotspot__caption" data-hotspot-caption>Hotspot-oversigten viser fordelingen af viste varianter langs hvert kromosom.</p>
      </div>
    </div>
    <div class="flex">
      <div>
        <label for="libSearch">Søg</label>
        <input id="libSearch" type="search" placeholder="Gen/HGVS/ISCN...">
        <details class="advanced-filter" id="variantLibraryFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>Gen<input type="search" data-filter-library="gene" placeholder="Gen"></label>
            <label>Transkript<input type="search" data-filter-library="transcript" placeholder="RefSeq/ENST"></label>
            <label>HGVS c.<input type="search" data-filter-library="hgvs_c" placeholder="c."></label>
            <label>HGVS p.<input type="search" data-filter-library="hgvs_p" placeholder="p."></label>
            <label>rsID<input type="search" data-filter-library="rsid" placeholder="rs123456"></label>
            <label>Genomisk position<input type="search" data-filter-library="genomic_position" placeholder="chr19-11105362"></label>
            <label>Klasse<input type="search" data-filter-library="classification" placeholder="1-5"></label>
            <label>Kriterier<input type="search" data-filter-library="criteria" placeholder="PM1,PP3..."></label>
            <label>Varianttype
              <select data-filter-library="variant_type">
                <option value="">Alle</option>
                ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
              </select>
            </label>
            <label>ISCN<input type="search" data-filter-library="iscn" placeholder="arr[GRCh38]..."></label>
            <label>Kromosom<input type="search" data-filter-library="chromosome" placeholder="Chr"></label>
            <label>Genom<input type="search" data-filter-library="genome_build" placeholder="GRCh38"></label>
            <label>Genomisk start<input type="search" data-filter-library="start" placeholder="Start"></label>
            <label>Genomisk slut<input type="search" data-filter-library="end" placeholder="Slut"></label>
            <label>SV-type<input type="search" data-filter-library="sv_subtype" placeholder="Deletion, duplication..."></label>
            <label>Kopital<input type="search" data-filter-library="copy_number" placeholder="x1/x3..."></label>
            <label>Størrelse<input type="search" data-filter-library="size_bp" placeholder="Mb/kb"></label>
            <label>Tilstand<input type="search" data-filter-library="condition" placeholder="Tilstand"></label>
            <label>Nedarvning<input type="search" data-filter-library="inheritance" placeholder="Arvegang"></label>
            <label>Kurateret af<input type="search" data-filter-library="curated_by" placeholder="Kurator"></label>
            <label>Berørte gener<input type="search" data-filter-library="affected_genes" placeholder="GEN1;GEN2"></label>
            <label>Beskrivelse<input type="search" data-filter-library="description" placeholder="Kort beskrivelse"></label>
            <label>Sidst gennemgået fra<input type="date" data-filter-library="last_review_from"></label>
            <label>Sidst gennemgået til<input type="date" data-filter-library="last_review_to"></label>
          </div>
        </details>
        <table>
          <thead>
            <tr><th>ID</th><th>Variant</th><th>Type</th><th>Genomisk position</th><th>HGVS c.</th><th>HGVS p.</th><th>rsID</th><th>Klasse</th><th>Frekvens</th><th>Forekomst</th><th>Kriterier</th><th>ISCN</th><th>Tilstand</th><th>Nedarvning</th><th>Kurateret af</th><th>Sidst gennemgået</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="table-actions">
          <button type="button" class="secondary" id="libraryOpenPatients" disabled data-tooltip="Åbn Patienter-fanen filtreret på den valgte variant">Vis patienter med varianten</button>
          <button type="button" class="secondary" id="libraryExportCsv">Eksportér CSV</button>
          <button type="button" class="secondary" id="libraryImportCsv">Importér CSV</button>
          <input type="file" id="variantLibraryImportInput" accept=".csv,text/csv" hidden>
        </div>
      </div>
      <div>
        <h2>Bibliotekspost</h2>
        <form id="variantLibraryForm">
          <input type="hidden" name="id">
          <label>Varianttype
            <select name="variant_type">
              ${VARIANT_TYPE_OPTIONS.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
            </select>
          </label>
          <label>Gen / region<input name="gene"></label>
          <div class="variant-field-group" data-variant-types="snv">
            <label>Transkript<input name="transcript"></label>
            <label>HGVS c.<input name="hgvs_c"></label>
            <label>HGVS p.<input name="hgvs_p"></label>
            <label>Genomisk position<input name="genomic_position" placeholder="chr19-11105362"></label>
            <label>dbSNP rsID<input name="rsid" placeholder="rs123456"></label>
          </div>
          <div class="variant-field-group" data-variant-types="cnv sv cyto">
            <div class="variant-structure-grid">
              <label>Genom reference<input name="genome_build"></label>
              <label>Kromosom<input name="chromosome"></label>
              <label>Start<input name="start"></label>
              <label>Slut<input name="end"></label>
              <label>Kopital<input name="copy_number"></label>
              <label>Strukturtype<select name="sv_subtype" data-allow-legacy-option>${renderStructureTypeOptions({includeBlank: true})}</select></label>
              <label>Størrelse<input name="size_bp"></label>
            </div>
            <label>ISCN<input name="iscn"></label>
            <label>Berørte gener<textarea class="small" name="affected_genes"></textarea></label>
            <label>Beskrivelse<textarea class="small" name="description"></textarea></label>
          </div>
          <label>ACMG-klasse
            <select name="classification" data-allow-legacy-option>
              ${classificationOptions}
            </select>
          </label>
          <label>Kriterier<input name="criteria" placeholder="PM1,PP3..."></label>
          <label>Tilstand<input name="condition"></label>
          <label>Nedarvning<input name="inheritance"></label>
          <label>Evidens<textarea name="evidence" rows="4"></textarea></label>
          <label>Kurateret af<input name="curated_by"></label>
          <label>Sidst gennemgået<input type="date" name="last_review"></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit" data-action="save" id="variantLibrarySave">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-save-new with-icon" type="submit" data-action="create" id="variantLibrarySaveNew" hidden>
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                  <path d="M15 14h6" />
                  <path d="M18 11v6" />
                </svg>
              </span>
              <span class="label">Gem som ny</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="variantLibraryClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="variantLibraryDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#libSearch');
  const form = section.querySelector('#variantLibraryForm');
  const saveButton = section.querySelector('#variantLibrarySave');
  const saveButtonLabel = saveButton?.querySelector('.label');
  const saveNewButton = section.querySelector('#variantLibrarySaveNew');
  const clearButton = section.querySelector('#variantLibraryClear');
  const deleteButton = section.querySelector('#variantLibraryDelete');
  const exportButton = section.querySelector('#libraryExportCsv');
  const importButton = section.querySelector('#libraryImportCsv');
  const importInput = section.querySelector('#variantLibraryImportInput');
  const openPatientsButton = section.querySelector('#libraryOpenPatients');
  const hotspotChartContainer = section.querySelector('#variantHotspotChart');
  const hotspotSummary = section.querySelector('[data-hotspot-summary]');
  const hotspotCaption = section.querySelector('[data-hotspot-caption]');
  const defaultSaveLabel = saveButtonLabel?.textContent?.trim() || saveButton?.textContent?.trim() || 'Gem';
  const {updateVariantTypeFields, variantTypeSelect} = setupVariantTypeForm(form);
  if (openPatientsButton) {
    const tip = openPatientsButton.dataset.tooltip || 'Åbn Patienter-fanen filtreret på den valgte variant.';
    setTooltip(openPatientsButton, tip);
  }
  const {
    countMap: variantFrequencyMap,
    patientCount: variantFrequencyPatientCount,
    maxCount: variantFrequencyMaxCount
  } = computeVariantFrequencyData();
  const getVariantFrequencyCount = entry => {
    const key = createVariantComparisonKey(entry);
    if (!key) return 0;
    return variantFrequencyMap.get(key) || 0;
  };
  const getVariantFrequencyLabel = entry => {
    const count = getVariantFrequencyCount(entry);
    if (!count && !variantFrequencyPatientCount) return '0';
    return formatVariantFrequencyLabel(count, variantFrequencyPatientCount);
  };
  const getVariantFrequencyCategory = entry => {
    if (!variantFrequencyMaxCount || variantFrequencyMaxCount <= 1) return 'Ukendt';
    const count = getVariantFrequencyCount(entry);
    if (!count) return 'Ukendt';
    const ratio = count / variantFrequencyMaxCount;
    if (!Number.isFinite(ratio) || ratio <= 0) return 'Ukendt';
    if (ratio >= 0.95) return 'Polymorf';
    if (ratio >= 0.65) return 'Hyppig';
    if (ratio >= 0.35) return 'Mellemfrekvent';
    if (ratio >= 0.2) return 'Lavfrekvent';
    if (ratio >= 0.1) return 'Sjælden';
    if (ratio >= 0.05) return 'Meget sjælden';
    return 'Ultra sjælden';
  };
  let filteredLibrary = list.slice();
  let selectedId = null;
  const defaultOpenPatientsLabel = openPatientsButton?.textContent?.trim() || 'Vis patienter med varianten';
  const updateOpenPatientsButton = () => {
    if (!openPatientsButton) return;
    const entry = selectedId != null
      ? list.find(item => Number(item?.id) === Number(selectedId))
      : null;
    if (!entry) {
      openPatientsButton.disabled = true;
      openPatientsButton.textContent = defaultOpenPatientsLabel;
      return;
    }
    const patientIds = getPatientIdsForVariant(entry);
    const count = patientIds.length;
    const baseText = count === 1 ? 'Vis patient med varianten' : 'Vis patienter med varianten';
    openPatientsButton.disabled = false;
    openPatientsButton.textContent = `${baseText} (${count})`;
  };
  const getHighlightedEntry = () => {
    if (selectedId == null) return null;
    return filteredLibrary.find(entry => Number(entry.id) === Number(selectedId)) || null;
  };
  const updateHotspotSummary = text => {
    if (hotspotSummary) {
      hotspotSummary.textContent = text || '';
    }
  };
  const updateHotspotCaption = text => {
    if (hotspotCaption) {
      hotspotCaption.textContent = text || '';
    }
  };
  const updateHotspotChart = (variants, options = {}) => {
    if (!hotspotChartContainer) return;
    const variantList = Array.isArray(variants) ? variants : [];
    const snvVariants = variantList.filter(variant => normalizeVariantType(variant?.variant_type) === 'snv');
    const excludedCount = variantList.length - snvVariants.length;
    const normalizedBuild = normalizeGenomeBuildValue(selectedGenomeBuild) || DEFAULT_GENOME_BUILD;
    selectedGenomeBuild = normalizedBuild;
    const buildLabel = getGenomeBuildLabel(normalizedBuild);
    const highlightVariant = options?.highlightVariant ?? getHighlightedEntry();
    const computeCoordinateInfo = variant => {
      if (!variant) return null;
      const coordinates = parseVariantCoordinates(variant);
      const chromosome = normalizeChromosomeValue(coordinates?.chromosome || variant.chromosome || variant.chrom);
      let start = Number.parseInt(coordinates?.start, 10);
      let end = Number.parseInt(coordinates?.end, 10);
      if (Number.isFinite(start) && Number.isFinite(end) && end < start) {
        [start, end] = [end, start];
      }
      let position = Number.isFinite(start) ? start : Number.parseInt(coordinates?.end, 10);
      if (Number.isFinite(start) && Number.isFinite(end) && start > 0 && end > 0) {
        position = Math.round((start + end) / 2);
      }
      if (!Number.isFinite(position) || position <= 0) {
        const rawPosition = variant.genomic_position || variant.genomicPosition || variant.position || '';
        const match = String(rawPosition).match(/[-:](\d+)/);
        if (match) {
          position = Number.parseInt(match[1], 10);
        }
      }
      if (!Number.isFinite(position) || position <= 0) {
        const startFallback = Number.parseInt(variant.start, 10);
        const endFallback = Number.parseInt(variant.end, 10);
        if (Number.isFinite(startFallback) && startFallback > 0) {
          position = startFallback;
        } else if (Number.isFinite(endFallback) && endFallback > 0) {
          position = endFallback;
        }
      }
      const build = normalizeGenomeBuildValue(inferGenomeBuildCode(variant, coordinates, normalizedBuild)) || normalizedBuild;
      if (!Number.isFinite(start) || start <= 0) {
        start = Number.isFinite(position) ? Math.max(0, position) : 0;
      }
      if (!Number.isFinite(end) || end <= 0) {
        end = Number.isFinite(position) ? Math.max(0, position) : start;
      }
      if (end < start) {
        [start, end] = [end, start];
      }
      start = Math.max(0, start);
      end = Math.max(start, end);
      const hasPosition = Number.isFinite(position) && position > 0;
      return {
        chromosome: chromosome || '',
        start,
        end,
        position: hasPosition ? position : 0,
        hasPosition,
        build,
        buildLabel: getGenomeBuildLabel(build)
      };
    };
    let highlightCandidate = null;
    let highlightInfo = null;
    let highlightSuppressedReason = '';
    if (highlightVariant) {
      const candidate = computeCoordinateInfo(highlightVariant);
      highlightCandidate = candidate;
      if (!candidate || !candidate.hasPosition) {
        highlightSuppressedReason = 'position';
      } else if (!candidate.chromosome) {
        highlightSuppressedReason = 'chromosome';
      } else if (candidate.build !== normalizedBuild) {
        highlightSuppressedReason = 'build';
      } else {
        highlightInfo = {
          ...candidate,
          title: formatVariantTitle(highlightVariant) || ''
        };
      }
    }
    hotspotChartContainer.innerHTML = '';
    let tooltipElement = null;
    let rowStates = [];
    let activeBandState = null;
    let activeBand = null;
    let updateNativeBandTooltip = () => {};
    const highlightBand = (state, band) => {
      if (!rowStates.length) return;
      rowStates.forEach(item => {
        if (item?.bandOverlays) {
          item.bandOverlays.classed('is-hovered', datum => item === state && datum === band);
        }
      });
    };
    const setActiveBand = (state, band) => {
      activeBandState = state || null;
      activeBand = band || null;
      highlightBand(activeBandState, activeBand);
    };
    const ensureTooltipElement = () => {
      if (!tooltipElement) {
        tooltipElement = document.createElement('div');
        tooltipElement.className = 'variant-hotspot__tooltip';
        tooltipElement.setAttribute('role', 'tooltip');
        tooltipElement.dataset.visible = 'false';
        tooltipElement.setAttribute('aria-hidden', 'true');
      }
      if (tooltipElement.parentNode !== hotspotChartContainer) {
        hotspotChartContainer.appendChild(tooltipElement);
      } else {
        hotspotChartContainer.appendChild(tooltipElement);
      }
      return tooltipElement;
    };
    const hideTooltip = () => {
      setActiveBand(null, null);
      if (!tooltipElement) return;
      tooltipElement.dataset.visible = 'false';
      tooltipElement.setAttribute('aria-hidden', 'true');
      tooltipElement.style.transform = 'translate(-9999px, -9999px)';
      tooltipElement.replaceChildren();
      updateNativeBandTooltip('');
    };
    const pointerFromEvent = event => {
      if (!event) return null;
      if (event.touches && event.touches.length) return event.touches[0];
      if (event.changedTouches && event.changedTouches.length) return event.changedTouches[0];
      return event;
    };
    const positionTooltip = event => {
      if (!tooltipElement || tooltipElement.dataset.visible !== 'true') return;
      const pointer = pointerFromEvent(event);
      if (!pointer) return;
      const tooltip = ensureTooltipElement();
      const rect = hotspotChartContainer.getBoundingClientRect();
      const rawX = pointer.clientX - rect.left;
      const rawY = pointer.clientY - rect.top;
      requestAnimationFrame(() => {
        const width = tooltip.offsetWidth || 0;
        const height = tooltip.offsetHeight || 0;
        const maxX = Math.max(8, hotspotChartContainer.clientWidth - width - 8);
        const maxY = Math.max(8, hotspotChartContainer.clientHeight - height - 8);
        const clampedX = Math.min(Math.max(rawX + 16, 8), maxX);
        const clampedY = Math.min(Math.max(rawY + 16, 8), maxY);
        tooltip.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
      });
    };
    const showTooltipContent = (event, lines) => {
      const tooltip = ensureTooltipElement();
      tooltip.replaceChildren();
      lines.forEach((text, index) => {
        if (!text) return;
        const element = index === 0 ? document.createElement('strong') : document.createElement('span');
        element.textContent = text;
        tooltip.appendChild(element);
      });
      tooltip.dataset.visible = 'true';
      tooltip.setAttribute('aria-hidden', 'false');
      positionTooltip(event);
    };
    const updateTooltipPosition = event => {
      positionTooltip(event);
    };
    let showBandTooltip = () => {};
    const controls = document.createElement('div');
    controls.className = 'variant-hotspot__controls';
    const buildLabelElement = document.createElement('label');
    buildLabelElement.className = 'variant-hotspot__build-control';
    const buildText = document.createElement('span');
    buildText.textContent = 'Reference';
    const buildSelect = document.createElement('select');
    buildSelect.className = 'variant-hotspot__build-select';
    const buildOptions = [
      {value: 'hg38', label: GENOME_BUILD_LABELS.hg38},
      {value: 'hg19', label: GENOME_BUILD_LABELS.hg19}
    ];
    buildOptions.forEach(option => {
      const opt = document.createElement('option');
      opt.value = option.value;
      opt.textContent = option.label;
      buildSelect.appendChild(opt);
    });
    buildSelect.value = normalizedBuild;
    buildSelect.addEventListener('change', () => {
      const nextBuild = normalizeGenomeBuildValue(buildSelect.value) || normalizedBuild;
      if (nextBuild !== normalizedBuild) {
        selectedGenomeBuild = nextBuild;
        requestAnimationFrame(redrawHotspot);
      }
    });
    buildLabelElement.append(buildText, buildSelect);
    controls.appendChild(buildLabelElement);
    const zoomIndicator = document.createElement('span');
    zoomIndicator.className = 'variant-hotspot__zoom-indicator';
    zoomIndicator.setAttribute('role', 'status');
    zoomIndicator.setAttribute('aria-live', 'polite');
    controls.appendChild(zoomIndicator);
    const resetButton = document.createElement('button');
    resetButton.type = 'button';
    resetButton.className = 'variant-hotspot__zoom-reset';
    resetButton.textContent = 'Nulstil zoom';
    resetButton.title = 'Nulstil visningen af hotspots';
    resetButton.disabled = true;
    controls.appendChild(resetButton);
    hotspotChartContainer.appendChild(controls);
    const setEmptyState = message => {
      hotspotChartContainer.dataset.chartEmpty = 'true';
      zoomIndicator.textContent = 'Zoom: –';
      resetButton.disabled = true;
      hideTooltip();
      const empty = document.createElement('p');
      empty.className = 'variant-hotspot__empty';
      empty.textContent = message;
      hotspotChartContainer.appendChild(empty);
    };
    const hasHighlight = Boolean(highlightInfo);
    if (!snvVariants.length && !hasHighlight) {
      setEmptyState('Ingen SNV/indels kan vises for det aktuelle udvalg.');
      const summaryParts = [`0 SNV/indels i ${buildLabel}`];
      if (excludedCount > 0) {
        summaryParts.push(`(${excludedCount} andre varianttyper udeladt)`);
      }
      updateHotspotSummary(summaryParts.join(' '));
      updateHotspotCaption('Hotspot-oversigten understøtter kun SNV/indel-poster. Vælg en filtrering med SNV/indels og angiv den ønskede reference.');
      return;
    }
    if (typeof d3 === 'undefined') {
      setEmptyState('D3.js kunne ikke indlæses – hotspot-grafen er ikke tilgængelig.');
      const summaryParts = [`${snvVariants.length} SNV/indel${snvVariants.length === 1 ? '' : 'er'} i ${buildLabel}`];
      if (excludedCount > 0) {
        summaryParts.push(`(${excludedCount} andre varianttyper udeladt)`);
      }
      updateHotspotSummary(summaryParts.join(' '));
      updateHotspotCaption('Indlæs D3.js for at se den genomiske hotspots-visualisering af SNV/indels.');
      return;
    }
    const theme = getCurrentTheme();
    let missingCoordinateCount = 0;
    const mismatchedBuildCounts = new Map();
    const parsed = [];
    snvVariants.forEach(variant => {
      const info = computeCoordinateInfo(variant);
      if (!info || !info.chromosome) {
        missingCoordinateCount++;
        return;
      }
      if (!info.hasPosition) {
        missingCoordinateCount++;
        return;
      }
      if (info.build !== normalizedBuild) {
        mismatchedBuildCounts.set(info.build, (mismatchedBuildCounts.get(info.build) || 0) + 1);
        return;
      }
      parsed.push({chromosome: info.chromosome, position: info.position});
    });
    const coordinatesCount = parsed.length;
    const missingCount = missingCoordinateCount;
    const mismatchedTotal = Array.from(mismatchedBuildCounts.values()).reduce((sum, count) => sum + count, 0);
    const mismatchedSummary = mismatchedTotal > 0
      ? Array.from(mismatchedBuildCounts.entries()).map(([build, count]) => `${count} i ${getGenomeBuildLabel(build)}`).join(', ')
      : '';
    if (!coordinatesCount && !hasHighlight) {
      const emptyParts = [`Ingen SNV/indels med genomiske koordinater i ${buildLabel}.`];
      if (missingCount > 0) {
        emptyParts.push(`${missingCount} uden koordinater.`);
      }
      if (mismatchedTotal > 0) {
        emptyParts.push(`${mismatchedSummary} vises ikke i denne reference.`);
      }
      setEmptyState(emptyParts.join(' '));
      const summaryParts = [`${snvVariants.length} SNV/indel${snvVariants.length === 1 ? '' : 'er'} i ${buildLabel}`];
      if (missingCount > 0) {
        summaryParts.push(`(${missingCount} uden koordinater)`);
      }
      if (mismatchedTotal > 0) {
        summaryParts.push(`(${mismatchedSummary} ekskluderet)`);
      }
      if (excludedCount > 0) {
        summaryParts.push(`(${excludedCount} andre varianttyper udeladt)`);
      }
      updateHotspotSummary(summaryParts.join(' '));
      const captionParts = ['Hotspot-oversigten kræver SNV/indels med koordinater i den valgte reference for at tegne grafen.'];
      if (mismatchedTotal > 0) {
        captionParts.push(`${mismatchedSummary} er registreret i en anden reference end ${buildLabel}.`);
      }
      updateHotspotCaption(captionParts.join(' '));
      return;
    }
    hotspotChartContainer.dataset.chartEmpty = 'false';
    const grouped = d3.groups(parsed, d => d.chromosome);
    if (!grouped.length && !hasHighlight) {
      setEmptyState('Ingen SNV/indels kan vises for det aktuelle udvalg.');
      updateHotspotSummary(`Ingen SNV/indels med koordinater i ${buildLabel}.`);
      updateHotspotCaption('Tilføj eller vælg SNV/indel-poster for at se hotspot-fordelingen.');
      return;
    }
    const CHROMOSOME_ORDER = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','X','Y','MT'];
    const FALLBACK_CHROMOSOME_LENGTHS = {
      '1': 248956422,
      '2': 242193529,
      '3': 198295559,
      '4': 190214555,
      '5': 181538259,
      '6': 170805979,
      '7': 159345973,
      '8': 145138636,
      '9': 138394717,
      '10': 133797422,
      '11': 135086622,
      '12': 133275309,
      '13': 114364328,
      '14': 107043718,
      '15': 101991189,
      '16': 90338345,
      '17': 83257441,
      '18': 80373285,
      '19': 58617616,
      '20': 64444167,
      '21': 46709983,
      '22': 50818468,
      'X': 156040895,
      'Y': 57227415,
      'MT': 16569
    };
    const CHROMOSOME_CENTROMERES = {
      '1': 123400000,
      '2': 93900000,
      '3': 90900000,
      '4': 50000000,
      '5': 48750000,
      '6': 60550000,
      '7': 60100000,
      '8': 45200000,
      '9': 43850000,
      '10': 39800000,
      '11': 53400000,
      '12': 35500000,
      '13': 17700000,
      '14': 17150000,
      '15': 19000000,
      '16': 36850000,
      '17': 25050000,
      '18': 18450000,
      '19': 26150000,
      '20': 28050000,
      '21': 11950000,
      '22': 15550000,
      'X': 60950000,
      'Y': 10450000,
      'MT': 0
    };
    const compareChromosomes = (a, b) => {
      const indexA = CHROMOSOME_ORDER.indexOf(a);
      const indexB = CHROMOSOME_ORDER.indexOf(b);
      if (indexA !== -1 && indexB !== -1) return indexA - indexB;
      if (indexA !== -1) return -1;
      if (indexB !== -1) return 1;
      return a.localeCompare(b, 'da');
    };
    const MIN_BIN_THRESHOLD = 24;
    const MAX_BASE_THRESHOLD = 5000;
    const MAX_DYNAMIC_THRESHOLD = 50000;
    const ZOOM_BIN_EXPONENT = 2;
    const MIN_BAND_LABEL_PX = 2;
    const CENTROMERE_DISPLAY_WIDTH = 1_000_000;

    let rows = grouped.map(([chromosome, data]) => {
      const rowHighlightMax = highlightInfo && highlightInfo.chromosome === chromosome
        ? Math.max(highlightInfo.start, highlightInfo.end, highlightInfo.position || 0)
        : 0;
      const maxPosition = d3.max(data, d => d.position) || 1;
      const cytobandLength = getCytobandChromosomeLength(normalizedBuild, chromosome);
      const fallbackLength = FALLBACK_CHROMOSOME_LENGTHS[chromosome] || Math.max(maxPosition, rowHighlightMax, 1);
      const canonicalLength = cytobandLength || fallbackLength;
      const chromLength = Math.max(canonicalLength, maxPosition, rowHighlightMax || 0, 1);
      const densityTarget = Math.round(Math.sqrt(data.length) * 2.4);
      const spanTarget = chromLength > 0 ? Math.round(chromLength / 600000) : 0;
      const thresholds = Math.min(MAX_BASE_THRESHOLD, Math.max(MIN_BIN_THRESHOLD, densityTarget, spanTarget));
      const histogram = d3.bin()
        .domain([0, chromLength])
        .thresholds(thresholds)(data.map(d => d.position));
      return {
        chromosome,
        chromLength,
        histogram,
        data,
        baseThresholds: thresholds
      };
    }).sort((a, b) => compareChromosomes(a.chromosome, b.chromosome));
    if (highlightInfo && !rows.some(row => row.chromosome === highlightInfo.chromosome)) {
      const chromosome = highlightInfo.chromosome;
      const highlightMax = Math.max(highlightInfo.start, highlightInfo.end, highlightInfo.position || 0, 1);
      const cytobandLength = getCytobandChromosomeLength(normalizedBuild, chromosome);
      const fallbackLength = FALLBACK_CHROMOSOME_LENGTHS[chromosome] || highlightMax;
      const chromLength = Math.max(cytobandLength || fallbackLength || 1, highlightMax);
      const thresholds = MIN_BIN_THRESHOLD;
      const histogram = d3.bin()
        .domain([0, chromLength])
        .thresholds(thresholds)([]);
      rows.push({
        chromosome,
        chromLength,
        histogram,
        data: [],
        baseThresholds: thresholds
      });
      rows.sort((a, b) => compareChromosomes(a.chromosome, b.chromosome));
    }
    const hideOtherChromosomes = Boolean(highlightInfo);
    if (hideOtherChromosomes) {
      rows = rows.filter(row => row.chromosome === highlightInfo.chromosome);
    }
    const maxBinCount = d3.max(rows, row => d3.max(row.histogram, bin => bin.length)) || 1;
    const containerWidth = hotspotChartContainer.clientWidth || 960;
    const width = Math.max(containerWidth, 720);
    const margin = {top: 28, right: 80, bottom: 88, left: 120};
    const bandHeight = 26;
    const axisOffset = bandHeight + 10;
    const rowSpacing = 72;
    const rowHeight = axisOffset + rowSpacing;
    const chartHeight = Math.max(rowHeight, rowHeight * rows.length);
    const innerWidth = width - margin.left - margin.right;
    const height = margin.top + margin.bottom + chartHeight;
    const svg = d3.select(hotspotChartContainer)
      .append('svg')
      .attr('class', 'variant-hotspot__svg')
      .attr('viewBox', `0 0 ${width} ${height}`)
      .attr('preserveAspectRatio', 'xMidYMid meet');
    const defs = svg.append('defs');
    const chartGroup = svg.append('g')
      .attr('transform', `translate(${margin.left}, ${margin.top})`);
    const colorScale = d3.scaleSequential(d3.interpolateYlOrRd)
      .domain([0, maxBinCount || 1]);
    const formatPosition = value => {
      if (!Number.isFinite(value) || value <= 0) return '0 bp';
      if (value >= 1e6) {
        const mb = value / 1e6;
        return `${mb.toFixed(mb >= 100 ? 0 : mb >= 10 ? 1 : 2)} Mb`;
      }
      if (value >= 1e3) {
        const kb = value / 1e3;
        return `${kb.toFixed(kb >= 100 ? 0 : kb >= 10 ? 1 : 2)} kb`;
      }
      return `${Math.round(value)} bp`;
    };
    showBandTooltip = (event, band, row) => {
      const startValue = Math.max(0, band.x0 ?? band.start ?? 0);
      const endValue = Math.max(startValue, band.x1 ?? band.end ?? startValue);
      const rangeLabel = startValue === endValue
        ? formatPosition(startValue)
        : `${formatPosition(startValue)} – ${formatPosition(endValue)}`;
      const stainLabel = band.stain ? band.stain.toUpperCase() : 'GNEG';
      const countLabel = band.count
        ? `${band.count} SNV/indel${band.count === 1 ? '' : 'er'}`
        : 'Ingen SNV/indels';
      const chromosomeLine = `Chr ${row.chromosome}`;
      const bandName = band.name ? String(band.name).trim() : '';
      const iscnLine = bandName ? `ISCN: ${bandName}` : 'ISCN: Ukendt bånd';
      const detailsLine = `${stainLabel}${rangeLabel ? ` · ${rangeLabel}` : ''}`;
      const nativeLabel = [chromosomeLine, iscnLine, detailsLine, countLabel].filter(Boolean).join(' · ');
      showTooltipContent(event, [chromosomeLine, iscnLine, detailsLine, countLabel]);
      updateNativeBandTooltip(nativeLabel);
    };
    const styleAxis = axisSelection => {
      axisSelection.selectAll('text').attr('dy', '0.7em');
      axisSelection.selectAll('line').attr('opacity', 0.35);
      const domain = axisSelection.select('.domain');
      if (!domain.empty()) {
        domain.attr('opacity', 0.35);
      }
    };
    const applyScaleToBars = (selection, scale) => {
      selection
        .attr('x', d => scale(Math.max(0, d.x0 || 0)))
        .attr('width', d => {
          const start = Math.max(0, d.x0 || 0);
          const end = Math.max(start, d.x1 || d.x0 || 0);
          const widthValue = scale(end) - scale(start);
          return Math.max(1, widthValue);
        });
    };
    const applyScaleToHighlight = (selection, scale) => {
      selection
        .attr('x', d => {
          const start = Math.max(0, d.x0 ?? d.start ?? 0);
          return scale(start);
        })
        .attr('width', d => {
          const start = Math.max(0, d.x0 ?? d.start ?? 0);
          const end = Math.max(start, d.x1 ?? d.end ?? start);
          const widthValue = scale(end) - scale(start);
          return Math.max(3, widthValue);
        });
    };
    const applyScaleToCentromereBoundaries = (selection, scale) => {
      selection
        .attr('x1', d => {
          const position = Math.max(0, d.position ?? d.x ?? d.start ?? 0);
          return scale(position);
        })
        .attr('x2', d => {
          const position = Math.max(0, d.position ?? d.x ?? d.end ?? 0);
          return scale(position);
        });
    };
    const applyScaleToBandLabels = (selection, scale) => {
      selection
        .attr('x', d => {
          const start = Math.max(0, d.x0 || 0);
          const end = Math.max(start, d.x1 || d.x0 || 0);
          const midPoint = start + ((end - start) / 2);
          return scale(midPoint);
        })
        .attr('display', d => {
          if (!d?.name) return 'none';
          const start = Math.max(0, d.x0 || 0);
          const end = Math.max(start, d.x1 || d.x0 || 0);
          const widthValue = scale(end) - scale(start);
          return widthValue >= MIN_BAND_LABEL_PX ? null : 'none';
        });
    };
    const updateBarTitles = (selection, row) => {
      selection.each(function(d) {
        const node = d3.select(this);
        node.selectAll('title')
          .data([d])
          .join('title')
          .text(bin => {
            const count = bin.length;
            const startValue = Math.max(0, bin.x0 || 0);
            const endValue = Math.max(startValue, bin.x1 || bin.x0 || 0);
            const rangeLabel = startValue === endValue
              ? formatPosition(startValue)
              : `${formatPosition(startValue)} – ${formatPosition(endValue)}`;
            const percentage = coordinatesCount ? (count / coordinatesCount) * 100 : 0;
            const percentageLabel = Number.isFinite(percentage) && percentage > 0
              ? ` (${percentage.toFixed(percentage >= 10 ? 0 : 1)}%)`
              : '';
            if (!count) {
              return `Ingen SNV/indels på kromosom ${row.chromosome} i intervallet ${rangeLabel}.`;
            }
            return `${count} SNV/indel${count === 1 ? '' : 'er'} på kromosom ${row.chromosome} i intervallet ${rangeLabel}${percentageLabel}.`;
          });
      });
    };
    const computeAdaptiveThresholds = (baseThresholds, zoomLevel) => {
      const base = Number.isFinite(baseThresholds) && baseThresholds > 0 ? baseThresholds : MIN_BIN_THRESHOLD;
      const scale = Math.pow(Math.max(1, zoomLevel), ZOOM_BIN_EXPONENT);
      const next = Math.round(base * scale);
      return Math.min(MAX_DYNAMIC_THRESHOLD, Math.max(MIN_BIN_THRESHOLD, next));
    };
    rowStates = [];
    activeBandState = null;
    activeBand = null;
    rows.forEach((row, index) => {
      const rowGroup = chartGroup.append('g')
        .attr('transform', `translate(0, ${index * rowHeight})`);
      const baseScale = d3.scaleLinear()
        .domain([0, row.chromLength])
        .range([0, innerWidth])
        .clamp(true);
      const clipId = `variant-hotspot-clip-${index}`;
      defs.append('clipPath')
        .attr('id', clipId)
        .append('rect')
        .attr('width', innerWidth)
        .attr('height', bandHeight);
      rowGroup.append('rect')
        .attr('class', 'variant-hotspot__track')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', innerWidth)
        .attr('height', bandHeight)
        .attr('rx', 6)
        .attr('ry', 6);
      const baseBands = getCytobandBands(normalizedBuild, row.chromosome);
      let bandData = baseBands.length
        ? baseBands.map(band => ({
            start: Math.max(0, band.start || 0),
            end: Math.max(band.start || 0, band.end || 0),
            name: band.name || '',
            stain: band.stain || ''
          }))
        : [{start: 0, end: row.chromLength, name: '', stain: 'gneg'}];
      if (bandData.length) {
        bandData[bandData.length - 1].end = Math.max(bandData[bandData.length - 1].end || 0, row.chromLength);
      }
      bandData = bandData.map(band => ({
        ...band,
        x0: Math.max(0, Math.min(row.chromLength, band.start)),
        x1: Math.max(0, Math.min(row.chromLength, band.end))
      })).filter(band => band.x1 > band.x0);
      if (!bandData.length) {
        bandData = [{start: 0, end: row.chromLength, x0: 0, x1: row.chromLength, name: '', stain: 'gneg'}];
      }
      const centromereOverlayData = [];
      const centromereBoundaryData = [];
      bandData = bandData.map((band, index) => {
        const upperBound = index === bandData.length - 1 ? band.x1 + 1 : band.x1;
        const count = row.data.reduce((sum, point) => {
          if (point.position >= band.x0 && point.position < upperBound) {
            return sum + 1;
          }
          return sum;
        }, 0);
        const stain = String(band.stain || '').toLowerCase();
        if (stain === 'acen') {
          const bandWidth = Math.max(0, band.x1 - band.x0);
          const center = band.x0 + (bandWidth / 2);
          const halfDisplay = CENTROMERE_DISPLAY_WIDTH / 2;
          const overlayStart = Math.max(0, center - halfDisplay);
          const overlayEnd = Math.min(row.chromLength, center + halfDisplay);
          centromereOverlayData.push({
            ...band,
            x0: overlayStart,
            x1: overlayEnd,
            sourceBand: band,
            count
          });
          const previousBand = index > 0 ? bandData[index - 1] : null;
          const nextBand = index < bandData.length - 1 ? bandData[index + 1] : null;
          const previousStain = previousBand?.stain ? String(previousBand.stain).toLowerCase() : '';
          const nextStain = nextBand?.stain ? String(nextBand.stain).toLowerCase() : '';
          if (previousStain && previousStain !== 'acen') {
            centromereBoundaryData.push({position: Math.max(0, band.x0)});
          }
          if (nextStain && nextStain !== 'acen') {
            centromereBoundaryData.push({position: Math.max(0, band.x1)});
          }
        }
        return {...band, count, xUpper: upperBound};
      });
      const normalizedBoundaryData = [];
      centromereBoundaryData.forEach(boundary => {
        const value = Math.max(0, Math.min(row.chromLength, boundary.position ?? boundary.x ?? boundary.start ?? 0));
        if (!Number.isFinite(value)) {
          return;
        }
        if (!normalizedBoundaryData.some(item => Math.abs(item.position - value) < 1e-6)) {
          normalizedBoundaryData.push({position: value});
        }
      });
      const bandGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__bands')
        .attr('clip-path', `url(#${clipId})`);
      const bandRects = bandGroup.selectAll('rect')
        .data(bandData)
        .join('rect')
        .attr('class', 'variant-hotspot__band')
        .attr('y', 0)
        .attr('height', bandHeight)
        .attr('fill', d => getCytobandFill(d.stain, theme));
      applyScaleToBars(bandRects, baseScale);
      const centromereGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__centromeres')
        .attr('clip-path', `url(#${clipId})`);
      const centromereRects = centromereGroup.selectAll('rect')
        .data(centromereOverlayData)
        .join('rect')
        .attr('class', 'variant-hotspot__centromere')
        .attr('y', 0)
        .attr('height', bandHeight);
      applyScaleToBars(centromereRects, baseScale);
      const centromereBoundaryGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__centromere-boundaries')
        .attr('clip-path', `url(#${clipId})`);
      const centromereBoundaryLines = centromereBoundaryGroup.selectAll('line')
        .data(normalizedBoundaryData)
        .join('line')
        .attr('class', 'variant-hotspot__centromere-boundary')
        .attr('y1', 0)
        .attr('y2', bandHeight);
      applyScaleToCentromereBoundaries(centromereBoundaryLines, baseScale);
      const bandOverlayGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__band-overlays')
        .attr('clip-path', `url(#${clipId})`);
      const bandOverlays = bandOverlayGroup.selectAll('rect')
        .data(bandData)
        .join('rect')
        .attr('class', 'variant-hotspot__band-overlay')
        .attr('y', 0)
        .attr('height', bandHeight);
      applyScaleToBars(bandOverlays, baseScale);
      const describeBand = d => {
        const rangeLabel = `${formatPosition(d.x0)} – ${formatPosition(d.x1)}`;
        const chromosomeLabel = `Chr ${row.chromosome}`;
        const bandName = d.name ? String(d.name).trim() : '';
        const iscnLabel = bandName ? `ISCN ${bandName}` : 'ISCN ukendt bånd';
        const stainLabel = d.stain ? d.stain.toUpperCase() : '';
        const countLabel = d.count
          ? `${d.count} SNV/indel${d.count === 1 ? '' : 'er'}`
          : 'Ingen SNV/indels';
        return [chromosomeLabel, iscnLabel, stainLabel, rangeLabel, countLabel].filter(Boolean).join(' · ');
      };
      bandOverlays
        .attr('aria-label', describeBand)
        .attr('data-band-label', describeBand);
      bandOverlays.selectAll('title').remove();
      bandOverlays.append('title')
        .text(describeBand);
      const bandLabelGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__band-labels')
        .attr('clip-path', `url(#${clipId})`);
      const bandLabels = bandLabelGroup.selectAll('text')
        .data(bandData)
        .join('text')
        .attr('class', 'variant-hotspot__band-label')
        .attr('y', bandHeight / 2)
        .attr('dy', '0.35em')
        .text(d => d.name ? String(d.name).trim() : '');
      applyScaleToBandLabels(bandLabels, baseScale);
      let rowState;
      const barsGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__bars')
        .attr('clip-path', `url(#${clipId})`);
      const refreshBars = (bins, {scale = baseScale, animate = false} = {}) => {
        const barSelection = barsGroup.selectAll('rect')
          .data(bins, bin => `${Math.round(bin.x0 || 0)}-${Math.round(bin.x1 || 0)}`);
        barSelection.exit().remove();
        const barEnter = barSelection.enter().append('rect')
          .attr('y', 0)
          .attr('height', bandHeight)
          .attr('rx', 2)
          .attr('ry', 2);
        if (animate) {
          barEnter
            .attr('fill', d => colorScale(d.length))
            .attr('opacity', 0)
            .call(enter => enter.transition().duration(600).delay((_, i) => i * 18)
              .attr('opacity', d => (d.length ? 0.95 : 0.4)));
        } else {
          barEnter
            .attr('fill', d => colorScale(d.length))
            .attr('opacity', d => (d.length ? 0.95 : 0.4));
        }
        const merged = barEnter.merge(barSelection)
          .attr('y', 0)
          .attr('height', bandHeight)
          .attr('rx', 2)
          .attr('ry', 2)
          .attr('fill', d => colorScale(d.length))
          .attr('opacity', d => (d.length ? 0.95 : 0.4));
        updateBarTitles(merged, row);
        applyScaleToBars(merged, scale);
        if (rowState) {
          rowState.histogram = bins;
          rowState.bars = merged;
        }
        return merged;
      };
      const baseThresholds = Number.isFinite(row.baseThresholds) && row.baseThresholds > 0
        ? row.baseThresholds
        : MIN_BIN_THRESHOLD;
      const bars = refreshBars(row.histogram, {animate: true});
      const highlightGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__highlights')
        .attr('clip-path', `url(#${clipId})`);
      let highlightData = [];
      if (highlightInfo && highlightInfo.chromosome === row.chromosome) {
        const startValue = Math.max(0, Math.min(row.chromLength, highlightInfo.start));
        const endValue = Math.max(0, Math.min(row.chromLength, highlightInfo.end));
        const x0 = Math.min(startValue, endValue);
        const x1 = Math.max(startValue, endValue);
        highlightData = [{x0, x1, title: highlightInfo.title || ''}];
      }
      const highlightHeight = bandHeight;
      const highlightY = 0;
      const highlightRadius = Math.min(4, Math.max(0, bandHeight / 6));
      const highlightRects = highlightGroup.selectAll('rect')
        .data(highlightData)
        .join('rect')
        .attr('class', 'variant-hotspot__highlight')
        .attr('y', highlightY)
        .attr('height', highlightHeight)
        .attr('rx', highlightRadius)
        .attr('ry', highlightRadius);
      applyScaleToHighlight(highlightRects, baseScale);
      highlightRects.attr('aria-label', d => {
        const startLabel = formatPosition(d.x0);
        const endLabel = formatPosition(d.x1);
        const rangeLabel = d.x0 === d.x1 ? startLabel : `${startLabel} – ${endLabel}`;
        const baseLabel = d.title ? `Valgt variant: ${d.title}` : 'Valgt variant';
        return `${baseLabel} · ${rangeLabel} på Chr ${row.chromosome}`;
      });
      highlightRects.selectAll('title').remove();
      highlightRects.append('title')
        .text(d => {
          const startLabel = formatPosition(d.x0);
          const endLabel = formatPosition(d.x1);
          const rangeLabel = d.x0 === d.x1 ? startLabel : `${startLabel} – ${endLabel}`;
          const variantLabel = d.title ? d.title : 'Valgt variant';
          return `${variantLabel} · ${rangeLabel} på Chr ${row.chromosome}`;
        });
      rowGroup.append('text')
        .attr('class', 'variant-hotspot__chromosome')
        .attr('x', -12)
        .attr('y', bandHeight / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', 'end')
        .text(`Chr ${row.chromosome}`);
      const tickCount = Math.min(6, Math.max(2, Math.round(innerWidth / 140)));
      const axisGroup = rowGroup.append('g')
        .attr('class', 'variant-hotspot__axis')
        .attr('transform', `translate(0, ${axisOffset})`);
      axisGroup.call(d3.axisBottom(baseScale)
        .ticks(tickCount)
        .tickFormat(value => formatPosition(value)));
      styleAxis(axisGroup);
      rowState = {
        baseScale,
        refreshBars,
        bars,
        bands: bandRects,
        centromeres: centromereRects,
        centromereBoundaries: normalizedBoundaryData.length ? centromereBoundaryLines : null,
        bandOverlays,
        bandLabels,
        applyLabelScale: scale => applyScaleToBandLabels(bandLabels, scale),
        centromereData: centromereOverlayData,
        bandData,
        row,
        yOffset: index * rowHeight,
        axisGroup,
        tickCount,
        baseThresholds,
        currentThresholds: baseThresholds,
        dataPositions: row.data.map(d => d.position),
        histogram: row.histogram,
        highlightRects: highlightData.length ? highlightRects : null
      };
      bandOverlays
        .on('mouseenter', (event, d) => {
          setActiveBand(rowState, d);
          showBandTooltip(event, d, rowState.row);
        })
        .on('mousemove', event => {
          updateTooltipPosition(event);
        })
        .on('mouseleave', () => {
          hideTooltip();
        })
        .on('touchstart', (event, d) => {
          setActiveBand(rowState, d);
          showBandTooltip(event, d, rowState.row);
        })
        .on('touchmove', event => {
          updateTooltipPosition(event);
        })
        .on('touchend', () => {
          hideTooltip();
        })
        .on('touchcancel', () => {
          hideTooltip();
        });
      rowStates.push(rowState);
    });
    const formatZoomLevel = value => {
      const decimals = value >= 10 ? 0 : value >= 3 ? 1 : 2;
      return value.toLocaleString('da-DK', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals
      });
    };
    let currentTransform = d3.zoomIdentity;
    const findBandAtPoint = (pointX, pointY) => {
      if (!rowStates.length) return null;
      if (!Number.isFinite(pointX) || !Number.isFinite(pointY)) return null;
      if (pointX < 0 || pointX > innerWidth) return null;
      if (pointY < 0 || pointY > chartHeight) return null;
      const rowIndex = Math.floor(pointY / rowHeight);
      const state = rowStates[rowIndex];
      if (!state) return null;
      const localY = pointY - state.yOffset;
      if (localY < 0 || localY > bandHeight) return null;
      const scaled = currentTransform.rescaleX(state.baseScale);
      const domainValue = scaled.invert(pointX);
      if (!Number.isFinite(domainValue)) return null;
      const stateBands = state.bandData || [];
      for (let index = 0; index < stateBands.length; index++) {
        const band = stateBands[index];
        const upper = band.xUpper ?? band.x1;
        const isLast = index === stateBands.length - 1;
        if (domainValue >= band.x0 && (isLast ? domainValue <= upper : domainValue < upper)) {
          return {state, band};
        }
      }
      return null;
    };
    const handleSurfaceHover = event => {
      if (event?.touches && event.touches.length > 1) {
        hideTooltip();
        return;
      }
      if (event?.buttons && event.buttons !== 0) {
        return;
      }
      const [pointX, pointY] = d3.pointer(event, chartGroup.node());
      const match = findBandAtPoint(pointX, pointY);
      if (!match) {
        hideTooltip();
        return;
      }
      if (match.state === activeBandState && match.band === activeBand) {
        updateTooltipPosition(event);
        return;
      }
      setActiveBand(match.state, match.band);
      showBandTooltip(event, match.band, match.state.row);
    };
    let zoomSurfaceSelection = null;
    const setOverlayCursor = value => {
      if (zoomSurfaceSelection) {
        zoomSurfaceSelection.style('cursor', value);
      } else {
        chartGroup.select('.variant-hotspot__zoom-surface').style('cursor', value);
      }
    };
    const updateZoomIndicator = () => {
      zoomIndicator.textContent = `Zoom: ${formatZoomLevel(currentTransform.k)}×`;
    };
    updateZoomIndicator();
    resetButton.disabled = false;
    const zoomBehavior = d3.zoom()
      .scaleExtent([1, 12])
      .translateExtent([[0, 0], [innerWidth, chartHeight]])
      .extent([[0, 0], [innerWidth, chartHeight]])
      .filter(event => {
        if (event.type === 'dblclick') return false;
        if (event.type === 'mousedown' && event.button !== 0) return false;
        return true;
      })
      .on('start', () => {
        hideTooltip();
        setOverlayCursor('grabbing');
      })
      .on('end', () => {
        setOverlayCursor(currentTransform.k > 1 ? 'move' : 'grab');
      })
      .on('zoom', event => {
        currentTransform = event.transform;
        let dynamicMax = 0;
        const zoomLevel = currentTransform.k;
        rowStates.forEach(state => {
          const scaled = event.transform.rescaleX(state.baseScale);
          const targetThresholds = computeAdaptiveThresholds(state.baseThresholds, zoomLevel);
          if (targetThresholds !== state.currentThresholds) {
            const binGenerator = d3.bin()
              .domain([0, state.row.chromLength])
              .thresholds(targetThresholds);
            const sourceData = Array.isArray(state.dataPositions) ? state.dataPositions : [];
            const newHistogram = binGenerator(sourceData);
            state.currentThresholds = targetThresholds;
            if (typeof state.refreshBars === 'function') {
              state.refreshBars(newHistogram, {scale: scaled});
            }
          } else if (state.bars) {
            applyScaleToBars(state.bars, scaled);
          }
          if (state.bands) {
            applyScaleToBars(state.bands, scaled);
          }
          if (state.centromeres) {
            applyScaleToBars(state.centromeres, scaled);
          }
          if (state.centromereBoundaries) {
            applyScaleToCentromereBoundaries(state.centromereBoundaries, scaled);
          }
          if (state.bandOverlays) {
            applyScaleToBars(state.bandOverlays, scaled);
          }
          if (state.highlightRects) {
            applyScaleToHighlight(state.highlightRects, scaled);
          }
          if (state.applyLabelScale) {
            state.applyLabelScale(scaled);
          }
          const scaledTickCount = Math.min(12, Math.max(2, Math.round(state.tickCount * zoomLevel)));
          state.axisGroup.call(d3.axisBottom(scaled)
            .ticks(scaledTickCount)
            .tickFormat(value => formatPosition(value)));
          styleAxis(state.axisGroup);
          const stateMax = d3.max(state.histogram || [], bin => bin.length) || 0;
          if (stateMax > dynamicMax) {
            dynamicMax = stateMax;
          }
        });
        updateColorScaleDomain(dynamicMax || 1);
        rowStates.forEach(state => {
          if (state.bars) {
            state.bars
              .attr('fill', d => colorScale(d.length))
              .attr('opacity', d => (d.length ? 0.95 : 0.4));
          }
        });
        refreshCaptionMax();
        updateZoomIndicator();
        if (event.sourceEvent && event.sourceEvent.type === 'wheel') {
          hideTooltip();
        }
        if (!event.sourceEvent || event.sourceEvent.type === 'wheel') {
          setOverlayCursor(currentTransform.k > 1 ? 'move' : 'grab');
        }
      });
    const zoomSurface = chartGroup.append('rect')
      .attr('class', 'variant-hotspot__zoom-surface')
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', innerWidth)
      .attr('height', chartHeight)
      .style('fill', 'transparent')
      .style('touch-action', 'none');
    zoomSurfaceSelection = zoomSurface;
    updateNativeBandTooltip = text => {
      if (!zoomSurfaceSelection) return;
      if (text) {
        zoomSurfaceSelection.attr('title', text);
        zoomSurfaceSelection.attr('aria-label', text);
      } else {
        zoomSurfaceSelection.attr('title', null);
        zoomSurfaceSelection.attr('aria-label', null);
      }
    };
    setOverlayCursor('grab');
    zoomSurface.call(zoomBehavior);
    zoomSurface
      .on('mouseenter.variantHotspotTooltip', handleSurfaceHover)
      .on('mousemove.variantHotspotTooltip', handleSurfaceHover)
      .on('mouseleave.variantHotspotTooltip', () => {
        hideTooltip();
      })
      .on('touchstart.variantHotspotTooltip', handleSurfaceHover)
      .on('touchmove.variantHotspotTooltip', handleSurfaceHover)
      .on('touchend.variantHotspotTooltip', () => {
        hideTooltip();
      })
      .on('touchcancel.variantHotspotTooltip', () => {
        hideTooltip();
      });
    zoomSurface.on('dblclick.zoom', null);
    const resetZoom = () => {
      hideTooltip();
      zoomSurface.transition().duration(250)
        .call(zoomBehavior.transform, d3.zoomIdentity);
    };
    zoomSurface.on('dblclick', event => {
      event.preventDefault();
      resetZoom();
    });
    resetButton.addEventListener('click', () => {
      resetZoom();
    });
    const gradientId = 'variant-hotspot-gradient';
    const gradient = defs.append('linearGradient')
      .attr('id', gradientId)
      .attr('x1', '0%')
      .attr('x2', '100%')
      .attr('y1', '0%')
      .attr('y2', '0%');
    const gradientStart = gradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', colorScale(0));
    const gradientEnd = gradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', colorScale(maxBinCount));
    const legendWidth = Math.min(220, innerWidth);
    const legendHeight = 12;
    const legendGroup = svg.append('g')
      .attr('transform', `translate(${margin.left}, ${height - margin.bottom + 20})`);
    legendGroup.append('text')
      .attr('class', 'variant-hotspot__legend-label')
      .attr('x', 0)
      .attr('y', -6)
      .text('Registreringer pr. segment');
    legendGroup.append('rect')
      .attr('width', legendWidth)
      .attr('height', legendHeight)
      .attr('rx', 6)
      .attr('ry', 6)
      .attr('fill', `url(#${gradientId})`);
    legendGroup.append('text')
      .attr('class', 'variant-hotspot__legend-label')
      .attr('x', 0)
      .attr('y', legendHeight + 12)
      .text('0');
    const legendMaxLabel = legendGroup.append('text')
      .attr('class', 'variant-hotspot__legend-label')
      .attr('x', legendWidth)
      .attr('y', legendHeight + 12)
      .attr('text-anchor', 'end')
      .text(String(maxBinCount));
    legendGroup.append('text')
      .attr('class', 'variant-hotspot__legend-label')
      .attr('x', legendWidth / 2)
      .attr('y', legendHeight + 12)
      .attr('text-anchor', 'middle')
      .text('Flere SNV/indels →');
    let currentMaxBinCount = Math.max(1, maxBinCount);
    const updateColorScaleDomain = newMax => {
      const safeMax = Math.max(1, newMax);
      currentMaxBinCount = safeMax;
      colorScale.domain([0, safeMax]);
      gradientStart.attr('stop-color', colorScale(0));
      gradientEnd.attr('stop-color', colorScale(safeMax));
      const displayMax = Math.max(0, Math.round(newMax));
      legendMaxLabel.text(String(displayMax));
    };
    const summaryParts = [`${coordinatesCount} SNV/indel${coordinatesCount === 1 ? '' : 'er'} i ${buildLabel}`];
    if (missingCount > 0) {
      summaryParts.push(`(${missingCount} uden koordinater)`);
    }
    if (mismatchedTotal > 0) {
      summaryParts.push(`(${mismatchedSummary} ekskluderet)`);
    }
    if (excludedCount > 0) {
      summaryParts.push(`(${excludedCount} andre varianttyper udeladt)`);
    }
    updateHotspotSummary(summaryParts.join(' '));
    let captionDetails = [
      `Vist mod ${buildLabel}, hvor farveintensiteten afspejler antallet af SNV/indels i hvert kromosomsegment.`,
      currentMaxBinCount > 1
        ? `Det travleste segment indeholder ${currentMaxBinCount} registrering${currentMaxBinCount === 1 ? '' : 'er'}.`
        : 'Alle viste segmenter rummer højst én registrering.',
      'Cytobåndene markerer de navngivne p/q-segmenter for den valgte reference – hold markøren over båndene for detaljer.'
    ];
    const refreshCaptionMax = () => {
      captionDetails[1] = currentMaxBinCount > 1
        ? `Det travleste segment indeholder ${currentMaxBinCount} registrering${currentMaxBinCount === 1 ? '' : 'er'}.`
        : 'Alle viste segmenter rummer højst én registrering.';
      updateHotspotCaption(captionDetails.join(' '));
    };
    if (missingCount > 0) {
      captionDetails.push(`${missingCount} SNV/indel${missingCount === 1 ? '' : 'er'} mangler koordinater og indgår derfor ikke.`);
    }
    if (mismatchedTotal > 0) {
      captionDetails.push(`${mismatchedSummary} vises ikke, fordi de er angivet i en anden reference end ${buildLabel}.`);
    }
    if (excludedCount > 0) {
      captionDetails.push(`${excludedCount} variant${excludedCount === 1 ? '' : 'er'} af andre typer vises ikke i hotspot-grafen.`);
    }
    if (highlightInfo) {
      captionDetails.push('Den valgte variant er markeret med et grønt bånd på det relevante kromosom.');
      if (hideOtherChromosomes) {
        captionDetails.push(`Visningen er afgrænset til kromosom ${highlightInfo.chromosome}, så fokus er på den valgte variant.`);
      }
    } else if (highlightVariant && highlightSuppressedReason) {
      const highlightMessage = (() => {
        switch (highlightSuppressedReason) {
          case 'position':
            return 'Den valgte variant mangler en gyldig genomisk position og kan derfor ikke markeres i hotspot-grafen.';
          case 'chromosome':
            return 'Den valgte variant mangler kromosomoplysning og kan derfor ikke markeres i hotspot-grafen.';
          case 'build': {
            const label = (highlightCandidate && highlightCandidate.buildLabel) || (highlightCandidate && highlightCandidate.build ? getGenomeBuildLabel(highlightCandidate.build) : '') || 'en anden reference';
            return `Den valgte variant er registreret i ${label} og kan derfor ikke markeres i hotspot-grafen.`;
          }
          default:
            return '';
        }
      })();
      if (highlightMessage) {
        captionDetails.push(highlightMessage);
      }
    }
    captionDetails.push('Zoom med scrollhjulet eller ved at trække for at undersøge kromosomerne. Dobbeltklik eller brug “Nulstil zoom” for at vende tilbage til udgangspunktet.');
    refreshCaptionMax();
  };
  const redrawHotspot = () => updateHotspotChart(filteredLibrary, {highlightVariant: getHighlightedEntry()});
  const csvColumns = [
    {key: 'id', label: 'ID'},
    {label: 'Varianttitel', value: entry => formatVariantTitle(entry) || ''},
    {key: 'gene', label: 'Gen'},
    {key: 'transcript', label: 'Transkript'},
    {key: 'hgvs_c', label: 'HGVS c.'},
    {key: 'hgvs_p', label: 'HGVS p.'},
    {key: 'rsid', label: 'rsID'},
    {key: 'genomic_position', label: 'Genomisk position'},
    {key: 'variant_type', label: 'Varianttype (kode)'},
    {label: 'Varianttype', value: entry => getVariantTypeLabel(entry.variant_type) || ''},
    {key: 'classification', label: 'Klasse'},
    {key: 'criteria', label: 'Kriterier'},
    {key: 'evidence', label: 'Evidens'},
    {key: 'condition', label: 'Tilstand'},
    {key: 'inheritance', label: 'Nedarvning'},
    {key: 'genome_build', label: 'Genom'},
    {key: 'chromosome', label: 'Kromosom'},
    {key: 'start', label: 'Start'},
    {key: 'end', label: 'Slut'},
    {key: 'copy_number', label: 'Kopital'},
    {key: 'sv_subtype', label: 'Strukturtype (kode)'},
    {label: 'Strukturtype', value: entry => getStructureTypeLabel(entry.sv_subtype) || ''},
    {key: 'size_bp', label: 'Størrelse'},
    {key: 'iscn', label: 'ISCN'},
    {key: 'description', label: 'Beskrivelse'},
    {key: 'affected_genes', label: 'Berørte gener'},
    {key: 'curated_by', label: 'Kurateret af'},
    {key: 'last_review', label: 'Sidst gennemgået'},
    {key: 'created_at', label: 'Oprettet'},
    {key: 'updated_at', label: 'Opdateret'}
  ];
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  const hotspotWrapper = section.querySelector('.variant-hotspot');
  const hotspotToggle = section.querySelector('[data-hotspot-toggle]');
  const hotspotContent = section.querySelector('[data-hotspot-content]');
  const setHotspotCollapsed = collapsed => {
    if (hotspotWrapper) {
      hotspotWrapper.dataset.collapsed = collapsed ? 'true' : 'false';
    }
    if (hotspotContent) {
      hotspotContent.hidden = collapsed;
    }
    if (hotspotToggle) {
      hotspotToggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      hotspotToggle.textContent = collapsed ? 'Vis hotspots' : 'Skjul hotspots';
      hotspotToggle.title = collapsed
        ? 'Vis hotspots-visualiseringen'
        : 'Skjul hotspots-visualiseringen';
    }
  };
  setHotspotCollapsed(true);
  hotspotToggle?.addEventListener('click', () => {
    const collapsed = hotspotWrapper?.dataset.collapsed !== 'false';
    const nextCollapsed = !collapsed;
    setHotspotCollapsed(nextCollapsed);
    if (!nextCollapsed) {
      requestAnimationFrame(redrawHotspot);
    }
  });
  const filterInputs = {
    gene: section.querySelector('[data-filter-library="gene"]'),
    transcript: section.querySelector('[data-filter-library="transcript"]'),
    hgvs_c: section.querySelector('[data-filter-library="hgvs_c"]'),
    hgvs_p: section.querySelector('[data-filter-library="hgvs_p"]'),
    rsid: section.querySelector('[data-filter-library="rsid"]'),
    genomic_position: section.querySelector('[data-filter-library="genomic_position"]'),
    classification: section.querySelector('[data-filter-library="classification"]'),
    criteria: section.querySelector('[data-filter-library="criteria"]'),
    variant_type: section.querySelector('[data-filter-library="variant_type"]'),
    iscn: section.querySelector('[data-filter-library="iscn"]'),
    chromosome: section.querySelector('[data-filter-library="chromosome"]'),
    genome_build: section.querySelector('[data-filter-library="genome_build"]'),
    start: section.querySelector('[data-filter-library="start"]'),
    end: section.querySelector('[data-filter-library="end"]'),
    sv_subtype: section.querySelector('[data-filter-library="sv_subtype"]'),
    copy_number: section.querySelector('[data-filter-library="copy_number"]'),
    size_bp: section.querySelector('[data-filter-library="size_bp"]'),
    condition: section.querySelector('[data-filter-library="condition"]'),
    inheritance: section.querySelector('[data-filter-library="inheritance"]'),
    curated_by: section.querySelector('[data-filter-library="curated_by"]'),
    affected_genes: section.querySelector('[data-filter-library="affected_genes"]'),
    description: section.querySelector('[data-filter-library="description"]'),
    last_review_from: section.querySelector('[data-filter-library="last_review_from"]'),
    last_review_to: section.querySelector('[data-filter-library="last_review_to"]')
  };
  const enterEditMode = id => {
    if (!form) return;
    form.dataset.mode = 'edit';
    form.dataset.editingId = id != null ? String(id) : '';
    if (saveButtonLabel) {
      saveButtonLabel.textContent = 'Opdater bibliotekspost';
    } else if (saveButton) {
      saveButton.textContent = 'Opdater bibliotekspost';
    }
    if (saveNewButton) saveNewButton.hidden = false;
  };
  const exitEditMode = () => {
    if (!form) return;
    form.dataset.mode = 'create';
    form.dataset.editingId = '';
    clearFormIdentifier(form);
    if (saveButtonLabel) {
      saveButtonLabel.textContent = defaultSaveLabel;
    } else if (saveButton) {
      saveButton.textContent = defaultSaveLabel;
    }
    if (saveNewButton) saveNewButton.hidden = true;
  };
  exitEditMode();
  const renderRows = () => {
    const term = (search?.value || '').trim().toLowerCase();
    const filters = {
      gene: filterInputs.gene?.value.trim().toLowerCase() || '',
      transcript: filterInputs.transcript?.value.trim().toLowerCase() || '',
      hgvs_c: filterInputs.hgvs_c?.value.trim().toLowerCase() || '',
      hgvs_p: filterInputs.hgvs_p?.value.trim().toLowerCase() || '',
      rsid: filterInputs.rsid?.value.trim().toLowerCase() || '',
      genomic_position: filterInputs.genomic_position?.value.trim().toLowerCase() || '',
      classification: filterInputs.classification?.value.trim().toLowerCase() || '',
      criteria: filterInputs.criteria?.value.trim().toLowerCase() || '',
      variant_type: filterInputs.variant_type?.value.trim().toLowerCase() || '',
      iscn: filterInputs.iscn?.value.trim().toLowerCase() || '',
      chromosome: filterInputs.chromosome?.value.trim().toLowerCase() || '',
      genome_build: filterInputs.genome_build?.value.trim().toLowerCase() || '',
      start: filterInputs.start?.value.trim().toLowerCase() || '',
      end: filterInputs.end?.value.trim().toLowerCase() || '',
      sv_subtype: filterInputs.sv_subtype?.value.trim().toLowerCase() || '',
      copy_number: filterInputs.copy_number?.value.trim().toLowerCase() || '',
      size_bp: filterInputs.size_bp?.value.trim().toLowerCase() || '',
      condition: filterInputs.condition?.value.trim().toLowerCase() || '',
      inheritance: filterInputs.inheritance?.value.trim().toLowerCase() || '',
      curated_by: filterInputs.curated_by?.value.trim().toLowerCase() || '',
      affected_genes: filterInputs.affected_genes?.value.trim().toLowerCase() || '',
      description: filterInputs.description?.value.trim().toLowerCase() || '',
      last_review_from: filterInputs.last_review_from?.value || '',
      last_review_to: filterInputs.last_review_to?.value || ''
    };
    const fromDate = filters.last_review_from ? new Date(filters.last_review_from) : null;
    const toDate = filters.last_review_to ? new Date(filters.last_review_to) : null;
    const validFrom = fromDate && !Number.isNaN(fromDate.getTime()) ? fromDate : null;
    const validTo = toDate && !Number.isNaN(toDate.getTime()) ? toDate : null;
    filteredLibrary = list.filter(v => {
      if (!term) return true;
      return [
        v.gene,
        v.transcript,
        v.hgvs_c,
        v.hgvs_p,
        v.rsid,
        v.genomic_position,
        v.classification,
        v.criteria,
        v.condition,
        v.inheritance,
        v.evidence,
        v.curated_by,
        v.iscn,
        v.chromosome,
        v.genome_build,
        v.start,
        v.end,
        v.copy_number,
        v.sv_subtype,
        getStructureTypeLabel(v.sv_subtype),
        v.size_bp,
        v.description,
        v.affected_genes,
        formatVariantGenomicRange(v),
        getVariantTypeLabel(v.variant_type),
        formatVariantTitle(v),
        getVariantFrequencyLabel(v),
        getVariantFrequencyCategory(v)
      ].some(val => (val || '').toString().toLowerCase().includes(term));
    }).filter(v => {
      if (filters.gene && !(v.gene || '').toLowerCase().includes(filters.gene)) return false;
      if (filters.transcript && !(v.transcript || '').toLowerCase().includes(filters.transcript)) return false;
      if (filters.hgvs_c && !(v.hgvs_c || '').toLowerCase().includes(filters.hgvs_c)) return false;
      if (filters.hgvs_p && !(v.hgvs_p || '').toLowerCase().includes(filters.hgvs_p)) return false;
      if (filters.rsid && !getVariantRsId(v).toLowerCase().includes(filters.rsid)) return false;
      if (filters.genomic_position && !(v.genomic_position || formatVariantGenomicRange(v) || '').toLowerCase().includes(filters.genomic_position)) return false;
      if (filters.classification && !(String(v.classification || '')).toLowerCase().includes(filters.classification)) return false;
      if (filters.criteria && !(v.criteria || '').toLowerCase().includes(filters.criteria)) return false;
      if (filters.variant_type && normalizeVariantType(v.variant_type) !== normalizeVariantType(filters.variant_type)) return false;
      if (filters.iscn && !(v.iscn || '').toLowerCase().includes(filters.iscn)) return false;
      if (filters.chromosome && !(v.chromosome || '').toLowerCase().includes(filters.chromosome)) return false;
      if (filters.genome_build && !(v.genome_build || '').toLowerCase().includes(filters.genome_build)) return false;
      if (filters.start && !(v.start || '').toLowerCase().includes(filters.start)) return false;
      if (filters.end && !(v.end || '').toLowerCase().includes(filters.end)) return false;
      if (filters.sv_subtype) {
        const subtypeValue = (v.sv_subtype || '').toLowerCase();
        const subtypeLabel = getStructureTypeLabel(v.sv_subtype || '').toLowerCase();
        if (!subtypeValue.includes(filters.sv_subtype) && !subtypeLabel.includes(filters.sv_subtype)) return false;
      }
      if (filters.copy_number && !(v.copy_number || '').toLowerCase().includes(filters.copy_number)) return false;
      if (filters.size_bp && !(v.size_bp || '').toLowerCase().includes(filters.size_bp)) return false;
      if (filters.condition && !(v.condition || '').toLowerCase().includes(filters.condition)) return false;
      if (filters.inheritance && !(v.inheritance || '').toLowerCase().includes(filters.inheritance)) return false;
      if (filters.curated_by && !(v.curated_by || '').toLowerCase().includes(filters.curated_by)) return false;
      if (filters.affected_genes && !(v.affected_genes || '').toLowerCase().includes(filters.affected_genes)) return false;
      if (filters.description && !(v.description || '').toLowerCase().includes(filters.description)) return false;
      if ((validFrom || validTo) && v.last_review) {
        const reviewDate = new Date(v.last_review);
        if (!Number.isNaN(reviewDate.getTime())) {
          if (validFrom && reviewDate < validFrom) return false;
          if (validTo && reviewDate > validTo) return false;
        } else if (validFrom || validTo) {
          return false;
        }
      } else if ((validFrom || validTo) && !v.last_review) {
        return false;
      }
      return true;
    });
    if (selectedId && !filteredLibrary.some(v => v.id === selectedId)) {
      selectedId = null;
    }
    updateOpenPatientsButton();
    if (!filteredLibrary.length) {
      tbody.innerHTML = `<tr><td colspan="16">Ingen poster matcher filtreringen.</td></tr>`;
      annotateTableCells(section);
      redrawHotspot();
      return;
    }
    tbody.innerHTML = filteredLibrary.map(v => {
      const selectedAttr = v.id === selectedId ? ' data-selected="true"' : '';
      const lastReview = formatDanishDate(v.last_review);
      const title = (formatVariantTitle(v) || '').trim();
      const displayTitle = truncateVariantTitleSegments(title);
      const variantTitleAttr = title ? ` title="${esc(title)}"` : '';
      const typeLabel = getVariantTypeLabel(v.variant_type);
      const genomic = formatVariantGenomicRange(v);
      const frequencyCount = getVariantFrequencyCount(v);
      const frequencyLabel = getVariantFrequencyLabel(v);
      const frequencyTitle = variantFrequencyPatientCount
        ? `${frequencyCount} registrering${frequencyCount === 1 ? '' : 'er'} blandt ${variantFrequencyPatientCount} patient${variantFrequencyPatientCount === 1 ? '' : 'er'}`
        : `${frequencyCount} registrering${frequencyCount === 1 ? '' : 'er'}`;
      const frequencyCategory = getVariantFrequencyCategory(v);
      const frequencyCategoryTitle = (() => {
        if (frequencyCategory === 'Ukendt') {
          if (!variantFrequencyMaxCount || variantFrequencyMaxCount <= 1) {
            return 'Forekomst kan ikke vurderes før der er flere registreringer i variantbiblioteket.';
          }
          return 'Forekomst er ikke tilgængelig.';
        }
        const topSuffix = variantFrequencyMaxCount
          ? ` sammenlignet med topposten på ${variantFrequencyMaxCount} registrering${variantFrequencyMaxCount === 1 ? '' : 'er'}`
          : '';
        return `${frequencyCategory} forekomst baseret på ${frequencyLabel}${topSuffix}.`;
      })();
      const condition = v.condition || '';
      const conditionDisplay = truncateConditionDisplay(condition);
      const conditionTitleAttr = condition
        ? ` title="${esc(condition).replace(/\r?\n/g, '&#10;')}"`
        : '';
      const inheritance = v.inheritance || '';
      const inheritanceDisplay = truncateInheritanceDisplay(inheritance);
      const inheritanceTitleAttr = inheritance
        ? ` title="${esc(inheritance).replace(/\r?\n/g, '&#10;')}"`
        : '';
      return `<tr data-id="${v.id}"${selectedAttr}><td>${v.id}</td><td${variantTitleAttr}>${esc(displayTitle)}</td><td>${esc(typeLabel)}</td><td>${esc(genomic)}</td><td>${esc(v.hgvs_c || '')}</td><td>${esc(v.hgvs_p || '')}</td><td>${formatRsIdCell(getVariantRsId(v))}</td><td>${esc(v.classification || '')}</td><td title="${esc(frequencyTitle)}">${esc(frequencyLabel)}</td><td title="${esc(frequencyCategoryTitle)}">${esc(frequencyCategory)}</td><td>${esc(v.criteria || '')}</td><td>${esc(v.iscn || '')}</td><td${conditionTitleAttr}>${esc(conditionDisplay)}</td><td${inheritanceTitleAttr}>${esc(inheritanceDisplay)}</td><td>${esc(v.curated_by || '')}</td><td>${esc(lastReview)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
    redrawHotspot();
  };
  renderRows();
  openPatientsButton?.addEventListener('click', () => {
    if (!openPatientsButton.disabled) {
      const entry = selectedId != null
        ? list.find(item => Number(item?.id) === Number(selectedId))
        : null;
      if (entry) {
        openPatientsForVariant(entry);
      }
    }
  });
  search?.addEventListener('input', renderRows);
  Object.entries(filterInputs).forEach(([, input]) => {
    if (!input) return;
    const eventName = input.type === 'date' ? 'change' : 'input';
    input.addEventListener(eventName, renderRows);
    if (eventName === 'change') {
      input.addEventListener('input', renderRows);
    }
  });
  tbody?.addEventListener('click', e => {
    const tr = e.target.closest('tr[data-id]');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const entry = list.find(v => v.id === id);
    if (!entry) return;
    selectedId = id;
    fillForm(form, {...entry, variant_type: normalizeVariantType(entry.variant_type)});
    updateVariantTypeFields();
    enterEditMode(id);
    renderRows();
  });
  const clearForm = () => {
    if (!form) return;
    form.reset();
    if (variantTypeSelect) {
      variantTypeSelect.value = normalizeVariantType('snv');
    }
    updateVariantTypeFields();
  };
  clearButton?.addEventListener('click', clearForm);
  form?.addEventListener('reset', () => {
    clearFormIdentifier(form);
    exitEditMode();
    selectedId = null;
    updateVariantTypeFields();
    renderRows();
  });
  form?.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('variant_library')) return;
    const submitterAction = e.submitter?.dataset.action || 'save';
    const data = Object.fromEntries(new FormData(form).entries());
    Object.keys(data).forEach(key => {
      if (typeof data[key] === 'string') {
        data[key] = data[key].trim();
      }
    });
    data.rsid = normalizeRsId(data.rsid);
    data.variant_type = normalizeVariantType(data.variant_type);
    data.sv_subtype = normalizeStructureTypeValue(data.sv_subtype);
    const editingId = Number(form.dataset.editingId || data.id || 0);
    const creatingNew = submitterAction === 'create' || !editingId;
    const normalizedClassification = mapVarSeqClassification(data.classification);
    const payload = {
      variant_type: data.variant_type,
      gene: data.gene || '',
      transcript: data.transcript || '',
      hgvs_c: data.hgvs_c || '',
      hgvs_p: data.hgvs_p || '',
      rsid: data.rsid || '',
      genomic_position: data.genomic_position || '',
      classification: normalizedClassification || '',
      criteria: data.criteria || '',
      genome_build: data.genome_build || '',
      chromosome: data.chromosome || '',
      start: data.start || '',
      end: data.end || '',
      copy_number: data.copy_number || '',
      sv_subtype: data.sv_subtype || '',
      size_bp: data.size_bp || '',
      iscn: data.iscn || '',
      description: data.description || '',
      affected_genes: data.affected_genes || '',
      condition: data.condition || '',
      inheritance: data.inheritance || '',
      evidence: data.evidence || '',
      curated_by: data.curated_by || '',
      last_review: data.last_review || ''
    };
    if (payload.last_review && !/^\d{4}-\d{2}-\d{2}$/.test(payload.last_review)) {
      const date = new Date(payload.last_review);
      if (!Number.isNaN(date.getTime())) {
        payload.last_review = date.toISOString().split('T')[0];
      }
    }
    if (!creatingNew) {
      const id = editingId;
      const beforeRecord = findById('variant_library', id);
      if (!beforeRecord) {
        alert('Kunne ikke finde biblioteksposten.');
        return;
      }
      const before = {...beforeRecord};
      const updated = {...before, ...payload, id};
      await updateRecord('variant_library', updated, before);
      setStatus(`Bibliotekspost ${id} opdateret.`);
    } else {
      if (!payload.curated_by) payload.curated_by = currentUserName() || '';
      if (!payload.last_review) payload.last_review = new Date().toISOString().split('T')[0];
      const record = {...payload};
      await addRecord('variant_library', record);
      setStatus('Bibliotekspost oprettet.');
    }
    renderTab('variant_library');
  });
  deleteButton?.addEventListener('click', async () => {
    const id = Number(form?.elements?.id?.value || 0);
    if (!id) {
      alert('Vælg en bibliotekspost der skal slettes.');
      return;
    }
    if (!ensureWrite('variant_library')) return;
    if (!confirm('Slet bibliotekspost?')) return;
    await deleteRecord('variant_library', id);
    setStatus(`Bibliotekspost ${id} slettet.`);
    renderTab('variant_library');
  });
  exportButton?.addEventListener('click', () => {
    const exportRows = filteredLibrary.map(entry => ({
      ...entry,
      variant_type: normalizeVariantType(entry.variant_type),
      sv_subtype: normalizeStructureTypeValue(entry.sv_subtype)
    }));
    const filename = downloadCsvFile(exportRows, csvColumns, 'glimr-variantbibliotek.csv');
    setStatus(`Eksporterede ${filteredLibrary.length} biblioteksposter til ${filename}.`);
  });
  importButton?.addEventListener('click', () => importInput?.click());
  importInput?.addEventListener('change', async () => {
    const file = importInput.files?.[0];
    if (!file) return;
    if (!ensureWrite('variant_library')) {
      importInput.value = '';
      return;
    }
    try {
      const text = await file.text();
      const {headers, rows} = parseCsv(text);
      if (!headers.length) throw new Error('CSV-filen mangler kolonneoverskrifter.');
      const headerMap = {
        id: 'id',
        gene: 'gene',
        gen: 'gene',
        transcript: 'transcript',
        transkript: 'transcript',
        hgvs_c: 'hgvs_c',
        hgvs_c_: 'hgvs_c',
        hgvs: 'hgvs_c',
        hgvs_p: 'hgvs_p',
        rsid: 'rsid',
        dbsnp: 'rsid',
        dbsnp_id: 'rsid',
        dbsnpid: 'rsid',
        dbsnp_rs: 'rsid',
        rs_id: 'rsid',
        genomic_position: 'genomic_position',
        genomisk_position: 'genomic_position',
        genomisk_position_ra: 'genomic_position',
        genomicpos: 'genomic_position',
        genomic_pos: 'genomic_position',
        position: 'genomic_position',
        pos: 'genomic_position',
        variant_type: 'variant_type',
        varianttype: 'variant_type',
        varianttypekode: 'variant_type',
        varianttype_kode: 'variant_type',
        type: 'variant_type',
        klassifikation: 'classification',
        classification: 'classification',
        class: 'classification',
        klasse: 'classification',
        criteria: 'criteria',
        kriterier: 'criteria',
        acmg: 'criteria',
        evidence: 'evidence',
        evidens: 'evidence',
        notes: 'evidence',
        condition: 'condition',
        tilstand: 'condition',
        phenotype: 'condition',
        inheritance: 'inheritance',
        nedarvning: 'inheritance',
        genome_build: 'genome_build',
        genome: 'genome_build',
        reference: 'genome_build',
        kromosom: 'chromosome',
        chromosome: 'chromosome',
        chr: 'chromosome',
        start: 'start',
        begin: 'start',
        begynd: 'start',
        position_start: 'start',
        end: 'end',
        stop: 'end',
        slut: 'end',
        position_end: 'end',
        copy_number: 'copy_number',
        copynumber: 'copy_number',
        kopital: 'copy_number',
        kopitaler: 'copy_number',
        cn: 'copy_number',
        sv_subtype: 'sv_subtype',
        svtype: 'sv_subtype',
        strukturtype: 'sv_subtype',
        strukturtypekode: 'sv_subtype',
        strukturtype_kode: 'sv_subtype',
        variant_subtype: 'sv_subtype',
        structuraltype: 'sv_subtype',
        size: 'size_bp',
        size_bp: 'size_bp',
        stoerrelse: 'size_bp',
        length: 'size_bp',
        iscn: 'iscn',
        cytogenetic: 'iscn',
        affected_genes: 'affected_genes',
        genes: 'affected_genes',
        gener: 'affected_genes',
        description: 'description',
        beskrivelse: 'description',
        curated_by: 'curated_by',
        kurator: 'curated_by',
        kurateret_af: 'curated_by',
        last_review: 'last_review',
        sidst_gennemgaaet: 'last_review',
        lastreview: 'last_review'
      };
      const computedColumnNames = new Set(['frekvens', 'frequency', 'forekomst', 'occurrence', 'genomisk_interval', 'genomic_interval']);
      const ignoredComputedColumns = new Set();
      const columnKeys = headers.map(header => {
        const normalized = normaliseHeader(header);
        if (computedColumnNames.has(normalized)) {
          const trimmed = (header || '').trim();
          if (trimmed) ignoredComputedColumns.add(trimmed);
          return null;
        }
        return headerMap[normalized] || null;
      });
      if (!columnKeys.some(key => ['gene', 'hgvs_c', 'hgvs_p', 'iscn', 'chromosome', 'description'].includes(key))) {
        throw new Error('CSV-filen skal mindst indeholde et identificerende felt (Gen, HGVS, ISCN, kromosom eller beskrivelse).');
      }
      const summary = {created: 0, updated: 0, skipped: 0};
      const existingCache = new Map(getCached('variant_library').map(entry => [entry.id, {...entry}]));
      for (const rowValues of rows) {
        if (!rowValues || rowValues.every(cell => !cell || !cell.trim())) {
          summary.skipped++;
          continue;
        }
        const entry = {};
        columnKeys.forEach((key, idx) => {
          if (!key) return;
          const raw = (rowValues[idx] || '').trim();
          if (key === 'rsid') {
            entry.rsid = normalizeRsId(raw);
            return;
          }
          if (key === 'sv_subtype') {
            entry.sv_subtype = normalizeStructureTypeValue(raw);
            return;
          }
          entry[key] = raw;
        });
        entry.variant_type = normalizeVariantType(entry.variant_type);
        let id = null;
        if (entry.id) {
          const parsedId = Number(entry.id);
          if (Number.isFinite(parsedId) && parsedId > 0) {
            id = parsedId;
            entry.id = parsedId;
          } else {
            delete entry.id;
          }
        }
        const ensureIsoDate = value => {
          if (!value) return '';
          if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
          const parsed = new Date(value);
          if (!Number.isNaN(parsed.getTime())) {
            return parsed.toISOString().split('T')[0];
          }
          return value;
        };
        entry.last_review = ensureIsoDate(entry.last_review || '');
        if (!entry.gene && !entry.hgvs_c && !entry.hgvs_p && !entry.genomic_position && !entry.iscn && !entry.chromosome && !entry.description) {
          summary.skipped++;
          continue;
        }
        if (id && existingCache.has(id)) {
          const before = existingCache.get(id);
          const updated = {...before, ...entry, id};
          await updateRecord('variant_library', updated, before);
          existingCache.set(id, updated);
          summary.updated++;
        } else {
          const record = {...entry};
          delete record.id;
          if (!record.curated_by) record.curated_by = currentUserName() || '';
          if (!record.last_review) record.last_review = new Date().toISOString().split('T')[0];
          await addRecord('variant_library', record);
          summary.created++;
        }
      }
      const summaryParts = [];
      if (summary.updated) summaryParts.push(`${summary.updated} opdateret`);
      if (summary.created) summaryParts.push(`${summary.created} tilføjet`);
      if (summary.skipped) summaryParts.push(`${summary.skipped} uændret`);
      const message = summaryParts.length ? summaryParts.join(', ') : 'Ingen poster ændret';
      const ignoredMessage = ignoredComputedColumns.size
        ? ` Beregnede kolonner ignoreret: ${Array.from(ignoredComputedColumns).join(', ')}.`
        : '';
      setStatus(`Import fuldført: ${message}.${ignoredMessage}`);
      alert(`Import fuldført: ${message}.${ignoredMessage ? `\n${ignoredMessage}` : ''}`);
      renderTab('variant_library');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke importere CSV: ' + err.message);
      setStatus('Fejl under import: ' + err.message);
    } finally {
      importInput.value = '';
    }
  });
}
function snapshotVariant(variant) {
  if (!variant) {
    return {id: null, order_id: null, variant_type: 'snv', gene: '', transcript: '', hgvs_c: '', hgvs_p: '', zygosity: '', classification: '', criteria: '', af: '', annotations: '', interpretation: '', genomic_position: '', genome_build: '', chromosome: '', start: '', end: '', copy_number: '', sv_subtype: '', size_bp: '', iscn: '', description: '', affected_genes: ''};
  }
  return {
    id: variant.id ?? null,
    order_id: variant.order_id ?? null,
    variant_type: normalizeVariantType(variant.variant_type),
    gene: variant.gene || '',
    transcript: variant.transcript || '',
    hgvs_c: variant.hgvs_c || '',
    hgvs_p: variant.hgvs_p || '',
    rsid: getVariantRsId(variant),
    zygosity: variant.zygosity || '',
    classification: variant.classification || '',
    criteria: variant.criteria || '',
    af: variant.af ?? '',
    annotations: variant.annotations || variant.annotation_summary || '',
    interpretation: variant.interpretation || '',
    genomic_position: variant.genomic_position || formatVariantGenomicRange(variant) || '',
    genome_build: variant.genome_build || '',
    chromosome: variant.chromosome || '',
    start: variant.start || '',
    end: variant.end || '',
    copy_number: variant.copy_number || '',
    sv_subtype: normalizeStructureTypeValue(variant.sv_subtype || variant.structural_type || ''),
    size_bp: variant.size_bp || '',
    iscn: variant.iscn || variant.cytogenetic || '',
    description: variant.description || '',
    affected_genes: variant.affected_genes || variant.genes || ''
  };
}
function parseReportVariantIds(value) {
  if (Array.isArray(value)) {
    return value.map(Number).filter(id => Number.isFinite(id));
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return [];
    try {
      const parsed = JSON.parse(trimmed);
      return parseReportVariantIds(parsed);
    } catch (err) {
      return trimmed.split(/[^0-9]+/).map(Number).filter(id => Number.isFinite(id));
    }
  }
  return [];
}
function getReportVariantSnapshots(report, orderId) {
  if (!report) return [];
  const detailsRaw = report.variant_details;
  if (Array.isArray(detailsRaw) && detailsRaw.length) {
    return detailsRaw.map(snapshotVariant);
  }
  if (typeof detailsRaw === 'string' && detailsRaw.trim()) {
    try {
      const parsed = JSON.parse(detailsRaw);
      if (Array.isArray(parsed) && parsed.length) {
        return parsed.map(snapshotVariant);
      }
    } catch (err) {
      console.warn('Kunne ikke parse variant_details', err);
    }
  }
  const ids = parseReportVariantIds(report.variant_ids);
  if (!ids.length) return [];
  const orderVariants = getCached('variants').filter(v => !orderId || v.order_id === orderId);
  return ids.map(id => {
    const found = orderVariants.find(v => v.id === id) || getCached('variants').find(v => v.id === id);
    if (!found) return null;
    return snapshotVariant(found);
  }).filter(Boolean);
}
function describeVariantNarrative(variant) {
  if (!variant) return '';
  const summaryParts = [];
  const typeLabel = getVariantTypeLabel(variant.variant_type);
  if (variant.classification) summaryParts.push(`Klasse ${variant.classification}`);
  if (variant.criteria) summaryParts.push(`ACMG: ${variant.criteria}`);
  if (variant.af !== undefined && variant.af !== null && variant.af !== '') summaryParts.push(`AF: ${variant.af}`);
  if (variant.zygosity) summaryParts.push(`Zygositet: ${variant.zygosity}`);
  const subtypeLabel = getStructureTypeLabel(variant.sv_subtype || variant.structural_type || '');
  if (subtypeLabel) summaryParts.push(`Type: ${subtypeLabel}`);
  if (variant.copy_number) summaryParts.push(`Kopital: ${variant.copy_number}`);
  if (variant.size_bp) summaryParts.push(`Størrelse: ${variant.size_bp}`);
  if (variant.affected_genes) summaryParts.push(`Berørte gener: ${variant.affected_genes}`);
  if (variant.iscn) summaryParts.push(`ISCN: ${variant.iscn}`);
  const genomic = formatVariantGenomicRange(variant);
  if (genomic) summaryParts.push(`Position: ${genomic}`);
  if (variant.interpretation) summaryParts.push(variant.interpretation);
  const title = formatVariantTitle(variant);
  const summary = summaryParts.join(' – ');
  const headingParts = [title || '', typeLabel && title !== typeLabel ? typeLabel : '', summary].filter(Boolean);
  return headingParts.join(' – ');
}
function buildConclusionPlaceholderGuide(context = 'report') {
  const intro = context === 'library'
    ? 'Indsæt pladsholdere i standardteksten for at få felter udfyldt automatisk, når teksten bruges i en rapport.'
    : 'Når du indsætter en standardtekst i rapporten, erstattes pladsholdere automatisk med data fra den valgte ordination.';
  return `
    <details class="placeholder-guide">
      <summary>
        <h3>Pladsholdere til konklusioner</h3>
        <span class="placeholder-guide-subtitle">Klik for at se tilgængelige felter fra ordination, prøve og varianter.</span>
      </summary>
      <div class="placeholder-guide-body">
        <p>${intro} Skriv pladsholderen i firkantede parenteser, fx <code>[Patient]</code>.</p>
        <div class="placeholder-guide-columns">
          <div>
            <h4>Patient &amp; ordination</h4>
            <ul>
              <li><code>[Patient]</code> – patientens navn</li>
              <li><code>[PatientMRN]</code> – patientens MRN/CPR</li>
              <li><code>[PatientID]</code> – ID</li>
              <li><code>[PatientFamilienummer]</code> – familienummer</li>
              <li><code>[PatientFødselsdato]</code> – fødselsdato (dd-mm-åååå)</li>
              <li><code>[OrdinationID]</code> – ordinationens ID</li>
              <li><code>[OrdinationStatus]</code> – ordinationens status</li>
              <li><code>[OrdinationDato]</code> – bestillingsdato</li>
              <li><code>[OrdinationRekvirent]</code> – rekvirerende afdeling/læge</li>
              <li><code>[OrdinationPanel]</code> – valgt panel</li>
              <li><code>[OrdinationAnalyseansvarlig]</code> – analyseansvarlig</li>
              <li><code>[OrdinationTolker]</code> – tolk/fortolker</li>
              <li><code>[OrdinationGodkender]</code> – godkender</li>
              <li><code>[OrdinationIndikation]</code> – ordinationens kliniske indikation</li>
              <li><code>[OrdinationPatientgruppe]</code> – ordinationens patientgruppe</li>
              <li><code>[OrdinationHPO]</code> / <code>[OrdinationHPOTermer]</code> – registrerede HPO-termer</li>
            </ul>
          </div>
          <div>
            <h4>Prøve</h4>
            <ul>
              <li><code>[SampleID]</code> – prøve-ID</li>
              <li><code>[SamplePMB]</code> – PMB-nummer</li>
              <li><code>[SampleType]</code> – prøvetype</li>
              <li><code>[SampleStatus]</code> – prøvens status</li>
              <li><code>[SampleDato]</code> – prøvetagningsdato</li>
            </ul>
          </div>
          <div>
            <h4>Varianter (fælles)</h4>
            <ul>
              <li><code>[VariantAntal]</code> – antal valgte varianter</li>
              <li><code>[VariantTyper]</code> / <code>[VariantType]</code> – liste over varianttyper (SNV, CNV, strukturel m.m.)</li>
              <li><code>[Gen]</code>, <code>[Transkript]</code>, <code>[HGVS_c]</code>, <code>[HGVS_p]</code> – lister over værdier på tværs af varianter</li>
              <li><code>[Zygositet]</code>, <code>[ACMG-klasse]</code>, <code>[ACMG-klasseTekst]</code>, <code>[Kriterier]</code> – kombinerede klassifikationer (inkl. tekst for ACMG-klasser)</li>
              <li><code>[Annoteringer]</code> – samlede annoteringer (inkl. VarSeq-noter)</li>
              <li><code>[Tolkning]</code> – samlede tolkninger</li>
              <li><code>[VariantListe]</code> – nummereret oversigt med detaljer (inkl. type, HGVS, ISCN m.m.)</li>
              <li><code>[Variant]</code> / <code>[Variant1]</code> – detaljeret tekst for den første variant</li>
            </ul>
            <h4>CNV, strukturelle &amp; cytogenetiske felter</h4>
            <ul>
              <li><code>[VariantISCN]</code> / <code>[ISCN]</code> – kombineret ISCN-notation for de valgte varianter</li>
              <li><code>[VariantGenomiskPosition]</code> / <code>[VariantPosition]</code> – genomiske positioner eller intervaller</li>
              <li><code>[VariantKopital]</code> / <code>[VariantCopyNumber]</code> – kopitaler/copy-number-resultater</li>
              <li><code>[VariantStrukturType]</code> / <code>[VariantSubtype]</code> – navngivne strukturtyper eller subtyper</li>
              <li><code>[VariantBeskrivelse]</code> – tekstbeskrivelser af strukturelle fund</li>
              <li><code>[BerørteGener]</code> / <code>[AffectedGenes]</code> – liste over berørte eller involverede gener</li>
            </ul>
          </div>
        </div>
        <p class="placeholder-guide-footnote">Tilgå enkelte varianter med nummererede pladsholdere, fx <code>[Variant1Gene]</code>, <code>[Variant1StrukturType]</code> eller <code>[Variant2ISCN]</code>. Manglende oplysninger giver tom tekst, og pladsholdere er uafhængige af store/små bogstaver. Punktum kan bruges som adskillelse, fx <code>[Patient.MRN]</code>.</p>
      </div>
    </details>
  `;
}

function renderConclusionLibrary(section) {
  const list = getCached('conclusion_library').slice().sort((a, b) => {
    const titleCompare = (a.title || '').localeCompare(b.title || '', 'da');
    if (titleCompare) return titleCompare;
    return (a.id || 0) - (b.id || 0);
  });
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="conclusionLibrarySearch">Søg</label>
        <input id="conclusionLibrarySearch" type="search" placeholder="Titel eller tekst...">
        <table>
          <thead>
            <tr><th>ID</th><th>Titel</th><th>Uddrag</th><th>Opdateret</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h2>Standardtekst</h2>
        <form id="conclusionLibraryForm">
          <input type="hidden" name="id">
          <label>Titel<input name="title" required></label>
          <label>Standardtekst<textarea name="body" rows="8" required></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="conclusionLibraryClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="conclusionLibraryDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
        <div data-placeholder-guide="library"></div>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#conclusionLibrarySearch');
  const form = section.querySelector('#conclusionLibraryForm');
  const clearBtn = section.querySelector('#conclusionLibraryClear');
  const deleteBtn = section.querySelector('#conclusionLibraryDelete');
  const placeholderGuideHost = section.querySelector('[data-placeholder-guide="library"]');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  if (placeholderGuideHost) {
    placeholderGuideHost.innerHTML = buildConclusionPlaceholderGuide('library');
  }
  let selectedId = null;
  let filtered = list.slice();
  const renderRows = () => {
    const term = (search?.value || '').toLowerCase().trim();
    filtered = list.filter(entry => {
      if (!term) return true;
      const haystack = `${entry.title || ''} ${(entry.body || '').replace(/\s+/g, ' ')}`.toLowerCase();
      return haystack.includes(term);
    });
    if (selectedId && !filtered.some(entry => entry.id === selectedId)) {
      selectedId = null;
    }
    if (!filtered.length) {
      tbody.innerHTML = '<tr><td colspan="4">Ingen standardtekster matcher søgningen.</td></tr>';
      annotateTableCells(section);
      return;
    }
    tbody.innerHTML = filtered.map(entry => {
      const snippetSource = (entry.body || '').replace(/\s+/g, ' ').trim();
      const snippet = snippetSource.length > 120 ? `${snippetSource.slice(0, 117)}…` : snippetSource;
      const updatedAt = formatDanishDate(entry.updated_at);
      const selectedAttr = entry.id === selectedId ? ' data-selected="true"' : '';
      return `<tr data-id="${entry.id}"${selectedAttr}><td>${entry.id}</td><td>${esc(entry.title || '')}</td><td>${esc(snippet)}</td><td>${esc(updatedAt)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search?.addEventListener('input', renderRows);
  tbody?.addEventListener('click', e => {
    const tr = e.target.closest('tr[data-id]');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const entry = list.find(item => item.id === id);
    if (!entry) return;
    selectedId = id;
    fillForm(form, entry);
    renderRows();
  });
  const clearForm = () => {
    if (!form) return;
    form.reset();
  };
  clearBtn?.addEventListener('click', clearForm);
  deleteBtn?.addEventListener('click', async () => {
    if (!ensureWrite('conclusion_library')) return;
    const id = Number(form?.elements.id.value);
    if (!id) {
      alert('Vælg en standardtekst der skal slettes.');
      return;
    }
    if (!confirm('Slet den valgte standardtekst?')) return;
    await deleteRecord('conclusion_library', id);
    setStatus(`Standardtekst ${id} slettet.`);
    renderTab('conclusion_library');
  });
  form?.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('conclusion_library')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    const payload = {
      title: (data.title || '').trim(),
      body: (data.body || '').trim()
    };
    if (!payload.title || !payload.body) {
      alert('Udfyld både titel og tekst.');
      return;
    }
    const id = Number(data.id || 0);
    if (id) {
      const before = findById('conclusion_library', id);
      if (!before) {
        alert('Kunne ikke finde standardteksten.');
        return;
      }
      const updated = {...before, ...payload, id};
      await updateRecord('conclusion_library', updated, before);
      setStatus(`Standardtekst ${id} opdateret.`);
    } else {
      await addRecord('conclusion_library', payload);
      setStatus('Standardtekst oprettet.');
    }
    renderTab('conclusion_library');
  });
  form?.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedId = null;
    renderRows();
  });
}

function renderReports(section) {
  const list = getCached('reports');
  const orders = getCached('orders');
  const samples = getCached('samples');
  const orderMap = new Map(orders.map(o => [Number(o.id), o]));
  const sampleMap = new Map(samples.map(s => [Number(s.id), s]));
  const orderOptions = orders.map(o => {
    const patientName = getName('patients', o.patient_id);
    const patientGroupName = getPatientGroupName(o.patient_group_id);
    const labelParts = [patientName];
    if (patientGroupName) labelParts.push(patientGroupName);
    const label = labelParts.filter(Boolean).join(' • ');
    return `<option value="${o.id}">${o.id} – ${esc(label || getOrderDisplayName(o.id))}</option>`;
  }).join('');
  const conclusionLibrary = getCached('conclusion_library').slice().sort((a, b) => (a.title || '').localeCompare(b.title || '', 'da'));
  const conclusionOptions = conclusionLibrary.map(entry => `<option value="${entry.id}">${esc(entry.title || `Tekst #${entry.id}`)}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="reportSearch">Søg</label>
        <input id="reportSearch" type="search" placeholder="Status...">
        <label class="list-toggle"><input type="checkbox" id="reportsActiveOnly" checked> Vis kun aktive</label>
        <details class="advanced-filter" id="reportsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-reports="id" placeholder="Rapport-ID"></label>
            <label>Ordination<input type="search" data-filter-reports="order" placeholder="Ordination (navn eller ID)"></label>
            <label>Prøve<input type="search" data-filter-reports="sample" placeholder="Prøve (ID eller PMB)"></label>
            <label>Status<input type="search" data-filter-reports="status" placeholder="Status"></label>
            <label>Udstedt fra<input type="date" data-filter-reports="issued_from"></label>
            <label>Udstedt til<input type="date" data-filter-reports="issued_to"></label>
          </div>
        </details>
        <table><thead><tr><th class="table-shortcuts"><span class="sr-only">Genveje</span></th><th>ID</th><th>Ordination</th><th>Status</th><th>Oprettet af</th><th>Udstedt</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="reportsExport">Eksportér filtrerede rapporter</button>
        </div>
      </div>
      <div>
        <h2>Rapport</h2>
        <form id="reportForm">
          <input type="hidden" name="id">
          <label>Ordination
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer ordinationer">
              <select name="order_id" required>
                <option value="" selected>Vælg ordination</option>
                ${orderOptions}
              </select>
            </div>
          </label>
          <label>Status<select name="status"><option value="draft">Udkast</option><option value="final">Endelig</option><option value="amended">Ændret</option></select></label>
          <label>Udstedt<input type="datetime-local" name="issued_at"></label>
          <label>Fund
            <div class="report-variant-selector">
              <div class="filterable-select">
                <input type="search" placeholder="Filtrer varianter" data-report-variant-filter>
                <select id="reportVariantSelect" disabled>
                  <option value="" selected>Vælg variant</option>
                </select>
              </div>
              <button class="secondary" type="button" id="reportAddVariant" disabled>Tilføj</button>
            </div>
          </label>
          <div class="report-variant-list" id="reportVariantList">
            <p class="report-variant-empty">Ingen varianter valgt.</p>
          </div>
          <input type="hidden" name="variant_ids" value="[]">
          <label>Konklusion<textarea name="summary"></textarea></label>
          <div class="conclusion-library-controls">
            <label>Standardtekst
              <select id="conclusionLibrarySelect">
                <option value="" selected>Vælg standardtekst</option>
                ${conclusionOptions}
              </select>
            </label>
            <div class="conclusion-library-buttons">
              <button class="secondary" type="button" id="conclusionLibraryInsert">Erstat konklusion</button>
              <button class="secondary" type="button" id="conclusionLibraryAppend">Tilføj til konklusion</button>
              <button class="secondary" type="button" id="conclusionPlaceholderApply">Anvend pladsholdere</button>
            </div>
          </div>
          <div data-placeholder-guide="report"></div>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="reportClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="reportDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
            <button class="secondary" type="button" id="reportPreview">Udskriv/forhåndsvis</button>
            <button class="secondary" type="button" id="reportDownloadPdf">Hent PDF</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#reportSearch');
  const form = section.querySelector('#reportForm');
  const orderSelect = form?.elements.order_id;
  const variantSelect = form?.querySelector('#reportVariantSelect');
  const variantFilterInput = form?.querySelector('[data-report-variant-filter]');
  const variantAddButton = form?.querySelector('#reportAddVariant');
  const variantList = form?.querySelector('#reportVariantList');
  const variantIdsInput = form?.elements.variant_ids;
  const conclusionSelect = form?.querySelector('#conclusionLibrarySelect');
  const conclusionInsertBtn = form?.querySelector('#conclusionLibraryInsert');
  const conclusionAppendBtn = form?.querySelector('#conclusionLibraryAppend');
  const conclusionPlaceholderBtn = form?.querySelector('#conclusionPlaceholderApply');
  const summaryField = form?.elements.summary;
  const conclusionMap = new Map(conclusionLibrary.map(entry => [String(entry.id), entry]));
  const placeholderGuideHost = section.querySelector('[data-placeholder-guide="report"]');
  let selectedReportVariants = [];
  let currentReportOrderId = null;
  let variantOptionState = [];
  if (placeholderGuideHost) {
    placeholderGuideHost.innerHTML = buildConclusionPlaceholderGuide('report');
  }
  const updateAddButtonState = () => {
    if (!variantAddButton || !variantSelect) return;
    const id = Number(variantSelect.value);
    const exists = selectedReportVariants.some(v => v.id === id);
    variantAddButton.disabled = variantSelect.disabled || !variantSelect.value || exists;
  };
  const syncVariantIdsInput = () => {
    if (!variantIdsInput) return;
    const ids = selectedReportVariants.map(v => v.id).filter(id => id != null);
    variantIdsInput.value = JSON.stringify(ids);
  };
  const renderSelectedReportVariants = () => {
    if (!variantList) return;
    if (!selectedReportVariants.length) {
      variantList.innerHTML = '<p class="report-variant-empty">Ingen varianter valgt.</p>';
      return;
    }
    const items = selectedReportVariants.map(variant => {
      const title = formatVariantTitle(variant) || `Variant ${variant.id ?? ''}`.trim();
      const metaParts = [];
      if (variant.id != null) metaParts.push(`<span><strong>ID:</strong> ${esc(variant.id)}</span>`);
      const typeLabel = getVariantTypeLabel(variant.variant_type);
      if (typeLabel) metaParts.push(`<span><strong>Type:</strong> ${esc(typeLabel)}</span>`);
      if (variant.transcript) metaParts.push(`<span><strong>Transkript:</strong> ${esc(variant.transcript)}</span>`);
      if (variant.classification) metaParts.push(`<span><strong>Klasse:</strong> ${esc(variant.classification)}</span>`);
      if (variant.criteria) metaParts.push(`<span><strong>ACMG:</strong> ${esc(variant.criteria)}</span>`);
      if (variant.af !== undefined && variant.af !== null && variant.af !== '') metaParts.push(`<span><strong>AF:</strong> ${esc(variant.af)}</span>`);
      if (variant.zygosity) metaParts.push(`<span><strong>Zygositet:</strong> ${esc(variant.zygosity)}</span>`);
      const genomic = formatVariantGenomicRange(variant);
      if (genomic) metaParts.push(`<span><strong>Position:</strong> ${esc(genomic)}</span>`);
      if (variant.copy_number) metaParts.push(`<span><strong>Kopital:</strong> ${esc(variant.copy_number)}</span>`);
      if (variant.iscn) metaParts.push(`<span><strong>ISCN:</strong> ${esc(variant.iscn)}</span>`);
      const metaHtml = metaParts.length ? `<div class="report-variant-meta">${metaParts.join('')}</div>` : '';
      const interpretationHtml = variant.interpretation ? `<p>${esc(variant.interpretation)}</p>` : '';
      return `<div class="report-variant-item" data-variant-id="${variant.id}"><header><span>${esc(title)}</span><button type="button" class="report-variant-remove" data-action="remove" data-variant-id="${variant.id}">Fjern</button></header>${metaHtml}${interpretationHtml}</div>`;
    }).join('');
    variantList.innerHTML = items;
  };
  const setSelectedReportVariants = variants => {
    selectedReportVariants = (variants || []).map(v => ({...v}));
    syncVariantIdsInput();
    renderSelectedReportVariants();
    updateAddButtonState();
  };
  const buildVariantOptionLabel = variant => {
    const title = formatVariantTitle(variant);
    if (title) return title;
    return `Variant ${variant.id}`;
  };
  const applyVariantFilter = () => {
    if (!variantFilterInput) return;
    const term = variantFilterInput.value.trim().toLowerCase();
    variantOptionState.forEach(({option, text}) => {
      const matches = !term || text.includes(term) || option.selected;
      option.hidden = !matches;
    });
    if (term && variantSelect) {
      const firstVisible = variantOptionState.find(({option}) => !option.hidden);
      if (firstVisible && !firstVisible.option.selected) {
        variantSelect.value = firstVisible.option.value;
      }
    }
    updateAddButtonState();
  };
  const refreshVariantOptions = () => {
    if (!variantSelect) return;
    const orderId = Number(orderSelect?.value || '');
    currentReportOrderId = Number.isFinite(orderId) && orderId ? orderId : null;
    variantOptionState = [];
    variantSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Vælg variant';
    variantSelect.appendChild(placeholder);
    if (!currentReportOrderId) {
      variantSelect.disabled = true;
      if (variantFilterInput) {
        variantFilterInput.value = '';
        variantFilterInput.disabled = true;
      }
      updateAddButtonState();
      return;
    }
    const variantsForOrder = getCached('variants').filter(v => v.order_id === currentReportOrderId);
    variantsForOrder.forEach(variant => {
      const option = document.createElement('option');
      option.value = variant.id;
      option.textContent = buildVariantOptionLabel(variant);
      variantSelect.appendChild(option);
      variantOptionState.push({option, text: option.textContent.toLowerCase()});
    });
    variantSelect.disabled = variantsForOrder.length === 0;
    if (variantFilterInput) {
      variantFilterInput.value = '';
      variantFilterInput.disabled = variantsForOrder.length === 0;
    }
    variantSelect.value = '';
    applyVariantFilter();
  };
  const filterInputs = {
    id: section.querySelector('[data-filter-reports="id"]'),
    order: section.querySelector('[data-filter-reports="order"]'),
    sample: section.querySelector('[data-filter-reports="sample"]'),
    status: section.querySelector('[data-filter-reports="status"]'),
    issued_from: section.querySelector('[data-filter-reports="issued_from"]'),
    issued_to: section.querySelector('[data-filter-reports="issued_to"]')
  };
  const activeToggle = section.querySelector('#reportsActiveOnly');
  const updateConclusionButtons = () => {
    const hasSelection = !!conclusionSelect?.value;
    if (conclusionInsertBtn) conclusionInsertBtn.disabled = !hasSelection;
    if (conclusionAppendBtn) conclusionAppendBtn.disabled = !hasSelection;
  };
  const normalizePlaceholderKey = key => {
    if (!key) return '';
    return key
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/[^a-z0-9_.æøå-]/g, '')
      .replace(/-+/g, '')
      .replace(/^[.]+|[.]+$/g, '');
  };
  const joinUnique = (values, separator = ', ') => {
    const seen = new Set();
    const result = [];
    for (const value of values || []) {
      const text = value == null ? '' : String(value).trim();
      if (!text || seen.has(text)) continue;
      seen.add(text);
      result.push(text);
    }
    return result.join(separator);
  };
  const joinUniqueParagraphs = values => {
    const seen = new Set();
    const result = [];
    for (const value of values || []) {
      const text = value == null ? '' : String(value).trim();
      if (!text || seen.has(text)) continue;
      seen.add(text);
      result.push(text);
    }
    return result.join('\n\n');
  };
  const describeVariantBlock = variant => {
    if (!variant) return '';
    const lines = [];
    const header = formatVariantTitle(variant);
    if (header) lines.push(header);
    const detailLines = formatVariantDetailLines(variant);
    if (detailLines.length) lines.push(detailLines.join(' – '));
    if (variant.annotations) lines.push(`Annoteringer: ${variant.annotations}`);
    if (variant.interpretation) lines.push(`Tolkning: ${variant.interpretation}`);
    return lines.join('\r\n');
  };
  const buildConclusionPlaceholderMap = () => {
    const map = new Map();
    const lowercaseInitialPatterns = [
      /^ordination\d*indikation$/,
      /^ordination\d*patientgruppe$/,
      /^zygositet\d*$/,
      /^sample\d*type$/,
      /^sample\d*status$/,
      /^acmg\d*klassetekst$/,
      /^acmg\d*tekst$/,
      /^variant\d*acmgtekst$/,
      /^variant\d*\.acmgtekst$/,
      /^variant\d*zygositet$/,
      /^variant\d*\.zygositet$/,
      /^variant\d*strukturtype$/,
      /^variant\d*\.strukturtype$/,
      /^variant\d*subtype$/,
      /^variant\d*\.subtype$/
    ];
    const lowercaseInitialValue = value => {
      if (!value) return value;
      return value.replace(/^([\s]*)(\S)/u, (match, leading, ch) => `${leading}${ch.toLocaleLowerCase()}`);
    };
    const formatPlaceholderValue = (normalizedKey, text) => {
      if (!text) return text;
      return lowercaseInitialPatterns.some(pattern => pattern.test(normalizedKey))
        ? lowercaseInitialValue(text)
        : text;
    };
    const add = (keys, value) => {
      if (!Array.isArray(keys)) keys = [keys];
      for (const key of keys) {
        const normalized = normalizePlaceholderKey(key);
        if (!normalized) continue;
        const text = value == null ? '' : String(value);
        map.set(normalized, formatPlaceholderValue(normalized, text));
      }
    };
    const orderId = Number(form?.elements.order_id?.value || '') || null;
    const order = orderId ? findById('orders', orderId) : null;
    const patient = order?.patient_id ? findById('patients', Number(order.patient_id)) : null;
    const sample = order?.sample_id ? findById('samples', Number(order.sample_id)) : null;
    const panel = order?.panel_id ? findById('panels', Number(order.panel_id)) : null;
    const analysisUser = order?.analysis_responsible_id ? findById('users', Number(order.analysis_responsible_id)) : null;
    const interpreterUser = order?.interpreter_id ? findById('users', Number(order.interpreter_id)) : null;
    const approverUser = order?.approver_id ? findById('users', Number(order.approver_id)) : null;
    const patientGroupName = order?.patient_group_id ? getPatientGroupName(order.patient_group_id) : '';
    const variants = selectedReportVariants.slice();
    const variantCount = variants.length;
    const firstVariant = variants[0] || null;
    add(['Patient', 'PatientNavn', 'Patient.Name'], patient?.name || '');
    add(['PatientMRN', 'MRN', 'Patient.MRN'], patient?.mrn || '');
    add(['PatientID', 'PatientId', 'PatientEkstraId', 'PatientEkstraID', 'EkstraID', 'Patient.EkstraID'], patient?.extra_id || '');
    add(['PatientFamilienummer', 'Familienummer', 'Patient.Familienummer'], patient?.family_number || '');
    add(['PatientFodselsdato', 'PatientFødselsdato', 'Patient.BirthDate'], patient?.birth_date ? formatDanishDate(patient.birth_date) : '');
    add(['OrdinationID', 'Ordination.Id', 'OrderID'], orderId ? String(orderId) : '');
    add(['OrdinationStatus', 'Ordination.Status'], order?.status || '');
    add(['OrdinationDato', 'OrdinationBestilt', 'Ordination.Ordered'], order?.ordered_at ? formatDanishDate(order.ordered_at) : '');
    add(['OrdinationRekvirent', 'Ordination.Clinician', 'Clinician'], order?.clinician || '');
    add(['OrdinationPanel', 'PanelNavn', 'Panel'], panel?.name || '');
    add(['OrdinationAnalyseansvarlig', 'Analyseansvarlig'], analysisUser?.name || '');
    add(['OrdinationTolker', 'Tolker'], interpreterUser?.name || '');
    add(['OrdinationGodkender', 'Godkender'], approverUser?.name || '');
    add(['OrdinationIndikation', 'Ordination.Indikation', 'Indikation'], order?.indication || '');
    add(['OrdinationPatientgruppe', 'Ordination.Patientgruppe', 'Patientgruppe'], patientGroupName || '');
    add(['OrdinationHPO', 'OrdinationHPOTermer', 'Ordination.HPO', 'HPO', 'HPOliste', 'HPOList'], formatHpoList(order?.hpo_terms));
    add(['SampleID', 'ProeveID', 'PrøveID'], sample?.id ? String(sample.id) : '');
    add(['SamplePMB', 'PMB'], sample?.pmb_number || '');
    add(['SampleType', 'ProeveType', 'PrøveType'], sample?.sample_type || '');
    add(['SampleStatus', 'ProeveStatus', 'PrøveStatus'], sample?.status || '');
    add(['SampleDato', 'Sample.Collected', 'PrøveDato'], sample?.collected_at ? formatDanishDate(sample.collected_at) : '');
    add(['VariantAntal', 'AntalVarianter'], variantCount ? String(variantCount) : '');
    const getClassificationLabel = classification => {
      const key = classification == null ? '' : String(classification).trim();
      if (!key) return '';
      return classificationMap?.[key]?.display || '';
    };
    const geneList = joinUnique(variants.map(v => v.gene));
    const transcriptList = joinUnique(variants.map(v => v.transcript));
    const hgvscList = joinUnique(variants.map(v => v.hgvs_c));
    const hgvsPList = joinUnique(variants.map(v => v.hgvs_p));
    const zygosityList = joinUnique(variants.map(v => v.zygosity));
    const classificationList = joinUnique(variants.map(v => v.classification));
    const classificationLabelList = joinUnique(variants.map(v => getClassificationLabel(v.classification)));
    const criteriaList = joinUnique(variants.map(v => v.criteria));
    const typeList = joinUnique(variants.map(v => getVariantTypeLabel(v.variant_type)));
    const iscnList = joinUnique(variants.map(v => v.iscn));
    const genomicList = joinUnique(variants.map(v => formatVariantGenomicRange(v)));
    const copyNumberList = joinUnique(variants.map(v => v.copy_number));
    const subtypeList = joinUnique(variants.map(v => getStructureTypeLabel(v.sv_subtype || v.structural_type || '')));
    const annotationsText = joinUniqueParagraphs(variants.map(v => v.annotations));
    const interpretationText = joinUniqueParagraphs(variants.map(v => v.interpretation));
    const descriptionText = joinUniqueParagraphs(variants.map(v => v.description));
    const affectedGenesText = joinUnique(variants.map(v => v.affected_genes));
    const variantSummaryBlocks = variants.map((variant, index) => {
      const block = describeVariantBlock(variant);
      if (!block) return '';
      const indented = block.replace(/\n/g, '\n   ');
      return `${index + 1}. ${indented}`;
    }).filter(Boolean);
    const variantSummary = variantSummaryBlocks.join('\n\n');
    add(['Gen', 'Gene', 'Gener'], geneList);
    add(['Transkript', 'Transcript'], transcriptList);
    add(['HGVS_c', 'HGVS c', 'HGVSc'], hgvscList);
    add(['HGVS_p', 'HGVS p', 'HGVSp'], hgvsPList);
    add(['Zygositet', 'Zygosity'], zygosityList);
    add(['ACMG-klasse', 'ACMGklasse', 'ACMG'], classificationList);
    add([
      'ACMG-klasseTekst',
      'ACMG-klasse (tekst)',
      'ACMGklasseTekst',
      'ACMGTekst'
    ], classificationLabelList);
    add(['Kriterier', 'Criteria'], criteriaList);
    add(['VariantTyper', 'VariantType', 'Varianttype'], typeList);
    add(['VariantISCN', 'ISCN'], iscnList);
    add(['VariantGenomisk', 'VariantGenomiskPosition', 'VariantPosition'], genomicList);
    add(['VariantKopital', 'VariantCopyNumber'], copyNumberList);
    add(['VariantStrukturType', 'VariantSubtype', 'VariantSVType'], subtypeList);
    add(['Annoteringer', 'Annotationer', 'Annotations', 'VarSeq'], annotationsText);
    add(['Tolkning', 'Tolkninger', 'Interpretation', 'Interpretations'], interpretationText);
    add(['VariantBeskrivelse', 'VariantBeskrivelser', 'VariantDescription'], descriptionText);
    add(['BerørteGener', 'AffectedGenes'], affectedGenesText);
    add(['VariantListe', 'VariantList', 'Varianter'], variantSummary);
    if (firstVariant) {
      add(['Variant', 'VariantNavn', 'Variant1'], describeVariantBlock(firstVariant));
      add(['VariantGene', 'VariantGen', 'Variant1Gene', 'Variant1.Gen'], firstVariant.gene || '');
      add(['VariantTranskript', 'Variant1Transkript'], firstVariant.transcript || '');
      add(['VariantHGVS_c', 'Variant1HGVS_c', 'Variant1.HGVS_c'], firstVariant.hgvs_c || '');
      add(['VariantHGVS_p', 'Variant1HGVS_p', 'Variant1.HGVS_p'], firstVariant.hgvs_p || '');
      add(['VariantZygositet', 'Variant1Zygositet'], firstVariant.zygosity || '');
      add(['VariantACMG', 'Variant1ACMG'], firstVariant.classification || '');
      add([
        'VariantACMGTekst',
        'Variant1ACMGTekst',
        'Variant1.ACMGTekst'
      ], getClassificationLabel(firstVariant.classification));
      add(['VariantKriterier', 'Variant1Kriterier'], firstVariant.criteria || '');
      add(['VariantAnnoteringer', 'Variant1Annoteringer'], firstVariant.annotations || '');
      add(['VariantTolkning', 'Variant1Tolkning'], firstVariant.interpretation || '');
      add(['VariantType', 'Variant1Type'], getVariantTypeLabel(firstVariant.variant_type));
      add(['VariantISCN', 'Variant1ISCN'], firstVariant.iscn || '');
      add(['VariantGenomiskPosition', 'Variant1GenomiskPosition'], formatVariantGenomicRange(firstVariant));
      add(['VariantKopital', 'Variant1Kopital'], firstVariant.copy_number || '');
      add(['VariantStrukturType', 'Variant1StrukturType', 'Variant1Subtype'], getStructureTypeLabel(firstVariant.sv_subtype || firstVariant.structural_type || ''));
      add(['VariantBeskrivelse', 'Variant1Beskrivelse'], firstVariant.description || '');
      add(['VariantBerørteGener', 'Variant1BerørteGener', 'Variant1AffectedGenes'], firstVariant.affected_genes || '');
    }
    variants.forEach((variant, index) => {
      const idx = index + 1;
      const prefix = `Variant${idx}`;
      add([`${prefix}`, `${prefix}Navn`, `${prefix}.Navn`], describeVariantBlock(variant));
      add([`${prefix}Gene`, `${prefix}.Gene`, `${prefix}Gen`, `${prefix}.Gen`], variant.gene || '');
      add([`${prefix}Transkript`, `${prefix}.Transkript`], variant.transcript || '');
      add([`${prefix}HGVS_c`, `${prefix}.HGVS_c`], variant.hgvs_c || '');
      add([`${prefix}HGVS_p`, `${prefix}.HGVS_p`], variant.hgvs_p || '');
      add([`${prefix}Zygositet`, `${prefix}.Zygositet`], variant.zygosity || '');
      add([`${prefix}ACMG`, `${prefix}.ACMG`], variant.classification || '');
      add([
        `${prefix}ACMGTekst`,
        `${prefix}.ACMGTekst`
      ], getClassificationLabel(variant.classification));
      add([`${prefix}Kriterier`, `${prefix}.Kriterier`], variant.criteria || '');
      add([`${prefix}Annoteringer`, `${prefix}.Annoteringer`], variant.annotations || '');
      add([`${prefix}Tolkning`, `${prefix}.Tolkning`], variant.interpretation || '');
      add([`${prefix}Type`, `${prefix}.Type`], getVariantTypeLabel(variant.variant_type));
      add([`${prefix}ISCN`, `${prefix}.ISCN`], variant.iscn || '');
      add([`${prefix}GenomiskPosition`, `${prefix}.GenomiskPosition`], formatVariantGenomicRange(variant));
      add([`${prefix}Kopital`, `${prefix}.Kopital`], variant.copy_number || '');
      add([`${prefix}StrukturType`, `${prefix}.StrukturType`, `${prefix}Subtype`, `${prefix}.Subtype`], getStructureTypeLabel(variant.sv_subtype || variant.structural_type || ''));
      add([`${prefix}Beskrivelse`, `${prefix}.Beskrivelse`], variant.description || '');
      add([`${prefix}BerørteGener`, `${prefix}.BerørteGener`, `${prefix}AffectedGenes`, `${prefix}.AffectedGenes`], variant.affected_genes || '');
    });
    return map;
  };
  const resolveConclusionTemplate = template => {
    if (!template) return '';
    const replacements = buildConclusionPlaceholderMap();
    return String(template).replace(/\[([^\]]+)\]/g, (match, rawKey) => {
      const normalized = normalizePlaceholderKey(rawKey);
      if (!normalized) return match;
      return replacements.has(normalized) ? replacements.get(normalized) : match;
    });
  };
  const applyConclusionText = mode => {
    if (!summaryField || !conclusionSelect) return;
    const entry = conclusionMap.get(conclusionSelect.value);
    if (!entry) return;
    const text = resolveConclusionTemplate(entry.body || '');
    if (mode === 'replace') {
      summaryField.value = text;
    } else if (mode === 'append') {
      const existing = summaryField.value || '';
      const trimmed = existing.replace(/\s+$/, '');
      summaryField.value = trimmed ? `${trimmed}\n\n${text}` : text;
    }
    summaryField.dispatchEvent(new Event('input', {bubbles: false}));
    summaryField.focus();
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  updateConclusionButtons();
  setSelectedReportVariants([]);
  refreshVariantOptions();
  if (variantFilterInput) {
    variantFilterInput.addEventListener('input', applyVariantFilter);
    variantFilterInput.addEventListener('keydown', evt => {
      if (evt.key === 'Escape') {
        variantFilterInput.value = '';
        applyVariantFilter();
      }
    });
  }
  if (variantSelect) {
    variantSelect.addEventListener('change', updateAddButtonState);
  }
  conclusionSelect?.addEventListener('change', updateConclusionButtons);
  conclusionInsertBtn?.addEventListener('click', () => applyConclusionText('replace'));
  conclusionAppendBtn?.addEventListener('click', () => applyConclusionText('append'));
  conclusionPlaceholderBtn?.addEventListener('click', () => {
    if (!summaryField) return;
    const resolved = resolveConclusionTemplate(summaryField.value || '');
    summaryField.value = resolved;
    summaryField.dispatchEvent(new Event('input', {bubbles: false}));
    summaryField.focus();
  });
  if (variantAddButton) {
    variantAddButton.addEventListener('click', () => {
      if (!variantSelect) return;
      const id = Number(variantSelect.value);
      if (!id || selectedReportVariants.some(v => v.id === id)) {
        updateAddButtonState();
        return;
      }
      const storeVariant = getCached('variants').find(v => v.id === id);
      const snapshot = snapshotVariant(storeVariant || {id, order_id: currentReportOrderId || Number(orderSelect?.value) || null});
      if (!snapshot.order_id) snapshot.order_id = currentReportOrderId || Number(orderSelect?.value) || null;
      setSelectedReportVariants(selectedReportVariants.concat(snapshot));
      variantSelect.value = '';
      applyVariantFilter();
    });
  }
  if (variantList) {
    variantList.addEventListener('click', evt => {
      const btn = evt.target.closest('[data-action="remove"]');
      if (!btn) return;
      const id = Number(btn.dataset.variantId);
      if (!id) return;
      setSelectedReportVariants(selectedReportVariants.filter(v => v.id !== id));
      updateAddButtonState();
    });
  }
  if (orderSelect) {
    orderSelect.addEventListener('change', () => {
      refreshVariantOptions();
      const orderId = Number(orderSelect.value);
      if (!orderId) {
        setSelectedReportVariants([]);
        return;
      }
      const filtered = selectedReportVariants.filter(v => Number(v.order_id) === orderId);
      if (filtered.length !== selectedReportVariants.length) {
        setSelectedReportVariants(filtered);
      } else {
        syncVariantIdsInput();
        renderSelectedReportVariants();
        updateAddButtonState();
      }
    });
  }
  const statusMap = {draft:'Udkast', final:'Endelig', amended:'Ændret'};
  let filteredReports = list.slice();
  let activeFilters = {};
  let pendingFilterOrderId = state.pendingReportFilterOrderId != null ? Number(state.pendingReportFilterOrderId) : null;
  if (!Number.isFinite(pendingFilterOrderId)) pendingFilterOrderId = null;
  let pendingFilterSampleId = state.pendingReportFilterSampleId != null ? Number(state.pendingReportFilterSampleId) : null;
  if (!Number.isFinite(pendingFilterSampleId)) pendingFilterSampleId = null;
  let requireExactSample = Boolean(state.pendingReportFilterSampleExact && pendingFilterSampleId != null);
  let requireExactOrder = Boolean(state.pendingReportFilterOrderExact && pendingFilterOrderId != null);
  const pendingSelectOrderIdRaw = state.pendingReportSelectOrderId != null ? Number(state.pendingReportSelectOrderId) : null;
  let pendingSelectOrderId = Number.isFinite(pendingSelectOrderIdRaw) ? pendingSelectOrderIdRaw : null;
  const pendingSelectReportIdRaw = state.pendingReportSelectReportId != null ? Number(state.pendingReportSelectReportId) : null;
  const pendingSelectReportId = Number.isFinite(pendingSelectReportIdRaw) ? pendingSelectReportIdRaw : null;
  let selectedReportId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  if (pendingFilterOrderId != null) {
    if (filterInputs.order) filterInputs.order.value = String(pendingFilterOrderId);
    if (search) search.value = '';
    if (state.pendingReportShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    const matchingReports = list.filter(r => Number(r.order_id) === pendingFilterOrderId);
    if (matchingReports.length) {
      matchingReports.sort((a, b) => {
        const timeA = (a.issued_at || a.updated_at || a.created_at || '');
        const timeB = (b.issued_at || b.updated_at || b.created_at || '');
        return timeB.localeCompare(timeA);
      });
      selectedReportId = matchingReports[0].id;
    }
  }
  if (pendingFilterSampleId != null) {
    if (filterInputs.sample) filterInputs.sample.value = String(pendingFilterSampleId);
    if (search) search.value = '';
    if (state.pendingReportShowAll && activeToggle) {
      showActiveOnly = false;
      activeToggle.checked = false;
    }
    const relatedOrders = orders.filter(o => Number(o.sample_id) === pendingFilterSampleId);
    const relatedOrderIds = new Set(relatedOrders.map(o => Number(o.id)).filter(id => Number.isFinite(id)));
    const matchingReports = list.filter(r => relatedOrderIds.has(Number(r.order_id)));
    if (matchingReports.length) {
      matchingReports.sort((a, b) => {
        const timeA = (a.issued_at || a.updated_at || a.created_at || '');
        const timeB = (b.issued_at || b.updated_at || b.created_at || '');
        return timeB.localeCompare(timeA);
      });
      if (selectedReportId == null) {
        selectedReportId = matchingReports[0].id;
      }
      if (pendingSelectOrderId == null) {
        const firstOrderId = Number(matchingReports[0].order_id);
        if (Number.isFinite(firstOrderId)) pendingSelectOrderId = firstOrderId;
      }
    } else if (relatedOrderIds.size === 1 && pendingSelectOrderId == null) {
      const onlyOrderId = relatedOrderIds.values().next().value;
      if (Number.isFinite(onlyOrderId)) pendingSelectOrderId = Number(onlyOrderId);
    }
  }
  if (selectedReportId == null && pendingSelectReportId != null) {
    selectedReportId = pendingSelectReportId;
  }
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      order: filterInputs.order?.value.trim().toLowerCase() || '',
      sample: filterInputs.sample?.value.trim().toLowerCase() || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      issued_from: filterInputs.issued_from?.value || '',
      issued_to: filterInputs.issued_to?.value || ''
    };
    const fromDate = filters.issued_from ? new Date(filters.issued_from) : null;
    const toDate = filters.issued_to ? new Date(filters.issued_to) : null;
    if (toDate) toDate.setHours(23, 59, 59, 999);
    const filterSummary = {...filters};
    const numericFilterOrder = Number(filters.order || '');
    const numericFilterSample = Number(filters.sample || '');
    const matchExactOrder = requireExactOrder && filters.order !== '' && Number.isFinite(numericFilterOrder) && numericFilterOrder === pendingFilterOrderId;
    const matchExactSample = requireExactSample && filters.sample !== '' && Number.isFinite(numericFilterSample) && numericFilterSample === pendingFilterSampleId;
    if (term) filterSummary.fritekst = term;
    if (filters.order) {
      const orderObj = orderMap.get(Number(filters.order));
      filterSummary.ordination = orderObj ? `${orderObj.id} (${getOrderDisplayName(orderObj.id) || '–'})` : filters.order;
    }
    delete filterSummary.order;
    if (filters.sample) {
      const sampleObj = sampleMap.get(Number(filters.sample));
      filterSummary.prøve = sampleObj ? `${sampleObj.id} (${sampleObj.pmb_number || '–'})` : filters.sample;
    }
    delete filterSummary.sample;
    filterSummary.visning = showActiveOnly ? 'Kun aktive' : 'Alle';
    activeFilters = filterSummary;
    filteredReports = list.filter(r => {
      const order = orderMap.get(Number(r.order_id));
      const sample = order ? sampleMap.get(Number(order.sample_id)) : null;
      const sampleStatus = (sample?.status || order?.status || '').toLowerCase();
      const samplePatientName = sample ? getName('patients', sample.patient_id) : '';
      if (!term) {
        if (showActiveOnly && !isActiveStatus(sampleStatus)) return false;
        return true;
      }
      const raw = (r.status || '').toLowerCase();
      const display = (statusMap[r.status] || r.status || '').toLowerCase();
      const creator = determineCreatedBy('reports', r).toLowerCase();
      const orderName = getOrderDisplayName(r.order_id).toLowerCase();
      const orderId = String(r.order_id || '').toLowerCase();
      const sampleIdString = sample ? String(sample.id || '').toLowerCase() : '';
      const samplePmb = (sample?.pmb_number || '').toLowerCase();
      const matches = [raw, display, creator, orderName, orderId, sampleStatus, sampleIdString, samplePmb, (samplePatientName || '').toLowerCase()].some(value => value.includes(term));
      if (!matches) return false;
      if (showActiveOnly && !isActiveStatus(sampleStatus)) return false;
      return true;
    }).filter(r => {
      if (filters.id && !String(r.id).includes(filters.id)) return false;
      if (filters.order) {
        if (matchExactOrder) {
          if (Number(r.order_id) !== pendingFilterOrderId) return false;
        } else {
          const orderIdString = String(r.order_id || '').toLowerCase();
          const orderName = getOrderDisplayName(r.order_id).toLowerCase();
          if (!orderIdString.includes(filters.order) && !orderName.includes(filters.order)) return false;
        }
      }
      const order = orderMap.get(Number(r.order_id));
      const sample = order ? sampleMap.get(Number(order.sample_id)) : null;
      const sampleStatus = (sample?.status || order?.status || '').toLowerCase();
      const samplePatientName = sample ? getName('patients', sample.patient_id) : '';
      if (filters.sample) {
        if (matchExactSample) {
          if (!sample || Number(sample.id) !== pendingFilterSampleId) return false;
        } else {
          const sampleValues = [
            sample ? String(sample.id || '').toLowerCase() : '',
            (sample?.pmb_number || '').toLowerCase(),
            (samplePatientName || '').toLowerCase()
          ];
          if (!sampleValues.some(v => v.includes(filters.sample))) return false;
        }
      }
      const statusStrings = [(r.status || '').toLowerCase(), (statusMap[r.status] || '').toLowerCase(), sampleStatus];
      if (filters.status && !statusStrings.some(v => v.includes(filters.status))) return false;
      if (fromDate || toDate) {
        if (!r.issued_at) return false;
        const issued = new Date(r.issued_at);
        if (Number.isNaN(issued.getTime())) return false;
        if (fromDate && issued < fromDate) return false;
        if (toDate && issued > toDate) return false;
      }
      if (showActiveOnly && !isActiveStatus(sampleStatus)) return false;
      return true;
    });
    if (selectedReportId != null && !filteredReports.some(r => r.id === selectedReportId)) {
      selectedReportId = null;
    }
    tbody.innerHTML = filteredReports.map(r => {
      const order = orderMap.get(Number(r.order_id));
      const sample = order ? sampleMap.get(Number(order?.sample_id)) : null;
      const sampleStatus = sample?.status || order?.status || '';
      const displayStatus = statusMap[r.status] || r.status || '';
      const createdBy = determineCreatedBy('reports', r);
      const issuedAt = formatDanishDate(r.issued_at);
      const orderName = getOrderDisplayName(r.order_id);
      const orderTitle = r.order_id != null ? ` title="Ordination #${r.order_id}"` : '';
      const sampleStatusBadge = sampleStatus && !isActiveStatus(sampleStatus)
        ? ` <span class="table-meta">(${esc(sampleStatus)})</span>`
        : '';
      const selectedAttr = r.id === selectedReportId ? ' data-selected="true"' : '';
      const hasOrder = r.order_id != null && Number.isFinite(Number(r.order_id));
      const sampleIdValue = sample ? Number(sample.id) : NaN;
      const orderTip = hasOrder
        ? 'Åbn Ordinationer-fanen med filter for denne rapport.'
        : 'Rapporten er ikke knyttet til en ordination.';
      const hasSample = Number.isFinite(sampleIdValue);
      const sampleTip = hasSample
        ? 'Åbn Prøver-fanen med filter for denne rapport.'
        : 'Rapportens ordination er ikke knyttet til en prøve.';
      const orderButtonDisabledAttr = hasOrder ? '' : ' disabled';
      const sampleButtonDisabledAttr = hasSample ? '' : ' disabled';
      const shortcutsCell = `<td class="table-actions-cell"><div class="table-shortcut-actions"><button type="button" class="icon-button" data-report-action="orders" data-report-id="${r.id}" data-tooltip="${esc(orderTip)}"${orderButtonDisabledAttr}><span class="icon-slot" data-icon="clipboard-document-list"></span></button><button type="button" class="icon-button" data-report-action="samples" data-report-id="${r.id}" data-tooltip="${esc(sampleTip)}"${sampleButtonDisabledAttr}><span class="icon-slot" data-icon="beaker"></span></button></div></td>`;
      return `<tr data-id="${r.id}"${selectedAttr}>${shortcutsCell}<td>${r.id}</td><td${orderTitle}>${esc(orderName)}</td><td>${esc(displayStatus)}${sampleStatusBadge}</td><td>${esc(createdBy)}</td><td>${esc(issuedAt)}</td></tr>`;
    }).join('');
    applyIconSlots(tbody);
    tbody.querySelectorAll('button[data-report-action]').forEach(btn => {
      const tip = btn.dataset.tooltip || btn.getAttribute('title') || '';
      if (tip) setTooltip(btn, tip);
    });
    annotateTableCells(section);
  };
  renderRows();
  if (selectedReportId != null) {
    const pendingReport = list.find(r => r.id === selectedReportId);
    if (pendingReport) {
      fillForm(form, pendingReport);
      const pendingRow = tbody?.querySelector(`tr[data-id="${pendingReport.id}"]`);
      if (pendingRow) {
        pendingRow.scrollIntoView({block: 'nearest'});
      }
      if (orderSelect) {
        orderSelect.dispatchEvent(new Event('change'));
      }
    }
  } else if (pendingSelectOrderId != null && orderSelect) {
    orderSelect.value = String(pendingSelectOrderId);
    orderSelect.dispatchEvent(new Event('change'));
  }
  state.pendingReportFilterOrderId = null;
  state.pendingReportFilterOrderExact = false;
  state.pendingReportFilterSampleId = null;
  state.pendingReportFilterSampleExact = false;
  state.pendingReportShowAll = false;
  state.pendingReportSelectOrderId = null;
  state.pendingReportSelectReportId = null;
  search.addEventListener('input', renderRows);
  const handleFilterChange = event => {
    if (event?.currentTarget === filterInputs.order) {
      requireExactOrder = false;
    }
    if (event?.currentTarget === filterInputs.sample) {
      requireExactSample = false;
    }
    renderRows();
  };
  Object.values(filterInputs).forEach(input => {
    if (!input) return;
    const isSelect = input.tagName === 'SELECT';
    input.addEventListener(isSelect ? 'change' : 'input', handleFilterChange);
    if (isSelect) {
      input.addEventListener('input', handleFilterChange);
    }
  });
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  const reportExportBaseColumns = [
    {key:'id', label:'ID'},
    {key:'order_id', label:'Ordination-ID'},
    {key:'order_name', label:'Ordination', value: row => getOrderDisplayName(row.order_id)},
    {key:'order_indication', label:'Ordination – indikation', value: row => orderMap.get(Number(row.order_id))?.indication || ''},
    {key:'order_patient_group_id', label:'Ordination – patientgruppe-ID', value: row => orderMap.get(Number(row.order_id))?.patient_group_id ?? ''},
    {key:'order_patient_group', label:'Ordination – patientgruppe', value: row => getPatientGroupName(orderMap.get(Number(row.order_id))?.patient_group_id)},
    {key:'order_hpo_terms', label:'Ordination – HPO-termer', value: row => formatHpoList(orderMap.get(Number(row.order_id))?.hpo_terms)},
    {key:'status', label:'Status (kode)'},
    {key:'status_label', label:'Status', value: row => statusMap[row.status] || row.status || ''},
    {key:'summary', label:'Konklusion'},
    {key:'findings', label:'Fund'},
    {key:'variant_count', label:'Antal varianter', value: row => typeof row.__variantCount === 'number' ? row.__variantCount : (Array.isArray(row.__variantSnapshots) ? row.__variantSnapshots.length : 0)},
    {key:'variant_ids', label:'Variant-ID\'er', value: row => Array.isArray(row.__variantIds) && row.__variantIds.length ? row.__variantIds.join(', ') : ''},
    {key:'variant_details', label:'Variantdetaljer', value: row => Array.isArray(row.__variantSummaries) && row.__variantSummaries.length ? row.__variantSummaries.join(' | ') : ''},
    {key:'issued_at', label:'Udstedt (ISO)'},
    {key:'issued_at_formatted', label:'Udstedt', value: row => formatDanishDate(row.issued_at, true)},
    {key:'created_by', label:'Oprettet af'},
    {key:'created_at', label:'Oprettet (ISO)'},
    {key:'created_at_formatted', label:'Oprettet', value: row => formatDanishDate(row.created_at, true)},
    {key:'updated_at', label:'Opdateret (ISO)'},
    {key:'updated_at_formatted', label:'Opdateret', value: row => formatDanishDate(row.updated_at, true)}
  ];

  const buildReportVariantColumns = rows => {
    if (!Array.isArray(rows) || !rows.length) return [];
    const variantFieldDefinitions = [
      {key:'title', label:'Titel', getter: variant => formatVariantTitle(variant)},
      {key:'id', label:'ID'},
      {key:'variant_type', label:'Varianttype', getter: variant => getVariantTypeLabel(variant.variant_type) || variant.variant_type || ''},
      {key:'gene', label:'Gen'},
      {key:'transcript', label:'Transkript'},
      {key:'hgvs_c', label:'HGVS.c'},
      {key:'hgvs_p', label:'HGVS.p'},
      {key:'classification', label:'Klassifikation'},
      {key:'criteria', label:'ACMG'},
      {key:'zygosity', label:'Zygositet'},
      {key:'af', label:'Allelfrekvens'},
      {key:'genomic_position', label:'Genomisk position'},
      {key:'copy_number', label:'Kopital'},
      {key:'sv_subtype', label:'Strukturel type'},
      {key:'size_bp', label:'Størrelse (bp)'},
      {key:'iscn', label:'ISCN'},
      {key:'affected_genes', label:'Berørte gener'},
      {key:'interpretation', label:'Fortolkning'},
      {key:'description', label:'Beskrivelse'},
      {key:'summary', label:'Opsummering', getter: variant => describeVariantNarrative(variant)}
    ];
    const maxVariants = rows.reduce((max, row) => {
      const count = Array.isArray(row.__variantSnapshots) ? row.__variantSnapshots.length : 0;
      return count > max ? count : max;
    }, 0);
    if (!maxVariants) return [];
    const columns = [];
    for (let i = 0; i < maxVariants; i++) {
      const variantNumber = i + 1;
      for (const field of variantFieldDefinitions) {
        columns.push({
          key: `variant_${variantNumber}_${field.key}`,
          label: `Variant ${variantNumber} – ${field.label}`,
          value: row => {
            const variant = Array.isArray(row.__variantSnapshots) ? row.__variantSnapshots[i] : null;
            if (!variant) return '';
            const raw = typeof field.getter === 'function' ? field.getter(variant, row, i) : variant[field.key];
            if (raw == null) return '';
            if (Array.isArray(raw)) return raw.join(', ');
            if (typeof raw === 'number') return Number.isFinite(raw) ? String(raw) : '';
            if (typeof raw === 'boolean') return raw ? 'Ja' : 'Nej';
            if (typeof raw === 'object') return JSON.stringify(raw);
            return String(raw);
          }
        });
      }
    }
    return columns;
  };
  section.querySelector('#reportsExport').addEventListener('click', () => {
    const rows = cloneWithCreatedBy('reports', filteredReports).map(report => {
      const variantSnapshots = getReportVariantSnapshots(report, Number(report.order_id));
      let variantIds = variantSnapshots.map(v => v.id).filter(id => id != null && id !== '');
      if (!variantIds.length) {
        variantIds = parseReportVariantIds(report.variant_ids).map(id => id != null ? String(id) : '').filter(Boolean);
      } else {
        variantIds = variantIds.map(id => id != null ? String(id) : '').filter(Boolean);
      }
      let variantSummaries = variantSnapshots.map(v => describeVariantNarrative(v)).filter(Boolean);
      if (!variantSummaries.length) {
        const rawDetails = report.variant_details;
        if (Array.isArray(rawDetails)) {
          variantSummaries = rawDetails.map(item => describeVariantNarrative(snapshotVariant(item))).filter(Boolean);
        } else if (typeof rawDetails === 'string' && rawDetails.trim()) {
          try {
            const parsed = JSON.parse(rawDetails);
            if (Array.isArray(parsed)) {
              variantSummaries = parsed.map(item => describeVariantNarrative(snapshotVariant(item))).filter(Boolean);
            }
          } catch (err) {
            const cleaned = rawDetails.replace(/[\[\]{}"]+/g, ' ').replace(/\s+/g, ' ').trim();
            if (cleaned) variantSummaries = [cleaned];
          }
        }
      }
      return {
        ...report,
        __variantSnapshots: variantSnapshots,
        __variantIds: variantIds,
        __variantSummaries: variantSummaries,
        __variantCount: variantSnapshots.length
      };
    });
    const variantColumns = buildReportVariantColumns(rows);
    const columns = reportExportBaseColumns.concat(variantColumns);
    exportFilteredCsv('glimr-rapporter-filtreret.csv', rows, columns, {
      entity: 'rapporter',
      plural: 'rapporter'
    });
  });
  tbody.addEventListener('click', e => {
    const actionButton = e.target.closest('button[data-report-action]');
    if (actionButton) {
      if (actionButton.disabled) return;
      const {reportId, reportAction} = actionButton.dataset;
      if (reportAction === 'orders') {
        openOrdersForReport(reportId);
      } else if (reportAction === 'samples') {
        openSamplesForReport(reportId);
      }
      return;
    }
    const tr = e.target.closest('tr');
    if (!tr) return;
    const report = list.find(r => r.id === Number(tr.dataset.id));
    if (!report) return;
    selectedReportId = report.id;
    fillForm(form, report);
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
    refreshVariantOptions();
    const variants = getReportVariantSnapshots(report, Number(report.order_id));
    setSelectedReportVariants(variants);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('reports')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.order_id = Number(data.order_id);
    const orderId = data.order_id;
    const variantStore = getCached('variants');
    const variantSnapshots = selectedReportVariants.map(item => {
      const source = variantStore.find(v => v.id === item.id) || item;
      const snapshot = snapshotVariant(source);
      if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
      return snapshot;
    });
    data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
    data.variant_details = variantSnapshots;
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('reports', id)};
      const updated = {...before, ...data, id};
      await updateRecord('reports', updated, before);
    } else {
      delete data.id;
      await addRecord('reports', data);
    }
    await loadStore('reports');
    renderTab('reports');
  });
  section.querySelector('#reportDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg rapport');
    if (!ensureWrite('reports')) return;
    if (confirm('Slet rapport?')) {
      await deleteRecord('reports', id);
      renderTab('reports');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedReportId = null;
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
    renderRows();
  });
  section.querySelector('#reportClear').addEventListener('click', () => {
    form.reset();
    setSelectedReportVariants([]);
    refreshVariantOptions();
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
  });
  section.querySelector('#reportPreview').addEventListener('click', () => {
    const data = Object.fromEntries(new FormData(form).entries());
    if (!data.order_id) return alert('Vælg ordre');
    const orderId = Number(data.order_id);
    data.order_id = orderId;
    const variantStore = getCached('variants');
    const variantSnapshots = selectedReportVariants.map(item => {
      const source = variantStore.find(v => v.id === item.id) || item;
      const snapshot = snapshotVariant(source);
      if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
      return snapshot;
    });
    data.variant_details = variantSnapshots;
    data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
    const html = buildReportHtml(orderId, data);
    const win = window.open('', '_blank');
    if (win) {
      win.document.write('<!DOCTYPE html><html><head><title>Rapport</title><style>body{font-family:Segoe UI,Arial;margin:2rem;}table{width:100%;border-collapse:collapse;}th,td{border:1px solid #ccc;padding:0.4rem;}th{background:#f0f0f0;}</style></head><body>' + html + '</body></html>');
      win.document.close();
    }
  });
  const downloadPdfButton = section.querySelector('#reportDownloadPdf');
  if (downloadPdfButton) {
    downloadPdfButton.addEventListener('click', async () => {
      const data = Object.fromEntries(new FormData(form).entries());
      if (!data.order_id) {
        alert('Vælg ordre');
        return;
      }
      const orderId = Number(data.order_id);
      data.order_id = orderId;
      const variantStore = getCached('variants');
      const variantSnapshots = selectedReportVariants.map(item => {
        const source = variantStore.find(v => v.id === item.id) || item;
        const snapshot = snapshotVariant(source);
        if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
        return snapshot;
      });
      data.variant_details = variantSnapshots;
      data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
      const exportedAt = new Date();
      const blob = await createReportPdfBlob(orderId, data, exportedAt);
      if (!blob) {
        alert('Kunne ikke generere PDF for rapporten.');
        return;
      }
      const filename = buildReportPdfFilename(orderId, data, exportedAt);
      const url = URL.createObjectURL(blob);
      triggerDownload(url, filename);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      setStatus(`Rapport PDF hentet som ${filename}.`);
      registerManualExport('report_pdf', {
        filename,
        orderId,
        exportedAt: exportedAt.toISOString(),
        variantCount: Array.isArray(variantSnapshots) ? variantSnapshots.length : 0
      });
    });
  }
}
function buildReportHtml(orderId, reportData) {
  const order = findById('orders', orderId);
  const patient = order ? findById('patients', Number(order.patient_id)) : null;
  const sample = order ? findById('samples', Number(order.sample_id)) : null;
  let variants = getReportVariantSnapshots(reportData, orderId);
  if (!variants.length) {
    variants = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
  }
  const patientGroupName = order ? getPatientGroupName(order.patient_group_id) : '';
  const sampleIdentifierParts = [];
  if (sample?.pmb_number) sampleIdentifierParts.push(sample.pmb_number);
  if (sample?.id != null) sampleIdentifierParts.push(`ID ${sample.id}`);
  const sampleIdentifier = sampleIdentifierParts.join(' / ');
  const hasIndication = !!collapseSpaces(order?.indication);
  const indicationHtml = hasIndication ? formatMultilineCell(order.indication) : esc('Ikke angivet');
  const hpoHtml = formatHpoHtml(order?.hpo_terms);
  const rows = variants.map(v => {
    const title = formatVariantTitle(v);
    const typeLabel = getVariantTypeLabel(v.variant_type);
    return `<tr><td>${esc(title)}</td><td>${esc(typeLabel)}</td><td>${esc(v.classification||'')}</td><td>${esc(v.criteria||'')}</td><td>${esc(v.af??'')}</td><td>${esc(v.zygosity||'')}</td><td>${esc(v.interpretation||'')}</td></tr>`;
  }).join('') || '<tr><td colspan="7">Ingen fund</td></tr>';
  const detailSections = variants.length ? variants.map(variant => {
    const heading = formatVariantTitle(variant) || `Variant ${variant.id ?? ''}`.trim();
    const meta = [];
    const typeLabel = getVariantTypeLabel(variant.variant_type);
    if (typeLabel) meta.push(`<li><strong>Type:</strong> ${esc(typeLabel)}</li>`);
    if (variant.transcript) meta.push(`<li><strong>Transkript:</strong> ${esc(variant.transcript)}</li>`);
    if (variant.zygosity) meta.push(`<li><strong>Zygositet:</strong> ${esc(variant.zygosity)}</li>`);
    if (variant.classification) meta.push(`<li><strong>Klasse:</strong> ${esc(variant.classification)}</li>`);
    if (variant.criteria) meta.push(`<li><strong>ACMG:</strong> ${esc(variant.criteria)}</li>`);
    if (variant.af !== undefined && variant.af !== null && variant.af !== '') meta.push(`<li><strong>AF:</strong> ${esc(variant.af)}</li>`);
    const genomic = formatVariantGenomicRange(variant);
    if (genomic) meta.push(`<li><strong>Genomisk position:</strong> ${esc(genomic)}</li>`);
    if (variant.copy_number) meta.push(`<li><strong>Kopital:</strong> ${esc(variant.copy_number)}</li>`);
    if (variant.iscn) meta.push(`<li><strong>ISCN:</strong> ${esc(variant.iscn)}</li>`);
    if (variant.affected_genes) meta.push(`<li><strong>Berørte gener:</strong> ${esc(variant.affected_genes)}</li>`);
    if (variant.description) meta.push(`<li><strong>Beskrivelse:</strong> ${esc(variant.description)}</li>`);
    const interpretation = variant.interpretation ? `<p>${esc(variant.interpretation)}</p>` : '';
    const metaList = meta.length ? `<ul>${meta.join('')}</ul>` : '';
    return `<div class="report-variant-detail"><h3>${esc(heading)}</h3>${metaList}${interpretation}</div>`;
  }).join('') : '<p>Ingen variantdetaljer registreret.</p>';
  const patientIdentifiersDisplay = (() => {
    const parts = [patient?.mrn, patient?.extra_id, patient?.family_number].filter(Boolean).map(esc);
    return parts.length ? ` (${parts.join(' • ')})` : '';
  })();
  return `
  <h1>Diagnostisk rapport</h1>
  <p><strong>Ordination:</strong> ${orderId}</p>
  <p><strong>Indikation:</strong><br>${indicationHtml}</p>
  ${patientGroupName ? `<p><strong>Patientgruppe:</strong> ${esc(patientGroupName)}</p>` : ''}
  ${hpoHtml ? `<p><strong>HPO-termer:</strong><br>${hpoHtml}</p>` : ''}
  <p><strong>Patient:</strong> ${esc(patient?.name||'')}${patientIdentifiersDisplay}</p>
  <p><strong>Prøve:</strong> ${esc(sample?.sample_type||'')}${sampleIdentifier ? ` (${esc(sampleIdentifier)})` : ''}</p>
  <p><strong>Status:</strong> ${esc(reportData.status||'')}</p>
  <p><strong>Udstedt:</strong> ${esc(formatDanishDate(reportData.issued_at))}</p>
  <h2>Konklusion</h2>
  <p>${esc(reportData.summary||'')}</p>
  <h2>Fund</h2>
  <table><thead><tr><th>Variant</th><th>Type</th><th>Klasse</th><th>ACMG</th><th>AF</th><th>Zygositet</th><th>Tolkning</th></tr></thead><tbody>${rows}</tbody></table>
  <h2>Detaljer</h2>
  ${detailSections}`;
}
function escapePdfText(text) {
  return String(text || '').replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)').replace(/\r/g, '').replace(/\n/g, '\\n');
}
function stringToPdfBytes(str) {
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    bytes[i] = code <= 0xFF ? code : 0x3F;
  }
  return bytes;
}
const PDF_PAGE_WIDTH = 595;
const PDF_PAGE_HEIGHT = 842;
const PDF_MARGIN = 48;
const PDF_GUTTER = 28;
const PDF_BODY_FONT_SIZE = 11;
const PDF_HEADING_FONT_SIZE = 13;
const PDF_TITLE_FONT_SIZE = 20;
const PDF_BODY_LEADING = 16;
const PDF_HEADING_LEADING = 20;
const PDF_HEADING_GAP = 6;
const PDF_SECTION_SPACING = 16;
const PDF_ROW_SPACING = 6;
const PDF_SIGNATURE_BLOCK_HEIGHT = 110;
const PDF_TITLE_LEADING = 28;
const PDF_SECTION_CARD_PADDING_X = 14;
const PDF_SECTION_CARD_PADDING_TOP = 14;
const PDF_SECTION_CARD_PADDING_BOTTOM = 16;
const PDF_SECTION_CARD_INSET = 6;
const PDF_HEADER_BAND_HEIGHT = 132;
const PDF_HEADER_TITLE_BASELINE_OFFSET = 26;
const PDF_TEXT_COLOR = '#1b2c45';
const PDF_MUTED_TEXT_COLOR = '#4a6080';
const PDF_HEADING_TEXT_COLOR = '#124c87';
const PDF_ACCENT_COLOR = '#124c87';
const PDF_HEADER_BAND_COLOR = '#e5effb';
const PDF_CARD_BACKGROUND_COLOR = '#f9fbff';
const PDF_CARD_BORDER_COLOR = '#c5d7ed';
const PDF_CARD_HEADING_COLOR = '#cfe0f6';
const PDF_SIGNATURE_BAND_COLOR = '#ecf2fb';
const PDF_SIGNATURE_LINE_COLOR = '#8ea8c7';
const PDF_HEADING_TEXT_OFFSET = 2;
const PDF_HEADING_BAR_OFFSET = 3;
const PT_TO_PX = 96 / 72;

function pdfColorToRgb(color) {
  if (!color) return null;
  if (Array.isArray(color) && color.length >= 3) {
    return color.slice(0, 3).map(component => Math.max(0, Math.min(1, Number(component) || 0))).join(' ');
  }
  if (typeof color === 'string') {
    let hex = color.trim();
    if (hex.startsWith('#')) hex = hex.slice(1);
    if (hex.length === 3) {
      hex = hex.split('').map(ch => ch + ch).join('');
    }
    if (hex.length === 6) {
      const r = parseInt(hex.slice(0, 2), 16) / 255;
      const g = parseInt(hex.slice(2, 4), 16) / 255;
      const b = parseInt(hex.slice(4, 6), 16) / 255;
      return [r, g, b].map(v => v.toFixed(4).replace(/0+$/, '').replace(/\.$/, '')).join(' ');
    }
  }
  return null;
}

let pdfMeasureCtx = null;

function getPdfMeasureContext(fontSize) {
  if (!pdfMeasureCtx) {
    const canvas = document.createElement('canvas');
    pdfMeasureCtx = canvas.getContext('2d');
  }
  if (pdfMeasureCtx) {
    pdfMeasureCtx.font = `${(fontSize * PT_TO_PX).toFixed(2)}px "Arial", "Helvetica", sans-serif`;
  }
  return pdfMeasureCtx;
}

function wrapPdfText(text, maxWidth, fontSize) {
  const ctx = getPdfMeasureContext(fontSize);
  if (!ctx) return [String(text ?? '')];
  const maxWidthPx = maxWidth * PT_TO_PX;
  const paragraphs = String(text ?? '').replace(/\r/g, '').split('\n');
  const lines = [];
  for (let p = 0; p < paragraphs.length; p++) {
    const paragraph = paragraphs[p];
    const words = paragraph.trim() ? paragraph.split(/\s+/) : [];
    if (!words.length) {
      if (p < paragraphs.length - 1) lines.push('');
      continue;
    }
    let current = '';
    const flush = () => {
      if (current) {
        lines.push(current);
        current = '';
      }
    };
    for (const word of words) {
      const candidate = current ? `${current} ${word}` : word;
      if (ctx.measureText(candidate).width <= maxWidthPx) {
        current = candidate;
        continue;
      }
      flush();
      if (ctx.measureText(word).width <= maxWidthPx) {
        current = word;
        continue;
      }
      let segment = '';
      for (const char of word) {
        const attempt = segment + char;
        if (ctx.measureText(attempt).width > maxWidthPx && segment) {
          lines.push(segment);
          segment = char;
        } else {
          segment = attempt;
        }
      }
      current = segment;
    }
    flush();
    if (p < paragraphs.length - 1) lines.push('');
  }
  if (!lines.length) lines.push('');
  return lines;
}

function indentWrappedLines(lines, indentText) {
  if (!indentText) return lines;
  return lines.map((line, index) => (index === 0 ? `${indentText}${line}` : `${indentText}${line}`));
}

function formatDanishDate(value, includeTimeHint) {
  if (!value) return '';
  const formatFromDate = (date, includeTime) => {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const base = `${day}.${month}.${year}`;
    const shouldIncludeTime = includeTime ?? (date.getHours() !== 0 || date.getMinutes() !== 0 || date.getSeconds() !== 0 || date.getMilliseconds() !== 0);
    if (!shouldIncludeTime) return base;
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${base}, ${hours}.${minutes}.${seconds}`;
  };
  if (value instanceof Date) {
    return formatFromDate(value, includeTimeHint);
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return '';
    const isoDateMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (isoDateMatch) {
      const [, year, month, day] = isoDateMatch;
      return `${day}.${month}.${year}`;
    }
    const isoDateTimeMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2})(?::(\d{2}))?/);
    if (isoDateTimeMatch) {
      const parsed = new Date(trimmed);
      if (!Number.isNaN(parsed.getTime())) {
        return formatFromDate(parsed, true);
      }
    }
    const parsed = new Date(trimmed);
    if (!Number.isNaN(parsed.getTime())) {
      const includeTime = trimmed.includes('T') || /\d{2}:\d{2}/.test(trimmed);
      return formatFromDate(parsed, includeTime);
    }
    return trimmed;
  }
  if (typeof value === 'number') {
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) {
      return formatFromDate(parsed, true);
    }
  }
  return '';
}

const numberFormatterCache = new Map();
function formatNumberDa(value, decimals = 0) {
  if (value === null || value === undefined) return '—';
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) return '—';
  const key = `${decimals}`;
  let formatter = numberFormatterCache.get(key);
  if (!formatter) {
    formatter = new Intl.NumberFormat('da-DK', {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals
    });
    numberFormatterCache.set(key, formatter);
  }
  return formatter.format(numeric);
}

function parseDateTimeValue(value) {
  if (!value && value !== 0) return null;
  if (value instanceof Date) {
    return Number.isNaN(value.getTime()) ? null : value;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = new Date(trimmed);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  if (typeof value === 'number') {
    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  return null;
}

function formatDaysSince(value, referenceValue = new Date()) {
  const baseDate = parseDateTimeValue(value);
  const referenceDate = parseDateTimeValue(referenceValue) || new Date();
  if (!baseDate || !referenceDate) return '';
  const diffMs = referenceDate.getTime() - baseDate.getTime();
  if (!Number.isFinite(diffMs) || diffMs < 0) return '';
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  if (diffDays === 0) return '0 dage siden';
  if (diffDays === 1) return '1 dag siden';
  return `${diffDays} dage siden`;
}

function calculatePercentile(values, percentile) {
  if (!Array.isArray(values) || !values.length) return null;
  const sorted = values.slice().sort((a, b) => a - b);
  const index = (sorted.length - 1) * percentile;
  const lower = Math.floor(index);
  const upper = Math.ceil(index);
  if (lower === upper) return sorted[lower];
  const weight = index - lower;
  return sorted[lower] * (1 - weight) + sorted[upper] * weight;
}

function formatDurationDays(days) {
  if (days === null || days === undefined || Number.isNaN(days) || days < 0) {
    return 'Ingen data';
  }
  if (days < 1) {
    const hours = Math.round(days * 24);
    if (hours <= 0) return '<1 time';
    return `${hours} ${hours === 1 ? 'time' : 'timer'}`;
  }
  if (days < 7) {
    const decimals = days < 3 ? 1 : 0;
    return `${formatNumberDa(days, decimals)} dage`;
  }
  const weeks = days / 7;
  if (weeks < 12) {
    const decimals = weeks < 3 ? 1 : 0;
    return `${formatNumberDa(weeks, decimals)} uger`;
  }
  return `${formatNumberDa(days, 0)} dage`;
}

function normalizeDateOnly(value) {
  if (!value && value !== 0) return null;
  if (value instanceof Date) {
    if (Number.isNaN(value.getTime())) return null;
    return new Date(value.getFullYear(), value.getMonth(), value.getDate());
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const dateOnlyMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (dateOnlyMatch) {
      const [, year, month, day] = dateOnlyMatch;
      const y = Number(year);
      const m = Number(month);
      const d = Number(day);
      if (Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(d)) {
        const parsed = new Date(y, m - 1, d);
        if (!Number.isNaN(parsed.getTime())) return parsed;
      }
      return null;
    }
    const parsed = new Date(trimmed);
    if (!Number.isNaN(parsed.getTime())) {
      return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
    }
    return null;
  }
  if (typeof value === 'number') {
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) {
      return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
    }
  }
  return null;
}

function formatAgeFromBirthDate(birthValue, referenceValue = new Date()) {
  const birthDate = normalizeDateOnly(birthValue);
  const referenceDate = normalizeDateOnly(referenceValue) || normalizeDateOnly(new Date());
  if (!birthDate || !referenceDate) return '';
  if (referenceDate < birthDate) return '';
  let years = referenceDate.getFullYear() - birthDate.getFullYear();
  const hasHadBirthday =
    referenceDate.getMonth() > birthDate.getMonth() ||
    (referenceDate.getMonth() === birthDate.getMonth() && referenceDate.getDate() >= birthDate.getDate());
  if (!hasHadBirthday) years -= 1;
  if (years > 1) return `${years} år`;
  if (years === 1) return '1 år';
  const totalMonths = (referenceDate.getFullYear() - birthDate.getFullYear()) * 12 + referenceDate.getMonth() - birthDate.getMonth();
  const adjustedMonths = hasHadBirthday ? totalMonths : totalMonths - 1;
  if (adjustedMonths > 1) return `${adjustedMonths} mdr`;
  if (adjustedMonths === 1) return '1 mdr';
  const diffMs = referenceDate.getTime() - birthDate.getTime();
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  if (diffDays > 1) return `${diffDays} dage`;
  if (diffDays === 1) return '1 dag';
  return '0 dage';
}

function translateGender(value) {
  if (value === null || value === undefined) return '';
  const text = String(value).trim();
  if (!text) return '';
  const normalized = text.toLowerCase();
  if (['male', 'mand', 'm'].includes(normalized)) return 'Mand';
  if (['female', 'kvinde', 'f'].includes(normalized)) return 'Kvinde';
  if (['other', 'andet'].includes(normalized)) return 'Andet';
  if (['unknown', 'ukendt'].includes(normalized)) return 'Uoplyst';
  return text;
}

class SimplePdfBuilder {
  constructor() {
    this.width = PDF_PAGE_WIDTH;
    this.height = PDF_PAGE_HEIGHT;
    this.margin = PDF_MARGIN;
    this.pages = [];
    this.images = [];
    this.currentPage = null;
  }
  startPage() {
    const page = {ops: [], imageNames: new Set()};
    this.pages.push(page);
    this.currentPage = page;
    return page;
  }
  ensurePage() {
    if (!this.currentPage) this.startPage();
  }
  addText(text, x, y, fontSize = PDF_BODY_FONT_SIZE, color = null) {
    this.ensurePage();
    const fill = pdfColorToRgb(color || PDF_TEXT_COLOR);
    const colorPart = fill ? `${fill} rg\n` : '';
    this.currentPage.ops.push(`BT\n${colorPart}/F1 ${fontSize.toFixed(2)} Tf\n1 0 0 1 ${x.toFixed(2)} ${y.toFixed(2)} Tm (${escapePdfText(text)}) Tj\nET`);
  }
  addLine(x1, y1, x2, y2, width = 1, color = null) {
    this.ensurePage();
    const stroke = pdfColorToRgb(color || PDF_ACCENT_COLOR);
    const colorPart = stroke ? `${stroke} RG ` : '';
    this.currentPage.ops.push(`q ${colorPart}${width.toFixed(2)} w ${x1.toFixed(2)} ${y1.toFixed(2)} m ${x2.toFixed(2)} ${y2.toFixed(2)} l S Q`);
  }
  fillRect(x, y, width, height, color = null) {
    this.ensurePage();
    const fill = pdfColorToRgb(color);
    const colorPart = fill ? `${fill} rg ` : '';
    this.currentPage.ops.push(`q ${colorPart}${x.toFixed(2)} ${y.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)} re f Q`);
  }
  strokeRect(x, y, width, height, lineWidth = 1, color = null) {
    this.ensurePage();
    const stroke = pdfColorToRgb(color || PDF_CARD_BORDER_COLOR);
    const colorPart = stroke ? `${stroke} RG ` : '';
    this.currentPage.ops.push(`q ${colorPart}${lineWidth.toFixed(2)} w ${x.toFixed(2)} ${y.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)} re S Q`);
  }
  registerImage(image) {
    const name = `Im${this.images.length + 1}`;
    this.images.push({...image, name});
    return name;
  }
  drawImage(name, x, y, width, height) {
    this.ensurePage();
    this.currentPage.imageNames.add(name);
    this.currentPage.ops.push(`q ${width.toFixed(2)} 0 0 ${height.toFixed(2)} ${x.toFixed(2)} ${y.toFixed(2)} cm /${name} Do Q`);
  }
  build() {
    if (!this.pages.length) this.startPage();
    const pageCount = this.pages.length;
    let pdf = '%PDF-1.4\n';
    const offsets = [0];
    const addObject = str => {
      offsets.push(pdf.length);
      pdf += str;
    };
    const kids = this.pages.map((_, idx) => `${3 + idx} 0 R`).join(' ');
    addObject('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
    addObject(`2 0 obj\n<< /Type /Pages /Count ${pageCount} /Kids [${kids}] >>\nendobj\n`);
    const fontObjNumber = 3 + pageCount * 2;
    const imageStart = fontObjNumber + 1;
    this.images.forEach((image, index) => {
      image.objectNumber = imageStart + index;
    });
    const contentObjects = [];
    this.pages.forEach((page, idx) => {
      const pageObjNumber = 3 + idx;
      const contentObjNumber = 3 + pageCount + idx;
      const resourceParts = [`/Font << /F1 ${fontObjNumber} 0 R >>`];
      if (page.imageNames.size) {
        const entries = [];
        page.imageNames.forEach(name => {
          const image = this.images.find(img => img.name === name);
          if (image) entries.push(`/${name} ${image.objectNumber} 0 R`);
        });
        if (entries.length) resourceParts.push(`/XObject << ${entries.join(' ')} >>`);
      }
      addObject(`${pageObjNumber} 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${this.width} ${this.height}] /Contents ${contentObjNumber} 0 R /Resources << ${resourceParts.join(' ')} >> >>\nendobj\n`);
      const content = page.ops.join('\n');
      contentObjects.push({number: contentObjNumber, content});
    });
    contentObjects.forEach(obj => {
      addObject(`${obj.number} 0 obj\n<< /Length ${obj.content.length} >>\nstream\n${obj.content}\nendstream\nendobj\n`);
    });
    addObject(`${fontObjNumber} 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica /Encoding /WinAnsiEncoding >>\nendobj\n`);
    this.images.forEach(image => {
      const filter = image.filter || '/DCTDecode';
      const colorSpace = image.colorSpace || '/DeviceRGB';
      addObject(`${image.objectNumber} 0 obj\n<< /Type /XObject /Subtype /Image /Width ${image.width} /Height ${image.height} /ColorSpace ${colorSpace} /BitsPerComponent ${image.bitsPerComponent || 8} /Filter ${filter} /Length ${image.dataString.length} >>\nstream\n${image.dataString}\nendstream\nendobj\n`);
    });
    const totalObjects = fontObjNumber + this.images.length;
    const xrefOffset = pdf.length;
    pdf += `xref\n0 ${totalObjects + 1}\n0000000000 65535 f \n`;
    for (let i = 1; i <= totalObjects; i++) {
      const offset = offsets[i] || 0;
      pdf += `${String(offset).padStart(10, '0')} 00000 n \n`;
    }
    pdf += `trailer\n<< /Size ${totalObjects + 1} /Root 1 0 R >>\nstartxref\n${xrefOffset}\n%%EOF`;
    return stringToPdfBytes(pdf);
  }
}

function bytesToBinaryString(bytes) {
  let result = '';
  for (let i = 0; i < bytes.length; i++) {
    result += String.fromCharCode(bytes[i]);
  }
  return result;
}

function base64ToUint8Array(base64) {
  const binary = atob(base64);
  const length = binary.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}

async function loadReportLogoImage() {
  if (loadReportLogoImage.cache !== undefined) {
    return loadReportLogoImage.cache;
  }
  try {
    const img = await new Promise((resolve, reject) => {
      const element = new Image();
      element.onload = () => resolve(element);
      element.onerror = reject;
      element.src = `logo.png?ts=${Date.now()}`;
    });
    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
    const base64 = dataUrl.split(',')[1];
    const bytes = base64ToUint8Array(base64);
    loadReportLogoImage.cache = {
      width: img.naturalWidth,
      height: img.naturalHeight,
      data: bytes,
      dataString: bytesToBinaryString(bytes),
      bitsPerComponent: 8,
      filter: '/DCTDecode',
      colorSpace: '/DeviceRGB'
    };
  } catch (err) {
    console.warn('Kunne ikke indlæse logo til PDF', err);
    loadReportLogoImage.cache = null;
  }
  return loadReportLogoImage.cache;
}

function drawReportHeader(builder, logo, exportedAt) {
  const margin = builder.margin;
  const pageHeight = builder.height;
  const headerBottom = pageHeight - margin - PDF_HEADER_BAND_HEIGHT;
  const titleBaseline = headerBottom + PDF_HEADER_TITLE_BASELINE_OFFSET;
  builder.fillRect(0, headerBottom, builder.width, PDF_HEADER_BAND_HEIGHT, PDF_HEADER_BAND_COLOR);
  let imageWidth = 0;
  let imageHeight = 0;
  if (logo) {
    if (!logo.objectName) {
      logo.objectName = builder.registerImage({
        width: logo.width,
        height: logo.height,
        dataString: logo.dataString,
        bitsPerComponent: logo.bitsPerComponent,
        filter: logo.filter,
        colorSpace: logo.colorSpace
      });
    }
    const maxHeaderImageHeight = PDF_HEADER_BAND_HEIGHT - 48;
    const targetHeight = Math.max(48, Math.min(68, maxHeaderImageHeight));
    const aspect = logo.width && logo.height ? logo.width / logo.height : 1;
    imageHeight = Math.min(targetHeight, Math.max(0, maxHeaderImageHeight));
    imageWidth = imageHeight * aspect;
    const imageY = headerBottom + PDF_HEADER_BAND_HEIGHT - imageHeight - 12;
    builder.drawImage(logo.objectName, margin, imageY, imageWidth, imageHeight);
  }
  const titleX = imageWidth ? margin + imageWidth + 28 : margin + PDF_SECTION_CARD_PADDING_X;
  builder.addText('Diagnostisk Rapport', titleX, titleBaseline, PDF_TITLE_FONT_SIZE, PDF_ACCENT_COLOR);
  const dateFormatter = drawReportHeader.dateFormatter || new Intl.DateTimeFormat('da-DK');
  drawReportHeader.dateFormatter = dateFormatter;
  const dateLabel = dateFormatter.format(exportedAt || new Date());
  const dateWidth = measurePdfTextWidth(dateLabel, 12);
  const dateX = builder.width - margin - dateWidth;
  builder.addText(dateLabel, dateX, titleBaseline, 12, PDF_MUTED_TEXT_COLOR);
  builder.addLine(margin, headerBottom + 8, builder.width - margin, headerBottom + 8, 1.1, PDF_ACCENT_COLOR);
  const contentStart = Math.min(titleBaseline - PDF_TITLE_LEADING, headerBottom - 12, pageHeight - margin - imageHeight - 42);
  return {contentTop: contentStart};
}

function measurePdfTextWidth(text, fontSize) {
  const ctx = getPdfMeasureContext(fontSize);
  if (!ctx) return String(text || '').length * fontSize * 0.5;
  return ctx.measureText(String(text || '')).width * (72 / 96);
}

function pdfValueIsBlank(value) {
  if (value === null || value === undefined) return true;
  if (typeof value === 'number') return false;
  if (typeof value === 'boolean') return false;
  if (value instanceof Date) return Number.isNaN(value.getTime());
  if (Array.isArray(value)) return value.length === 0;
  const text = collapseSpaces(value);
  return text === '';
}

function shouldRenderPdfRow(row) {
  if (!row || row.renderWhenEmpty) return true;
  switch (row.type) {
    case 'kv':
      return !pdfValueIsBlank(row.value);
    case 'paragraph':
      return !pdfValueIsBlank(row.value);
    case 'text':
      return collapseSpaces(row.text) !== '';
    case 'list':
      return Array.isArray(row.items) && row.items.some(item => collapseSpaces(item) !== '');
    default:
      return true;
  }
}

function buildSectionLayout(heading, rows, width) {
  const contentWidth = Math.max(10, width - PDF_SECTION_CARD_PADDING_X * 2);
  const layout = {
    heading,
    width,
    contentWidth,
    blocks: [],
    height: PDF_SECTION_CARD_PADDING_TOP + PDF_HEADING_TEXT_OFFSET + PDF_HEADING_LEADING + PDF_HEADING_GAP + PDF_SECTION_CARD_PADDING_BOTTOM + PDF_SECTION_SPACING
  };
  const sourceRows = Array.isArray(rows) ? rows : [];
  const renderRows = sourceRows.filter(shouldRenderPdfRow);
  renderRows.forEach((row, index) => {
    switch (row.type) {
      case 'kv': {
        const value = !pdfValueIsBlank(row.value) ? String(row.value) : row.fallback || '';
        if (!value) break;
        const text = `${row.label}: ${value}`;
        const lines = wrapPdfText(text, contentWidth, PDF_BODY_FONT_SIZE);
        layout.blocks.push({lines});
        layout.height += lines.length * PDF_BODY_LEADING;
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'paragraph': {
        const label = row.label ? `${row.label}:` : '';
        if (label) {
          const labelLines = wrapPdfText(label, contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines: labelLines});
          layout.height += labelLines.length * PDF_BODY_LEADING;
        }
        const hasBody = !pdfValueIsBlank(row.value);
        const bodyText = hasBody ? String(row.value) : (row.emptyText || '');
        if (!bodyText) break;
        const bodyLines = wrapPdfText(bodyText, contentWidth, PDF_BODY_FONT_SIZE);
        const indented = row.indent ? indentWrappedLines(bodyLines, row.indent) : bodyLines;
        layout.blocks.push({lines: indented});
        layout.height += indented.length * PDF_BODY_LEADING;
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'text': {
        const lines = wrapPdfText(row.text || '', contentWidth, PDF_BODY_FONT_SIZE);
        layout.blocks.push({lines});
        layout.height += lines.length * PDF_BODY_LEADING;
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'list': {
        const items = Array.isArray(row.items) ? row.items : [];
        if (!items.length) {
          const emptyLines = wrapPdfText(row.emptyText || 'Ingen poster.', contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines: emptyLines});
          layout.height += emptyLines.length * PDF_BODY_LEADING;
          if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
          break;
        }
        items.forEach((item, idx) => {
          const lines = wrapPdfText(item, contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines});
          layout.height += lines.length * PDF_BODY_LEADING;
          if (idx < items.length - 1) layout.height += PDF_ROW_SPACING / 2;
        });
        if (index < renderRows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      default:
        break;
    }
  });
  return layout;
}

function renderSection(builder, column, section) {
  const startCursor = column.cursor;
  const bodyHeight = section.height - PDF_SECTION_SPACING;
  const cardBottom = startCursor - bodyHeight;
  const cardX = column.x - PDF_SECTION_CARD_INSET;
  const cardWidth = column.width + PDF_SECTION_CARD_INSET * 2;
  builder.fillRect(cardX, cardBottom, cardWidth, bodyHeight, PDF_CARD_BACKGROUND_COLOR);
  builder.strokeRect(cardX, cardBottom, cardWidth, bodyHeight, 0.8, PDF_CARD_BORDER_COLOR);
  const headingBaseline = startCursor - PDF_SECTION_CARD_PADDING_TOP;
  const baseHeadingBarBottom = Math.max(cardBottom, headingBaseline - (PDF_HEADING_FONT_SIZE + 2));
  const baseHeadingBarTop = Math.min(startCursor - 2, headingBaseline + PDF_SECTION_CARD_PADDING_TOP - 2);
  const headingBarBottom = baseHeadingBarBottom + PDF_HEADING_BAR_OFFSET;
  const headingBarTop = baseHeadingBarTop + PDF_HEADING_BAR_OFFSET;
  const headingFillHeight = headingBarTop - headingBarBottom;
  if (headingFillHeight > 0.1) {
    builder.fillRect(cardX, headingBarBottom, cardWidth, headingFillHeight, PDF_CARD_HEADING_COLOR);
  }
  let cursor = headingBaseline - PDF_HEADING_TEXT_OFFSET;
  const textX = column.x + PDF_SECTION_CARD_PADDING_X;
  builder.addText(section.heading, textX, cursor, PDF_HEADING_FONT_SIZE, PDF_HEADING_TEXT_COLOR);
  cursor -= (PDF_HEADING_LEADING + PDF_HEADING_GAP);
  section.blocks.forEach((block, idx) => {
    const lines = block.lines || [];
    lines.forEach(line => {
      builder.addText(line, textX, cursor, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
      cursor -= PDF_BODY_LEADING;
    });
    if (idx < section.blocks.length - 1) cursor -= PDF_ROW_SPACING;
  });
  cursor -= PDF_SECTION_CARD_PADDING_BOTTOM;
  cursor -= PDF_SECTION_SPACING;
  column.cursor = cursor;
}

function ensureSingleColumnSpace(builder, column, neededHeight, reserveBottom) {
  const bottomLimit = builder.margin + (reserveBottom || 0);
  if (column.cursor - neededHeight < bottomLimit) {
    const {logo, exportedAt} = ensureSingleColumnSpace;
    const header = startNewReportPage(builder, logo, exportedAt);
    column.cursor = header.contentTop;
  }
}

function startNewReportPage(builder, logo, exportedAt) {
  builder.startPage();
  return drawReportHeader(builder, logo, exportedAt);
}

function parsePanelGeneListForPdf(value) {
  if (value == null) return [];
  return String(value)
    .split(/[\n;,]/)
    .map(token => token.trim())
    .filter(Boolean);
}

function determineGeneListFontSize(count) {
  if (!count || count <= 0) return 8;
  if (count <= 150) return 8;
  if (count <= 300) return 7;
  return 6;
}

function computePdfLeading(fontSize) {
  const scaled = Math.round(fontSize * 1.35);
  return Math.max(fontSize + 2, scaled);
}

function renderPanelGeneAppendix(builder, logo, exportedAt, panel) {
  if (!panel) return;
  const genes = parsePanelGeneListForPdf(panel.gene_list);
  const geneCount = genes.length;
  const panelName = (panel.name || 'Genpanel').toString();
  const versionDisplay = panel.version != null && panel.version !== '' ? `(v${panel.version})` : '';
  const panelLabel = versionDisplay ? `${panelName} ${versionDisplay}` : panelName;
  const geneFontSize = determineGeneListFontSize(geneCount);
  const panelNameFontSize = Math.max(8, Math.min(12, geneFontSize + 2));
  const metaFontSize = Math.max(8, Math.min(10, geneFontSize + 1));
  const geneLeading = computePdfLeading(geneFontSize);
  const panelNameLeading = computePdfLeading(panelNameFontSize);
  const metaLeading = computePdfLeading(metaFontSize);
  const contentWidth = builder.width - builder.margin * 2;
  const geneListContent = genes.length ? genes.join(', ') : collapseSpaces(panel.gene_list) || '';
  const listLinesSource = geneListContent ? wrapPdfText(geneListContent, contentWidth, geneFontSize) : ['Ingen gener angivet.'];
  const listLines = listLinesSource.length ? listLinesSource : ['Ingen gener angivet.'];
  const countLabel = `Antal gener: ${geneCount}`;
  const textX = builder.margin;
  let cursor = 0;
  let continuation = false;
  const renderAppendixHeader = () => {
    const headingLabel = continuation ? 'Bilag: Genpanel (fortsat)' : 'Bilag: Genpanel';
    const header = startNewReportPage(builder, logo, exportedAt);
    cursor = header.contentTop;
    builder.addText(headingLabel, textX, cursor, PDF_HEADING_FONT_SIZE, PDF_HEADING_TEXT_COLOR);
    cursor -= PDF_HEADING_LEADING;
    builder.addText(panelLabel, textX, cursor, panelNameFontSize, PDF_TEXT_COLOR);
    cursor -= panelNameLeading;
    builder.addText(countLabel, textX, cursor, metaFontSize, PDF_MUTED_TEXT_COLOR);
    cursor -= metaLeading;
    cursor -= PDF_HEADING_GAP;
    continuation = true;
  };
  renderAppendixHeader();
  listLines.forEach(line => {
    if (cursor - geneLeading < builder.margin) {
      renderAppendixHeader();
    }
    builder.addText(line, textX, cursor, geneFontSize, PDF_TEXT_COLOR);
    cursor -= geneLeading;
  });
}

async function createReportPdfBlob(orderId, reportData, exportedAt = new Date()) {
  try {
    const order = findById('orders', orderId);
    if (!order) return null;
    const patient = findById('patients', Number(order.patient_id));
    const sample = findById('samples', Number(order.sample_id));
    const panel = order?.panel_id ? findById('panels', Number(order.panel_id)) : null;
    const interpreterName = order?.interpreter_id ? getName('users', order.interpreter_id) : '';
    const approverName = order?.approver_id ? getName('users', order.approver_id) : '';
    const analysisResponsible = order?.analysis_responsible_id ? getName('users', order.analysis_responsible_id) : '';
    const clinician = order?.clinician || '';
    const patientGroupName = getPatientGroupName(order?.patient_group_id);
    const qcEntries = sample ? getCached('qc').filter(q => Number(q.sample_id) === Number(sample.id)) : [];
    let variants = getReportVariantSnapshots(reportData, orderId);
    if (!variants.length) {
      variants = getCached('variants').filter(v => Number(v.order_id) === Number(order.id)).map(snapshotVariant);
    }
    const builder = new SimplePdfBuilder();
    const logo = await loadReportLogoImage();
    const initialHeader = startNewReportPage(builder, logo, exportedAt);
    ensureSingleColumnSpace.logo = logo;
    ensureSingleColumnSpace.exportedAt = exportedAt;
    const columnWidth = (builder.width - builder.margin * 2 - PDF_GUTTER) / 2;
    const leftColumn = {x: builder.margin, width: columnWidth, cursor: initialHeader.contentTop};
    const rightColumn = {x: builder.margin + columnWidth + PDF_GUTTER, width: columnWidth, cursor: initialHeader.contentTop};
    const patientBirthDate = formatDanishDate(patient?.birth_date) || (patient?.birth_date || '');
    const patientRows = [
      {type: 'kv', label: 'Navn', value: patient?.name},
      {type: 'kv', label: 'MRN', value: patient?.mrn},
      {type: 'kv', label: 'ID', value: patient?.extra_id},
      {type: 'kv', label: 'Familienummer', value: patient?.family_number},
      {type: 'kv', label: 'Køn', value: translateGender(patient?.gender)},
      {type: 'kv', label: 'Fødselsdato', value: patientBirthDate}
    ];
    const sampleRows = [
      {type: 'kv', label: 'PMB-nummer', value: sample?.pmb_number},
      {type: 'kv', label: 'Prøvetype', value: sample?.sample_type},
      {type: 'kv', label: 'Status', value: sample?.status},
      {type: 'kv', label: 'Opsamlet', value: sample?.collected_at},
      {type: 'paragraph', label: 'Noter', value: sample?.notes, emptyText: 'Ingen noter.', indent: '  '}
    ];
    const orderIndicationText = collapseSpaces(order?.indication) ? order.indication : '';
    const analysisRows = [
      {type: 'kv', label: 'Panel', value: panel?.name},
      {type: 'kv', label: 'Analyseansvarlig', value: analysisResponsible},
      {type: 'kv', label: 'Rekvirent', value: clinician},
      {type: 'kv', label: 'Patientgruppe', value: patientGroupName, fallback: 'Ikke angivet'},
      {type: 'kv', label: 'Bestilt', value: order?.ordered_at},
      {type: 'paragraph', label: 'Indikation', value: orderIndicationText, emptyText: 'Ingen indikation angivet.'}
    ];
    const qcRows = [];
    if (qcEntries.length) {
      qcEntries.forEach((qc, index) => {
        const label = `${index + 1}. ${qc.metric}`;
        const unit = qc.unit ? ` ${qc.unit}` : '';
        const value = `${qc.value}${unit}`;
        const parts = [value];
        if (qc.notes) parts.push(`Noter: ${qc.notes}`);
        qcRows.push({type: 'paragraph', label, value: parts.join('\n'), indent: '  '});
      });
    } else {
      qcRows.push({type: 'text', text: 'Ingen registrerede kvalitetsmålinger.'});
    }
    const patientSection = buildSectionLayout('Patientoplysninger', patientRows, columnWidth);
    const analysisSection = buildSectionLayout('Analyse', analysisRows, columnWidth);
    const sampleSection = buildSectionLayout('Prøvedata', sampleRows, columnWidth);
    const qcSection = buildSectionLayout('Kvalitetsmålinger', qcRows, columnWidth);
    renderSection(builder, leftColumn, patientSection);
    renderSection(builder, rightColumn, sampleSection);
    renderSection(builder, leftColumn, analysisSection);
    renderSection(builder, rightColumn, qcSection);
    const singleColumn = {
      x: builder.margin,
      width: builder.width - builder.margin * 2,
      cursor: Math.min(leftColumn.cursor, rightColumn.cursor) - PDF_SECTION_SPACING
    };
    if (singleColumn.cursor < builder.margin + PDF_SIGNATURE_BLOCK_HEIGHT + 40) {
      const header = startNewReportPage(builder, logo, exportedAt);
      singleColumn.cursor = header.contentTop;
    }
    const fundRows = [];
    if (variants.length) {
      variants.forEach((variant, index) => {
        const heading = formatVariantTitle(variant) || `Variant ${variant.id ?? index + 1}`;
        const meta = [];
        const typeLabel = getVariantTypeLabel(variant.variant_type);
        if (typeLabel) meta.push(`Type: ${typeLabel}`);
        if (variant.transcript) meta.push(`Transkript: ${variant.transcript}`);
        if (variant.zygosity) meta.push(`Zygositet: ${variant.zygosity}`);
        if (variant.classification) meta.push(`Klasse: ${variant.classification}`);
        if (variant.criteria) meta.push(`ACMG: ${variant.criteria}`);
        if (variant.af !== undefined && variant.af !== null && variant.af !== '') meta.push(`AF: ${variant.af}`);
        const genomic = formatVariantGenomicRange(variant);
        if (genomic) meta.push(`Genomisk position: ${genomic}`);
        if (variant.copy_number) meta.push(`Kopital: ${variant.copy_number}`);
        if (variant.iscn) meta.push(`ISCN: ${variant.iscn}`);
        if (variant.affected_genes) meta.push(`Berørte gener: ${variant.affected_genes}`);
        if (variant.description) meta.push(`Beskrivelse: ${variant.description}`);
        if (variant.annotations) meta.push(`Annoteringer: ${variant.annotations}`);
        const bodyParts = [];
        if (meta.length) bodyParts.push(meta.join(' · '));
        if (variant.interpretation) bodyParts.push(variant.interpretation);
        fundRows.push({
          type: 'paragraph',
          label: `${index + 1}. ${heading}`,
          value: bodyParts.join('\n\n'),
          emptyText: 'Ingen detaljer angivet.',
          indent: '  ',
          renderWhenEmpty: true
        });
      });
    } else {
      fundRows.push({type: 'text', text: 'Ingen registrerede varianter.'});
    }
    const fundSection = buildSectionLayout('Fund', fundRows, singleColumn.width);
    const conclusionText = reportData.summary || '';
    const conclusionRows = [
      conclusionText ? {type: 'text', text: conclusionText} : {type: 'text', text: 'Ingen konklusion angivet.'}
    ];
    const conclusionSection = buildSectionLayout('Konklusion', conclusionRows, singleColumn.width);
    const singleSections = [fundSection, conclusionSection];
    singleSections.forEach((section, index) => {
      const remaining = singleSections.slice(index + 1).reduce((sum, item) => sum + item.height, 0);
      const reserve = remaining + PDF_SIGNATURE_BLOCK_HEIGHT + 20;
      ensureSingleColumnSpace(builder, singleColumn, section.height, reserve);
      renderSection(builder, singleColumn, section);
    });
    ensureSingleColumnSpace(builder, singleColumn, PDF_SIGNATURE_BLOCK_HEIGHT, 0);
    const signatureBottom = builder.margin;
    const signatureHeight = PDF_SIGNATURE_BLOCK_HEIGHT;
    const signatureX = builder.margin - PDF_SECTION_CARD_INSET;
    const signatureWidth = builder.width - 2 * builder.margin + PDF_SECTION_CARD_INSET * 2;
    builder.fillRect(signatureX, signatureBottom, signatureWidth, signatureHeight, PDF_SIGNATURE_BAND_COLOR);
    builder.strokeRect(signatureX, signatureBottom, signatureWidth, signatureHeight, 0.8, PDF_CARD_BORDER_COLOR);
    const signatureHeadingY = signatureBottom + signatureHeight - 18;
    const signatureTextX = singleColumn.x + PDF_SECTION_CARD_PADDING_X;
    builder.addText('Signering', signatureTextX, signatureHeadingY, PDF_HEADING_FONT_SIZE, PDF_HEADING_TEXT_COLOR);
    const signatureInnerWidth = singleColumn.width - PDF_SECTION_CARD_PADDING_X * 2;
    const signatureLineY = signatureBottom + 40;
    const firstLineStart = signatureTextX;
    const midPoint = signatureTextX + signatureInnerWidth / 2;
    const gap = 24;
    let firstLineEnd = midPoint - gap;
    if (firstLineEnd - firstLineStart < 80) firstLineEnd = firstLineStart + 80;
    firstLineEnd = Math.min(firstLineEnd, midPoint - 6);
    let secondLineStart = midPoint + gap;
    if (secondLineStart < firstLineEnd + 24) {
      secondLineStart = firstLineEnd + 24;
    }
    let secondLineEnd = signatureTextX + signatureInnerWidth;
    if (secondLineEnd - secondLineStart < 80) {
      secondLineStart = Math.max(secondLineEnd - 80, secondLineStart);
    }
    builder.addLine(firstLineStart, signatureLineY, firstLineEnd, signatureLineY, 1, PDF_SIGNATURE_LINE_COLOR);
    builder.addText(`Tolker: ${interpreterName || 'Ikke angivet'}`, firstLineStart, signatureLineY + 24, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
    builder.addLine(secondLineStart, signatureLineY, secondLineEnd, signatureLineY, 1, PDF_SIGNATURE_LINE_COLOR);
    builder.addText(`Godkender: ${approverName || 'Ikke angivet'}`, secondLineStart, signatureLineY + 24, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
    renderPanelGeneAppendix(builder, logo, exportedAt, panel);
    const bytes = builder.build();
    return new Blob([bytes], {type: 'application/pdf'});
  } catch (err) {
    console.error('Kunne ikke generere PDF for rapporten', err);
    return null;
  }
}

function sanitizeFilenameComponent(value) {
  if (!value) return 'ukendt';
  return String(value).trim().replace(/[^0-9A-Za-zÆØÅæøå_-]+/g, '_') || 'ukendt';
}

function buildReportPdfFilename(orderId, reportData, exportedAt = new Date()) {
  const order = findById('orders', Number(orderId));
  const patient = order ? findById('patients', Number(order?.patient_id)) : null;
  const mrnPart = sanitizeFilenameComponent(patient?.mrn || patient?.extra_id || patient?.cpr || 'ukendt');
  const dateStamp = exportedAt.toISOString().slice(0, 10).replace(/-/g, '');
  return `${mrnPart}_Diagnostisk_Rapport_${dateStamp}.pdf`;
}
function renderQC(section) {
  const list = getCached('qc');
  const samples = getCached('samples');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="qcSearch">Søg</label>
        <input id="qcSearch" type="search" placeholder="Måling...">
        <label class="list-toggle"><input type="checkbox" id="qcActiveOnly" checked> Vis kun aktive</label>
        <table><thead><tr><th>ID</th><th>Prøve</th><th>Måling</th><th>Værdi</th><th>Enhed</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
      </div>
      <div>
        <h2>Kvalitetsmåling</h2>
        <form id="qcForm">
          <input type="hidden" name="id">
          <label>Prøve
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer prøver">
              <select name="sample_id" required>
                <option value="" selected>Vælg prøve</option>
                ${samples.map(s => `<option value="${s.id}">${s.id} (${esc(s.pmb_number||'–')}) – ${esc(getName('patients', s.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Måling<select name="metric" required data-allow-legacy-option>${buildQcPresetOptions('metric', null, 'Vælg måling')}</select></label>
          <label>Værdi<input name="value" type="number" step="0.0001" required></label>
          <label>Enhed<select name="unit" data-allow-legacy-option>${buildQcPresetOptions('unit', null, 'Vælg enhed')}</select></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="qcClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="qcDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#qcSearch');
  const form = section.querySelector('#qcForm');
  const activeToggle = section.querySelector('#qcActiveOnly');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  const sampleMap = new Map(samples.map(s => [Number(s.id), s]));
  let selectedQcId = null;
  let showActiveOnly = activeToggle ? activeToggle.checked : false;
  const renderRows = () => {
    const term = search.value.trim().toLowerCase();
    const filteredQc = list.filter(q => {
      const sample = sampleMap.get(Number(q.sample_id));
      const sampleStatus = sample?.status || '';
      if (showActiveOnly && sampleStatus && !isActiveStatus(sampleStatus)) return false;
      if (!term) return true;
      const creator = determineCreatedBy('qc', q);
      return [
        q.metric,
        q.unit,
        q.notes,
        creator,
        q.sample_id,
        sample?.pmb_number,
        sample?.sample_type,
        sampleStatus
      ].some(v => String(v ?? '').toLowerCase().includes(term));
    });
    if (selectedQcId != null && !filteredQc.some(q => q.id === selectedQcId)) {
      selectedQcId = null;
    }
    tbody.innerHTML = filteredQc.map(q => {
      const createdBy = determineCreatedBy('qc', q);
      const sample = sampleMap.get(Number(q.sample_id));
      const sampleStatus = sample?.status || '';
      const sampleLabel = getName('samples', Number(q.sample_id));
      const sampleDisplay = sampleLabel || (q.sample_id != null ? `#${q.sample_id}` : '');
      const sampleStatusMeta = sampleStatus && !isActiveStatus(sampleStatus)
        ? ` <span class="table-meta">(${esc(sampleStatus)})</span>`
        : '';
      const selectedAttr = q.id === selectedQcId ? ' data-selected="true"' : '';
      return `<tr data-id="${q.id}"${selectedAttr}><td>${q.id}</td><td>${esc(sampleDisplay)}${sampleStatusMeta}</td><td>${esc(q.metric)}</td><td>${esc(q.value)}</td><td>${esc(q.unit||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  activeToggle?.addEventListener('change', () => {
    showActiveOnly = activeToggle.checked;
    renderRows();
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const qc = list.find(q => q.id === Number(tr.dataset.id));
    if (!qc) return;
    selectedQcId = qc.id;
    fillForm(form, qc);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('qc')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.sample_id = Number(data.sample_id);
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('qc', id)};
      const updated = {...before, ...data, id};
      await updateRecord('qc', updated, before);
    } else {
      delete data.id;
      await addRecord('qc', data);
    }
    await loadStore('qc');
    renderTab('qc');
  });
  section.querySelector('#qcDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg QC-post');
    if (!ensureWrite('qc')) return;
    if (confirm('Slet QC-post?')) {
      await deleteRecord('qc', id);
      renderTab('qc');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedQcId = null;
    renderRows();
  });
  section.querySelector('#qcClear').addEventListener('click', () => form.reset());
}

function renderPlanner(section) {
  section.innerHTML = `
<details class="panel tool-panel" open>
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Arbejdsplanlægger</span>
        <span class="tool-subtitle">Planlæg QC, analyser, tolkninger, godkendelser og rapporter for dine ordinationer.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Arbejdsplanlægger</h3>
      <p>Få et samlet overblik over de opgaver der er knyttet til dine ordinationer og planlæg næste skridt.</p>
      <div id="planningSummary" class="planning-summary"></div>
      <div class="planning-controls">
        <div class="planning-toggles">
          <label class="list-toggle">
            <input type="checkbox" id="planningHideDone" checked>
            Skjul færdige trin
          </label>
          <label class="list-toggle">
            <input type="checkbox" id="planningHideNotStarted" checked>
            Skjul ikke startede trin
          </label>
          <label class="list-toggle">
            <input type="checkbox" id="planningHideHealthy" checked>
            Skjul raske familiemedlemmer
          </label>
        </div>
        <div class="planning-actions">
          <button type="button" class="secondary planning-button" id="planningRefresh">Opdater</button>
          <button type="button" class="primary planning-button" id="planningExport" disabled>Eksportér plan til kalender</button>
          <button type="button" class="secondary planning-button" id="planningExportCsv" disabled>Eksportér plan til CSV</button>
        </div>
      </div>
      <div class="planning-status" id="planningStatus"></div>
      <div id="planningBoard" class="planning-board"></div>
      <p class="tool-note">Brug kalender-eksporten til at dele planen med Outlook eller Exchange.</p>
      <div class="planning-guide">
        <h4>Kort vejledning</h4>
        <ul>
          <li>En rød ramme viser, at en opgave er forfaldet, mens en gul ramme markerer, at deadline nærmer sig.</li>
          <li>Tilføj noter og deadlines på hvert kort, og husk også at skifte status når du marker opgaver som færdige.</li>
          <li>Brug knapperne <em>Åbn ordination</em>, <em>Åbn prøver</em> og <em>Åbn rapporter</em> for at hoppe direkte til filtrerede lister for den valgte ordination.</li>
        </ul>
      </div>
    </div>
  </details>
  <details class="panel tool-panel planning-missing-panel" id="planningMissingAssignments">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Manglende roller</span>
        <span class="tool-subtitle" id="planningMissingSummary">Overblik over ordinationer uden tildelt analyseansvarlig, tolk eller godkender.</span>
      </div>
    </summary>
    <div class="tool-body">
      <div class="planning-missing-intro">
        <p>Følg op på ordinationer, der mangler ansvarlige roller, så opgaverne hurtigt kan fordeles. Klik på en række for at åbne ordinationen i Ordinationer.</p>
        <div class="planning-missing-controls">
          <label for="planningMissingRole">Vis ordinationer der mangler</label>
          <select id="planningMissingRole">
            <option value="analysis_responsible_id">Analyseansvarlig</option>
            <option value="interpreter_id">Tolker</option>
            <option value="approver_id">Godkender</option>
          </select>
        </div>
        <div class="planning-missing-totals" id="planningMissingTotals"></div>
      </div>
      <div id="planningMissingList"></div>
    </div>
  </details>
  `;
  const planningBoard = section.querySelector('#planningBoard');
  const planningSummary = section.querySelector('#planningSummary');
  const planningHideDoneToggle = section.querySelector('#planningHideDone');
  const planningHideNotStartedToggle = section.querySelector('#planningHideNotStarted');
  const planningHideHealthyToggle = section.querySelector('#planningHideHealthy');
  const planningExportBtn = section.querySelector('#planningExport');
  const planningExportCsvBtn = section.querySelector('#planningExportCsv');
  const planningRefreshBtn = section.querySelector('#planningRefresh');
  const planningStatusText = section.querySelector('#planningStatus');
  const planningMissingSummary = section.querySelector('#planningMissingSummary');
  const planningMissingTotals = section.querySelector('#planningMissingTotals');
  const planningMissingList = section.querySelector('#planningMissingList');
  const planningMissingRoleFilter = section.querySelector('#planningMissingRole');

  const HIDDEN_SAMPLE_STATUS_KEYS = new Set(['svaret', 'biobank', 'annulleret']);
  const shouldHideSampleStatus = status => {
    if (!status) return false;
    const normalized = status.toString().trim().toLowerCase();
    if (!normalized) return false;
    if (HIDDEN_SAMPLE_STATUS_KEYS.has(normalized)) return true;
    for (const key of HIDDEN_SAMPLE_STATUS_KEYS) {
      if (normalized.startsWith(`${key} `)) return true;
    }
    return false;
  };

  const ROLE_LABELS = {
    analysis_responsible_id: 'Analyseansvarlig',
    interpreter_id: 'Tolker',
    approver_id: 'Godkender'
  };
  const ROLE_ORDER = ['analysis_responsible_id', 'interpreter_id', 'approver_id'];

  const summariseReportStatuses = reports => {
    if (!Array.isArray(reports) || !reports.length) return 'Ingen rapporter registreret endnu';
    const counts = new Map();
    reports.forEach(report => {
      const status = (report?.status || 'Uden status').trim() || 'Uden status';
      counts.set(status, (counts.get(status) || 0) + 1);
    });
    const summary = Array.from(counts.entries()).map(([status, count]) => `${status} (${count})`).join(', ');
    return `Rapporter (${reports.length}): ${summary}`;
  };

  const APPROVED_REPORT_STATUSES = new Set(['godkendt', 'udstedt', 'sendt', 'svaret', 'frigivet', 'released', 'færdig', 'afsluttet']);
  const PUBLISHED_REPORT_STATUSES = new Set(['udstedt', 'sendt', 'svaret', 'frigivet', 'released']);

  const planningStages = [
    {
      id: 'qc',
      label: 'Kvalitetskontrol',
      shortLabel: 'QC',
      description: 'Forbered og registrér QC-målinger.',
      sampleStatus: 'QC',
      roleKeys: ['analysis_responsible_id'],
      actions: [
        {type: 'open-sample', label: 'Åbn prøve'},
        {type: 'open-order', label: 'Åbn ordination'}
      ],
      computeCompletion: ({sample, context}) => {
        const sampleId = Number(sample?.id);
        if (!Number.isFinite(sampleId)) return false;
        return (context.qcBySample.get(sampleId) || []).length > 0;
      },
      buildInfo: ({sample, context}) => {
        const sampleId = Number(sample?.id);
        const qcCount = Number.isFinite(sampleId) ? (context.qcBySample.get(sampleId) || []).length : 0;
        return [qcCount ? `${qcCount} QC-måling${qcCount === 1 ? '' : 'er'} registreret` : 'Ingen QC-målinger registreret endnu'];
      }
    },
    {
      id: 'analysis',
      label: 'Analyse',
      shortLabel: 'Analyse',
      description: 'Koordinér analysearbejdet og variantregistrering.',
      sampleStatus: 'Analyse',
      roleKeys: ['analysis_responsible_id'],
      actions: [
        {type: 'open-order', label: 'Åbn ordination'}
      ],
      buildInfo: ({context, orderId}) => {
        const variantCount = (context.variantsByOrder.get(orderId) || []).length;
        return [variantCount ? `${variantCount} variant${variantCount === 1 ? '' : 'er'} registreret` : 'Ingen varianter registreret endnu'];
      }
    },
    {
      id: 'interpretation',
      label: 'Tolkning',
      shortLabel: 'Tolkning',
      description: 'Planlæg fortolkning og konklusioner.',
      sampleStatus: 'Tolkning',
      roleKeys: ['interpreter_id'],
      actions: [
        {type: 'open-order', label: 'Åbn ordination'},
        {type: 'open-report', label: 'Åbn rapporter'}
      ],
      buildInfo: ({context, orderId}) => {
        const variantCount = (context.variantsByOrder.get(orderId) || []).length;
        return [variantCount ? `${variantCount} variant${variantCount === 1 ? '' : 'er'} til fortolkning` : 'Ingen varianter klar til fortolkning endnu'];
      }
    },
    {
      id: 'approval',
      label: 'Godkendelse',
      shortLabel: 'Godkendelse',
      description: 'Følg rapporter der afventer godkendelse.',
      sampleStatus: 'Godkendelse',
      roleKeys: ['approver_id'],
      actions: [
        {type: 'open-report', label: 'Åbn rapporter'},
        {type: 'open-order', label: 'Åbn ordination'}
      ],
      computeCompletion: ({context, orderId}) => {
        const reports = context.reportsByOrder.get(orderId) || [];
        return reports.some(report => APPROVED_REPORT_STATUSES.has((report?.status || '').toLowerCase()));
      },
      buildInfo: ({context, orderId}) => {
        const reports = context.reportsByOrder.get(orderId) || [];
        if (!reports.length) return ['Ingen rapporter klar til godkendelse endnu'];
        return [summariseReportStatuses(reports)];
      }
    },
    {
      id: 'report',
      label: 'Rapport',
      shortLabel: 'Rapport',
      description: 'Planlæg rapportskrivning og udsendelse.',
      sampleStatus: 'Rapport',
      roleKeys: ['analysis_responsible_id', 'interpreter_id'],
      actions: [
        {type: 'open-report', label: 'Åbn rapporter'},
        {type: 'open-order', label: 'Åbn ordination'}
      ],
      computeCompletion: ({context, orderId}) => {
        const reports = context.reportsByOrder.get(orderId) || [];
        return reports.some(report => PUBLISHED_REPORT_STATUSES.has((report?.status || '').toLowerCase()));
      },
      buildInfo: ({context, orderId}) => {
        const reports = context.reportsByOrder.get(orderId) || [];
        if (!reports.length) return ['Ingen rapportudkast oprettet endnu'];
        return [summariseReportStatuses(reports)];
      }
    }
  ];

  const STAGE_STATUS_LABELS = {
    pending: 'Ikke startet',
    in_progress: 'I gang',
    done: 'Færdig',
    blocked: 'Afventer data',
    unknown: 'Status ukendt'
  };

  const STAGE_STATUS_DESCRIPTIONS = {
    pending: 'Trinnet afventer at forrige trin afsluttes eller at prøven opdateres.',
    in_progress: 'Trinnet er aktivt og kræver opmærksomhed.',
    done: 'Trinnet er markeret som afsluttet.',
    blocked: 'Der mangler prøvestatus eller data for at vurdere trinets fremdrift.',
    unknown: 'Kan ikke fastslå fremdriften for dette trin.'
  };

  const sampleStatusOrder = new Map(SAMPLE_STATUSES.map((status, index) => [status.toLowerCase(), index]));
  const dateTimeFormatter = new Intl.DateTimeFormat('da-DK', {dateStyle: 'short', timeStyle: 'short'});
  const planningCsvColumns = [
    {label: 'Opgave-id', value: task => task.id},
    {label: 'Ordination', value: task => task.orderName},
    {label: 'Trin', value: task => task.stage?.label || ''},
    {label: 'Patient', value: task => task.patientName || ''},
    {label: 'Patient MRN', value: task => task.patientMrn || ''},
    {label: 'Rask familiemedlem', value: task => task.healthyFamilyMember ? 'Ja' : 'Nej'},
    {label: 'Prøve', value: task => task.sampleLabel || ''},
    {label: 'Rolle', value: task => task.roleLabel || ''},
    {label: 'Prøvestatus', value: task => task.sampleStatusText || ''},
    {label: 'Status', value: task => task.statusLabel || ''},
    {label: 'Deadline', value: task => task.dueDisplay || ''},
    {label: 'Deadline relativ', value: task => task.dueRelative || ''},
    {label: 'Færdig', value: task => task.isDone ? 'Ja' : 'Nej'},
    {label: 'Noter', value: task => task.note || ''},
    {label: 'Ekstra info', value: task => Array.isArray(task.info) ? task.info.join(' | ') : ''}
  ];

  const DEFAULT_PLAN_VIEW = {hideDone: true, hideNotStarted: true, hideHealthy: true};

  const sanitizePlanView = value => {
    const view = {...DEFAULT_PLAN_VIEW};
    if (value && typeof value === 'object') {
    if (Object.prototype.hasOwnProperty.call(value, 'hideDone')) {
      view.hideDone = Boolean(value.hideDone);
    }
    if (Object.prototype.hasOwnProperty.call(value, 'hideNotStarted')) {
      view.hideNotStarted = Boolean(value.hideNotStarted);
    }
    if (Object.prototype.hasOwnProperty.call(value, 'hideHealthy')) {
      view.hideHealthy = Boolean(value.hideHealthy);
    }
  }
  return view;
};

  const currentUser = state.currentUser;
  const currentUserId = currentUser?.id != null ? String(currentUser.id) : null;
  const canModifySampleStatus = currentCanWrite();
  const legacyPlanningStorageKey = currentUserId ? `glimr-plan-${currentUserId}` : null;
  let planStateSource = 'none';

  const loadLegacyPlanState = () => {
    if (!legacyPlanningStorageKey) return null;
    try {
      const raw = storage.getItem(legacyPlanningStorageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return null;
      if (!parsed.tasks || typeof parsed.tasks !== 'object') parsed.tasks = {};
      if (!parsed.createdAt && parsed.created_at) parsed.createdAt = parsed.created_at;
      if (!parsed.updatedAt && parsed.updated_at) parsed.updatedAt = parsed.updated_at;
      parsed.view = sanitizePlanView(parsed.view);
      return parsed;
    } catch (err) {
      console.warn('Kunne ikke indlæse planlægning fra lokalt lager:', err);
      return null;
    }
  };

  const loadPlanState = () => {
    if (!currentUserId) {
      planStateSource = 'none';
      return {tasks: {}, view: sanitizePlanView(null)};
    }
    const plannerRows = getCached('planner') || [];
    const entry = plannerRows.find(row => String(row.id) === currentUserId);
    if (entry && typeof entry === 'object') {
      planStateSource = 'db';
      const tasks = entry.tasks && typeof entry.tasks === 'object' ? {...entry.tasks} : {};
      const createdAt = entry.created_at || entry.createdAt || null;
      const updatedAt = entry.updated_at || entry.updatedAt || null;
      const view = sanitizePlanView(entry.view);
      return {tasks, view, createdAt, updatedAt};
    }
    const legacy = loadLegacyPlanState();
    if (legacy) {
      planStateSource = 'legacy';
      return legacy;
    }
    planStateSource = 'new';
    return {tasks: {}, view: sanitizePlanView(null)};
  };

  let planState = loadPlanState();

  const ensurePlanTasks = () => {
    if (!planState || typeof planState !== 'object') planState = {tasks: {}};
    if (!planState.tasks || typeof planState.tasks !== 'object') planState.tasks = {};
    if (!planState.createdAt) {
      planState.createdAt = planState.updatedAt || new Date().toISOString();
    }
    if (planState.updatedAt === undefined) {
      planState.updatedAt = null;
    }
    planState.view = sanitizePlanView(planState.view);
  };

  ensurePlanTasks();

  let planPersistQueue = Promise.resolve();
  let planPersistPending = false;

  const refreshPlanningStatusText = () => {
    if (!planningStatusText) return;
    if (!currentUserId) {
      planningStatusText.textContent = '';
      return;
    }
    if (planPersistPending) {
      planningStatusText.textContent = 'Gemmer ændringer...';
      return;
    }
    if (planState.updatedAt) {
      const ts = parseDateTimeValue(planState.updatedAt);
      if (ts) {
        planningStatusText.textContent = `Sidst gemt: ${dateTimeFormatter.format(ts)}`;
        return;
      }
    }
    planningStatusText.textContent = 'Planen er endnu ikke gemt.';
  };

  async function persistPlanStateImmediate() {
    if (!currentUserId) return;
    ensurePlanTasks();
    const timestamp = new Date().toISOString();
    const createdAt = planState.createdAt || planState.updatedAt || timestamp;
    const updatedAt = timestamp;
    planState.createdAt = createdAt;
    planState.updatedAt = updatedAt;
    if (state.db) {
      try {
        const tx = state.db.transaction('planner', 'readwrite');
        const store = tx.objectStore('planner');
        const view = sanitizePlanView(planState.view);
        planState.view = view;
        store.put({
          id: currentUserId,
          user_id: currentUserId,
          tasks: planState.tasks,
          view,
          created_at: createdAt,
          updated_at: updatedAt
        });
        await tx.done?.catch(() => {});
        await loadStore('planner');
        planStateSource = 'db';
        scheduleAutosave();
      } catch (err) {
        console.warn('Kunne ikke gemme planlægning i database:', err);
      }
    }
    if (legacyPlanningStorageKey) {
      try {
        storage.setItem(legacyPlanningStorageKey, JSON.stringify(planState));
      } catch (err) {
        console.warn('Kunne ikke gemme planlægning i lokal storage:', err);
      }
    }
  }

  const queuePlanPersist = () => {
    planPersistPending = true;
    refreshPlanningStatusText();
    const run = planPersistQueue.then(() => persistPlanStateImmediate());
    planPersistQueue = run
      .catch(err => {
        console.warn('Kunne ikke gemme planlægning:', err);
      })
      .then(() => {
        planPersistPending = false;
        refreshPlanningStatusText();
      });
    return run;
  };

  const waitForPlanPersistence = async () => {
    try {
      await planPersistQueue;
    } catch (err) {
      console.warn('Kunne ikke færdiggøre plan-gemning:', err);
    }
  };

  if (planStateSource === 'legacy') {
    queuePlanPersist().catch(err => console.warn('Kunne ikke migrere planlægning til database:', err));
  }

  const sanitizeDueValue = value => {
    if (typeof value !== 'string') return '';
    const trimmed = value.trim();
    if (!trimmed) return '';
    return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(trimmed) ? trimmed : '';
  };

  const sanitizeNoteValue = value => {
    if (typeof value !== 'string') return '';
    return value.replace(/\r/g, '').slice(0, 2000);
  };

  const getPlanView = () => {
    ensurePlanTasks();
    const view = sanitizePlanView(planState.view);
    planState.view = view;
    return {...view};
  };

  const setPlanView = (updates, options = {}) => {
    if (!updates || typeof updates !== 'object') return false;
    ensurePlanTasks();
    const previous = sanitizePlanView(planState.view);
    const next = {...previous};
    let changed = false;
    if (Object.prototype.hasOwnProperty.call(updates, 'hideDone')) {
      const hideDone = Boolean(updates.hideDone);
      if (next.hideDone !== hideDone) {
        next.hideDone = hideDone;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(updates, 'hideNotStarted')) {
      const hideNotStarted = Boolean(updates.hideNotStarted);
      if (next.hideNotStarted !== hideNotStarted) {
        next.hideNotStarted = hideNotStarted;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(updates, 'hideHealthy')) {
      const hideHealthy = Boolean(updates.hideHealthy);
      if (next.hideHealthy !== hideHealthy) {
        next.hideHealthy = hideHealthy;
        changed = true;
      }
    }
    if (!changed) return false;
    planState.view = next;
    if (options.persist === false) {
      return true;
    }
    queuePlanPersist().catch(err => console.warn('Kunne ikke gemme planlægning:', err));
    return true;
  };

  const getPlanSettings = id => {
    ensurePlanTasks();
    const entry = planState.tasks?.[id];
    if (!entry || typeof entry !== 'object') {
      return {due: '', note: '', done: false};
    }
    return {
      due: sanitizeDueValue(entry.due),
      note: sanitizeNoteValue(entry.note || ''),
      done: Boolean(entry.done)
    };
  };

  const setPlanSettings = (id, updates, options = {}) => {
    if (!id || !updates || typeof updates !== 'object') return false;
    ensurePlanTasks();
    const previous = planState.tasks?.[id] && typeof planState.tasks[id] === 'object'
      ? planState.tasks[id]
      : null;
    const current = {...(previous || {})};
    let changed = false;
    if (Object.prototype.hasOwnProperty.call(updates, 'due')) {
      const sanitizedDue = sanitizeDueValue(updates.due);
      if ((previous?.due || '') !== sanitizedDue) {
        changed = true;
      }
      if (sanitizedDue) {
        current.due = sanitizedDue;
      } else {
        delete current.due;
      }
    }
    if (Object.prototype.hasOwnProperty.call(updates, 'note')) {
      const sanitizedNote = sanitizeNoteValue(updates.note);
      if ((previous?.note || '') !== sanitizedNote) {
        changed = true;
      }
      if (sanitizedNote) {
        current.note = sanitizedNote;
      } else {
        delete current.note;
      }
    }
    if (Object.prototype.hasOwnProperty.call(updates, 'done')) {
      const doneValue = Boolean(updates.done);
      if (Boolean(previous?.done) !== doneValue) {
        changed = true;
      }
      if (doneValue) {
        current.done = true;
      } else {
        delete current.done;
      }
    }
    const hasData = Boolean(current.due) || Boolean(current.note) || Boolean(current.done);
    if (hasData) {
      if (changed || !previous) {
        planState.tasks[id] = current;
      }
    } else if (previous) {
      delete planState.tasks[id];
      changed = true;
    }
    if (!changed) return false;
    if (options.persist === false) {
      return true;
    }
    queuePlanPersist().catch(err => console.warn('Kunne ikke gemme planlægning:', err));
    return true;
  };

  const commitPlannerEdits = () => {
    if (!planningBoard || !currentUserId) return false;
    let changed = false;
    const cards = planningBoard.querySelectorAll('.planning-card');
    cards.forEach(card => {
      if (!(card instanceof HTMLElement)) return;
      const taskId = card.dataset.taskId;
      if (!taskId) return;
      const updates = {};
      let hasUpdates = false;
      const dueInput = card.querySelector('.planning-due');
      if (dueInput instanceof HTMLInputElement) {
        updates.due = dueInput.value;
        hasUpdates = true;
      }
      const noteInput = card.querySelector('.planning-note');
      const noteIsDirty = card.classList.contains('planning-note-dirty');
      if (noteInput instanceof HTMLTextAreaElement && !noteIsDirty) {
        updates.note = noteInput.value;
        hasUpdates = true;
      }
      const doneInput = card.querySelector('.planning-done');
      if (doneInput instanceof HTMLInputElement && doneInput.type === 'checkbox') {
        updates.done = doneInput.checked;
        hasUpdates = true;
      }
      if (!hasUpdates) return;
      if (setPlanSettings(taskId, updates, {persist: false})) {
        changed = true;
      }
    });
    return changed;
  };

  const flushPlannerChanges = async () => {
    if (!currentUserId) return false;
    const hadNewChanges = commitPlannerEdits();
    if (hadNewChanges) {
      await queuePlanPersist();
    }
    await waitForPlanPersistence();
    return hadNewChanges;
  };

  state.flushPlannerChanges = flushPlannerChanges;

  const formatRelativeDue = (date, now = new Date()) => {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
    const diffMs = date.getTime() - now.getTime();
    const absMs = Math.abs(diffMs);
    const hourMs = 60 * 60 * 1000;
    const dayMs = 24 * hourMs;
    if (absMs < hourMs) {
      return diffMs >= 0 ? 'Forfalder om < 1 time' : 'Forfaldt for under 1 time siden';
    }
    if (absMs < dayMs) {
      const hours = Math.round(absMs / hourMs);
      const label = hours === 1 ? 'time' : 'timer';
      return diffMs >= 0 ? `Forfalder om ${hours} ${label}` : `Forfaldt for ${hours} ${label} siden`;
    }
    const days = Math.round(absMs / dayMs);
    const label = days === 1 ? 'dag' : 'dage';
    return diffMs >= 0 ? `Forfalder om ${days} ${label}` : `Forfaldt for ${days} ${label} siden`;
  };

  let planningTasks = [];

  const computePlanningTasks = () => {
    if (!currentUserId) return [];
    const orders = getCached('orders') || [];
    if (!orders.length) return [];
    const patients = getCached('patients') || [];
    const samples = getCached('samples') || [];
    const qcRows = getCached('qc') || [];
    const variantRows = getCached('variants') || [];
    const reportRows = getCached('reports') || [];
    const patientMap = new Map(patients.map(p => [Number(p.id), p]));
    const sampleMap = new Map(samples.map(s => [Number(s.id), s]));
    const qcBySample = new Map();
    qcRows.forEach(row => {
      const sampleId = Number(row.sample_id);
      if (!Number.isFinite(sampleId)) return;
      const list = qcBySample.get(sampleId) || [];
      list.push(row);
      qcBySample.set(sampleId, list);
    });
    const variantsByOrder = new Map();
    variantRows.forEach(row => {
      const orderId = Number(row.order_id);
      if (!Number.isFinite(orderId)) return;
      const list = variantsByOrder.get(orderId) || [];
      list.push(row);
      variantsByOrder.set(orderId, list);
    });
    const reportsByOrder = new Map();
    reportRows.forEach(row => {
      const orderId = Number(row.order_id);
      if (!Number.isFinite(orderId)) return;
      const list = reportsByOrder.get(orderId) || [];
      list.push(row);
      reportsByOrder.set(orderId, list);
    });
    const context = {qcBySample, variantsByOrder, reportsByOrder};
    const now = new Date();
    const results = [];
    orders.forEach(order => {
      const orderId = Number(order.id);
      if (!Number.isFinite(orderId)) return;
      const sample = sampleMap.get(Number(order.sample_id));
      const patient = patientMap.get(Number(order.patient_id));
      const healthyFamilyMember = Boolean(patient?.healthy_family_member);
      const sampleStatusRaw = sample?.status || order?.status || '';
      if (shouldHideSampleStatus(sampleStatusRaw)) return;
      planningStages.forEach(stage => {
        const matchedRoles = stage.roleKeys.filter(key => {
          const value = order?.[key];
          return value !== undefined && value !== null && String(value) === currentUserId;
        });
        if (!matchedRoles.length) return;
        const taskId = `${orderId}:${stage.id}`;
        const planSettings = getPlanSettings(taskId);
        const dueInputValue = sanitizeDueValue(planSettings.due);
        const dueDate = dueInputValue ? parseDateTimeValue(dueInputValue) : null;
        const sampleStatusValueRaw = sample?.status || '';
        const sampleStatusValue = sampleStatusValueRaw.toLowerCase();
        const sampleStatusIndex = sampleStatusOrder.get(sampleStatusValue);
        const stageStatusIndex = stage.sampleStatus ? sampleStatusOrder.get(stage.sampleStatus.toLowerCase()) : undefined;
        let statusKey = 'unknown';
        if (!sample) {
          statusKey = 'blocked';
        } else if (stageStatusIndex === undefined || stageStatusIndex === -1 || sampleStatusIndex === undefined) {
          statusKey = 'unknown';
        } else if (sampleStatusIndex > stageStatusIndex) {
          statusKey = 'done';
        } else if (sampleStatusIndex === stageStatusIndex) {
          statusKey = 'in_progress';
        } else {
          statusKey = 'pending';
        }
        if (stage.computeCompletion?.({order, sample, context, orderId, sampleStatusIndex})) {
          statusKey = 'done';
        }
        const note = planSettings.note;
        const planDone = Boolean(planSettings.done);
        if (planDone && statusKey !== 'done') {
          statusKey = 'done';
        }
        const isDone = statusKey === 'done';
        const dueState = dueDate ? (dueDate.getTime() < now.getTime() ? 'overdue' : (dueDate.getTime() - now.getTime()) <= 48 * 60 * 60 * 1000 ? 'soon' : 'scheduled') : 'none';
        const dueRelative = dueDate ? formatRelativeDue(dueDate, now) : '';
        const info = [];
        const stageInfo = stage.buildInfo ? stage.buildInfo({order, sample, patient, context, orderId}) : [];
        if (Array.isArray(stageInfo)) {
          stageInfo.forEach(item => { if (item) info.push(item); });
        } else if (stageInfo) {
          info.push(stageInfo);
        }
        if (healthyFamilyMember) {
          info.unshift('Patient markeret som rask familiemedlem');
        }
        const familyType = normalizeFamilyType(order?.family_type);
        const familyTypeLabel = getFamilyTypeLabel(familyType);
        if (familyTypeLabel) info.push(`Familietype: ${familyTypeLabel}`);
        if (sample?.sample_type) info.push(`Prøvetype: ${sample.sample_type}`);
        if (order?.status) info.push(`Ordinationsstatus: ${order.status}`);
        if (order?.ordered_at) {
          const orderedText = formatDanishDate(order.ordered_at, true);
          if (orderedText) info.push(`Bestilt: ${orderedText}`);
        }
        const orderName = getOrderDisplayName(orderId) || `Ordination #${orderId}`;
        const patientName = patient?.name || '';
        const patientMrn = patient?.mrn || '';
        const sampleLabel = sample ? `Prøve ${sample.id}${sample.pmb_number ? ` (${sample.pmb_number})` : ''}` : '';
        const roleNames = matchedRoles.map(key => ROLE_LABELS[key] || key);
        const roleLabel = roleNames.length ? `Din rolle: ${roleNames.join(' & ')}` : '';
        const sampleStatusText = sampleStatusValueRaw || 'Ikke angivet';
        const priorityHtml = renderOrderPriorityIcons(order);
        results.push({
          id: taskId,
          orderId,
          stage,
          sampleId: sample?.id != null ? Number(sample.id) : null,
          orderName,
          patientName,
          patientMrn,
          sampleLabel,
          roleLabel,
          familyType,
          familyTypeLabel,
          healthyFamilyMember,
          statusKey,
          statusLabel: STAGE_STATUS_LABELS[statusKey] || 'Status ukendt',
          statusDescription: STAGE_STATUS_DESCRIPTIONS[statusKey] || '',
          dueInputValue,
          dueDate,
          dueDisplay: dueDate ? dateTimeFormatter.format(dueDate) : '',
          dueRelative,
          dueState,
          note,
          planDone,
          isDone,
          sampleStatusValue: sampleStatusValueRaw,
          sampleStatusText,
          info,
          priorityHtml
        });
      });
    });
    return results;
  };

  const comparePlanningTasks = (a, b) => {
    if (a.isDone !== b.isDone) return a.isDone ? 1 : -1;
    if (a.dueDate && b.dueDate) return a.dueDate - b.dueDate;
    if (a.dueDate) return -1;
    if (b.dueDate) return 1;
    if (a.dueState === 'overdue' && b.dueState !== 'overdue') return -1;
    if (b.dueState === 'overdue' && a.dueState !== 'overdue') return 1;
    return a.orderId - b.orderId;
  };

  const computeMissingAssignments = () => {
    if (!currentUserId) return [];
    const orders = getCached('orders') || [];
    if (!orders.length) return [];
    const patients = getCached('patients') || [];
    const samples = getCached('samples') || [];
    const patientMap = new Map(patients.map(p => [Number(p.id), p]));
    const sampleMap = new Map(samples.map(s => [Number(s.id), s]));
    const results = [];
    orders.forEach(order => {
      if (!order) return;
      const orderId = Number(order.id);
      if (!Number.isFinite(orderId)) return;
      const missingKeys = ROLE_ORDER.filter(key => {
        const value = order?.[key];
        if (value === undefined || value === null) return true;
        if (typeof value === 'string' && !value.trim()) return true;
        return false;
      });
      if (!missingKeys.length) return;
      const patient = patientMap.get(Number(order.patient_id));
      const sample = sampleMap.get(Number(order.sample_id));
      const orderName = getOrderDisplayName(orderId) || `Ordination #${orderId}`;
      const orderedSource = order?.ordered_at || order?.created_at || order?.updated_at || '';
      const orderedDisplay = orderedSource ? formatDanishDate(orderedSource, true) : '';
      let orderedTimestamp = Date.parse(orderedSource || '');
      if (!Number.isFinite(orderedTimestamp) && order?.created_at) {
        const createdTs = Date.parse(order.created_at);
        if (Number.isFinite(createdTs)) orderedTimestamp = createdTs;
      }
      const sampleLabel = sample
        ? sample.pmb_number
          ? `Prøve ${sample.id} (${sample.pmb_number})`
          : `Prøve ${sample.id}`
        : '';
      results.push({
        orderId,
        orderName,
        missingKeys,
        missingLabels: missingKeys.map(key => ROLE_LABELS[key] || key),
        status: order?.status || '',
        patientName: patient?.name || '',
        patientMrn: patient?.mrn || '',
        sampleLabel,
        orderedDisplay,
        orderedTimestamp,
        priorityHtml: renderOrderPriorityIcons(order)
      });
    });
    return results;
  };

  const renderMissingAssignments = () => {
    if (!planningMissingList || !planningMissingSummary || !planningMissingTotals) return;
    if (!currentUserId) {
      planningMissingSummary.textContent = 'Log ind for at se manglende roller.';
      planningMissingTotals.innerHTML = '';
      planningMissingList.innerHTML = '<p class="planning-missing-empty">Log ind for at se hvilke ordinationer der mangler analyseansvarlig, tolk eller godkender.</p>';
      planningMissingRoleFilter?.setAttribute('disabled', 'disabled');
      if (planningMissingRoleFilter) planningMissingRoleFilter.value = ROLE_ORDER[0];
      return;
    }
    const assignments = computeMissingAssignments();
    if (planningMissingRoleFilter) {
      planningMissingRoleFilter.disabled = assignments.length === 0;
    }
    const totals = ROLE_ORDER.map(key => ({
      key,
      label: ROLE_LABELS[key] || key,
      count: assignments.reduce((acc, entry) => acc + (entry.missingKeys.includes(key) ? 1 : 0), 0)
    }));
    const totalCount = assignments.length;
    if (!totalCount) {
      planningMissingSummary.textContent = 'Alle ordinationer har tildelt analyseansvarlig, tolk og godkender.';
      planningMissingTotals.innerHTML = '<span>Ingen mangler registreret.</span>';
      planningMissingList.innerHTML = '<p class="planning-missing-empty">Alle ordinationer har tildelt analyseansvarlig, tolk og godkender.</p>';
      if (planningMissingRoleFilter) planningMissingRoleFilter.value = ROLE_ORDER[0];
      return;
    }
    let selectedRoleKey = planningMissingRoleFilter?.value || ROLE_ORDER[0];
    if (!ROLE_ORDER.includes(selectedRoleKey)) {
      selectedRoleKey = ROLE_ORDER[0];
      if (planningMissingRoleFilter) planningMissingRoleFilter.value = selectedRoleKey;
    }
    const selectedRoleLabel = ROLE_LABELS[selectedRoleKey] || selectedRoleKey;
    const roleSummary = totals
      .filter(item => item.count > 0)
      .map(item => `${item.label}: ${item.count}`)
      .join(' • ');
    const summaryBase = `${totalCount} ordination${totalCount === 1 ? '' : 'er'} mangler roller`;
    const summaryParts = [summaryBase];
    if (roleSummary) summaryParts.push(`Fordeling: ${roleSummary}`);
    summaryParts.push(`Viser: ${selectedRoleLabel}`);
    planningMissingSummary.textContent = `${summaryParts.join('. ')}.`;
    const totalsHtml = totals
      .filter(item => item.count > 0)
      .map(item => `<span><strong>${esc(item.label)}:</strong> ${esc(String(item.count))}</span>`)
      .join('');
    planningMissingTotals.innerHTML = totalsHtml || '<span>Ingen mangler registreret.</span>';
    const collator = new Intl.Collator('da', {sensitivity: 'base'});
    const getPrimaryRoleIndex = entry => {
      if (!entry || !Array.isArray(entry.missingKeys) || !entry.missingKeys.length) {
        return ROLE_ORDER.length;
      }
      let index = ROLE_ORDER.length;
      entry.missingKeys.forEach(key => {
        const roleIndex = ROLE_ORDER.indexOf(key);
        if (roleIndex !== -1 && roleIndex < index) {
          index = roleIndex;
        }
      });
      return index;
    };
    const sorted = assignments.slice().sort((a, b) => {
      const idxA = getPrimaryRoleIndex(a);
      const idxB = getPrimaryRoleIndex(b);
      if (idxA !== idxB) {
        return idxA - idxB;
      }
      if (Number.isFinite(a.orderedTimestamp) && Number.isFinite(b.orderedTimestamp) && a.orderedTimestamp !== b.orderedTimestamp) {
        return a.orderedTimestamp - b.orderedTimestamp;
      }
      const nameCompare = collator.compare(a.orderName, b.orderName);
      if (nameCompare !== 0) return nameCompare;
      return a.orderId - b.orderId;
    });
    const filtered = sorted.filter(entry => Array.isArray(entry.missingKeys) && entry.missingKeys.includes(selectedRoleKey));
    if (!filtered.length) {
      const missingLabelLower = (selectedRoleLabel || '').toLowerCase();
      planningMissingList.innerHTML = `<p class="planning-missing-empty">Ingen ordinationer mangler ${esc(missingLabelLower || 'den valgte rolle')}.</p>`;
      return;
    }
    const rowsHtml = filtered.map(entry => {
      const metaParts = [];
      if (entry.patientName) metaParts.push(entry.patientName);
      if (entry.patientMrn) metaParts.push(`MRN ${entry.patientMrn}`);
      if (entry.sampleLabel) metaParts.push(entry.sampleLabel);
      const metaHtml = metaParts.length
        ? `<div class="planning-missing-meta">${metaParts.map((part, index) => `${index ? '<span class="planning-missing-sep" aria-hidden="true">•</span>' : ''}<span>${esc(part)}</span>`).join('')}</div>`
        : '';
      const priorityHtml = entry.priorityHtml ? `<span class="planning-missing-priority">${entry.priorityHtml}</span>` : '';
      const missingText = entry.missingLabels.map(label => esc(label)).join(', ');
      const statusText = entry.status ? esc(entry.status) : 'Ikke angivet';
      const orderedText = entry.orderedDisplay ? esc(entry.orderedDisplay) : 'Ukendt';
      return `
        <tr data-order-id="${esc(entry.orderId)}" role="button" tabindex="0">
          <td>
            <div class="planning-missing-order">
              <div class="planning-missing-name">${priorityHtml}${priorityHtml ? ' ' : ''}${esc(entry.orderName)}</div>
              ${metaHtml}
            </div>
          </td>
          <td class="planning-missing-missing">${missingText}</td>
          <td>${statusText}</td>
          <td>${orderedText}</td>
        </tr>`;
    }).join('');
    planningMissingList.innerHTML = `
      <table class="planning-missing-table">
        <thead>
          <tr><th>Ordination</th><th>Mangler</th><th>Status</th><th>Bestilt</th></tr>
        </thead>
        <tbody>${rowsHtml}
        </tbody>
      </table>
    `;
    const handleRowActivation = event => {
      if (event.type === 'keydown') {
        const key = event.key;
        if (key !== 'Enter' && key !== ' ') return;
        event.preventDefault();
      }
      const target = event.currentTarget;
      if (!target) return;
      const orderId = target.getAttribute('data-order-id');
      if (orderId) {
        openOrderDetails(orderId, {showAll: true, filter: true});
      }
    };
    planningMissingList.querySelectorAll('tbody tr[data-order-id]').forEach(row => {
      row.addEventListener('click', handleRowActivation);
      row.addEventListener('keydown', handleRowActivation);
    });
  };

  const updatePlanningSummary = () => {
    if (!planningSummary) return;
    if (!currentUserId) {
      planningSummary.innerHTML = '<p class="planning-summary-intro">Log ind for at se dine planlagte opgaver.</p>';
      return;
    }
    if (!planningTasks.length) {
      planningSummary.innerHTML = `<p class="planning-summary-intro"><strong>${esc(currentUser.name || 'Du')}</strong> har ingen planlagte trin knyttet til sine ordinationer endnu.</p>`;
      return;
    }
    const now = new Date();
    const total = planningTasks.length;
    const doneCount = planningTasks.filter(task => task.isDone).length;
    const activeCount = total - doneCount;
    const overdueCount = planningTasks.filter(task => !task.isDone && task.dueDate && task.dueDate < now).length;
    const dueSoonCount = planningTasks.filter(task => !task.isDone && task.dueDate && task.dueDate >= now && (task.dueDate.getTime() - now.getTime()) <= 48 * 60 * 60 * 1000).length;
    const orderCount = new Set(planningTasks.map(task => task.orderId)).size;
    planningSummary.innerHTML = `
      <div class="planning-summary-intro"><strong>${esc(currentUser.name || 'Du')}</strong> har ${activeCount} aktive trin fordelt på ${orderCount} ordination${orderCount === 1 ? '' : 'er'}.</div>
      <div class="planning-summary-grid">
        <div class="planning-summary-item">
          <div class="planning-summary-value">${activeCount}</div>
          <div class="planning-summary-label">Aktive trin</div>
        </div>
        <div class="planning-summary-item">
          <div class="planning-summary-value">${doneCount}</div>
          <div class="planning-summary-label">Færdige trin</div>
        </div>
        <div class="planning-summary-item">
          <div class="planning-summary-value">${overdueCount}</div>
          <div class="planning-summary-label">Forfaldne</div>
        </div>
        <div class="planning-summary-item">
          <div class="planning-summary-value">${dueSoonCount}</div>
          <div class="planning-summary-label">Forfalder &lt; 48 timer</div>
        </div>
      </div>
    `;
  };

  const buildPlanningCard = task => {
    const metaParts = [];
    if (task.patientName) metaParts.push(task.patientName);
    if (task.sampleLabel) metaParts.push(task.sampleLabel);
    if (task.roleLabel) metaParts.push(task.roleLabel);
    const metaHtml = metaParts.length ? `<div class="planning-card-meta">${metaParts.map(part => `<span>${esc(part)}</span>`).join(' • ')}</div>` : '';
    const healthyFlag = task.healthyFamilyMember ? '<span class="planning-card-flag" title="Patienten er markeret som rask familiemedlem">Rask familiemedlem</span>' : '';
    const badgeFragments = [];
    if (healthyFlag) badgeFragments.push(healthyFlag);
    if (task.priorityHtml) badgeFragments.push(task.priorityHtml);
    const badgeHtml = badgeFragments.length ? `<div class="planning-card-badges">${badgeFragments.join('')}</div>` : '';
    const dueText = task.dueDate ? `${esc(task.dueDisplay)}${task.dueRelative ? ` (${esc(task.dueRelative)})` : ''}` : 'Ikke planlagt';
    const infoHtml = task.info.length ? `<ul class="planning-info-list">${task.info.map(item => `<li>${esc(item)}</li>`).join('')}</ul>` : '';
    const actionsHtml = task.stage.actions?.length ? task.stage.actions.map(action => `<button type="button" class="secondary planning-button" data-action="${esc(action.type)}" data-task-id="${esc(task.id)}">${esc(action.label)}</button>`).join('') : '';
    const statusOptionsList = SAMPLE_STATUSES.slice();
    const normalizedStatusOptions = new Set(statusOptionsList.map(status => status.toLowerCase()));
    if (task.sampleStatusValue && !normalizedStatusOptions.has(task.sampleStatusValue.toLowerCase())) {
      statusOptionsList.push(task.sampleStatusValue);
    }
    const statusOptionsHtml = [
      `<option value="" disabled${task.sampleStatusValue ? '' : ' selected'}>Vælg status</option>`,
      ...statusOptionsList.map(status => {
        const selectedAttr = status === task.sampleStatusValue ? ' selected' : '';
        return `<option value="${esc(status)}"${selectedAttr}>${esc(status)}</option>`;
      })
    ].join('');
    const statusControlHtml = task.sampleId
      ? `<label>Skift status
            <select class="planning-status-select" data-task-id="${esc(task.id)}" data-sample-id="${esc(task.sampleId)}" data-original-status="${esc(task.sampleStatusValue || '')}"${canModifySampleStatus ? '' : ' disabled'}>${statusOptionsHtml}</select>
          </label>`
      : '';
    const exportHtml = `
      <div class="planning-card-actions planning-card-export-actions">
        <button type="button" class="secondary planning-button" data-export="calendar" data-task-id="${esc(task.id)}">Eksportér opgave til kalender</button>
        <button type="button" class="secondary planning-button" data-export="csv" data-task-id="${esc(task.id)}">Eksportér opgave til CSV</button>
      </div>
    `;
    return `
      <article class="planning-card" data-task-id="${esc(task.id)}" data-status="${esc(task.statusKey)}" data-due="${esc(task.dueState)}" data-healthy="${task.healthyFamilyMember ? 'true' : 'false'}">
        <div class="planning-card-header">
          <div>
            <div class="planning-card-title">${esc(task.orderName)}</div>
            ${metaHtml}
          </div>
          ${badgeHtml}
        </div>
        <div class="planning-card-stage" title="${esc(task.statusDescription)}">
          <span class="planning-stage-badge">${esc(task.stage.shortLabel)}</span>
          <span class="planning-card-status-label">${esc(task.statusLabel)}</span>
        </div>
        <div class="planning-card-info">
          <span><strong>Prøvestatus:</strong> ${esc(task.sampleStatusText)}</span>
          <span><strong>Deadline:</strong> ${esc(dueText)}</span>
        </div>
        ${infoHtml ? `<div class="planning-card-extra">${infoHtml}</div>` : ''}
        <div class="planning-card-controls">
          <label>Deadline
            <input type="datetime-local" class="planning-due" data-task-id="${esc(task.id)}" value="${esc(task.dueInputValue)}">
          </label>
          <div class="planning-note-block">
            <label>Noter
              <textarea class="planning-note" data-task-id="${esc(task.id)}" placeholder="Tilføj dine noter her">${esc(task.note || '')}</textarea>
            </label>
            <div class="planning-note-actions">
              <button type="button" class="secondary planning-button planning-note-save" data-note-save data-task-id="${esc(task.id)}" disabled>Gem note</button>
              <span class="planning-note-hint">Gem når du er færdig med at skrive.</span>
            </div>
          </div>
          ${statusControlHtml}
          <label class="planning-checkbox">
            <input type="checkbox" class="planning-done" data-task-id="${esc(task.id)}" ${task.planDone ? 'checked' : ''}>
            Markér som færdig
          </label>
        </div>
        ${actionsHtml ? `<div class="planning-card-actions">${actionsHtml}</div>` : ''}
        ${exportHtml}
      </article>
    `;
  };

  const renderPlanningBoard = () => {
    if (!planningBoard) return;
    if (!currentUserId) {
      planningBoard.innerHTML = '<p class="planning-empty">Log ind for at planlægge dine opgaver.</p>';
      return;
    }
    if (!planningTasks.length) {
      planningBoard.innerHTML = '<p class="planning-empty">Ingen opgaver er knyttet til dine aktuelle ordinationer.</p>';
      return;
    }
    const hideDone = Boolean(planningHideDoneToggle?.checked);
    const hideNotStarted = Boolean(planningHideNotStartedToggle?.checked);
    const hideHealthy = Boolean(planningHideHealthyToggle?.checked);
    const lanes = planningStages.reduce((output, stage) => {
      const allStageTasks = planningTasks.filter(task => task.stage.id === stage.id);
      if (!allStageTasks.length) return output;
      const visibleTasks = allStageTasks.filter(task => {
        if (hideDone && task.isDone) return false;
        if (hideNotStarted && task.statusKey === 'pending') return false;
        if (hideHealthy && task.healthyFamilyMember) return false;
        return true;
      });
      if (!visibleTasks.length) return output;
      const laneCount = visibleTasks.length === allStageTasks.length
        ? `${allStageTasks.length}`
        : `${visibleTasks.length} af ${allStageTasks.length}`;
      const cards = visibleTasks.sort(comparePlanningTasks).map(buildPlanningCard).join('');
      output.push(`
        <section class="planning-lane" data-stage="${esc(stage.id)}">
          <header class="planning-lane-header">
            <div class="planning-stage-title">${esc(stage.label)}</div>
            <div class="planning-lane-count">${laneCount}</div>
            <p class="planning-lane-subtitle">${esc(stage.description)}</p>
          </header>
          <div class="planning-lane-body">${cards}</div>
        </section>
      `);
      return output;
    }, []);
    planningBoard.innerHTML = lanes.length
      ? lanes.join('')
      : '<p class="planning-empty">Alle opgaver i planen er markeret som færdige.</p>';
  };

  const updateExportButtons = () => {
    const hasDue = planningTasks.some(task => task.dueDate);
    if (planningExportBtn) {
      planningExportBtn.disabled = !currentUserId || !hasDue;
    }
    if (planningExportCsvBtn) {
      const hasTasks = planningTasks.length > 0;
      planningExportCsvBtn.disabled = !currentUserId || !hasTasks;
    }
  };

  const updatePlanningUi = () => {
    const view = getPlanView();
    if (planningHideDoneToggle) {
      planningHideDoneToggle.checked = view.hideDone;
    }
    if (planningHideNotStartedToggle) {
      planningHideNotStartedToggle.checked = view.hideNotStarted;
    }
    if (planningHideHealthyToggle) {
      planningHideHealthyToggle.checked = view.hideHealthy;
    }
    renderMissingAssignments();
    if (!planningBoard || !planningSummary) return;
    planningTasks = computePlanningTasks();
    if (planningHideDoneToggle) {
      const hasCompleted = planningTasks.some(task => task.isDone);
      planningHideDoneToggle.disabled = !currentUserId || !hasCompleted;
    }
    if (planningHideNotStartedToggle) {
      const hasPending = planningTasks.some(task => task.statusKey === 'pending');
      planningHideNotStartedToggle.disabled = !currentUserId || !hasPending;
    }
    if (planningHideHealthyToggle) {
      const hasHealthy = planningTasks.some(task => task.healthyFamilyMember);
      planningHideHealthyToggle.disabled = !currentUserId || !hasHealthy;
    }
    if (planningRefreshBtn) planningRefreshBtn.disabled = !currentUserId;
    updatePlanningSummary();
    renderPlanningBoard();
    updateExportButtons();
    refreshPlanningStatusText();
  };

  const refreshPlanningData = async () => {
    if (!currentUserId) {
      updatePlanningUi();
      return;
    }
    await waitForPlanPersistence();
    await loadAllStores();
    planState = loadPlanState();
    ensurePlanTasks();
    if (planStateSource === 'legacy') {
      try {
        await queuePlanPersist();
      } catch (err) {
        console.warn('Kunne ikke migrere planlægning til database:', err);
      }
    }
    updatePlanningUi();
  };

  const formatIcsDate = date => {
    const pad = value => String(value).padStart(2, '0');
    return `${date.getUTCFullYear()}${pad(date.getUTCMonth() + 1)}${pad(date.getUTCDate())}T${pad(date.getUTCHours())}${pad(date.getUTCMinutes())}${pad(date.getUTCSeconds())}Z`;
  };

  const escapeIcsText = text => {
    return text
      .split('\\').join('\\\\')
      .replace(/;/g, '\;')
      .replace(/,/g, '\,')
      .replace(/\r?\n/g, '\n');
  };

  const buildPlanningIcsText = (tasks, generatedAt = new Date()) => {
    const lines = ['BEGIN:VCALENDAR', 'VERSION:2.0', 'PRODID:-//GlimR//Planner//DA'];
    tasks.forEach(task => {
      if (!task || !task.dueDate) return;
      const dueUtc = new Date(task.dueDate.getTime());
      const summaryParts = [task.stage?.label, task.orderName].filter(Boolean);
      const summary = escapeIcsText(summaryParts.join(' – '));
      const descriptionParts = [
        task.patientName ? `Patient: ${task.patientName}` : '',
        task.sampleLabel ? `Prøve: ${task.sampleLabel}` : '',
        `Prøvestatus: ${task.sampleStatusText}`,
        task.roleLabel || '',
        ...(Array.isArray(task.info) ? task.info : []),
        task.note ? `Noter: ${task.note}` : ''
      ].filter(Boolean);
      const description = escapeIcsText(descriptionParts.join('\n'));
      lines.push('BEGIN:VTODO');
      lines.push(`UID:${escapeIcsText(task.id)}@glimr.local`);
      lines.push(`DTSTAMP:${formatIcsDate(generatedAt)}`);
      lines.push(`DUE:${formatIcsDate(dueUtc)}`);
      lines.push(`SUMMARY:${summary}`);
      if (description) lines.push(`DESCRIPTION:${description}`);
      if (task.isDone) {
        lines.push('STATUS:COMPLETED');
        lines.push(`COMPLETED:${formatIcsDate(generatedAt)}`);
      } else {
        lines.push('STATUS:NEEDS-ACTION');
      }
      lines.push('CATEGORIES:GlimR');
      lines.push('END:VTODO');
    });
    lines.push('END:VCALENDAR');
    return lines.join('\r\n');
  };

  const downloadPlanningIcs = (tasks, filename, generatedAt = new Date()) => {
    const icsText = buildPlanningIcsText(tasks, generatedAt);
    const blob = new Blob([icsText], {type: 'text/calendar'});
    const url = URL.createObjectURL(blob);
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    registerManualExport('planning_ics', {
      filename,
      taskCount: Array.isArray(tasks) ? tasks.length : 0,
      generatedAt: generatedAt?.toISOString?.() || null
    });
    return filename;
  };

  const downloadPlanningCsv = (tasks, filename, delimiter = ';') => {
    const cols = planningCsvColumns;
    const header = cols.map((col, index) => {
      const label = col.label ?? col.key ?? '';
      const displayLabel = index === 0 ? sanitizeFirstCsvHeaderLabel(label) : label;
      return escapeCsvValue(displayLabel, delimiter);
    }).join(delimiter);
    const lines = tasks.map(task => cols.map(col => {
      const raw = typeof col.value === 'function' ? col.value(task) : task?.[col.key];
      return escapeCsvValue(raw, delimiter);
    }).join(delimiter));
    const csv = [header, ...lines].join('\r\n');
    const encoded = encodeWindows1252(csv);
    const blob = new Blob([encoded], {type: 'text/csv;charset=windows-1252;'});
    const url = URL.createObjectURL(blob);
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    registerManualExport('planning_csv', {
      filename,
      taskCount: Array.isArray(tasks) ? tasks.length : 0,
      delimiter
    });
    return filename;
  };

  const buildTaskDocumentationCsvFilename = (task, userName, generatedAt = new Date()) => {
    const mrnPart = sanitizeFilenameComponent(task?.patientMrn || task?.patientName || 'ukendt');
    const userPart = sanitizeFilenameComponent(userName || 'ukendt');
    const datePart = generatedAt.toISOString().slice(0, 10);
    return `Dokumentation_${mrnPart}_${userPart}_${datePart}.csv`;
  };

  if (planningBoard && planningSummary) {
    const initialView = getPlanView();
    if (planningHideDoneToggle) planningHideDoneToggle.checked = initialView.hideDone;
    if (planningHideNotStartedToggle) planningHideNotStartedToggle.checked = initialView.hideNotStarted;
    if (planningHideHealthyToggle) planningHideHealthyToggle.checked = initialView.hideHealthy;
    updatePlanningUi();

    planningMissingRoleFilter?.addEventListener('change', () => renderMissingAssignments());
    planningHideDoneToggle?.addEventListener('change', () => {
      setPlanView({hideDone: planningHideDoneToggle.checked});
      renderPlanningBoard();
    });
    planningHideNotStartedToggle?.addEventListener('change', () => {
      setPlanView({hideNotStarted: planningHideNotStartedToggle.checked});
      renderPlanningBoard();
    });
    planningHideHealthyToggle?.addEventListener('change', () => {
      setPlanView({hideHealthy: planningHideHealthyToggle.checked});
      renderPlanningBoard();
    });

    planningRefreshBtn?.addEventListener('click', async () => {
      if (!planningRefreshBtn || planningRefreshBtn.disabled) return;
      if (!currentUserId) {
        planningRefreshBtn.disabled = true;
        setStatus('Log ind for at opdatere planen.');
        return;
      }
      planningRefreshBtn.disabled = true;
      setStatus('Gemmer ændringer i planen...');
      try {
        await flushPlannerChanges();
        setStatus('Opdaterer plan...');
        await refreshPlanningData();
        setStatus('Planen er opdateret.');
      } catch (err) {
        console.error('Kunne ikke opdatere planen:', err);
        setStatus('Kunne ikke opdatere planen: ' + (err?.message || err));
      } finally {
        if (planningRefreshBtn) planningRefreshBtn.disabled = !currentUserId;
      }
    });

    planningBoard.addEventListener('change', async event => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const taskId = target.dataset.taskId;
      if (!taskId) return;
      if (target.classList.contains('planning-due')) {
        setPlanSettings(taskId, {due: target.value});
        updatePlanningUi();
      } else if (target.classList.contains('planning-done')) {
        setPlanSettings(taskId, {done: target.checked});
        updatePlanningUi();
      } else if (target.classList.contains('planning-status-select')) {
        const sampleId = Number(target.dataset.sampleId);
        const originalStatus = target.dataset.originalStatus || '';
        const newStatus = (target instanceof HTMLSelectElement ? target.value : target.getAttribute('value') || '').trim();
        if (!Number.isFinite(sampleId)) {
          target.value = originalStatus;
          return;
        }
        if (newStatus === originalStatus) return;
        if (!ensureWrite('samples')) {
          target.value = originalStatus;
          return;
        }
        const sample = findById('samples', sampleId);
        if (!sample) {
          alert('Kunne ikke finde prøve i databasen.');
          target.value = originalStatus;
          return;
        }
        if (!newStatus) {
          target.value = originalStatus;
          return;
        }
        const trimmedStatus = newStatus;
        try {
          const beforeSample = {...sample};
          const updatedSample = {...sample, status: trimmedStatus};
          await updateRecord('samples', updatedSample, beforeSample);
          const controlSync = await syncControlSampleStatus(updatedSample, trimmedStatus);
          const relatedOrders = getCached('orders').filter(order => Number(order.sample_id) === sampleId);
          let ordersUpdated = controlSync.ordersUpdated;
          for (const order of relatedOrders) {
            if ((order.status || '') !== trimmedStatus) {
              const beforeOrder = {...order};
              const updatedOrder = {...order, status: trimmedStatus};
              await updateRecord('orders', updatedOrder, beforeOrder);
              ordersUpdated = true;
            }
          }
          await loadStore('samples');
          if (ordersUpdated) {
            await loadStore('orders');
            if (state.currentTab === 'orders') {
              renderTab('orders');
            }
          }
          target.dataset.originalStatus = trimmedStatus;
          if (target instanceof HTMLSelectElement) {
            target.value = trimmedStatus;
          }
          setStatus(`Prøvestatus opdateret til ${trimmedStatus || 'Ikke angivet'}.`);
          updatePlanningUi();
        } catch (err) {
          console.error('Kunne ikke opdatere prøvestatus:', err);
          alert('Kunne ikke opdatere prøvestatus: ' + (err?.message || err));
          target.value = originalStatus;
        }
      }
    });

    planningBoard.addEventListener('input', event => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      if (target.classList.contains('planning-note')) {
        const taskId = target.dataset.taskId;
        if (!taskId) return;
        const card = target.closest('.planning-card');
        const saveButton = card?.querySelector('.planning-note-save');
        const savedNote = getPlanSettings(taskId).note || '';
        const hasChanges = target.value !== savedNote;
        if (saveButton instanceof HTMLButtonElement) {
          saveButton.disabled = !hasChanges;
        }
        if (card instanceof HTMLElement) {
          card.classList.toggle('planning-note-dirty', hasChanges);
        }
      }
    });

    planningBoard.addEventListener('click', event => {
      if (!(event.target instanceof HTMLElement)) return;
      const noteSaveButton = event.target.closest('button[data-note-save]');
      if (noteSaveButton instanceof HTMLButtonElement) {
        if (!currentUserId) {
          alert('Log ind for at gemme noter.');
          return;
        }
        const taskId = noteSaveButton.dataset.taskId;
        if (!taskId) return;
        const card = noteSaveButton.closest('.planning-card');
        const textarea = card?.querySelector('.planning-note');
        if (!(textarea instanceof HTMLTextAreaElement)) return;
        const currentNote = textarea.value;
        const savedSettings = getPlanSettings(taskId);
        const savedNote = savedSettings.note || '';
        if (currentNote === savedNote) {
          setStatus('Ingen ændringer i noten at gemme.');
          noteSaveButton.disabled = true;
          if (card instanceof HTMLElement) {
            card.classList.remove('planning-note-dirty');
          }
          return;
        }
        const didUpdate = setPlanSettings(taskId, {note: currentNote});
        if (didUpdate) {
          const sanitizedNote = getPlanSettings(taskId).note || '';
          textarea.value = sanitizedNote;
          noteSaveButton.disabled = true;
          if (card instanceof HTMLElement) {
            card.classList.remove('planning-note-dirty');
          }
          setStatus('Noten er gemt.');
        } else {
          setStatus('Ingen ændringer i noten at gemme.');
          noteSaveButton.disabled = true;
          if (card instanceof HTMLElement) {
            card.classList.remove('planning-note-dirty');
          }
        }
        return;
      }
      const exportButton = event.target.closest('button[data-export]');
      if (exportButton) {
        if (!currentUserId) {
          alert('Log ind for at eksportere opgaver.');
          return;
        }
        const taskId = exportButton.dataset.taskId;
        if (!taskId) return;
        const tasksSnapshot = computePlanningTasks();
        const task = tasksSnapshot.find(item => item.id === taskId);
        if (!task) return;
        const exportType = exportButton.dataset.export;
        if (exportType === 'calendar') {
          if (!task.dueDate) {
            alert('Tilføj en deadline før du eksporterer opgaven til kalender.');
            return;
          }
          const generatedAt = new Date();
          const orderPart = sanitizeFilenameComponent(task.orderName || 'opgave');
          const stagePart = sanitizeFilenameComponent(task.stage?.shortLabel || task.stage?.id || 'trin');
          const filename = `GlimR-opgave-${orderPart}-${stagePart}-${generatedAt.toISOString().slice(0, 10)}.ics`;
          downloadPlanningIcs([task], filename, generatedAt);
          setStatus('Kalenderfil genereret for den valgte opgave.');
        } else if (exportType === 'csv') {
          const generatedAt = new Date();
          const filename = buildTaskDocumentationCsvFilename(task, currentUser?.name || '', generatedAt);
          downloadPlanningCsv([task], filename);
          setStatus(`CSV genereret for den valgte opgave (${filename}).`);
        }
        return;
      }
      const actionButton = event.target.closest('button[data-action]');
      if (!actionButton) return;
      const taskId = actionButton.dataset.taskId;
      if (!taskId) return;
      const task = planningTasks.find(item => item.id === taskId);
      if (!task) return;
      const action = actionButton.dataset.action;
      if (action === 'open-order') {
        openOrderDetails(task.orderId, {showAll: true});
      } else if (action === 'open-sample') {
        openSamplesForOrder(task.orderId);
      } else if (action === 'open-report') {
        openReportsForOrder(task.orderId);
      }
    });

    planningExportBtn?.addEventListener('click', () => {
      if (!currentUserId) {
        alert('Log ind for at eksportere planen.');
        return;
      }
      const exportTasks = computePlanningTasks().filter(task => task.dueDate);
      if (!exportTasks.length) {
        alert('Tilføj mindst én deadline før du eksporterer planen til kalender.');
        return;
      }
      const generatedAt = new Date();
      const filename = `GlimR-plan-${generatedAt.toISOString().slice(0, 10)}.ics`;
      downloadPlanningIcs(exportTasks, filename, generatedAt);
      setStatus(`Kalenderfil genereret med dine planlagte trin (${filename}).`);
    });

    planningExportCsvBtn?.addEventListener('click', () => {
      if (!currentUserId) {
        alert('Log ind for at eksportere planen.');
        return;
      }
      const exportTasks = computePlanningTasks();
      if (!exportTasks.length) {
        alert('Ingen opgaver at eksportere.');
        return;
      }
      const generatedAt = new Date();
      const filename = `glimr-plan-${generatedAt.toISOString().slice(0, 10)}.csv`;
      downloadPlanningCsv(exportTasks, filename);
      setStatus(`CSV genereret med dine planlagte trin (${filename}).`);
    });
  }
  applyButtonTooltips(section);
  applyControlTooltips(section);
}

function renderTools(section) {
  const STRENGTH_DEFINITIONS = {
    pathogenic: {
      veryStrong: {label: 'Meget stærk (+8)', summary: 'meget stærk', weight: 8},
      strong: {label: 'Stærk (+4)', summary: 'stærk', weight: 4},
      moderate: {label: 'Moderat (+2)', summary: 'moderat', weight: 2},
      supporting: {label: 'Supporting (+1)', summary: 'supporting', weight: 1}
    },
    benign: {
      standAlone: {label: 'Stand-alone (–8)', summary: 'stand-alone', weight: -8},
      strong: {label: 'Stærk (–4)', summary: 'stærk', weight: -4},
      supporting: {label: 'Supporting (–1)', summary: 'supporting', weight: -1}
    }
  };
  const DEFAULT_STRENGTH_ORDER = {
    pathogenic: ['veryStrong', 'strong', 'moderate', 'supporting'],
    benign: ['standAlone', 'strong', 'supporting']
  };
  const pathogenicCriteria = [
    {code: 'PVS1', label: 'Loss-of-function variant i gen hvor loss-of-function er kendt sygdomsmekanisme.', defaultStrength: 'veryStrong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Nedgrader ved usikker LoF-effekt (fx initierende exon, alternativ splejsning).', strengthGuidance: {veryStrong: 'Meget stærk når varianten forventes at udløse nonsense mediated decay eller tydelig truncering i et gen hvor loss-of-function er veletableret sygdomsmekanisme uden kendte undtagelser.', strong: 'Stærk når LoF-effekten er sandsynlig men placeret i sidste exon eller når redundans reducerer forventet fuld tabsfunktion.', moderate: 'Moderat når LoF kun delvist understøttes af modeller eller når alternative transkripter kan bevare funktion.', supporting: 'Supporting når LoF kun indikeres af indirekte data og yderligere bevis er nødvendigt for højere styrke.'}},
    {code: 'PS1', label: 'Samme aminosyreændring som kendt patogen variant uden ændret nukleotid.', defaultStrength: 'strong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Overvej styrkejustering når evidens for ækvivalens er begrænset eller stærkere end reference.', strengthGuidance: {veryStrong: 'Meget stærk når ækvivalente aminosyreændringer har omfattende klinisk dokumentation og funktionelle studier der klart viser patogenicitet.', strong: 'Stærk når referencevarianten er kurateret patogen og ækvivalensen er veldokumenteret.', moderate: 'Moderat når referencevarianten kun er sandsynligvis patogen eller dokumentationen for samme mekanisme er begrænset.', supporting: 'Supporting når ligheden primært bygger på in silico vurdering eller enkelte rapporter.'}},
    {code: 'PS2', label: 'De novo (bekræftet) hos patient med sund(e) forælder(e).', defaultStrength: 'strong', strengths: ['strong', 'moderate', 'supporting'], description: 'Kræver verifikation af forældres status. Nedgrader ved begrænset test eller phenotypematch.', strengthGuidance: {strong: 'Stærk når de novo-status er bekræftet med forældretest og fænotypen er stærkt forenelig.', moderate: 'Moderat når kun en forælder er testet, eller når fænotypen er delvist konsistent.', supporting: 'Supporting når de novo-mistanken bygger på familiesygehistorie uden fuld laboratoriebekræftelse.'}},
    {code: 'PS3', label: 'Funktionelle studier viser skadelig effekt.', defaultStrength: 'strong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Justér efter kvalitet og sygdomsrelevans af den funktionelle evidens.', strengthGuidance: {veryStrong: 'Meget stærk når validerede sygdomsrelevante assays reproducerbart demonstrerer alvorligt tab af funktion.', strong: 'Stærk når robuste funktionelle studier viser klar patologisk effekt i passende modeller.', moderate: 'Moderat når assays viser effekt men har begrænsninger i validering eller sygdomsrelevans.', supporting: 'Supporting når data kommer fra explorative modeller eller enkeltstående resultater.'}},
    {code: 'PS4', label: 'Signifikant øget forekomst i syge kontra kontroller.', defaultStrength: 'strong', strengths: ['veryStrong', 'strong', 'moderate', 'supporting'], description: 'Styrke afhænger af størrelsen på kohorter og statistisk signifikans.', strengthGuidance: {veryStrong: 'Meget stærk ved store uafhængige kohorter med odds ratio over ca. 10 og stringente kontroller.', strong: 'Stærk når case-control-data viser signifikant berigelse med passende korrigering for multiple test.', moderate: 'Moderat når kohorten er mindre eller odds ratio ligger omkring 5 med konsistente data.', supporting: 'Supporting ved begrænset men signifikant berigelse eller meta-analyser med moderate effekter.'}},
    {code: 'PM1', label: 'Hotspot/domæne uden godartede variationer.', defaultStrength: 'moderate', strengths: ['strong', 'moderate', 'supporting'], description: 'Opjuster ved veletablerede hotspots; nedgrader ved begrænset domænedata.', strengthGuidance: {strong: 'Stærk når varianten sidder i et veldefineret funktionelt hotspot med mange uafhængige patogene fund og fravær af godartede varianter.', moderate: 'Moderat for dokumenteret kritiske domæner med få godartede observationer.', supporting: 'Supporting når domænet antages vigtigt men evidensen for hotspot-status er begrænset.'}},
    {code: 'PM2', label: 'Fraværende eller ekstremt lav frekvens i kontroller.', defaultStrength: 'moderate', strengths: ['moderate', 'supporting'], description: 'Opdater med populationsdatabaser; nedgrader hvis sparsom dækning eller blandede populationer.', strengthGuidance: {moderate: 'Moderat når varianten er fraværende eller under forventet frekvens i store populationer med tilstrækkelig dækning.', supporting: 'Supporting når populationstallene er små eller når variantens fravær kun vises i enkelte datasæt.'}},
    {code: 'PM3', label: 'Påvist i trans med patogen variant i recessiv sygdom.', defaultStrength: 'moderate', strengths: ['strong', 'moderate', 'supporting'], description: 'Opjuster ved flere uafhængige observationer; kræver kendt patogen partner-variant.', strengthGuidance: {strong: 'Stærk ved flere uafhængige observationer i trans med velkarakteriserede patogene varianter eller dokumenteret compound heterozygoti.', moderate: 'Moderat når observationen er begrænset til få familier men med sikker fasebestemmelse.', supporting: 'Supporting når fase er antaget i stedet for bevist eller når partner-varianten er sandsynligvis patogen.'}},
    {code: 'PM4', label: 'Proteinaltering der påvirker læseramme eller stopper protein.', defaultStrength: 'moderate', strengths: ['strong', 'moderate', 'supporting'], description: 'Ekskluderer velkarakteriserede LoF-gen undtagelser; overvej nedgradering ved in-frame ændringer.', strengthGuidance: {strong: 'Stærk når ændringen giver trunkering før kritiske domæner uden forventet NMD-redning.', moderate: 'Moderat for in-frame deletioner/indsættelser eller truncering nær C-terminus hvor effekt er sandsynlig.', supporting: 'Supporting når strukturel påvirkning er usikker men proteinændringen er forenelig med funktionstab.'}},
    {code: 'PM5', label: 'Ny missense på samme aminosyre som anden patogen variant.', defaultStrength: 'moderate', strengths: ['moderate', 'supporting'], description: 'Forudsætter samme sygdomsmekanisme som den kendte variant; nedgrader hvis evidens er svag.', strengthGuidance: {moderate: 'Moderat når en anden nukleotidændring på samme kodon er velunderbygget patogen og mekanismen deles.', supporting: 'Supporting når referencevarianten kun er sandsynligvis patogen eller når mekanismen kan variere.'}},
    {code: 'PM6', label: 'De novo (uformelt) uden bekræftede forældre.', defaultStrength: 'moderate', strengths: ['moderate', 'supporting'], description: 'Nedgrader hvis fænotypen er mindre specifik eller forældrestatus er usikker.', strengthGuidance: {moderate: 'Moderat når de novo-status understøttes af kliniske oplysninger men genetisk test af forældre mangler.', supporting: 'Supporting når mistanken om de novo stammer fra familiehistorik eller når kun en forælder er testet.'}},
    {code: 'PP1', label: 'Segregerer med sygdommen i familien.', defaultStrength: 'supporting', strengths: ['strong', 'moderate', 'supporting'], description: 'Opgrader ved robuste LOD-beregninger; nedgrader ved få informative meioser.', strengthGuidance: {strong: 'Stærk når kombineret LOD-score er over 3 eller når flere uafhængige familier viser overbevisende segregering.', moderate: 'Moderat når LOD-score er mellem cirka 1,5 og 3 eller få men informative meioser foreligger.', supporting: 'Supporting når segregeringen ses i begrænset antal familier uden formel LOD-beregning.'}},
    {code: 'PP2', label: 'Missense i gen hvor missense er hyppig sygdomsmekanisme.', defaultStrength: 'supporting', strengths: ['moderate', 'supporting'], description: 'Kræver lav forekomst af godartede missense-varianter og LoF-dominans fraværende.', strengthGuidance: {moderate: 'Moderat når genets sygdomsmekanisme stærkt favoriserer missense-varianter og godartede missense er sjældne.', supporting: 'Supporting når data tyder på missense-sårbarhed men referencegrundlaget er begrænset.'}},
    {code: 'PP3', label: 'In silico-støtte for skadelig effekt.', defaultStrength: 'supporting', strengths: ['moderate', 'supporting'], description: 'Vurder konsistens mellem flere algoritmer; undgå brug når modeller er uenige.', strengthGuidance: {moderate: 'Moderat når flere orthogonale algoritmer og konservationsdata er samstemmende om skadelig effekt.', supporting: 'Supporting når de fleste modeller peger på skade men enkelte kilder er usikre.'}},
    {code: 'PP4', label: 'Fænotype/specifik sygdom i tråd med genet.', defaultStrength: 'supporting', strengths: ['moderate', 'supporting'], description: 'Kræver høj specificitet i fænotypen; opgrader ved veldefinerede syndromer.', strengthGuidance: {moderate: 'Moderat når patientens fænotype er højt specifik for genet eller når flere tilfælde matcher samme syndrom.', supporting: 'Supporting ved delvis overlap mellem fænotype og kendt spektrum eller når differentialdiagnoser er mulige.'}},
    {code: 'PP5', label: 'Anført som patogen af velrenommeret kilde.', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Bruges kun når kilden dokumenterer evidens og er uafhængig.', strengthGuidance: {supporting: 'Supporting når en uafhængig klinisk laboratorierapport giver transparent dokumentation for patogenicitet.'}}
  ];
  const benignCriteria = [
    {code: 'BA1', label: 'Allelfrekvens >5 % i kontroller (stand-alone).', effect: 'benign', defaultStrength: 'standAlone', strengths: ['standAlone', 'strong', 'supporting'], description: 'Kræver tilstrækkelig populationsrepræsentation og passende sygdomsprævalens.', strengthGuidance: {standAlone: 'Stand-alone når frekvensen overstiger 5 procent i en velrepræsenteret population og klart er uforenelig med sygdommens forekomst.', strong: 'Stærk når frekvensen ligger over maksimal forventet for sygdommen efter justering for penetrans men under stand-alone tærsklen.', supporting: 'Supporting når frekvensen er højere end forventet men datasættet er lille eller populationsrelevantheden begrænset.'}},
    {code: 'BS1', label: 'Allelfrekvens større end forventet for lidelsen.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Justér efter penetrans og genetisk heterogenitet.', strengthGuidance: {strong: 'Stærk når beregnet maksimumsfrekvens klart overskrides i flere populationer med god dækning.', supporting: 'Supporting når frekvensen kun svagt overstiger forventet eller når enkelte populationsdatasæt driver signalet.'}},
    {code: 'BS2', label: 'Observeret hos sund homozygot/hemizygot.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Kræver veldokumenteret fænotype og eksklusion af alder-afhængig debut.', strengthGuidance: {strong: 'Stærk når flere voksne uden sygdom er dokumenteret homozygote eller hemizygote med passende klinisk opfølgning.', supporting: 'Supporting når observationen er enkeltstående eller når opfølgningen er begrænset.'}},
    {code: 'BS3', label: 'Funktionelle studier viser ingen skadelig effekt.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Vurder assayets robusthed; nedgrader ved begrænset sygdomsrelevans.', strengthGuidance: {strong: 'Stærk når validerede sygdomsrelevante assays konsekvent viser normal funktion.', supporting: 'Supporting når assays er mindre validerede eller når resultaterne kun delvist understøtter normal funktion.'}},
    {code: 'BS4', label: 'Mangel på segregering med sygdommen.', effect: 'benign', defaultStrength: 'strong', strengths: ['strong', 'supporting'], description: 'Kræver flere informative familier; nedgrader ved mulige fenokopier.', strengthGuidance: {strong: 'Stærk når varianten ikke segregerer i flere informative familier med klare sygdomsdefinitioner.', supporting: 'Supporting når brudt segregering ses i begrænsede familier eller når fenokopier ikke kan udelukkes.'}},
    {code: 'BP1', label: 'Missense i gen hvor loss-of-function er dominerende mekanisme.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Anvendes når missense sjældent er sygdomsfremkaldende i genet.', strengthGuidance: {supporting: 'Supporting når genets kendte patogene variationer primært er loss-of-function og missense sjældent giver sygdom.'}},
    {code: 'BP2', label: 'Observeret sammen med patogen variant for dominant sygdom.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Forudsætter sikre fasedata og veldokumenteret patogen partner.', strengthGuidance: {supporting: 'Supporting når varianten findes i trans eller cis med uafhængigt patogen variant i dominant tilstand og patienten er rask.'}},
    {code: 'BP3', label: 'In-frame indel i repetitiv region uden kendt funktion.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Anvendes når indel ikke forventes at påvirke proteinfunktionen.', strengthGuidance: {supporting: 'Supporting når ændringen ligger i repetitivt motiv uden bevaret funktion og lignende variation er hyppig i raske populationer.'}},
    {code: 'BP4', label: 'In silico understøtter benign effekt.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Kræver samstemmende modeller for neutral effekt.', strengthGuidance: {supporting: 'Supporting når flere uafhængige algoritmer og konservationsdata peger på neutral eller tolerant effekt.'}},
    {code: 'BP5', label: 'Variant forklarer alternativ diagnose.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Kræver veldokumenteret alternativ årsag til fænotypen.', strengthGuidance: {supporting: 'Supporting når patientens fænotype forklares af en anden evidensbaseret genetisk diagnose og varianten er i linkage.'}},
    {code: 'BP6', label: 'Anført som godartet af velrenommeret kilde.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Brug kun når kilde dokumenterer bevis for benignitet.', strengthGuidance: {supporting: 'Supporting når et akkrediteret laboratorie eller database dokumenterer benignitet med sporbar evidens.'}},
    {code: 'BP7', label: 'Synonym variant uden splice-påvirkning.', effect: 'benign', defaultStrength: 'supporting', strengths: ['supporting'], description: 'Kræver fravær af spliceeffekt i relevante modeller.', strengthGuidance: {supporting: 'Supporting når splice-site analyser og funktionelle data viser uændret splejsning og ingen påvirkning af regulerende elementer.'}}
  ];
  const SNP_REFERENCE_BASELINE = 2.05; // Tidligere arrays (~2,05 i nordeuropæiske kohorter)
  const WGS_TARGET_BASELINE = 1.62;   // WGS-observation: "lige over 1,6" het/hom i nordeuropæiske patienter
  const WGS_BASELINE_FACTOR = WGS_TARGET_BASELINE / SNP_REFERENCE_BASELINE;
  const scaleWgsBaseline = baseline => Number((baseline * WGS_BASELINE_FACTOR).toFixed(3));
  const consanguinityProfiles = [
    {
      value: 'generic',
      label: 'Ukendt/blandet (global baseline)',
      snpBaseline: 2.0,
      wgsBaseline: scaleWgsBaseline(2.0),
      note: 'Generisk baseline; vælg WGS for helgenomdata eller SNP for ældre array-profiler.',
      defaultSelected: true
    },
    {
      value: 'northern_europe',
      label: 'Nordeuropæisk/Skandinavisk',
      snpBaseline: 2.05,
      wgsBaseline: scaleWgsBaseline(2.05),
      note: 'Kalibreret til helgenomsekventering; skandinaviske patienter viser het/hom ≈ 1,62 (≈62 % heterozygote).'
    },
    {
      value: 'southern_europe_middle_east',
      label: 'Sydeuropæisk/Mellemøstlig',
      snpBaseline: 1.85,
      wgsBaseline: scaleWgsBaseline(1.85),
      note: 'Historisk øget beslægtethed med WGS-justeret forventet het/hom omkring 1,4.'
    },
    {
      value: 'south_asia',
      label: 'Sydasiatisk',
      snpBaseline: 1.7,
      wgsBaseline: scaleWgsBaseline(1.7),
      note: 'Populationsstudier rapporterer lavere heterozygositet; WGS-justeret baseline ~1,3.'
    },
    {
      value: 'east_asia',
      label: 'Østasiatisk',
      snpBaseline: 1.95,
      wgsBaseline: scaleWgsBaseline(1.95),
      note: 'Store urbaniserede populationer med moderat heterozygositet; WGS-justeret baseline ~1,5.'
    },
    {
      value: 'sub_saharan_africa',
      label: 'Subsaharisk Afrika',
      snpBaseline: 2.3,
      wgsBaseline: scaleWgsBaseline(2.3),
      note: 'Høj genetisk diversitet; WGS viser het/hom omkring 1,8 for outbred kohorter.'
    },
    {
      value: 'americas',
      label: 'Latinamerikansk/admixed',
      snpBaseline: 2.0,
      wgsBaseline: scaleWgsBaseline(2.0),
      note: 'Stor variation – baseline sat til WGS-justeret global gennemsnitsværdi (~1,6).'
    }
  ];
  const consanguinityCategories = [
    {minF: 0.1875, title: 'Forælder-barn eller fulde søskende', detail: 'Typisk F≈25 % (1. grads slægtskab).', pedigree: 'parentChild'},
    {minF: 0.09375, title: 'Halvsøskende / onkel-niece / tante-nevø', detail: 'Typisk F≈12,5 % (1½. grad).', pedigree: 'avuncular'},
    {minF: 0.046875, title: 'Fætter/kusine (første)', detail: 'Typisk F≈6,25 % (2. grad).', pedigree: 'firstCousin'},
    {minF: 0.0234375, title: 'Fætter/kusine én gang fjernet', detail: 'Typisk F≈3,1 % (2½.–3. grad).', pedigree: 'cousinOnceRemoved'},
    {minF: 0.01171875, title: 'Anden fætter/kusine', detail: 'Typisk F≈1,6 % (3. grad).', pedigree: 'secondCousin'},
    {minF: 0.005, title: 'Fjern beslægtning (≥3.-4. led)', detail: 'Typisk F≈0,5–1 %.', pedigree: 'distant'}
  ];
  const renderPedigreeNode = (x, y, label, note = '', options = {}) => {
    const width = Number(options.width ?? 44);
    const height = Number(options.height ?? 26);
    const xPos = (x - width / 2).toFixed(1);
    const yPos = (y - height / 2).toFixed(1);
    const classes = ['pedigree-node'];
    if (options.proband) classes.push('proband');
    const nameClasses = ['pedigree-label', 'name'];
    if (options.proband) nameClasses.push('proband');
    const labelY = (y + 4).toFixed(1);
    const noteY = (y + height / 2 + 9).toFixed(1);
    return `
      <rect class="${classes.join(' ')}" x="${xPos}" y="${yPos}" width="${width.toFixed(1)}" height="${height.toFixed(1)}" rx="6" ry="6"></rect>
      <text class="${nameClasses.join(' ')}" x="${x.toFixed(1)}" y="${labelY}">${esc(label)}</text>
      ${note ? `<text class="pedigree-label" x="${x.toFixed(1)}" y="${noteY}">${esc(note)}</text>` : ''}
    `;
  };
  const renderPedigreeLine = (x1, y1, x2, y2, extraClass = '') => `
    <line class="pedigree-link${extraClass ? ' ' + extraClass : ''}" x1="${x1.toFixed(1)}" y1="${y1.toFixed(1)}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}"></line>
  `;
  const consanguinityPedigreeTemplates = {
    parentChild: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 51, 120, 51),
        renderPedigreeLine(120, 51, 120, 81),
        renderPedigreeLine(120, 81, 150, 81),
        renderPedigreeLine(70, 51, 70, 126),
        renderPedigreeLine(150, 107, 150, 126),
        renderPedigreeLine(70, 126, 150, 126),
        renderPedigreeLine(110, 126, 110, 137)
      ];
      const nodes = [
        renderPedigreeNode(70, 38, 'Forælder A', '(ældre generation)'),
        renderPedigreeNode(150, 94, 'Forælder B', '(barn af A)'),
        renderPedigreeNode(110, 150, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 220 190',
        title: `Stamtræ – ${relationText}`,
        desc: 'Illustration af et forælder-barn-forhold; fulde søskende giver tilsvarende F.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    avuncular: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 41, 150, 41),
        renderPedigreeLine(110, 41, 110, 54),
        renderPedigreeLine(70, 54, 150, 54),
        renderPedigreeLine(70, 54, 70, 60),
        renderPedigreeLine(150, 54, 150, 60),
        renderPedigreeLine(70, 85, 70, 105),
        renderPedigreeLine(150, 85, 150, 131),
        renderPedigreeLine(70, 131, 150, 131),
        renderPedigreeLine(110, 131, 110, 149)
      ];
      const nodes = [
        renderPedigreeNode(70, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(150, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(70, 72, 'Forælder A', '(søskende)'),
        renderPedigreeNode(150, 72, 'Onkel/tante', '(søskende)'),
        renderPedigreeNode(70, 118, 'Forælder B', '(barn af A)'),
        renderPedigreeNode(110, 162, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 220 200',
        title: `Stamtræ – ${relationText}`,
        desc: 'Skitsen viser et onkel/niece-forhold; halvsøskende følger samme logik.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    firstCousin: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 41, 170, 41),
        renderPedigreeLine(120, 41, 120, 56),
        renderPedigreeLine(70, 56, 170, 56),
        renderPedigreeLine(70, 56, 70, 60),
        renderPedigreeLine(170, 56, 170, 60),
        renderPedigreeLine(70, 84, 70, 106),
        renderPedigreeLine(170, 84, 170, 106),
        renderPedigreeLine(70, 130, 170, 130),
        renderPedigreeLine(120, 130, 120, 146)
      ];
      const nodes = [
        renderPedigreeNode(70, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(170, 28, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(70, 72, 'Forælder A', '(søskende)'),
        renderPedigreeNode(170, 72, 'Forælder B', '(søskende)'),
        renderPedigreeNode(70, 118, 'Forælder 1', '(barn af A)'),
        renderPedigreeNode(170, 118, 'Forælder 2', '(barn af B)'),
        renderPedigreeNode(120, 158, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 240 200',
        title: `Stamtræ – ${relationText}`,
        desc: 'Første fætre/kusiner får et barn – probanden er markeret nederst.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    cousinOnceRemoved: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(70, 37, 170, 37),
        renderPedigreeLine(120, 37, 120, 48),
        renderPedigreeLine(70, 48, 170, 48),
        renderPedigreeLine(70, 48, 70, 52),
        renderPedigreeLine(170, 48, 170, 52),
        renderPedigreeLine(70, 76, 70, 94),
        renderPedigreeLine(170, 76, 170, 94),
        renderPedigreeLine(170, 118, 170, 132),
        renderPedigreeLine(70, 117, 70, 157),
        renderPedigreeLine(70, 157, 170, 157),
        renderPedigreeLine(120, 157, 120, 167)
      ];
      const nodes = [
        renderPedigreeNode(70, 24, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(170, 24, 'Bedsteforælder', '(fælles)'),
        renderPedigreeNode(70, 64, 'Forælder A', '(søskende)'),
        renderPedigreeNode(170, 64, 'Forælder B', '(søskende)'),
        renderPedigreeNode(70, 102, 'Forælder 1', '(barn af A)'),
        renderPedigreeNode(170, 102, 'Fætter', '(barn af B)'),
        renderPedigreeNode(170, 140, 'Forælder 2', '(barn af fætter)'),
        renderPedigreeNode(120, 178, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 240 210',
        title: `Stamtræ – ${relationText}`,
        desc: 'Et første fætter/kusine-forhold med én generations forskydning.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    secondCousin: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(60, 37, 160, 37),
        renderPedigreeLine(110, 37, 110, 48),
        renderPedigreeLine(60, 48, 160, 48),
        renderPedigreeLine(60, 48, 60, 51),
        renderPedigreeLine(160, 48, 160, 51),
        renderPedigreeLine(60, 77, 60, 91),
        renderPedigreeLine(160, 77, 160, 91),
        renderPedigreeLine(60, 117, 60, 131),
        renderPedigreeLine(160, 117, 160, 131),
        renderPedigreeLine(60, 157, 160, 157),
        renderPedigreeLine(110, 157, 110, 167)
      ];
      const nodes = [
        renderPedigreeNode(60, 24, 'Oldeforælder', '(fælles)'),
        renderPedigreeNode(160, 24, 'Oldeforælder', '(fælles)'),
        renderPedigreeNode(60, 64, 'Bedsteforælder A', '(søskende)'),
        renderPedigreeNode(160, 64, 'Bedsteforælder B', '(søskende)'),
        renderPedigreeNode(60, 104, 'Forælder A', '(barn af A)'),
        renderPedigreeNode(160, 104, 'Forælder B', '(barn af B)'),
        renderPedigreeNode(60, 144, 'Forælder 1', '(barnebarn af A)'),
        renderPedigreeNode(160, 144, 'Forælder 2', '(barnebarn af B)'),
        renderPedigreeNode(110, 180, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 240 210',
        title: `Stamtræ – ${relationText}`,
        desc: 'Andet fætre/kusiner deler oldeforældre; probanden er nederst.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    },
    distant: ({relationText, detailText, inbreedingText}) => {
      const lines = [
        renderPedigreeLine(110, 34, 110, 58, 'distant'),
        renderPedigreeLine(80, 58, 140, 58, 'distant'),
        renderPedigreeLine(80, 58, 80, 92, 'distant'),
        renderPedigreeLine(140, 58, 170, 92, 'distant'),
        renderPedigreeLine(80, 118, 110, 140, 'distant'),
        renderPedigreeLine(170, 118, 170, 128, 'distant')
      ];
      const nodes = [
        renderPedigreeNode(110, 24, 'Fælles forfader'),
        renderPedigreeNode(80, 104, 'Probandens gren'),
        renderPedigreeNode(170, 104, 'Fjern gren'),
        renderPedigreeNode(170, 140, 'Fjern slægtning', '(vejledende)'),
        renderPedigreeNode(110, 170, 'Proband', '', {proband: true})
      ];
      return {
        viewBox: '0 0 220 200',
        title: `Stamtræ – ${relationText}`,
        desc: 'Illustration af fjern beslægtning med delt forfader flere led tilbage.',
        content: lines.concat(nodes).join(''),
        caption: `Proband markeret i blå. Estimeret F ${esc(inbreedingText)} (${esc(detailText)}).`
      };
    }
  };
  const consangOptions = consanguinityProfiles.map(profile => `
    <option value="${esc(profile.value)}"${profile.defaultSelected ? ' selected' : ''}>${esc(profile.label)}</option>
  `).join('');
  const BLAST_PROGRAMS = [
    {value: 'blastn', label: 'blastn – nukleotid mod nukleotid'},
    {value: 'blastp', label: 'blastp – protein mod protein'},
    {value: 'blastx', label: 'blastx – oversæt nukleotid mod protein'},
    {value: 'tblastn', label: 'tblastn – protein mod oversatte nukleotider'},
    {value: 'tblastx', label: 'tblastx – oversatte nukleotider mod oversatte nukleotider'}
  ];
  const BLAST_DATABASES = {
    blastn: [
      {value: 'nt', label: 'nt – NCBI nukleotid-database'},
      {value: 'refseq_rna', label: 'refseq_rna – RefSeq RNA'},
      {value: 'refseq_genomic', label: 'refseq_genomic – RefSeq genom'},
      {value: 'wgs', label: 'wgs – whole genome shotgun contigs'}
    ],
    blastp: [
      {value: 'nr', label: 'nr – NCBI protein'},
      {value: 'swissprot', label: 'swissprot – Swiss-Prot kurateret'},
      {value: 'refseq_protein', label: 'refseq_protein – RefSeq protein'}
    ],
    blastx: [
      {value: 'nr', label: 'nr – NCBI protein'},
      {value: 'swissprot', label: 'swissprot – Swiss-Prot kurateret'},
      {value: 'refseq_protein', label: 'refseq_protein – RefSeq protein'}
    ],
    tblastn: [
      {value: 'nt', label: 'nt – NCBI nukleotid-database'},
      {value: 'refseq_rna', label: 'refseq_rna – RefSeq RNA'},
      {value: 'refseq_genomic', label: 'refseq_genomic – RefSeq genom'}
    ],
    tblastx: [
      {value: 'nt', label: 'nt – NCBI nukleotid-database'},
      {value: 'refseq_rna', label: 'refseq_rna – RefSeq RNA'}
    ]
  };
  const DEFAULT_BLAST_PROGRAM = 'blastn';
  const DEFAULT_BLAST_DATABASE = 'nt';
  const renderBlastDatabaseOptions = (program, selectedValue) => {
    const items = BLAST_DATABASES[program] || [];
    if (!items.length) {
      return '<option value="" disabled>Ingen database tilgængelig</option>';
    }
    return items.map((item, index) => {
      const value = esc(item.value);
      const label = esc(item.label);
      const selected = selectedValue ? selectedValue === item.value : index === 0;
      return `<option value="${value}"${selected ? ' selected' : ''}>${label}</option>`;
    }).join('');
  };
  const blastProgramOptions = BLAST_PROGRAMS.map(item => {
    const value = esc(item.value);
    const label = esc(item.label);
    const selected = item.value === DEFAULT_BLAST_PROGRAM ? ' selected' : '';
    return `<option value="${value}"${selected}>${label}</option>`;
  }).join('');
  const initialBlastDatabaseOptions = renderBlastDatabaseOptions(DEFAULT_BLAST_PROGRAM, DEFAULT_BLAST_DATABASE);
  const makeCriteriaList = list => list.map(item => {
    const code = esc(item.code);
    const label = esc(item.label);
    const effectRaw = item.effect === 'benign' ? 'benign' : 'pathogenic';
    const effect = esc(effectRaw);
    const description = item.description ? ` ${item.description}` : '';
    const tooltip = esc(`${item.code} – ${item.label}${description}`);
    const allowedStrengths = Array.isArray(item.strengths) && item.strengths.length
      ? item.strengths
      : DEFAULT_STRENGTH_ORDER[effectRaw] || [];
    const validStrengths = allowedStrengths.filter(strength => STRENGTH_DEFINITIONS[effectRaw]?.[strength]);
    const fallbackStrength = DEFAULT_STRENGTH_ORDER[effectRaw]?.find(strength => STRENGTH_DEFINITIONS[effectRaw]?.[strength]);
    const defaultStrength = (item.defaultStrength && STRENGTH_DEFINITIONS[effectRaw]?.[item.defaultStrength])
      ? item.defaultStrength
      : (validStrengths[0] || fallbackStrength || 'supporting');
    const options = (validStrengths.length ? validStrengths : [defaultStrength]).map(strength => {
      const definition = STRENGTH_DEFINITIONS[effectRaw]?.[strength];
      if (!definition) return '';
      const optionLabel = esc(definition.label);
      const selected = strength === defaultStrength ? ' selected' : '';
      const guidance = item.strengthGuidance?.[strength];
      const titleAttr = guidance ? ` title="${esc(guidance)}"` : '';
      return `<option value="${strength}"${selected}${titleAttr}>${optionLabel}</option>`;
    }).join('');
    return `
    <label class="tool-criteria" title="${tooltip}">
      <input type="checkbox" class="criterion-toggle" value="${code}" data-effect="${effect}">
      <span>
        <span class="criterion-text"><strong>${code}</strong> ${label}</span>
        <span class="criterion-strength-wrapper">
          <select class="criterion-strength" data-code="${code}" data-effect="${effect}" data-default-strength="${esc(defaultStrength)}" disabled>
            ${options}
          </select>
        </span>
      </span>
    </label>
  `;
  }).join('');
  section.innerHTML = `
    <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">ACMG klassifikationshjælper</span>
        <span class="tool-subtitle">Forenklet vægtning af ACMG/AMP 2015 med opdaterede pointværdier.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>ACMG klassifikationshjælper</h3>
      <p>Vælg de kriterier der er opfyldt for varianten. Resultatet bruger en forenklet vægtning af ACMG/AMP 2015 med opdaterede pointværdier.</p>
      <form id="acmgTool">
        <div class="tool-columns">
          <fieldset>
            <legend>Patogene kriterier</legend>
            <div class="tool-criteria-list">
              ${makeCriteriaList(pathogenicCriteria)}
            </div>
          </fieldset>
          <fieldset>
            <legend>Benigne kriterier</legend>
            <div class="tool-criteria-list">
              ${makeCriteriaList(benignCriteria)}
            </div>
          </fieldset>
        </div>
        <div class="btn-row">
          <button type="button" class="secondary" id="acmgReset">Nulstil kriterier</button>
        </div>
      </form>
      <div class="tool-result" id="acmgResult">Vælg kriterier for at se forslag til klassifikation.</div>
      <p class="tool-note">Vurderingen er vejledende og kræver altid manuel gennemgang og dokumentation.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">HGVS c. nomenklaturhjælper</span>
        <span class="tool-subtitle">Byg hurtigt cDNA-notation for substitutioner, deletioner m.m.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>HGVS c. nomenklaturhjælper</h3>
      <p>Udfyld felterne for at få foreslået et gyldigt HGVS c.-udtryk til simple varianter. Vælg varianttype og angiv de relevante positioner og sekvenser.</p>
      <form id="hgvsForm">
        <div class="tool-inline">
          <label for="hgvsTranscript" title="Angiv referencetranskript (RefSeq, LRG eller tilsvarende).">
            Referencetranskript
            <input id="hgvsTranscript" name="transcript" placeholder="fx NM_000546.5">
          </label>
          <label for="hgvsType" title="Vælg varianttypen for at vise de relevante felter.">
            Varianttype
            <select id="hgvsType" name="type">
              <option value="substitution">Basiskift (substitution)</option>
              <option value="deletion">Deletion</option>
              <option value="insertion">Insertion</option>
              <option value="duplication">Duplikation</option>
              <option value="delins">Delins (deletion+insertion)</option>
            </select>
          </label>
        </div>
        <div class="tool-inline">
          <label for="hgvsStart" data-hgvs-field="start" title="Startpositionen for ændringen. Brug intronnotation ved behov (fx 123+1).">
            Position (start)
            <input id="hgvsStart" name="start" placeholder="fx 215">
          </label>
          <label for="hgvsEnd" data-hgvs-field="end" title="Slutpositionen for ændringen. Udelades for enkeltbase-varianter.">
            Position (slut)
            <input id="hgvsEnd" name="end" placeholder="fx 217">
          </label>
        </div>
        <div class="tool-inline">
          <label for="hgvsRef" data-hgvs-field="ref" title="Referencebase(r) eller slettet sekvens, hvis kendt.">
            Reference/sekvens
            <input id="hgvsRef" name="ref" placeholder="fx C eller AGT">
          </label>
          <label for="hgvsAlt" data-hgvs-field="alt" title="Ændringen, indsatte baser eller erstatningssekvens.">
            Ændring/indsættelse
            <input id="hgvsAlt" name="alt" placeholder="fx G eller TTA">
          </label>
        </div>
        <p class="tool-note">Felter skjules automatisk for varianttyper, hvor de ikke anvendes. Positioner kan skrives med intronnotation (fx 123+1).</p>
        <div class="btn-row">
          <button type="button" class="secondary" id="hgvsCopy">Kopiér notation</button>
        </div>
      </form>
      <div class="tool-result" id="hgvsResult">Udfyld felterne for at få et HGVS-forslag.</div>
      <p class="tool-note">Kontroller altid notationen mod HGVS-retningslinjerne og kliniske SOP&apos;er før rapportering.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Konsangvinitetsestimator</span>
        <span class="tool-subtitle">Oversæt het/hom-forhold til vejledende slægtskab.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Konsangvinitetsestimator</h3>
      <p>Angiv prøvens heterozygot/homozygot-forhold og vælg en befolkningsbaseline. Beregningen antager at reduktion i heterozygositet primært skyldes beslægtethed.</p>
      <form id="consangForm">
        <div class="tool-inline">
          <label for="consangRatio" title="Forholdet mellem heterozygote og homozygote varianter (fx 1,80).">
            Het/hom ratio
            <input id="consangRatio" name="ratio" inputmode="decimal" placeholder="fx 1,80">
          </label>
          <label for="consangEthnicity" title="Baseline anvendt til forventet heterozygositet.">
            Etnicitet/baggrund
            <select id="consangEthnicity" name="ethnicity">
              ${consangOptions}
            </select>
          </label>
        </div>
        <fieldset class="consang-baseline">
          <legend>Baseline-type</legend>
          <label class="radio-option" title="Brug helgenomsekventeringsdata som reference (1,62 i nordiske kohorter).">
            <input type="radio" name="consangBaseline" value="wgs" checked>
            <span>WGS-kalibreret (helgenom)</span>
          </label>
          <label class="radio-option" title="Brug tidligere SNP-array baseline uden WGS-kalibrering.">
            <input type="radio" name="consangBaseline" value="snp">
            <span>SNP-array baseline (ukalibreret)</span>
          </label>
        </fieldset>
      </form>
      <p class="tool-note" id="consangProfileNote"></p>
      <div class="tool-result" id="consangResult">Angiv et positivt het/hom-forhold for at få et estimat.</div>
      <p class="tool-note">Estimatet er vejledende og bør understøttes af andre mål (ROH, IBD, familieoplysninger) før kliniske konklusioner.</p>
      <figure class="consang-diagram" id="consangDiagram" hidden></figure>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Genomisk afstandsberegner</span>
        <span class="tool-subtitle">Beregn antal baser mellem to lokationer.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Genomisk afstandsberegner</h3>
      <p>Beregn antal baser mellem to lokationer. Indtast fx <code>chr7:55191822</code> og <code>chr7:55277778</code>.</p>
      <form id="distanceTool">
        <div class="tool-inline">
          <label for="distanceStart">Startposition<input id="distanceStart" name="start" placeholder="fx chr7:55191822"></label>
          <label for="distanceEnd">Slutposition<input id="distanceEnd" name="end" placeholder="fx 55277778"></label>
        </div>
        <div class="btn-row">
          <button type="button" class="secondary" id="distanceSwap">Byt positioner</button>
        </div>
      </form>
      <div class="tool-result" id="distanceResult">Indtast positioner for at se resultatet.</div>
      <p class="tool-note">Resultatet viser både eksklusiv (end-start) og inklusiv (end-start+1) afstand.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Genome browser opslag</span>
        <span class="tool-subtitle">Åbn koordinater, gener eller varianter direkte i Ensembl eller UCSC.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Genome browser opslag</h3>
      <p>Angiv en position (fx chr1:123456-123789), et gen (fx BRCA1) eller et variant-id (fx rs80357713) og vælg browser og reference.</p>
      <form id="genomeBrowserForm">
        <div class="tool-inline">
          <label for="genomeLookupType">
            Opslagstype
            <select id="genomeLookupType" name="lookup_type">
              <option value="position">Position</option>
              <option value="gene">Gen</option>
              <option value="variant">Variant-id</option>
            </select>
          </label>
          <label for="genomeAssembly">
            Reference
            <select id="genomeAssembly" name="assembly">
              <option value="grch38" selected>GRCh38 / hg38</option>
              <option value="grch37">GRCh37 / hg19</option>
            </select>
          </label>
          <label for="genomeBrowserChoice">
            Browser
            <select id="genomeBrowserChoice" name="browser">
              <option value="ensembl" selected>Ensembl</option>
              <option value="ucsc">UCSC Genome Browser</option>
            </select>
          </label>
        </div>
        <label for="genomeLookupValue">
          Søgeværdi
          <input id="genomeLookupValue" name="value" placeholder="fx chr7:140453136-140453250 eller BRCA1" autocomplete="off">
        </label>
        <div class="tool-inline" data-padding-row>
          <label for="genomePadding" title="Bruges når kun en enkelt position angives for at definere visningsvinduet omkring positionen.">
            Visningsvindue (bp)
            <input type="number" id="genomePadding" name="padding" min="10" max="2000000" value="1000">
          </label>
        </div>
        <div class="btn-row">
          <button type="submit" class="primary" id="genomeBrowserOpen">Åbn i ny fane</button>
          <button type="button" class="secondary" id="genomeBrowserClear">Ryd</button>
        </div>
      </form>
      <div class="tool-result" id="genomeBrowserStatus">Indtast en søgeværdi og vælg browser for at åbne visningen.</div>
      <p class="tool-note">Positioner udvides automatisk med et vindue omkring koordinatet, hvis der ikke angives et interval.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Sekvens BLAST</span>
        <span class="tool-subtitle">Send sekvenser til NCBI BLAST i en ny fane.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Sekvens BLAST</h3>
      <p>Indsæt en DNA- eller proteinsekvens og vælg program og database. Forespørgslen sendes til NCBI BLAST i en ny browserfane.</p>
      <form id="blastForm">
        <div class="tool-inline">
          <label for="blastProgram">
            Program
            <select id="blastProgram" name="program">
              ${blastProgramOptions}
            </select>
          </label>
          <label for="blastDatabase">
            Database
            <select id="blastDatabase" name="database">
              ${initialBlastDatabaseOptions}
            </select>
          </label>
          <label for="blastExpect">
            E-værdi (valgfri)
            <input id="blastExpect" name="expect" placeholder="fx 1e-5">
          </label>
        </div>
        <div class="tool-inline">
          <label for="blastTitle">
            Sekvenstitel (valgfri)
            <input id="blastTitle" name="title" placeholder="fx Patient123_variant">
          </label>
          <label for="blastOrganism">
            Organisme-filter (valgfri)
            <input id="blastOrganism" name="organism" placeholder="fx Homo sapiens [taxid:9606]">
          </label>
        </div>
        <label for="blastQuery">
          Sekvens
          <textarea id="blastQuery" name="query" rows="6" placeholder="Indsæt DNA- eller proteinsekvens (FASTA eller rå tekst)"></textarea>
        </label>
        <label class="list-toggle" id="blastMegablastRow">
          <input type="checkbox" id="blastMegablast" name="megablast" checked>
          <span>Brug MEGABLAST for højt lignende DNA-sekvenser (blastn)</span>
        </label>
        <div class="btn-row">
          <button type="submit" class="primary" id="blastSubmit">Kør BLAST (NCBI)</button>
          <button type="button" class="secondary" id="blastClear">Ryd</button>
        </div>
      </form>
      <div class="tool-result" id="blastStatus">Indsæt en sekvens og kør BLAST for at åbne resultatet hos NCBI.</div>
      <p class="tool-note">Sekvensen sendes direkte til NCBI BLAST via en ny fane og gemmes ikke i GlimR.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Primerdesign</span>
        <span class="tool-subtitle">Foreslå primerpar ud fra sekvens, målområde og ønsket Tm.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Primerdesign</h3>
      <p>Angiv en sekvens og evt. målområde for at få et forslag til forward og reverse primer baseret på simple heuristikker.</p>
      <form id="primerTool">
        <label for="primerSequence">Sekvens
          <textarea id="primerSequence" name="sequence" rows="4" placeholder="Indsæt målsekvens (DNA) her"></textarea>
        </label>
        <div class="tool-inline">
          <label for="primerStart">Amplicon-start (1-baseret)
            <input type="number" id="primerStart" name="start" min="1" placeholder="fx 120">
          </label>
          <label for="primerEnd">Amplicon-slut (1-baseret)
            <input type="number" id="primerEnd" name="end" min="1" placeholder="fx 420">
          </label>
        </div>
        <div class="tool-inline">
          <label for="primerMinLen">Minimum primerlængde
            <input type="number" id="primerMinLen" name="min_len" min="10" max="60" value="18">
          </label>
          <label for="primerMaxLen">Maksimum primerlængde
            <input type="number" id="primerMaxLen" name="max_len" min="10" max="60" value="24">
          </label>
          <label for="primerTargetTm">Ønsket Tm (°C)
            <input type="number" step="0.1" id="primerTargetTm" name="target_tm" min="30" max="80" value="60">
          </label>
        </div>
        <div class="btn-row">
          <button type="submit" class="primary" id="primerDesign">Design primere</button>
          <button type="button" class="secondary" id="primerClear">Ryd</button>
        </div>
      </form>
      <div class="tool-result" id="primerResult">Indsæt en sekvens og angiv evt. målområde for at foreslå primere.</div>
      <p class="tool-note">Primere beregnes med simple regler (Wallace-Tm og GC-clamp) og kræver laboratoriel validering før brug.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">GC- og sekvensværktøj</span>
        <span class="tool-subtitle">Analyser sekvensen for GC-indhold og reverse komplement.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>GC- og sekvensværktøj</h3>
      <p>Analyser en DNA/RNA-sekvens for længde, GC-indhold og generér reverse komplement.</p>
      <form id="gcTool">
        <label for="gcSequence">Sekvens
          <textarea id="gcSequence" name="sequence" rows="4" placeholder="Indsæt sekvens her"></textarea>
        </label>
        <div class="btn-row">
          <button type="button" class="secondary" id="gcUpper">Rens og formater</button>
          <button type="button" class="secondary" id="gcReverse">Reverse komplement</button>
        </div>
      </form>
      <div class="tool-result" id="gcResult">Indsæt en sekvens for at beregne GC%.</div>
      <p class="tool-note">Beregningen ignorerer mellemrum og tal. Ambigue baser (fx N, R, Y) medtages i længden.</p>
    </div>
  </details>`;



  applyButtonTooltips(section);
  applyControlTooltips(section);
  section.querySelectorAll('form').forEach(form => applyFormTooltips(form));

  const cleanSequence = value => value.replace(/[^A-Za-z]/g, '').toUpperCase();
  const toDnaSequence = value => cleanSequence(value).replace(/U/g, 'T');
  const COMPLEMENT_MAP = {A: 'T', T: 'A', U: 'A', G: 'C', C: 'G', Y: 'R', R: 'Y', S: 'S', W: 'W', K: 'M', M: 'K', B: 'V', V: 'B', D: 'H', H: 'D', N: 'N'};

  const acmgForm = section.querySelector('#acmgTool');
  const acmgResult = section.querySelector('#acmgResult');
  const acmgToggles = Array.from(acmgForm.querySelectorAll('.criterion-toggle'));
  const acmgReset = section.querySelector('#acmgReset');
  const formatList = list => list.length ? list.join(', ') : 'Ingen';
  const syncCriterionStrength = toggle => {
    const container = toggle.closest('.tool-criteria');
    const select = container?.querySelector('.criterion-strength');
    if (!select) return;
    if (toggle.checked) {
      select.disabled = false;
    } else {
      select.disabled = true;
      const defaultStrength = select.dataset.defaultStrength;
      if (defaultStrength) {
        select.value = defaultStrength;
      }
    }
  };
  const updateAcmgResult = () => {
    let score = 0;
    const selectedPath = [];
    const selectedBenign = [];
    acmgToggles.forEach(toggle => {
      if (!toggle.checked) return;
      const effect = toggle.dataset.effect === 'benign' ? 'benign' : 'pathogenic';
      const container = toggle.closest('.tool-criteria');
      const select = container?.querySelector('.criterion-strength');
      const strength = select?.value;
      const definition = strength ? STRENGTH_DEFINITIONS[effect]?.[strength] : null;
      const delta = definition ? definition.weight : 0;
      score += delta;
      const summaryLabel = definition?.summary;
      const entry = summaryLabel ? `${toggle.value} (${summaryLabel})` : toggle.value;
      if (effect === 'benign') {
        selectedBenign.push(entry);
      } else {
        selectedPath.push(entry);
      }
    });
    if (!selectedPath.length && !selectedBenign.length) {
      acmgResult.textContent = 'Vælg kriterier for at se forslag til klassifikation.';
      return;
    }
    let classification;
    if (score >= 10) classification = 'Patogen';
    else if (score >= 6) classification = 'Formodet patogen';
    else if (score <= -6) classification = 'Benign';
    else if (score <= -2) classification = 'Formodet benign';
    else classification = 'Usikker signifikans';
    acmgResult.innerHTML = `<strong>${classification}</strong><br>` +
      `Vægtet score: ${score}.<br>` +
      `Patogene kriterier: ${formatList(selectedPath)}.<br>` +
      `Benigne kriterier: ${formatList(selectedBenign)}.`;
  };
  acmgToggles.forEach(toggle => {
    syncCriterionStrength(toggle);
    toggle.addEventListener('change', () => syncCriterionStrength(toggle));
  });
  acmgForm.addEventListener('change', event => {
    if (event.target.classList.contains('criterion-strength') && event.target.disabled) {
      return;
    }
    updateAcmgResult();
  });
  acmgReset?.addEventListener('click', () => {
    acmgToggles.forEach(toggle => {
      toggle.checked = false;
      syncCriterionStrength(toggle);
    });
    acmgForm.querySelectorAll('.criterion-strength').forEach(select => {
      const defaultStrength = select.dataset.defaultStrength;
      if (defaultStrength) {
        select.value = defaultStrength;
      }
    });
    updateAcmgResult();
  });
  updateAcmgResult();

  const hgvsForm = section.querySelector('#hgvsForm');
  const hgvsResult = section.querySelector('#hgvsResult');
  if (hgvsForm && hgvsResult) {
    const hgvsType = hgvsForm.querySelector('#hgvsType');
    if (hgvsType) {
      const hgvsCopy = section.querySelector('#hgvsCopy');
      const hgvsFields = {
        transcript: hgvsForm.querySelector('#hgvsTranscript'),
        start: hgvsForm.querySelector('#hgvsStart'),
        end: hgvsForm.querySelector('#hgvsEnd'),
        ref: hgvsForm.querySelector('#hgvsRef'),
        alt: hgvsForm.querySelector('#hgvsAlt')
      };
      const hgvsFieldVisibility = {
        substitution: {start: true, end: false, ref: true, alt: true},
        deletion: {start: true, end: true, ref: true, alt: false},
        insertion: {start: true, end: true, ref: false, alt: true},
        duplication: {start: true, end: true, ref: false, alt: false},
        delins: {start: true, end: true, ref: true, alt: true}
      };
      const hgvsRequiredFields = {
        substitution: ['start', 'ref', 'alt'],
        deletion: ['start'],
        insertion: ['start', 'end', 'alt'],
        duplication: ['start'],
        delins: ['start', 'alt']
      };
      const hgvsFieldLabels = {
        start: 'Position (start)',
        end: 'Position (slut)',
        ref: 'Reference/sekvens',
        alt: 'Ændring/indsættelse'
      };
      const hgvsFieldControls = Array.from(hgvsForm.querySelectorAll('[data-hgvs-field]'));
      const setHgvsVisibility = type => {
        const config = hgvsFieldVisibility[type] || hgvsFieldVisibility.substitution;
        hgvsFieldControls.forEach(label => {
          const field = label.getAttribute('data-hgvs-field');
          label.hidden = config[field] === false;
        });
      };
      const normaliseTranscript = value => value.trim();
      const normaliseSequenceField = value => value.replace(/\s+/g, '').toUpperCase();
      const buildCoordinate = (start, end) => {
        if (!end || end === start) return start;
        return `${start}_${end}`;
      };
      const updateHgvsResult = () => {
        const type = hgvsType.value;
        setHgvsVisibility(type);
        const config = hgvsFieldVisibility[type] || hgvsFieldVisibility.substitution;
        const transcript = normaliseTranscript(hgvsFields.transcript?.value || '');
        const start = (hgvsFields.start?.value || '').trim();
        const rawEnd = (hgvsFields.end?.value || '').trim();
        const end = config.end === false ? '' : rawEnd;
        const rawRef = hgvsFields.ref?.value || '';
        const rawAlt = hgvsFields.alt?.value || '';
        const ref = config.ref === false ? '' : normaliseSequenceField(rawRef);
        const alt = config.alt === false ? '' : normaliseSequenceField(rawAlt);
        const required = hgvsRequiredFields[type] || hgvsRequiredFields.substitution;
        const values = {start, end, ref, alt};
        const missing = required.filter(key => !values[key]);
        if (missing.length) {
          const names = missing.map(key => hgvsFieldLabels[key] || key).join(', ');
          hgvsResult.textContent = `Udfyld følgende felter: ${names}.`;
          hgvsResult.dataset.hgvsString = '';
          return;
        }
        let coordinate = start;
        if (end) {
          coordinate = buildCoordinate(start, end);
        }
        let variantPart = '';
        switch (type) {
          case 'deletion':
            variantPart = `${coordinate}del${ref}`;
            break;
          case 'insertion':
            variantPart = `${coordinate}ins${alt}`;
            break;
          case 'duplication':
            variantPart = `${coordinate}dup${ref || ''}`;
            break;
          case 'delins':
            variantPart = `${coordinate}delins${alt}`;
            break;
          default:
            variantPart = `${coordinate}${ref}>${alt}`;
        }
        let transcriptPart = '';
        if (transcript) {
          let cleaned = transcript.replace(/\s+/g, '');
          if (/^c\./i.test(cleaned)) {
            cleaned = cleaned.replace(/^c\./i, '');
            transcriptPart = '';
          } else {
            const lower = cleaned.toLowerCase();
            const colonIndex = lower.indexOf(':c.');
            if (colonIndex !== -1) {
              cleaned = cleaned.slice(0, colonIndex);
            } else {
              cleaned = cleaned.replace(/:$/,'').replace(/:c$/i, '');
            }
            if (cleaned) {
              transcriptPart = `${cleaned}:`;
            }
          }
        }
        const notation = `${transcriptPart}c.${variantPart}`;
        hgvsResult.innerHTML = `<strong>Forslag:</strong> <code>${esc(notation)}</code>`;
        hgvsResult.dataset.hgvsString = notation;
      };
      hgvsForm.addEventListener('input', updateHgvsResult);
      hgvsType.addEventListener('change', updateHgvsResult);
      updateHgvsResult();
      hgvsCopy?.addEventListener('click', async () => {
        const notation = hgvsResult.dataset.hgvsString;
        if (!notation) {
          alert('Der er ingen notation at kopiere endnu.');
          return;
        }
        try {
          await navigator.clipboard.writeText(notation);
          setStatus(`HGVS-notation kopieret: ${notation}`);
        } catch (err) {
          console.error(err);
          alert('Kunne ikke kopiere til udklipsholderen.');
      }
    });
  }
  }

  const genomeBrowserForm = section.querySelector('#genomeBrowserForm');
  const genomeBrowserStatus = section.querySelector('#genomeBrowserStatus');
  if (genomeBrowserForm && genomeBrowserStatus) {
    const typeField = genomeBrowserForm.querySelector('#genomeLookupType');
    const assemblyField = genomeBrowserForm.querySelector('#genomeAssembly');
    const browserField = genomeBrowserForm.querySelector('#genomeBrowserChoice');
    const valueField = genomeBrowserForm.querySelector('#genomeLookupValue');
    const paddingField = genomeBrowserForm.querySelector('#genomePadding');
    const clearButton = genomeBrowserForm.querySelector('#genomeBrowserClear');
    const paddingRow = genomeBrowserForm.querySelector('[data-padding-row]');
    const placeholders = {
      position: 'fx chr7:140453136-140453250',
      gene: 'fx BRCA1',
      variant: 'fx rs80357713 eller NM_007294.3:c.68_69del'
    };
    const assemblyConfig = {
      grch38: {label: 'GRCh38 / hg38', ensemblHost: 'https://www.ensembl.org', ucscDb: 'hg38'},
      grch37: {label: 'GRCh37 / hg19', ensemblHost: 'https://grch37.ensembl.org', ucscDb: 'hg19'}
    };
    const browserLabels = {
      ensembl: 'Ensembl',
      ucsc: 'UCSC Genome Browser'
    };
    const typeStatusLabels = {
      position: 'positionen',
      gene: 'genet',
      variant: 'varianten'
    };
    const updateLookupUi = () => {
      const type = typeField?.value || 'position';
      if (valueField) {
        valueField.placeholder = placeholders[type] || 'Angiv søgeværdi';
      }
      if (paddingRow) {
        paddingRow.hidden = type !== 'position';
      }
    };
    updateLookupUi();
    typeField?.addEventListener('change', updateLookupUi);

    const parseWindowSize = () => {
      if (!paddingField) return 1000;
      const parsed = Number.parseInt(paddingField.value, 10);
      if (!Number.isFinite(parsed) || parsed <= 0) return 1000;
      return Math.min(parsed, 2000000);
    };
    const parsePositionValue = (value, windowSize) => {
      if (!value) return null;
      const normalised = value.toString().trim().replace(/\s+/g, '');
      if (!normalised) return null;
      const match = normalised.match(/^(?:chr)?([0-9]{1,2}|X|Y|M|MT)(?::(\d+)(?:-(\d+))?)?$/i);
      if (!match) return null;
      let chrom = match[1].toUpperCase();
      if (chrom === 'M') chrom = 'MT';
      let start = match[2] ? Number.parseInt(match[2], 10) : NaN;
      let end = match[3] ? Number.parseInt(match[3], 10) : NaN;
      if (!Number.isFinite(start)) return null;
      start = Math.max(1, start);
      if (Number.isFinite(end)) {
        end = Math.max(1, end);
        if (end < start) [start, end] = [end, start];
        if (end === start) end = start + 1;
      } else {
        const span = Number.isFinite(windowSize) && windowSize > 0 ? windowSize : 1000;
        const half = Math.max(1, Math.round(span / 2));
        const startCandidate = Math.max(1, start - half);
        const endCandidate = startCandidate + span;
        start = startCandidate;
        end = endCandidate;
      }
      const ensemblRange = `${chrom}:${start}-${end}`;
      const ucscChrom = chrom === 'MT' ? 'chrM' : `chr${chrom}`;
      const ucscRange = `${ucscChrom}:${start}-${end}`;
      return {chrom, start, end, ensemblRange, ucscRange, displayRange: ucscRange};
    };
    const isRsId = value => /^rs\d+$/i.test((value || '').trim());
    const buildStatusLink = (url, text) => `<a href="${esc(url)}" target="_blank" rel="noopener">${esc(text)}</a>`;

    genomeBrowserForm.addEventListener('submit', event => {
      event.preventDefault();
      const type = typeField?.value || 'position';
      const assemblyKey = assemblyField?.value || 'grch38';
      const browserKey = browserField?.value || 'ensembl';
      const assembly = assemblyConfig[assemblyKey];
      if (!assembly) {
        genomeBrowserStatus.textContent = 'Vælg en understøttet reference.';
        return;
      }
      const rawValue = (valueField?.value || '').trim();
      if (!rawValue) {
        genomeBrowserStatus.textContent = 'Angiv en søgeværdi først.';
        valueField?.focus();
        return;
      }
      let url = '';
      let displayValue = rawValue;
      if (type === 'position') {
        const windowSize = parseWindowSize();
        const parsed = parsePositionValue(rawValue, windowSize);
        if (!parsed) {
          genomeBrowserStatus.textContent = 'Kunne ikke tolke positionen. Brug formatet chr1:123456-123789.';
          return;
        }
        displayValue = parsed.displayRange;
        if (browserKey === 'ensembl') {
          url = `${assembly.ensemblHost}/Homo_sapiens/Location/View?r=${encodeURIComponent(parsed.ensemblRange)}`;
        } else if (browserKey === 'ucsc') {
          url = `https://genome.ucsc.edu/cgi-bin/hgTracks?db=${encodeURIComponent(assembly.ucscDb)}&position=${encodeURIComponent(parsed.ucscRange)}`;
        }
      } else if (type === 'gene') {
        if (browserKey === 'ensembl') {
          url = `${assembly.ensemblHost}/Multi/Search/Results?q=${encodeURIComponent(rawValue)};site=ensembl`;
        } else if (browserKey === 'ucsc') {
          url = `https://genome.ucsc.edu/cgi-bin/hgTracks?db=${encodeURIComponent(assembly.ucscDb)}&position=${encodeURIComponent(rawValue)}`;
        }
      } else {
        if (browserKey === 'ensembl') {
          if (isRsId(rawValue)) {
            url = `${assembly.ensemblHost}/Homo_sapiens/Variation/Summary?v=${encodeURIComponent(rawValue)}`;
          } else {
            url = `${assembly.ensemblHost}/Multi/Search/Results?q=${encodeURIComponent(rawValue)};site=ensembl`;
          }
        } else if (browserKey === 'ucsc') {
          url = `https://genome.ucsc.edu/cgi-bin/hgTracks?db=${encodeURIComponent(assembly.ucscDb)}&position=${encodeURIComponent(rawValue)}`;
        }
      }
      if (!url) {
        genomeBrowserStatus.textContent = 'Kombinationen understøttes ikke endnu.';
        return;
      }
      const browserLabel = browserLabels[browserKey] || browserKey;
      const opened = window.open(url, '_blank', 'noopener');
      const linkHtml = buildStatusLink(url, displayValue);
      if (opened) {
        genomeBrowserStatus.innerHTML = `<strong>Åbnede:</strong> ${linkHtml} i ${esc(browserLabel)} (${esc(assembly.label || assemblyKey)}).`;
        const typeLabel = typeStatusLabels[type] || 'opslaget';
        setStatus(`Åbnede ${typeLabel} ${displayValue} i ${browserLabel}.`);
      } else {
        genomeBrowserStatus.innerHTML = `Pop-up blev blokeret. Åbn manuelt: ${linkHtml}`;
      }
    });

    clearButton?.addEventListener('click', () => {
      genomeBrowserForm.reset();
      updateLookupUi();
      genomeBrowserStatus.textContent = 'Indtast en søgeværdi og vælg browser for at åbne visningen.';
    });
  }

  const consangForm = section.querySelector('#consangForm');
  const consangResult = section.querySelector('#consangResult');
  const consangProfileNote = section.querySelector('#consangProfileNote');
  const consangDiagram = section.querySelector('#consangDiagram');
  if (consangForm && consangResult) {
    const ratioInput = consangForm.querySelector('#consangRatio');
    const ethnicitySelect = consangForm.querySelector('#consangEthnicity');
    const baselineRadios = Array.from(consangForm.querySelectorAll('input[name="consangBaseline"]'));
    const setConsangPedigree = (relationship, inbreedingValue) => {
      if (!consangDiagram) return;
      if (!relationship) {
        consangDiagram.hidden = true;
        consangDiagram.innerHTML = '';
        return;
      }
      const templateBuilder = relationship.pedigree ? consanguinityPedigreeTemplates[relationship.pedigree] : null;
      if (typeof templateBuilder !== 'function') {
        consangDiagram.hidden = true;
        consangDiagram.innerHTML = '';
        return;
      }
      const template = templateBuilder({
        relationText: relationship.title,
        detailText: relationship.detail,
        inbreedingText: formatPercent(inbreedingValue)
      }) || {};
      const viewBox = template.viewBox || '0 0 220 200';
      const title = esc(template.title || relationship.title || 'Vejledende slægtskab');
      const desc = esc(template.desc || relationship.detail || 'Pedigree illustration');
      const caption = template.caption || '';
      if (!template.content) {
        consangDiagram.hidden = true;
        consangDiagram.innerHTML = '';
        return;
      }
      consangDiagram.hidden = false;
      consangDiagram.innerHTML = `
        <svg viewBox="${viewBox}" role="img" aria-labelledby="consangDiagramTitle consangDiagramDesc">
          <title id="consangDiagramTitle">${title}</title>
          <desc id="consangDiagramDesc">${desc}</desc>
          ${template.content}
        </svg>
        <figcaption>${caption}</figcaption>
      `;
    };
    const parseRatio = value => {
      if (!value) return NaN;
      const normalised = value.toString().replace(/\s+/g, '').replace(',', '.');
      const number = Number(normalised);
      return Number.isFinite(number) ? number : NaN;
    };
    const formatRatio = value => Number.isFinite(value)
      ? Number(value).toLocaleString('da-DK', {minimumFractionDigits: 2, maximumFractionDigits: 2})
      : '–';
    const formatPercent = value => Number.isFinite(value)
      ? Number(value).toLocaleString('da-DK', {style: 'percent', maximumFractionDigits: 1})
      : '–';
    const getBaselineRatio = (profile, mode) => {
      if (!profile) return NaN;
      if (mode === 'snp') {
        return Number(profile?.snpBaseline);
      }
      const wgs = Number(profile?.wgsBaseline ?? profile?.baseline);
      if (Number.isFinite(wgs) && wgs > 0) {
        return wgs;
      }
      return Number(profile?.snpBaseline);
    };
    const updateConsang = () => {
      setConsangPedigree(null, 0);
      const selectedValue = ethnicitySelect?.value;
      const profile = consanguinityProfiles.find(p => p.value === selectedValue) || consanguinityProfiles[0];
      const baselineMode = baselineRadios.find(r => r.checked)?.value || 'wgs';
      const baselineModeLabel = baselineMode === 'snp' ? 'SNP-array baseline' : 'WGS-kalibreret baseline';
      const baselineRatio = getBaselineRatio(profile, baselineMode);
      const baselineHet = Number.isFinite(baselineRatio) && baselineRatio > 0 ? baselineRatio / (1 + baselineRatio) : NaN;
      if (consangProfileNote) {
        let noteText = profile ? `${profile.label} (${baselineModeLabel}): ` : '';
        const snpBaseline = Number(profile?.snpBaseline);
        const hasSnpBaseline = Number.isFinite(snpBaseline) && snpBaseline > 0;
        if (Number.isFinite(baselineHet) && baselineHet > 0) {
          noteText += `forventet het/hom ≈ ${formatRatio(baselineRatio)} (${formatPercent(baselineHet)} heterozygote)`;
          if (hasSnpBaseline && Math.abs(snpBaseline - baselineRatio) > 0.001) {
            noteText += ` – kalibreret fra SNP baseline ${formatRatio(snpBaseline)} (faktor ${formatRatio(WGS_BASELINE_FACTOR)} ≈ ${formatPercent(WGS_BASELINE_FACTOR)} af SNP-niveauet)`;
          }
          noteText += '.';
        } else {
          noteText += 'forventet het/hom ikke tilgængeligt.';
        }
        if (profile?.note) {
          noteText += ` ${profile.note}`;
        }
        consangProfileNote.textContent = noteText.trim();
      }
      if (!Number.isFinite(baselineRatio) || baselineRatio <= 0 || !Number.isFinite(baselineHet) || baselineHet <= 0) {
        consangResult.textContent = 'Baseline for den valgte baggrund er ikke tilstrækkeligt defineret.';
        return;
      }
      const ratio = parseRatio(ratioInput?.value || '');
      if (!Number.isFinite(ratio) || ratio <= 0) {
        consangResult.textContent = 'Angiv et positivt het/hom-forhold for at få et estimat.';
        return;
      }
      const observedHet = ratio / (1 + ratio);
      if (!Number.isFinite(observedHet) || observedHet <= 0) {
        consangResult.textContent = 'Kunne ikke beregne heterozygositet ud fra de angivne værdier.';
        return;
      }
      const heterozygosityRatio = observedHet / baselineHet;
      let inbreedingCoefficient = 1 - heterozygosityRatio;
      if (!Number.isFinite(inbreedingCoefficient)) {
        consangResult.textContent = 'Kunne ikke beregne estimat fra værdierne.';
        return;
      }
      inbreedingCoefficient = Math.max(0, Math.min(inbreedingCoefficient, 1));
      const relationship = consanguinityCategories.find(cat => inbreedingCoefficient >= cat.minF) || null;
      const relationText = relationship ? `${relationship.title} (${relationship.detail})` : 'Ingen tydelig forhøjet konsangvinitet (F < 0,5 %).';
      const baselineHetPct = formatPercent(baselineHet);
      const observedHetPct = formatPercent(observedHet);
      const retentionPct = formatPercent(heterozygosityRatio);
      const Fpct = formatPercent(inbreedingCoefficient);
      setConsangPedigree(relationship, inbreedingCoefficient);
      consangResult.innerHTML = `<strong>Forventet het/hom (${baselineModeLabel}):</strong> ${formatRatio(baselineRatio)} (${baselineHetPct} heterozygote)<br>` +
        `<strong>Observeret:</strong> ${formatRatio(ratio)} (${observedHetPct} heterozygote)<br>` +
        `<strong>Bevaret heterozygositet:</strong> ${retentionPct}<br>` +
        `<strong>Estimeret inavlskoefficient (F):</strong> ${Fpct}<br>` +
        `<strong>Vejledende slægtskab:</strong> ${esc(relationText)}.`;
    };
    if (ratioInput) {
      ratioInput.addEventListener('input', updateConsang);
      ratioInput.addEventListener('blur', updateConsang);
    }
    ethnicitySelect?.addEventListener('change', updateConsang);
    baselineRadios.forEach(radio => radio.addEventListener('change', updateConsang));
    updateConsang();
  }

  const distanceForm = section.querySelector('#distanceTool');
  const distanceResult = section.querySelector('#distanceResult');
  const distanceStart = distanceForm.querySelector('#distanceStart');
  const distanceEnd = distanceForm.querySelector('#distanceEnd');
  const parsePosition = value => {
    if (!value) return NaN;
    const cleaned = value.replace(/,/g, '');
    const matches = cleaned.match(/-?\d+/g);
    if (!matches) return NaN;
    return Number(matches[matches.length - 1]);
  };
  const updateDistance = () => {
    const startVal = parsePosition(distanceStart.value);
    const endVal = parsePosition(distanceEnd.value);
    if (!Number.isFinite(startVal) || !Number.isFinite(endVal)) {
      distanceResult.textContent = 'Indtast gyldige numeriske positioner for begge felter.';
      return;
    }
    const diff = Math.abs(endVal - startVal);
    const inclusive = diff + 1;
    const orientation = endVal === startVal ? 'samme position' : endVal > startVal ? 'stigende koordinater' : 'faldende koordinater';
    distanceResult.innerHTML = `<strong>Eksklusiv afstand:</strong> ${diff.toLocaleString('da-DK')} baser` +
      `<br><strong>Inklusiv afstand:</strong> ${inclusive.toLocaleString('da-DK')} baser` +
      `<br><span class="tool-note">Fortolkning: ${orientation}.</span>`;
  };
  distanceForm.addEventListener('input', updateDistance);
  section.querySelector('#distanceSwap')?.addEventListener('click', () => {
    const tmp = distanceStart.value;
    distanceStart.value = distanceEnd.value;
    distanceEnd.value = tmp;
    updateDistance();
  });
  updateDistance();

  const blastForm = section.querySelector('#blastForm');
  const blastStatus = section.querySelector('#blastStatus');
  if (blastForm && blastStatus) {
    const sequenceInput = blastForm.querySelector('#blastQuery');
    const titleInput = blastForm.querySelector('#blastTitle');
    const programSelect = blastForm.querySelector('#blastProgram');
    const databaseSelect = blastForm.querySelector('#blastDatabase');
    const organismInput = blastForm.querySelector('#blastOrganism');
    const expectInput = blastForm.querySelector('#blastExpect');
    const megablastToggle = blastForm.querySelector('#blastMegablast');
    const megablastRow = blastForm.querySelector('#blastMegablastRow');
    let lastMegablastState = megablastToggle?.checked ?? true;

    const updateBlastDatabases = () => {
      if (programSelect && databaseSelect) {
        const program = programSelect.value || DEFAULT_BLAST_PROGRAM;
        const current = databaseSelect.value;
        databaseSelect.innerHTML = renderBlastDatabaseOptions(program, current);
        if (!Array.from(databaseSelect.options).some(opt => opt.selected) && databaseSelect.options.length) {
          databaseSelect.selectedIndex = 0;
        }
        if (megablastRow) {
          const isBlastn = program === 'blastn';
          megablastRow.hidden = !isBlastn;
          if (megablastToggle) {
            if (!isBlastn) {
              lastMegablastState = megablastToggle.checked;
              megablastToggle.checked = false;
            } else {
              megablastToggle.checked = lastMegablastState;
            }
          }
        }
      }
    };

    const normaliseFastaTitle = title => {
      return (title || '')
        .trim()
        .replace(/\s+/g, '_')
        .replace(/[^A-Za-z0-9_.-]/g, '_')
        .slice(0, 80);
    };

    const wrapSequence = seq => seq.replace(/(.{1,70})/g, '$1\n').trim();

    const ensureFastaInput = (title, text) => {
      const trimmed = (text || '').replace(/\r\n/g, '\n').trim();
      if (!trimmed) return '';
      if (trimmed.startsWith('>')) {
        return trimmed;
      }
      const sequence = trimmed.replace(/[^A-Za-z*\-]/g, '').toUpperCase();
      if (!sequence) return '';
      const safeTitle = normaliseFastaTitle(title) || 'Query';
      return `>${safeTitle}\n${wrapSequence(sequence)}`;
    };

    const countLetters = text => (text || '').replace(/^>.*$/gm, '').replace(/[^A-Za-z]/g, '').length;

    updateBlastDatabases();
    programSelect?.addEventListener('change', updateBlastDatabases);

    blastForm.addEventListener('submit', event => {
      event.preventDefault();
      const raw = sequenceInput?.value || '';
      const letters = countLetters(raw);
      if (!letters) {
        blastStatus.textContent = 'Indsæt en sekvens før du kører BLAST.';
        sequenceInput?.focus();
        return;
      }
      if (letters < 10) {
        blastStatus.textContent = 'Sekvensen er meget kort – BLAST kræver typisk mindst 10 baser/aminosyrer.';
        sequenceInput?.focus();
        return;
      }
      const fasta = ensureFastaInput(titleInput?.value || '', raw);
      if (!fasta) {
        blastStatus.textContent = 'Kunne ikke formatere sekvensen til FASTA. Kontroller indholdet.';
        return;
      }
      const program = programSelect?.value;
      if (!program) {
        blastStatus.textContent = 'Vælg et BLAST-program.';
        programSelect?.focus();
        return;
      }
      const database = databaseSelect?.value;
      if (!database) {
        blastStatus.textContent = 'Vælg en database for søgningen.';
        databaseSelect?.focus();
        return;
      }
      const hiddenForm = document.createElement('form');
      hiddenForm.method = 'post';
      hiddenForm.action = 'https://blast.ncbi.nlm.nih.gov/Blast.cgi';
      hiddenForm.target = '_blank';
      const appendField = (name, value) => {
        if (value === undefined || value === null || value === '') return;
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = name;
        input.value = value;
        hiddenForm.appendChild(input);
      };
      appendField('CMD', 'Put');
      appendField('PROGRAM', program);
      appendField('DATABASE', database);
      appendField('QUERY', fasta);
      const expect = expectInput?.value.trim();
      if (expect) appendField('EXPECT', expect);
      const organism = organismInput?.value.trim();
      if (organism) appendField('ENTREZ_QUERY', organism);
      if (program === 'blastn' && megablastToggle?.checked) {
        appendField('MEGABLAST', 'on');
      }
      appendField('CLIENT', 'GlimR');
      document.body.appendChild(hiddenForm);
      const offline = typeof navigator !== 'undefined' && navigator && navigator.onLine === false;
      if (offline) {
        blastStatus.textContent = 'Forsøger at åbne NCBI BLAST, men der er ingen registreret internetforbindelse.';
      } else {
        blastStatus.textContent = 'Sekvens sendt til NCBI BLAST i en ny fane. Følg status i den åbne fane.';
      }
      try {
        hiddenForm.submit();
        setStatus('BLAST-forespørgsel åbnet i ny fane.');
      } catch (err) {
        console.error(err);
        blastStatus.textContent = 'Kunne ikke åbne NCBI BLAST. Kontrollér popup-blokering og internetforbindelse.';
      } finally {
        window.setTimeout(() => hiddenForm.remove(), 1000);
      }
    });

    section.querySelector('#blastClear')?.addEventListener('click', () => {
      if (sequenceInput) sequenceInput.value = '';
      if (titleInput) titleInput.value = '';
      if (organismInput) organismInput.value = '';
      if (expectInput) expectInput.value = '';
      if (programSelect) programSelect.value = DEFAULT_BLAST_PROGRAM;
      updateBlastDatabases();
      if (megablastToggle) {
        megablastToggle.checked = true;
        lastMegablastState = true;
      }
      blastStatus.textContent = 'Indsæt en sekvens og kør BLAST for at åbne resultatet hos NCBI.';
      sequenceInput?.focus();
    });
  }

  const primerForm = section.querySelector('#primerTool');
  if (primerForm) {
    const primerResult = section.querySelector('#primerResult');
    const sequenceField = primerForm.querySelector('#primerSequence');
    const startField = primerForm.querySelector('#primerStart');
    const endField = primerForm.querySelector('#primerEnd');
    const minLenField = primerForm.querySelector('#primerMinLen');
    const maxLenField = primerForm.querySelector('#primerMaxLen');
    const targetTmField = primerForm.querySelector('#primerTargetTm');
    const reverseComplement = seq => seq.split('').reverse().map(base => COMPLEMENT_MAP[base] || base).join('');
    const calculateTm = seq => {
      const gcCount = (seq.match(/[GC]/g) || []).length;
      const atCount = seq.length - gcCount;
      return (4 * gcCount) + (2 * atCount);
    };
    const calculateGc = seq => {
      if (!seq.length) return 0;
      const gcCount = (seq.match(/[GC]/g) || []).length;
      return (gcCount / seq.length) * 100;
    };
    const hasHomopolymer = seq => /([ACGT])\1{3,}/.test(seq);
    const readPositiveInt = (field, fallback) => {
      if (!field) return fallback;
      const value = (field.value || '').trim();
      if (!value) return fallback;
      const parsed = Number.parseInt(value, 10);
      return Number.isFinite(parsed) && parsed > 0 ? parsed : NaN;
    };
    const readNumber = (field, fallback) => {
      if (!field) return fallback;
      const value = (field.value || '').trim();
      if (!value) return fallback;
      const normalised = value.replace(',', '.');
      const parsed = Number.parseFloat(normalised);
      return Number.isFinite(parsed) ? parsed : NaN;
    };
    const buildWarnings = primer => {
      const warnings = [];
      if (!primer.clamp) warnings.push('Manglende GC-clamp i 3′-enden');
      if (primer.gc < 35 || primer.gc > 65) warnings.push('GC% uden for 35–65 %');
      if (primer.homopolymer) warnings.push('Homopolymer på ≥4 baser');
      return warnings;
    };
    const designPrimers = () => {
      const template = toDnaSequence(sequenceField?.value || '');
      if (!template.length) {
        primerResult.textContent = 'Indsæt en sekvens for at foreslå primere.';
        return;
      }
      let start = readPositiveInt(startField, 1);
      let end = readPositiveInt(endField, template.length);
      if (Number.isNaN(start) || Number.isNaN(end)) {
        primerResult.textContent = 'Angiv gyldige tal for start og slut (1-baseret).';
        return;
      }
      start = Math.max(1, Math.min(start, template.length));
      end = Math.max(1, Math.min(end, template.length));
      if (start > end) {
        const tmp = start;
        start = end;
        end = tmp;
      }
      let minLen = readPositiveInt(minLenField, 18);
      let maxLen = readPositiveInt(maxLenField, 24);
      if (Number.isNaN(minLen) || Number.isNaN(maxLen)) {
        primerResult.textContent = 'Angiv gyldige primerlængder.';
        return;
      }
      if (minLen > maxLen) [minLen, maxLen] = [maxLen, minLen];
      minLen = Math.max(10, Math.min(minLen, 60));
      maxLen = Math.max(minLen, Math.min(maxLen, 60));
      let targetTm = readNumber(targetTmField, 60);
      if (Number.isNaN(targetTm)) targetTm = 60;
      targetTm = Math.max(30, Math.min(targetTm, 80));
      const regionStartIndex = start - 1;
      const regionEndIndex = end - 1;
      if (regionEndIndex - regionStartIndex + 1 < minLen) {
        primerResult.textContent = 'Målområdet er kortere end den ønskede primerlængde.';
        return;
      }
      const invalidPattern = /[^ACGT]/;
      const searchWindow = 80;
      const evaluateForward = () => {
        let best = null;
        const limit = Math.min(regionEndIndex - minLen + 1, regionStartIndex + searchWindow);
        for (let pos = regionStartIndex; pos <= limit; pos++) {
          const maxLenAtPos = Math.min(maxLen, regionEndIndex - pos + 1);
          for (let len = minLen; len <= maxLenAtPos; len++) {
            const candidate = template.slice(pos, pos + len);
            if (!candidate || invalidPattern.test(candidate)) continue;
            const tm = calculateTm(candidate);
            const gc = calculateGc(candidate);
            const clamp = /[GC]$/.test(candidate);
            const homopolymer = hasHomopolymer(candidate);
            const score = Math.abs(tm - targetTm) + (clamp ? 0 : 1.5) + ((gc < 35 || gc > 65) ? 0.5 : 0) + (homopolymer ? 0.75 : 0) + ((pos - regionStartIndex) * 0.02);
            if (!best || score < best.score) {
              best = {
                sequence: candidate,
                tm,
                gc,
                clamp,
                homopolymer,
                length: len,
                start: pos + 1,
                end: pos + len,
                score
              };
            }
          }
        }
        return best;
      };
      const evaluateReverse = () => {
        let best = null;
        const startLimit = Math.max(regionStartIndex + minLen - 1, regionEndIndex - searchWindow);
        for (let endPos = regionEndIndex; endPos >= startLimit; endPos--) {
          const maxLenAtPos = Math.min(maxLen, endPos - regionStartIndex + 1);
          for (let len = minLen; len <= maxLenAtPos; len++) {
            const startPos = endPos - len + 1;
            if (startPos < regionStartIndex) continue;
            const templateSegment = template.slice(startPos, endPos + 1);
            if (!templateSegment || invalidPattern.test(templateSegment)) continue;
            const primerSeq = reverseComplement(templateSegment);
            const tm = calculateTm(primerSeq);
            const gc = calculateGc(primerSeq);
            const clamp = /[GC]$/.test(primerSeq);
            const homopolymer = hasHomopolymer(primerSeq);
            const score = Math.abs(tm - targetTm) + (clamp ? 0 : 1.5) + ((gc < 35 || gc > 65) ? 0.5 : 0) + (homopolymer ? 0.75 : 0) + ((regionEndIndex - endPos) * 0.02);
            if (!best || score < best.score) {
              best = {
                sequence: primerSeq,
                tm,
                gc,
                clamp,
                homopolymer,
                length: len,
                start: startPos + 1,
                end: endPos + 1,
                score
              };
            }
          }
        }
        return best;
      };
      const forward = evaluateForward();
      const reverse = evaluateReverse();
      if (!forward || !reverse) {
        primerResult.textContent = 'Kunne ikke finde egnede primere. Justér længder, Tm eller målområde.';
        return;
      }
      const tmDelta = Math.abs(forward.tm - reverse.tm);
      const ampliconSize = (reverse.end - forward.start) + 1;
      if (ampliconSize <= 0) {
        primerResult.textContent = 'Primere overlapper hinanden – udvid målområdet eller justér parametre.';
        return;
      }
      const forwardWarnings = buildWarnings(forward);
      const reverseWarnings = buildWarnings(reverse);
      const summaryLines = [
        `<strong>Amplicon:</strong> ${forward.start.toLocaleString('da-DK')}–${reverse.end.toLocaleString('da-DK')} (${ampliconSize.toLocaleString('da-DK')} bp)`,
        `<strong>Forward primer (5′→3′)</strong> ${forward.sequence}`,
        `• Position: ${forward.start.toLocaleString('da-DK')}–${forward.end.toLocaleString('da-DK')} | Længde: ${forward.length} bp | GC: ${forward.gc.toFixed(1)} % | Tm: ${forward.tm.toFixed(1)} °C${forward.clamp ? ' | 3′-ende: GC-clamp' : ''}`,
        forwardWarnings.length ? `• Bemærkninger: ${forwardWarnings.join('; ')}` : '',
        `<strong>Reverse primer (5′→3′)</strong> ${reverse.sequence}`,
        `• Position: ${reverse.start.toLocaleString('da-DK')}–${reverse.end.toLocaleString('da-DK')} | Længde: ${reverse.length} bp | GC: ${reverse.gc.toFixed(1)} % | Tm: ${reverse.tm.toFixed(1)} °C${reverse.clamp ? ' | 3′-ende: GC-clamp' : ''}`,
        reverseWarnings.length ? `• Bemærkninger: ${reverseWarnings.join('; ')}` : '',
        `ΔTm mellem primere: ${tmDelta.toFixed(1)} °C (mål: ${targetTm.toFixed(1)} °C)`
      ].filter(Boolean);
      if (tmDelta > 3) {
        summaryLines.push('Advarsel: Stor forskel i Tm – overvej at justere længder eller målområde.');
      }
      primerResult.innerHTML = summaryLines.join('<br>');
    };
    primerForm.addEventListener('submit', e => {
      e.preventDefault();
      designPrimers();
    });
    section.querySelector('#primerClear')?.addEventListener('click', () => {
      primerForm.reset();
      primerResult.textContent = 'Indsæt en sekvens og angiv evt. målområde for at foreslå primere.';
      sequenceField?.focus();
    });
  }

  const gcTextarea = section.querySelector('#gcSequence');
  const gcResult = section.querySelector('#gcResult');
  const gcUpper = section.querySelector('#gcUpper');
  const gcReverse = section.querySelector('#gcReverse');
  const normaliseSequence = value => value.replace(/[^A-Za-z]/g, '').toUpperCase();
  const updateGc = () => {
    const seq = normaliseSequence(gcTextarea.value);
    if (!seq.length) {
      gcResult.textContent = 'Indsæt en sekvens for at beregne GC%.';
      return;
    }
    const gcCount = (seq.match(/[GC]/g) || []).length;
    const atCount = (seq.match(/[ATU]/g) || []).length;
    const nCount = (seq.match(/[N]/g) || []).length;
    const otherCount = seq.length - (gcCount + atCount + nCount);
    const gcPct = (gcCount / seq.length) * 100;
    gcResult.innerHTML = `<strong>Længde:</strong> ${seq.length.toLocaleString('da-DK')} baser` +
      `<br><strong>GC-indhold:</strong> ${gcPct.toFixed(1)} % (${gcCount} G/C)` +
      `<br><strong>A/T/U:</strong> ${atCount}` +
      `<br><strong>N/andre:</strong> ${nCount + otherCount}`;
  };
  gcTextarea.addEventListener('input', updateGc);
  gcUpper?.addEventListener('click', () => {
    gcTextarea.value = normaliseSequence(gcTextarea.value);
    updateGc();
  });
  gcReverse?.addEventListener('click', () => {
    const seq = normaliseSequence(gcTextarea.value);
    if (!seq.length) {
      gcResult.textContent = 'Indsæt en sekvens for at beregne GC%.';
      return;
    }
    const reversed = seq.split('').reverse().map(base => COMPLEMENT_MAP[base] || base).join('');
    gcTextarea.value = reversed;
    updateGc();
  });
  updateGc();
}

function renderResponses(section) {
  const list = getCached('responses').slice().reverse();
  const uniqueSenders = Array.from(new Set(list.map(r => (r.sender || '').trim()).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const senderOptions = uniqueSenders.map(sender => `<option value="${esc(sender)}">${esc(sender)}</option>`).join('');
  const templates = getCached('fhir_templates').slice().sort((a, b) => (a?.name || '').localeCompare(b?.name || '', 'da'));
  const templateOptions = templates
    .map((tpl, index) => `<option value="${tpl.id}"${index === 0 ? ' selected' : ''}>${esc(tpl.name || `Skabelon ${tpl.id}`)}</option>`)
    .join('');
  const templateSelectOptions = templates.length
    ? `${templateOptions}<option value="">Standard (basisformat)</option>`
    : '<option value="" selected>Standard (basisformat)</option>';
  section.innerHTML = `
  <div class="panel">
    <div class="panel-header">
      <h2>Importerede MedCom/FHIR-svar</h2>
      <div class="response-controls">
        <div class="filter-field">
          <label for="responseSearch">Søg</label>
          <input type="search" id="responseSearch" placeholder="Filtrer svar...">
        </div>
        <div class="filter-field">
          <label for="responseSenderFilter">Sender</label>
          <div class="filterable-select">
            <input type="search" data-select-filter placeholder="Filtrer afsendere">
            <select id="responseSenderFilter">
              <option value="">Alle afsendere</option>
              ${senderOptions}
            </select>
          </div>
        </div>
        <label class="secondary" id="fhirImportLabel" style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.4rem 0.8rem;border-radius:0.5rem;cursor:pointer;">Importér FHIR...
          <input type="file" id="fhirImport" accept="application/json" style="display:none;">
        </label>
      </div>
    </div>
    <p class="panel-hint" data-response-count></p>
    <table><thead><tr><th>Tid</th><th>Sender</th><th>Patient</th><th>Rapport</th><th>Varianter</th></tr></thead><tbody data-response-rows></tbody></table>
  </div>
  <div class="panel">
    <h2>Udgående MedCom-svar</h2>
    <label>Vælg ordre
      <div class="filterable-select">
        <input type="search" data-select-filter placeholder="Filtrer ordinationer">
        <select id="fhirOrderSelect"><option value="">Vælg...</option>${getCached('orders').map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}</select>
      </div>
    </label>
    <label>Vælg skabelon
      <div class="filterable-select">
        <input type="search" data-select-filter placeholder="Filtrer skabeloner">
        <select id="fhirTemplateSelect">${templateSelectOptions}</select>
      </div>
    </label>
    <div class="fhir-template-summary" data-template-summary>
      <p class="form-hint">${templates.length ? 'Vælg en skabelon for at se detaljer om profiler og levering.' : 'Opret skabeloner under Administration for at målrette FHIR-eksporten.'}</p>
    </div>
    <div class="btn-row">
      <button class="primary" id="generateFhir">Generér FHIR-bundle</button>
      <button class="secondary" id="previewFhir">Forhåndsvis</button>
    </div>
    <pre id="fhirPreview" style="display:none"></pre>
  </div>`;
  annotateHeaders(section);
  annotateSearchInputs(section);
  applySelectFilters(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  const orderLabel = section.querySelector('#fhirOrderSelect')?.closest('label');
  if (orderLabel) setTooltip(orderLabel, tooltipCatalog.controls.fhirOrderSelect);
  const templateSelect = section.querySelector('#fhirTemplateSelect');
  const templateLabel = templateSelect?.closest('label');
  if (templateLabel) setTooltip(templateLabel, tooltipCatalog.controls.fhirTemplateSelect);
  const templateSummary = section.querySelector('[data-template-summary]');
  if (templateSummary) setTooltip(templateSummary, tooltipCatalog.controls.fhirTemplateSummary);
  const previewBox = section.querySelector('#fhirPreview');
  const findTemplate = value => {
    if (!value) return null;
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) return null;
    return templates.find(tpl => Number(tpl.id) === numeric) || null;
  };
  const renderTemplateSummary = () => {
    if (!templateSummary) return;
    const template = findTemplate(templateSelect?.value);
    if (!template) {
      templateSummary.innerHTML = '<p class="form-hint">Standard (basisformat) udsender DiagnosticReport og variantobservationer uden ekstra profiler.</p>';
      return;
    }
    const rows = [];
    if (template.target_system) rows.push(`<dt>Modtager</dt><dd>${esc(template.target_system)}</dd>`);
    if (template.message_event_display || template.message_event_code) {
      const label = [template.message_event_display, template.message_event_code].filter(Boolean).map(esc).join(' – ');
      rows.push(`<dt>MedCom-event</dt><dd>${label}</dd>`);
    }
    if (template.bundle_profile) rows.push(`<dt>Bundle-profil</dt><dd>${esc(template.bundle_profile)}</dd>`);
    if (template.message_profile) rows.push(`<dt>Header-profil</dt><dd>${esc(template.message_profile)}</dd>`);
    if (template.diagnostic_report_profile) rows.push(`<dt>DiagnosticReport-profil</dt><dd>${esc(template.diagnostic_report_profile)}</dd>`);
    if (template.observation_profile) rows.push(`<dt>Observation-profil</dt><dd>${esc(template.observation_profile)}</dd>`);
    if (template.destination_name || template.destination_endpoint) {
      const destParts = [template.destination_name, template.destination_endpoint].filter(Boolean).map(part => esc(part)).join('<br>');
      rows.push(`<dt>Destination</dt><dd>${destParts}</dd>`);
    }
    if (template.destination_identifier_value || template.destination_identifier_system) {
      const identifier = [template.destination_identifier_system, template.destination_identifier_value].filter(Boolean).map(esc).join(' · ');
      rows.push(`<dt>Destination-ID</dt><dd>${identifier}</dd>`);
    }
    const boolRow = (label, value) => rows.push(`<dt>${label}</dt><dd>${value ? 'Ja' : 'Nej'}</dd>`);
    boolRow('Journalnotat', Boolean(template.include_composition));
    boolRow('Variantobservationer', template.include_variant_observations !== false);
    boolRow('Rapportbilag', Boolean(template.include_document_reference));
    templateSummary.innerHTML = `
      <p class="form-hint">${esc(template.description || 'Skabelonen er ikke beskrevet endnu.')}</p>
      ${rows.length ? `<dl class="template-summary-list">${rows.join('')}</dl>` : ''}
    `;
  };
  const responseRows = section.querySelector('[data-response-rows]');
  const searchInput = section.querySelector('#responseSearch');
  const senderFilter = section.querySelector('#responseSenderFilter');
  const countLabel = section.querySelector('[data-response-count]');
  const renderRows = () => {
    const term = (searchInput?.value || '').trim().toLowerCase();
    const senderValue = senderFilter?.value || '';
    const filtered = list.filter(entry => {
      if (senderValue && entry.sender !== senderValue) return false;
      if (!term) return true;
      const fields = [entry.ts, entry.sender, entry.patient, entry.diagnostic_report_id, entry.variant_count, entry.variants];
      return fields.some(value => (value || '').toString().toLowerCase().includes(term));
    });
    if (responseRows) {
      responseRows.innerHTML = filtered.length
        ? filtered.map(r => `<tr><td>${esc(r.ts || '')}</td><td>${esc(r.sender || '')}</td><td>${esc(r.patient || '')}</td><td>${esc(r.diagnostic_report_id || '')}</td><td>${esc(Number.isFinite(Number(r.variant_count)) ? Number(r.variant_count) : (r.variant_count || 0))}</td></tr>`).join('')
        : '<tr><td colspan="5">Ingen svar</td></tr>';
    }
    if (countLabel) {
      if (!list.length) {
        countLabel.textContent = 'Ingen importerede FHIR-svar endnu.';
      } else {
        const filtersActive = Boolean(term || senderValue);
        if (!filtered.length) {
          countLabel.textContent = filtersActive ? 'Ingen svar matcher filtrene.' : 'Ingen importerede FHIR-svar.';
        } else {
          const noun = filtered.length === 1 ? 'svar' : 'svar';
          countLabel.textContent = filtersActive
            ? `${filtered.length} ${noun} matcher filtrene.`
            : `${filtered.length} ${noun} importeret.`;
        }
      }
    }
    annotateTableCells(section);
  };
  renderRows();
  searchInput?.addEventListener('input', renderRows);
  senderFilter?.addEventListener('change', renderRows);
  const orderSelect = section.querySelector('#fhirOrderSelect');
  orderSelect?.addEventListener('change', () => {
    if (previewBox) previewBox.style.display = 'none';
  });
  renderTemplateSummary();
  templateSelect?.addEventListener('change', () => {
    if (previewBox) previewBox.style.display = 'none';
    renderTemplateSummary();
  });
  section.querySelector('#generateFhir').addEventListener('click', () => exportFhir(section, true));
  section.querySelector('#previewFhir').addEventListener('click', () => exportFhir(section, false));
  section.querySelector('#fhirImport').addEventListener('change', async e => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const json = JSON.parse(text);
      await handleInboundFhir(json, true);
      alert('FHIR bundle importeret.');
      await loadStore('responses');
      renderTab('responses');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke importere: ' + err.message);
    }
    e.target.value = '';
  });
}
async function exportFhir(section, download) {
  const select = section.querySelector('#fhirOrderSelect');
  const id = Number(select?.value);
  if (!id) return alert('Vælg ordre');
  const templateSelect = section.querySelector('#fhirTemplateSelect');
  const templateValue = templateSelect?.value || '';
  const templateId = Number(templateValue);
  const template = templateValue && Number.isFinite(templateId) ? findById('fhir_templates', templateId) : null;
  const bundle = buildFhirBundle(id, Number.isFinite(templateId) ? templateId : null);
  const json = JSON.stringify(bundle, null, 2);
  const preview = section.querySelector('#fhirPreview');
  preview.textContent = json;
  preview.style.display = 'block';
  if (download) {
    const blob = new Blob([json], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp(`glimr-ordre-${id}.json`);
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`FHIR-meddelelse for ordination ${id} downloadet som ${filename}.`);
    registerManualExport('fhir_bundle', {
      filename,
      orderId: id,
      byteSize: blob.size,
      templateId: template?.id ?? null,
      templateName: template?.name || (templateValue ? `Skabelon ${templateValue}` : 'Standard')
    });
  }
}
function resolveFhirTemplate(templateId) {
  if (templateId == null) return null;
  const numeric = Number(templateId);
  if (!Number.isFinite(numeric)) return null;
  const templates = getCached('fhir_templates') || [];
  return templates.find(tpl => Number(tpl.id) === numeric) || null;
}

function buildFhirBundle(orderId, templateId = null) {
  const order = findById('orders', orderId);
  if (!order) throw new Error('Ordination ikke fundet');
  const patient = findById('patients', Number(order.patient_id));
  const sample = findById('samples', Number(order.sample_id));
  const panel = order.panel_id ? findById('panels', Number(order.panel_id)) : null;
  const template = resolveFhirTemplate(templateId);
  const report = getCached('reports').find(r => r.order_id === orderId) || {status:'final', summary:'', variant_ids:'[]', variant_details:[]};
  let variants = getReportVariantSnapshots(report, orderId);
  if (!variants.length) {
    variants = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
  }
  const variantSummaries = variants.map(describeVariantNarrative).filter(Boolean);
  const narrative = variantSummaries.join('\n');
  const timestamp = new Date().toISOString();
  const patientIdentifiers = [];
  if (patient?.mrn) patientIdentifiers.push({system:'urn:oid:1.2.208.176.1.2', value:patient.mrn});
  if (patient?.extra_id) patientIdentifiers.push({system:'urn:glimr:patient-extra-id', value:patient.extra_id});
  const patientResource = {
    resourceType:'Patient',
    id:`patient-${patient?.id||order.patient_id}`,
    identifier: patientIdentifiers.length ? patientIdentifiers : undefined,
    name: patient?.name ? [{text:patient.name}] : undefined,
    gender: patient?.gender || undefined,
    birthDate: patient?.birth_date || undefined
  };
  const specimenResource = {
    resourceType:'Specimen',
    id:`specimen-${sample?.id||order.sample_id}`,
    status:'available',
    identifier: sample?.pmb_number ? [{system:'urn:glimr:pmb', value: sample.pmb_number}] : undefined,
    type: {text: sample?.sample_type || 'Genomic specimen'},
    receivedTime: sample?.collected_at || undefined,
    subject: {reference:`Patient/${patientResource.id}`}
  };
  const producerOrg = {resourceType:'Organization', id:'org-producer', name:'GenLab Producer'};
  const requesterOrg = {resourceType:'Organization', id:'org-requester', name: order.clinician || 'Requester'};
  const diagnosticReport = {
    resourceType:'DiagnosticReport',
    id:`dr-${orderId}`,
    status: report.status || 'final',
    category:[{coding:[{system:'http://terminology.hl7.org/CodeSystem/v2-0074', code:'LAB', display:'Laboratory'}]}],
    code:{coding:[{system:'http://loinc.org', code:'51969-4', display:'Genetic analysis report'}]},
    subject:{reference:`Patient/${patientResource.id}`},
    effectiveDateTime: report.issued_at || new Date().toISOString(),
    issued: report.issued_at || new Date().toISOString(),
    performer:[{reference:'Organization/org-producer'}],
    resultsInterpreter: requesterOrg.name ? [{reference:'Organization/org-requester'}] : undefined,
    conclusion: report.summary || undefined
  };
  if (narrative) {
    diagnosticReport.presentedForm = [{contentType:'text/plain', data:base64EncodeUtf8(narrative)}];
  }
  if (template?.diagnostic_report_profile) {
    diagnosticReport.meta = {profile:[template.diagnostic_report_profile]};
  }
  const includeVariantObservations = template ? template.include_variant_observations !== false : true;
  const includeDocumentReference = Boolean(template?.include_document_reference);
  const includeComposition = Boolean(template?.include_composition);
  const entries = [];
  const addEntry = resource => entries.push({fullUrl:`urn:uuid:${crypto.randomUUID?.() || Math.random().toString(36).slice(2)}`, resource});
  const eventSystem = template?.message_event_system || 'http://medcom.dk/fhir/medcom-messaging-event';
  const eventCode = template?.message_event_code || 'medcom-lab-reporting';
  const eventDisplay = template?.message_event_display || 'MedCom Lab Report';
  const destination = {name: template?.destination_name || 'Recipient'};
  if (template?.destination_endpoint) destination.endpoint = template.destination_endpoint;
  if (template?.destination_identifier_value) {
    destination.receiver = {
      identifier: {
        system: template.destination_identifier_system || undefined,
        value: template.destination_identifier_value
      }
    };
  }
  const messageHeader = {
    resourceType:'MessageHeader',
    id:`mh-${orderId}`,
    eventCoding:{system: eventSystem, code: eventCode, display: eventDisplay},
    source:{name:'GlimR'},
    destination:[destination],
    sender:{reference:'Organization/org-producer'},
    focus:[]
  };
  if (template?.message_profile) {
    messageHeader.meta = {profile:[template.message_profile]};
  }
  const messageFocus = new Set();
  const addFocus = reference => { if (reference) messageFocus.add(reference); };
  addEntry(messageHeader);
  addEntry(patientResource);
  addEntry(producerOrg);
  addEntry(requesterOrg);
  addEntry(specimenResource);
  addEntry(diagnosticReport);
  addFocus(`DiagnosticReport/${diagnosticReport.id}`);
  if (includeVariantObservations) {
    variants.forEach((variant, idx) => {
      const obs = {
        resourceType:'Observation',
        id:`var-${orderId}-${idx+1}`,
        status:'final',
        category:[{coding:[{system:'http://terminology.hl7.org/CodeSystem/observation-category', code:'laboratory'}]}],
        code:{coding:[{system:'http://loinc.org', code:'69548-6', display:'Genomic sequence variation interpretation'}]},
        subject:{reference:`Patient/${patientResource.id}`},
        specimen:{reference:`Specimen/${specimenResource.id}`},
        valueCodeableConcept:{text:[variant.hgvs_c, variant.hgvs_p].filter(Boolean).join(' / ') || variant.gene},
        component:[{code:{text:'Gene'}, valueCodeableConcept:{text:variant.gene}}],
        interpretation: classificationMap[String(variant.classification)] ? [{coding:[{system:'http://loinc.org', code:classificationMap[String(variant.classification)].code, display:classificationMap[String(variant.classification)].display}]}] : undefined,
        note: variant.criteria ? [{text:`ACMG: ${variant.criteria}`}]: undefined
      };
      if (template?.observation_profile) {
        obs.meta = {profile:[template.observation_profile]};
      }
      addEntry(obs);
      diagnosticReport.result = diagnosticReport.result || [];
      diagnosticReport.result.push({reference:`Observation/${obs.id}`});
    });
  }
  if (includeDocumentReference) {
    const docParts = [];
    if (report.summary) docParts.push(`Konklusion: ${report.summary}`);
    if (variantSummaries.length) docParts.push('Varianter:\n' + variantSummaries.join('\n'));
    const documentText = docParts.join('\n\n').trim();
    if (documentText) {
      const documentReference = {
        resourceType:'DocumentReference',
        id:`doc-${orderId}`,
        status:'current',
        type: template?.document_type_code || template?.document_type_display || template?.document_type_system
          ? {
              coding:[{
                system: template?.document_type_system || 'http://loinc.org',
                code: template?.document_type_code || '51969-4',
                display: template?.document_type_display || 'Genetic analysis report'
              }]
            }
          : undefined,
        subject:{reference:`Patient/${patientResource.id}`},
        author:[{reference:'Organization/org-producer'}],
        date: timestamp,
        description: template?.document_title || `Genetisk rapport for ordination ${orderId}`,
        content:[{
          attachment:{
            contentType:'text/plain',
            data: base64EncodeUtf8(documentText),
            title: template?.document_title || 'Genetisk rapport',
            creation: timestamp
          }
        }],
        context:{related:[{reference:`DiagnosticReport/${diagnosticReport.id}`}]}
      };
      if (template?.document_profile) {
        documentReference.meta = {profile:[template.document_profile]};
      }
      addEntry(documentReference);
      addFocus(`DocumentReference/${documentReference.id}`);
    }
  }
  if (includeComposition) {
    const htmlEscape = text => esc(text || '').replace(/\n/g, '<br>');
    const sections = [];
    if (report.summary) {
      sections.push({
        title: 'Rapport',
        text: {status:'generated', div:`<div xmlns="http://www.w3.org/1999/xhtml"><p>${htmlEscape(report.summary)}</p></div>`}
      });
    }
    if (variantSummaries.length) {
      const items = variantSummaries.map(item => `<li>${esc(item)}</li>`).join('');
      sections.push({
        title: 'Varianter',
        text: {status:'generated', div:`<div xmlns="http://www.w3.org/1999/xhtml"><ul>${items}</ul></div>`}
      });
    }
    if (sections.length) {
      const composition = {
        resourceType:'Composition',
        id:`comp-${orderId}`,
        status:'final',
        type:{
          coding:[{
            system: template?.composition_type_system || 'http://loinc.org',
            code: template?.composition_type_code || '11488-4',
            display: template?.composition_type_display || 'Consult note'
          }]
        },
        title: template?.composition_title || 'Genetisk journalnotat',
        date: timestamp,
        subject:{reference:`Patient/${patientResource.id}`},
        author:[{reference:'Organization/org-producer'}],
        section: sections
      };
      if (template?.composition_profile) {
        composition.meta = {profile:[template.composition_profile]};
      }
      addEntry(composition);
      addFocus(`Composition/${composition.id}`);
    }
  }
  messageHeader.focus = Array.from(messageFocus).map(reference => ({reference}));
  const bundle = {
    resourceType:'Bundle',
    type:'message',
    timestamp,
    entry: entries
  };
  if (template?.bundle_profile) {
    bundle.meta = {profile:[template.bundle_profile]};
  }
  return bundle;
}
async function handleInboundFhir(bundle, offerLibrary=false) {
  if (!ensureWrite('responses')) return;
  if (!bundle || bundle.resourceType !== 'Bundle') throw new Error('Ikke en FHIR Bundle');
  const entries = bundle.entry || [];
  const findResource = type => entries.map(e => e.resource).find(r => r.resourceType === type);
  const diagnosticReport = findResource('DiagnosticReport');
  const patient = findResource('Patient');
  const observations = entries.map(e => e.resource).filter(r => r.resourceType === 'Observation');
  const response = {
    ts: new Date().toISOString(),
    sender: findResource('MessageHeader')?.sender?.reference || 'ukendt',
    patient: patient?.name?.[0]?.text || patient?.id || '',
    diagnostic_report_id: diagnosticReport?.id || '',
    variant_count: observations.length,
    variants: JSON.stringify(observations.map(o => ({gene:o.component?.[0]?.valueCodeableConcept?.text, note:o.note?.[0]?.text, value:o.valueCodeableConcept?.text}))),
    raw: JSON.stringify(bundle)
  };
  await addRecord('responses', response);
  if (offerLibrary && observations.length) {
    if (ensureWrite('variant_library') && confirm('Tilføj varianter til bibliotek?')) {
      for (const obs of observations) {
        const note = obs.note?.[0]?.text || '';
        await addRecord('variant_library', {
          gene: obs.component?.[0]?.valueCodeableConcept?.text || '',
          transcript: '',
          hgvs_c: obs.valueCodeableConcept?.text || '',
          hgvs_p: '',
          genomic_position: '',
          classification: note.includes('Pathogenic') ? '5' : '',
          criteria: note.replace('ACMG: ','') || '',
          evidence: note,
          condition: '',
          inheritance: '',
          curated_by: 'FHIR import',
          last_review: new Date().toISOString().split('T')[0]
        });
      }
      await loadStore('variant_library');
    }
  }
}
function renderUsers(section) {
  const list = getCached('users');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="userSearch">Søg</label>
        <input id="userSearch" type="search" placeholder="Navn/mail...">
        <table><thead><tr><th>ID</th><th>Navn</th><th>E-mail</th><th>Rolle</th></tr></thead><tbody></tbody></table>
      </div>
      <div>
        <h2>Bruger</h2>
        <form id="userForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <label>E-mail<input type="email" name="email" required></label>
          <label>Rolle<select name="role" required>${ROLE_OPTIONS.map(opt => `<option value="${opt.value}">${opt.value} – ${opt.description}</option>`).join('')}</select></label>
          <label>Adgangskode (PIN)<input type="password" name="pin" placeholder="Valgfri kode"></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="userClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="userDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#userSearch');
  const form = section.querySelector('#userForm');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  let selectedUserId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filteredUsers = list.filter(u => !term || [u.name,u.email,u.role].some(v => (v||'').toLowerCase().includes(term)));
    if (selectedUserId != null && !filteredUsers.some(u => u.id === selectedUserId)) {
      selectedUserId = null;
    }
    tbody.innerHTML = filteredUsers.map(u => {
      const selectedAttr = u.id === selectedUserId ? ' data-selected="true"' : '';
      const emailCell = u.email
        ? `<a href="mailto:${encodeURIComponent(u.email)}">${esc(u.email)}</a>`
        : '';
      return `<tr data-id="${u.id}"${selectedAttr}><td>${u.id}</td><td>${esc(u.name)}</td><td>${emailCell}</td><td>${esc(roleLabel(u.role))}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const user = list.find(u => u.id === Number(tr.dataset.id));
    if (!user) return;
    selectedUserId = user.id;
    fillForm(form, user);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('users')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('users', id)};
      if (!data.pin) data.pin = before?.pin || '';
      const updated = {...before, ...data, id};
      await updateRecord('users', updated, before);
    } else {
      if (!data.pin) data.pin = '';
      delete data.id;
      await addRecord('users', data);
    }
    await loadStore('users');
    refreshLoginOptions();
    restoreUserSession();
    renderTab('users');
  });
  section.querySelector('#userDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg bruger');
    if (!ensureWrite('users')) return;
    if (confirm('Slet bruger?')) {
      await deleteRecord('users', id);
      refreshLoginOptions();
      const storedId = storage.getItem('glimr-user-id');
      if (storedId && Number(storedId) === id) {
        logoutUser();
      }
      renderTab('users');
    }
  });
  form.addEventListener('reset', () => {
    clearFormIdentifier(form);
    selectedUserId = null;
    renderRows();
  });
  section.querySelector('#userClear').addEventListener('click', () => form.reset());
}
function renderAudit(section) {
  const list = getCached('audit').slice().reverse();
  const uniqueUsers = Array.from(new Set(list.map(entry => entry.user).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const uniqueActions = Array.from(new Set(list.map(entry => entry.action).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const uniqueEntities = Array.from(new Set(list.map(entry => entry.entity).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  section.innerHTML = `
  <div class="panel">
    <div class="panel-header audit-panel-header">
      <h2>Revision</h2>
      <div class="audit-controls">
        <input type="search" id="auditSearch" placeholder="Filtrer revision..." aria-label="Filtrer revisionslog">
        <select id="auditUserFilter" aria-label="Filtrer efter bruger">
          <option value="">Alle brugere</option>
          ${uniqueUsers.map(user => `<option value="${esc(user)}">${esc(user)}</option>`).join('')}
        </select>
        <select id="auditActionFilter" aria-label="Filtrer efter handling">
          <option value="">Alle handlinger</option>
          ${uniqueActions.map(action => `<option value="${esc(action)}">${esc(action)}</option>`).join('')}
        </select>
        <select id="auditEntityFilter" aria-label="Filtrer efter entitet">
          <option value="">Alle entiteter</option>
          ${uniqueEntities.map(entity => `<option value="${esc(entity)}">${esc(entity)}</option>`).join('')}
        </select>
        <button class="secondary with-icon" type="button" id="auditExport">
          <span class="icon-slot" data-icon="clipboard-document-list"></span>
          <span>Eksportér</span>
        </button>
        <button class="danger with-icon" type="button" id="auditClear" data-tooltip="Ryd revisionsloggen, når du har eksporteret">
          <span class="icon-slot" data-icon="trash"></span>
          <span>Ryd log</span>
        </button>
      </div>
    </div>
    <p class="panel-hint" data-audit-count></p>
    <table>
      <thead><tr><th>Tid</th><th>Bruger</th><th>Handling</th><th>Entitet</th><th>ID</th><th>Før</th><th>Efter</th></tr></thead>
      <tbody data-audit-rows></tbody>
    </table>
  </div>`;
  const searchInput = section.querySelector('#auditSearch');
  const userFilter = section.querySelector('#auditUserFilter');
  const actionFilter = section.querySelector('#auditActionFilter');
  const entityFilter = section.querySelector('#auditEntityFilter');
  const tbody = section.querySelector('[data-audit-rows]');
  const countLabel = section.querySelector('[data-audit-count]');
  const exportButton = section.querySelector('#auditExport');
  const clearButton = section.querySelector('#auditClear');
  let filteredRows = list.slice();

  const formatAuditTimestamp = value => {
    if (!value) {
      return {label: '', datetime: '', title: ''};
    }
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) {
      return {label: value, datetime: '', title: ''};
    }
    const label = date.toLocaleString('da-DK', {dateStyle: 'short', timeStyle: 'medium'});
    const datetime = date.toISOString();
    const title = value || '';
    return {label, datetime, title};
  };

  const formatCountMessage = total => {
    const noun = total === 1 ? 'revisionspost' : 'revisionsposter';
    const filtersActive = Boolean((searchInput?.value || '').trim() || userFilter?.value || actionFilter?.value || entityFilter?.value);
    if (!filtersActive) {
      return `${total} ${noun} i alt.`;
    }
    return `${total} ${noun} matcher filtrene.`;
  };

  const buildFilterSummary = () => {
    const parts = [];
    const term = (searchInput?.value || '').trim();
    if (term) parts.push(`tekst=${term}`);
    if (userFilter?.value) parts.push(`bruger=${userFilter.value}`);
    if (actionFilter?.value) parts.push(`handling=${actionFilter.value}`);
    if (entityFilter?.value) parts.push(`entitet=${entityFilter.value}`);
    return parts.length ? parts.join('; ') : 'ingen filtre';
  };

  const matchesSearch = (entry, term) => {
    if (!term) return true;
    const lowered = term.toLowerCase();
    const fields = [
      entry.ts,
      formatAuditTimestamp(entry.ts).label,
      entry.user,
      entry.action,
      entry.entity,
      entry.entity_id,
      entry.before,
      entry.after
    ];
    return fields.some(value => (value || '').toString().toLowerCase().includes(lowered));
  };

  const applyFilters = () => {
    const term = (searchInput?.value || '').trim();
    const userValue = userFilter?.value || '';
    const actionValue = actionFilter?.value || '';
    const entityValue = entityFilter?.value || '';
    filteredRows = list.filter(entry => {
      if (userValue && entry.user !== userValue) return false;
      if (actionValue && entry.action !== actionValue) return false;
      if (entityValue && entry.entity !== entityValue) return false;
      if (!matchesSearch(entry, term)) return false;
      return true;
    });
    tbody.innerHTML = filteredRows.length
      ? filteredRows.map(a => {
          const {label, datetime, title} = formatAuditTimestamp(a.ts);
          const timeContent = datetime
            ? `<time datetime="${esc(datetime)}"${title ? ` title="${esc(title)}"` : ''}>${esc(label)}</time>`
            : esc(label || (a.ts ?? ''));
          return `<tr><td>${timeContent}</td><td>${esc(a.user)}</td><td>${esc(a.action)}</td><td>${esc(a.entity)}</td><td>${esc(a.entity_id??'')}</td><td>${esc(a.before||'')}</td><td>${esc(a.after||'')}</td></tr>`;
        }).join('')
      : '<tr><td colspan="7">Ingen revisionsposter</td></tr>';
    if (countLabel) {
      countLabel.textContent = formatCountMessage(filteredRows.length);
    }
    annotateTableCells(section);
  };

  applyFilters();
  searchInput?.addEventListener('input', applyFilters);
  userFilter?.addEventListener('change', applyFilters);
  actionFilter?.addEventListener('change', applyFilters);
  entityFilter?.addEventListener('change', applyFilters);

  clearButton?.addEventListener('click', async () => {
    if (!ensureWrite('audit')) return;
    if (!state.db) {
      alert('Database er ikke initialiseret endnu.');
      return;
    }
    const cachedAudit = getCached('audit');
    const totalBefore = Array.isArray(cachedAudit) ? cachedAudit.length : list.length;
    const confirmMessage = totalBefore
      ? `Dette vil rydde alle ${totalBefore} revisionsposter. Sørg for at have eksporteret loggen først. Handling kan ikke fortrydes. Fortsæt?`
      : 'Der er ingen revisionsposter lige nu. Handlingen logges som en rydning. Fortsæt?';
    if (!confirm(confirmMessage)) return;
    clearButton.disabled = true;
    let cleared = false;
    try {
      const tx = state.db.transaction('audit', 'readwrite');
      tx.objectStore('audit').clear();
      await transactionToPromise(tx);
      await logAudit('CLEAR', 'audit', null, null, {
        cleared_by: currentUserName(),
        cleared_count: totalBefore,
        filter_summary: buildFilterSummary()
      });
      setStatus('Revisionsloggen er ryddet og handlingen er registreret.');
      cleared = true;
      scheduleAutosave();
    } catch (err) {
      console.error('Kunne ikke rydde revisionsloggen', err);
      alert('Kunne ikke rydde revisionsloggen: ' + (err?.message || err));
    } finally {
      clearButton.disabled = false;
    }
    if (cleared) {
      renderAudit(section);
    }
  });

  exportButton?.addEventListener('click', () => {
    const columns = [
      {key: 'ts', label: 'Tid'},
      {key: 'user', label: 'Bruger'},
      {key: 'action', label: 'Handling'},
      {key: 'entity', label: 'Entitet'},
      {key: 'entity_id', label: 'ID'},
      {key: 'before', label: 'Før'},
      {key: 'after', label: 'Efter'}
    ];
    exportFilteredCsv('glimr-revision-filtreret.csv', filteredRows, columns, {
      entity: 'revision',
      plural: 'revisionsposter',
      auditEntity: 'audit',
      auditContext: buildFilterSummary()
    });
  });

  applyIconSlots(section);
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
}

function renderDbTab(section) {
  section = section || document.querySelector('section[data-tab="db"]');
  const rememberedName = storage.getItem(BOUND_HANDLE_NAME_KEY);
  const status = state.boundHandle
    ? `Tilknyttet fil: ${state.boundHandle.name}`
    : (rememberedName ? `Tidligere fil: ${rememberedName} (kræver ny godkendelse)` : 'Ingen fil tilknyttet');
  const memoryWarning = state.usingMemoryDb
    ? '<p class="panel-hint warning">Browseren blokerer for IndexedDB. Data gemmes kun midlertidigt i denne session.</p>'
    : '';
  const canClearBinding = Boolean(state.boundHandle || rememberedName);
  if (!section) return;
  section.innerHTML = `
  <div class="panel">
    <h2>Filbaseret database</h2>
    <p>${esc(status)}</p>
    ${memoryWarning}
    <div class="btn-row">
      <button class="secondary" id="bindFile">Knyt/åbn DB-fil...</button>
      <button class="secondary" id="unbindFile" ${canClearBinding ? '' : 'disabled'}>Fjern tilknytning</button>
      <button class="secondary" id="saveNow">Gem nu</button>
      <label style="display:flex;align-items:center;gap:0.5rem;">
        <input type="checkbox" id="autosaveToggle" ${state.autosave?'checked':''}> Autogem
      </label>
    </div>
  </div>
  <div class="panel">
    <h2>Backup og eksport</h2>
    <div class="btn-row">
      <button class="secondary" id="downloadBackup">Udfør backup (json)</button>
      <button class="secondary" type="button" id="restoreBackup">Gendan fra backup (json)</button>
      <input type="file" id="restoreFile" accept="application/json" hidden>
    </div>
    <div class="btn-row">
      <button class="secondary" id="downloadCsvBackup">Eksportér data (csv)</button>
      <button class="secondary" type="button" id="restoreCsvBackup">Importer data (csv)</button>
      <input type="file" id="restoreCsvFile" accept=".csv,.zip,text/csv,application/zip" hidden>
    </div>
    <div class="btn-row">
      <button class="secondary" type="button" id="downloadSql">Hent glimr.sql</button>
      <button class="secondary" id="showSchema">Vis skema</button>
      <button class="secondary" id="downloadZip">Hent ZIP</button>
    </div>
    <div class="btn-row">
      <button class="danger" id="resetDataBtn">Backup &amp; ryd data (undtagen brugere)</button>
    </div>
    <textarea id="schemaText" style="width:100%;min-height:200px;margin-top:1rem;display:none;"></textarea>
    <p class="panel-hint">Opret eller gendan backups, hent SQL-dump eller download et komplet ZIP-arkiv med GlimR.</p>
  </div>`;
  applyButtonTooltips(section);
  applyControlTooltips(section);
  section.querySelector('#bindFile').addEventListener('click', bindDbFile);
  section.querySelector('#saveNow').addEventListener('click', manualSave);
  section.querySelector('#autosaveToggle').addEventListener('change', e => {
    state.autosave = e.target.checked;
    storage.setItem(AUTOSAVE_STORAGE_KEY, state.autosave ? '1' : '0');
    setStatus('Autogemning ' + (state.autosave ? 'aktiveret' : 'deaktiveret'));
    if (state.autosave && state.boundHandle) {
      scheduleAutosave();
    } else if (!state.autosave && state.autosaveTimer) {
      clearTimeout(state.autosaveTimer);
      state.autosaveTimer = null;
    }
  });
  const unbindButton = section.querySelector('#unbindFile');
  if (unbindButton) {
    unbindButton.addEventListener('click', async () => {
      if (unbindButton.disabled) return;
      await clearBoundHandle();
      setStatus('Filbinding fjernet.');
    });
  }
  section.querySelector('#downloadBackup').addEventListener('click', downloadBackup);
  const restoreInput = section.querySelector('#restoreFile');
  const restoreBtn = section.querySelector('#restoreBackup');
  restoreBtn?.addEventListener('click', () => restoreInput?.click());
  restoreInput?.addEventListener('change', async e => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      await restoreFromFile(file);
      alert('Backup gendannet.');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke gendanne: ' + err.message);
    }
    e.target.value = '';
  });
  section.querySelector('#downloadCsvBackup').addEventListener('click', downloadCsvBackup);
  const restoreCsvInput = section.querySelector('#restoreCsvFile');
  const restoreCsvBtn = section.querySelector('#restoreCsvBackup');
  restoreCsvBtn?.addEventListener('click', () => restoreCsvInput?.click());
  restoreCsvInput?.addEventListener('change', async e => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      await restoreFromCsvFile(file);
      alert('CSV-data gendannet.');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke importere CSV-data: ' + (err?.message || err));
    }
    e.target.value = '';
  });
  const resetBtn = section.querySelector('#resetDataBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', backupAndResetData);
  }
  section.querySelector('#downloadSql').addEventListener('click', async () => {
    const sql = await generateSqlDump();
    const blob = new Blob([sql], {type:'text/sql'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp('glimr.sql');
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`MySQL-dump downloadet som ${filename}.`);
    registerManualExport('sql_dump', {
      filename,
      byteSize: blob.size
    });
  });
  section.querySelector('#showSchema').addEventListener('click', async () => {
    const sql = await generateSqlDump();
    const textarea = section.querySelector('#schemaText');
    if (!textarea) return;
    textarea.value = sql;
    textarea.style.display = 'block';
  });
  section.querySelector('#downloadZip').addEventListener('click', async () => {
    const files = await buildZipFiles();
    const zipBytes = createZip(files);
    const blob = new Blob([zipBytes], {type:'application/zip'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp('glimr.zip');
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`ZIP-arkiv downloadet som ${filename}.`);
    registerManualExport('zip_archive', {
      filename,
      fileCount: Array.isArray(files) ? files.length : 0,
      byteSize: blob.size
    });
  });
}
function renderAdmin(section) {
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="patientGroupSearch">Søg</label>
        <input id="patientGroupSearch" type="search" placeholder="Patientgruppe...">
        <table data-patient-group-table>
          <thead><tr><th>ID</th><th>Navn</th><th>Opdateret</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h2 class="panel-title-left">Patientgruppe</h2>
        <form id="patientGroupForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <div class="btn-row">
            <button class="primary action-button action-save with-icon" type="submit">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                  <path d="M17 21v-8H7v8" />
                  <path d="M7 3v5h8" />
                </svg>
              </span>
              <span class="label">Gem</span>
            </button>
            <button class="secondary action-button action-new with-icon" type="button" id="patientGroupClear">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <circle cx="12" cy="12" r="7" />
                  <path d="M12 8.5v7" />
                  <path d="M8.5 12h7" />
                </svg>
              </span>
              <span class="label">Ny</span>
            </button>
            <button class="danger action-button action-delete with-icon" type="button" id="patientGroupDelete">
              <span class="icon-slot" aria-hidden="true">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4 6h16" />
                  <path d="M19 6v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" />
                </svg>
              </span>
              <span class="label">Slet</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>
  <div class="panel">
    <h2>FHIR-eksport skabeloner</h2>
    <p class="form-hint">Opret og vedligehold modtagerspecifikke skabeloner til FHIR-eksport.</p>
    <div class="fhir-template-manager">
      <div class="fhir-template-list">
        <label for="fhirTemplateSearch">Søg</label>
        <input id="fhirTemplateSearch" type="search" placeholder="Skabelon eller modtager...">
        <table data-fhir-template-table>
          <thead><tr><th>ID</th><th>Navn</th><th>Modtager</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="fhir-template-form">
        <h3>Skabelon</h3>
        <form id="fhirTemplateForm">
          <input type="hidden" name="id">
          <div class="template-form-grid">
            <label>Navn<input name="name" required></label>
            <label>Modtagersystem<input name="target_system" placeholder="fx Sundhedsplatformen"></label>
            <label>Destination navn<input name="destination_name" placeholder="fx Sundhedsplatformen"></label>
            <label>Destination endpoint<input name="destination_endpoint" placeholder="https://..."></label>
            <label>Journal-overskrift<input name="composition_title" placeholder="fx Genetisk notat"></label>
            <label>Beskrivelse<textarea name="description" placeholder="Formål, format og særlige krav"></textarea></label>
          </div>
          <div class="template-form-grid">
            <label>MedCom event-system<input name="message_event_system" placeholder="http://medcom.dk/fhir/..."></label>
            <label>MedCom event-kode<input name="message_event_code" placeholder="fx medcom-lab-reporting"></label>
            <label>MedCom event-tekst<input name="message_event_display" placeholder="Visningsnavn"></label>
            <label>Bundle-profil<input name="bundle_profile" placeholder="http://..."></label>
            <label>Header-profil<input name="message_profile" placeholder="http://..."></label>
            <label>DiagnosticReport-profil<input name="diagnostic_report_profile" placeholder="http://..."></label>
            <label>Observation-profil<input name="observation_profile" placeholder="http://..."></label>
            <label>Destination ID-system<input name="destination_identifier_system" placeholder="urn:..."></label>
            <label>Destination ID-værdi<input name="destination_identifier_value" placeholder="Fx GLIMR"></label>
          </div>
          <div class="template-checkboxes">
            <label><input type="checkbox" name="include_variant_observations" checked> Inkludér variantobservationer</label>
            <label><input type="checkbox" name="include_document_reference"> Inkludér rapportbilag</label>
            <label><input type="checkbox" name="include_composition"> Inkludér journalnotat</label>
          </div>
          <details class="template-advanced">
            <summary>Avancerede profiler og koder</summary>
            <div class="template-form-grid">
              <label>DocumentReference-profil<input name="document_profile" placeholder="http://..."></label>
              <label>DocumentReference type-system<input name="document_type_system" placeholder="http://loinc.org"></label>
              <label>DocumentReference type-kode<input name="document_type_code" placeholder="fx 51969-4"></label>
              <label>DocumentReference type-visning<input name="document_type_display" placeholder="Visningsnavn"></label>
              <label>Dokumenttitel<input name="document_title" placeholder="fx Genetisk laboratoriesvar"></label>
              <label>Composition-profil<input name="composition_profile" placeholder="http://..."></label>
              <label>Composition type-system<input name="composition_type_system" placeholder="http://loinc.org"></label>
              <label>Composition type-kode<input name="composition_type_code" placeholder="fx 11488-4"></label>
              <label>Composition type-visning<input name="composition_type_display" placeholder="Visningsnavn"></label>
            </div>
          </details>
          <div class="btn-row">
            <button class="primary" type="submit" id="fhirTemplateSave">Gem</button>
            <button class="secondary" type="button" id="fhirTemplateClear">Ny</button>
            <button class="danger" type="button" id="fhirTemplateDelete">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>
  <div class="panel">
    <h2>Forvalg til kvalitetskontrol</h2>
    <p class="form-hint">Administrer dropdownværdier for QC-målinger og enheder.</p>
    <div class="flex qc-preset-manager">
      <div class="preset-column" data-qc-preset="metric">
        <h3>Målinger</h3>
        <div class="qc-preset-list" data-qc-preset-list="metric"></div>
        <div class="inline-group">
          <input type="text" data-qc-preset-input="metric" placeholder="Tilføj måling">
          <button type="button" class="secondary" data-qc-preset-add="metric">Tilføj</button>
        </div>
      </div>
      <div class="preset-column" data-qc-preset="unit">
        <h3>Enheder</h3>
        <div class="qc-preset-list" data-qc-preset-list="unit"></div>
        <div class="inline-group">
          <input type="text" data-qc-preset-input="unit" placeholder="Tilføj enhed">
          <button type="button" class="secondary" data-qc-preset-add="unit">Tilføj</button>
        </div>
      </div>
    </div>
    <div class="btn-row">
      <button type="button" class="secondary" id="qcPresetsRestore">Gendan standardværdier</button>
    </div>
  </div>
  <div class="panel">
    <h2>Selvtest</h2>
    <table><thead><tr><th>Test</th><th>Status</th><th>Detaljer</th></tr></thead><tbody id="testsBody"></tbody></table>
    <div class="btn-row">
      <button class="primary" id="runTestsBtn">Kør selvtest</button>
    </div>
  </div>
  <div class="panel single-action-panel">
    <div class="btn-row">
      <button class="primary" id="demoDataBtn">Indlæs demo-data</button>
    </div>
  </div>`;
  applyButtonTooltips(section);
  applyControlTooltips(section);
  annotateSearchInputs(section);
  annotateHeaders(section);
  section.querySelectorAll('form').forEach(form => applyFormTooltips(form));
  const testsBody = section.querySelector('#testsBody');
  if (testsBody) {
    testsBody.innerHTML = state.testResults.length
      ? state.testResults.map(([name, pass, detail]) => `<tr><td>${esc(name)}</td><td>${pass ? 'OK' : 'FEJL'}</td><td>${esc(detail||'')}</td></tr>`).join('')
      : '<tr><td colspan="3">Ingen tests kørt endnu.</td></tr>';
  }
  annotateTableCells(section);
  const demoBtn = section.querySelector('#demoDataBtn');
  if (demoBtn) {
    demoBtn.addEventListener('click', () => {
      if (!ensureWrite('patients')) return;
      loadDemoData();
    });
  }
  const testsBtn = section.querySelector('#runTestsBtn');
  testsBtn?.addEventListener('click', runTests);
  const groupTableBody = section.querySelector('[data-patient-group-table] tbody');
  const groupSearch = section.querySelector('#patientGroupSearch');
  const groupForm = section.querySelector('#patientGroupForm');
  const groupClearBtn = section.querySelector('#patientGroupClear');
  const groupDeleteBtn = section.querySelector('#patientGroupDelete');
  const groups = getCached('patient_groups').slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'da'));
  let filteredGroups = groups.slice();
  let selectedGroupId = null;
  const refreshDependentTabs = () => {
    ['orders','case_create','reports'].forEach(id => {
      const target = document.querySelector(`section[data-tab="${id}"]`);
      if (target && target.classList.contains('active')) {
        renderTab(id);
      }
    });
  };
  const renderGroupRows = () => {
    if (!groupTableBody) return;
    const term = (groupSearch?.value || '').trim().toLowerCase();
    filteredGroups = groups.filter(group => {
      if (!term) return true;
      const haystack = `${group.name || ''} ${(group.created_by || '')}`.toLowerCase();
      return haystack.includes(term);
    });
    if (!filteredGroups.length) {
      groupTableBody.innerHTML = '<tr><td colspan="3">Ingen patientgrupper.</td></tr>';
      annotateTableCells(section);
      return;
    }
    groupTableBody.innerHTML = filteredGroups.map(group => {
      const updated = formatDanishDate(group.updated_at, true) || formatDanishDate(group.updated_at) || (group.updated_at || '');
      const selectedAttr = group.id === selectedGroupId ? ' data-selected="true"' : '';
      return `<tr data-id="${group.id}"${selectedAttr}><td>${group.id}</td><td>${esc(group.name || '')}</td><td>${esc(updated)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderGroupRows();
  groupSearch?.addEventListener('input', renderGroupRows);
  groupTableBody?.addEventListener('click', evt => {
    const row = evt.target.closest('tr[data-id]');
    if (!row) return;
    const id = Number(row.dataset.id);
    const group = groups.find(item => item.id === id);
    if (!group) return;
    selectedGroupId = id;
    if (groupForm) {
      fillForm(groupForm, group);
    }
    renderGroupRows();
  });
  groupClearBtn?.addEventListener('click', () => {
    groupForm?.reset();
    selectedGroupId = null;
    renderGroupRows();
  });
  groupForm?.addEventListener('submit', async evt => {
    evt.preventDefault();
    if (!ensureWrite('patient_groups')) return;
    const data = Object.fromEntries(new FormData(groupForm).entries());
    data.name = (data.name || '').trim();
    if (!data.name) {
      alert('Angiv et navn for patientgruppen.');
      groupForm.elements.name?.focus();
      return;
    }
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('patient_groups', id)};
      const updated = {...before, ...data, id};
      await updateRecord('patient_groups', updated, before);
    } else {
      delete data.id;
      await addRecord('patient_groups', data);
    }
    await loadStore('patient_groups');
    renderTab('admin');
    refreshDependentTabs();
  });
  groupDeleteBtn?.addEventListener('click', async () => {
    const id = Number(groupForm?.elements.id?.value);
    if (!id) {
      alert('Vælg en patientgruppe der skal slettes.');
      return;
    }
    if (!ensureWrite('patient_groups')) return;
    if (!confirm('Slet patientgruppe? Dette påvirker ikke eksisterende ordinationer, men feltet vil stå tomt.')) return;
    await deleteRecord('patient_groups', id);
    await loadStore('patient_groups');
    renderTab('admin');
    refreshDependentTabs();
  });

  const templateTableBody = section.querySelector('[data-fhir-template-table] tbody');
  const templateSearch = section.querySelector('#fhirTemplateSearch');
  const templateForm = section.querySelector('#fhirTemplateForm');
  const templateClearBtn = section.querySelector('#fhirTemplateClear');
  const templateDeleteBtn = section.querySelector('#fhirTemplateDelete');
  let templateFormDirty = false;
  const markTemplateDirty = () => { templateFormDirty = true; };
  templateForm?.addEventListener('input', markTemplateDirty, true);
  templateForm?.addEventListener('change', evt => {
    if (evt.target && evt.target.form === templateForm) {
      templateFormDirty = true;
    }
  }, true);
  const getSortedTemplates = () => (getCached('fhir_templates') || []).slice().sort((a, b) => (a?.name || '').localeCompare(b?.name || '', 'da'));
  const refreshTemplateConsumers = () => {
    const responsesSection = document.querySelector('section[data-tab="responses"]');
    if (responsesSection && responsesSection.classList.contains('active')) {
      renderTab('responses');
    }
  };
  let templateData = getSortedTemplates();
  let filteredTemplates = templateData.slice();
  let selectedTemplateId = templateData[0] && Number.isFinite(Number(templateData[0].id)) ? Number(templateData[0].id) : null;
  const loadTemplateIntoForm = template => {
    if (!templateForm) return;
    if (template) {
      fillForm(templateForm, template);
      templateForm.elements.include_variant_observations.checked = template.include_variant_observations !== false;
      templateForm.elements.include_document_reference.checked = Boolean(template.include_document_reference);
      templateForm.elements.include_composition.checked = Boolean(template.include_composition);
    } else {
      templateForm.reset();
      clearFormIdentifier(templateForm);
      const includeVariantsField = templateForm.elements.include_variant_observations;
      if (includeVariantsField) includeVariantsField.checked = true;
    }
    templateFormDirty = false;
  };
  const renderTemplateRows = () => {
    if (!templateTableBody) return;
    const term = (templateSearch?.value || '').trim().toLowerCase();
    filteredTemplates = templateData.filter(template => {
      if (!term) return true;
      const haystack = `${template.name || ''} ${template.target_system || ''} ${template.description || ''}`.toLowerCase();
      return haystack.includes(term);
    });
    if (!filteredTemplates.length) {
      templateTableBody.innerHTML = '<tr><td colspan="3">Ingen skabeloner.</td></tr>';
      annotateTableCells(section);
      if (!term) {
        loadTemplateIntoForm(null);
        selectedTemplateId = null;
      }
      return;
    }
    if (selectedTemplateId != null && !filteredTemplates.some(template => Number(template.id) === selectedTemplateId)) {
      if (templateFormDirty) {
        selectedTemplateId = null;
      } else {
        const firstTemplateId = filteredTemplates[0]?.id;
        selectedTemplateId = Number.isFinite(Number(firstTemplateId)) ? Number(firstTemplateId) : null;
        if (selectedTemplateId != null) {
          const match = filteredTemplates.find(t => Number(t.id) === selectedTemplateId);
          loadTemplateIntoForm(match || null);
        } else {
          loadTemplateIntoForm(null);
        }
      }
    }
    templateTableBody.innerHTML = filteredTemplates.map(template => {
      const selectedAttr = Number(template.id) === selectedTemplateId ? ' data-selected="true"' : '';
      return `<tr data-id="${template.id}"${selectedAttr}><td>${template.id}</td><td>${esc(template.name || '')}</td><td>${esc(template.target_system || '')}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderTemplateRows();
  if (selectedTemplateId != null) {
    const initialTemplate = templateData.find(t => Number(t.id) === selectedTemplateId);
    if (initialTemplate) loadTemplateIntoForm(initialTemplate);
  } else {
    loadTemplateIntoForm(null);
  }
  templateSearch?.addEventListener('input', renderTemplateRows);
  templateTableBody?.addEventListener('click', evt => {
    const row = evt.target.closest('tr[data-id]');
    if (!row) return;
    const id = Number(row.dataset.id);
    if (!Number.isFinite(id)) return;
    if (templateFormDirty && id !== selectedTemplateId) {
      const discard = confirm('Der er ugemte ændringer i skabelonen. Kassér ændringerne?');
      if (!discard) return;
    }
    const template = templateData.find(item => Number(item.id) === id);
    if (!template) return;
    selectedTemplateId = id;
    loadTemplateIntoForm(template);
    renderTemplateRows();
  });
  templateClearBtn?.addEventListener('click', () => {
    if (templateFormDirty) {
      const discard = confirm('Der er ugemte ændringer i skabelonen. Kassér ændringerne?');
      if (!discard) return;
    }
    selectedTemplateId = null;
    loadTemplateIntoForm(null);
    renderTemplateRows();
  });
  templateForm?.addEventListener('submit', async evt => {
    evt.preventDefault();
    if (!ensureWrite('fhir_templates')) return;
    const formData = new FormData(templateForm);
    const toNullable = value => {
      if (value == null) return null;
      const trimmed = value.toString().trim();
      return trimmed ? trimmed : null;
    };
    const payload = {
      name: toNullable(formData.get('name')),
      target_system: toNullable(formData.get('target_system')),
      destination_name: toNullable(formData.get('destination_name')),
      destination_endpoint: toNullable(formData.get('destination_endpoint')),
      composition_title: toNullable(formData.get('composition_title')),
      description: toNullable(formData.get('description')),
      message_event_system: toNullable(formData.get('message_event_system')),
      message_event_code: toNullable(formData.get('message_event_code')),
      message_event_display: toNullable(formData.get('message_event_display')),
      bundle_profile: toNullable(formData.get('bundle_profile')),
      message_profile: toNullable(formData.get('message_profile')),
      diagnostic_report_profile: toNullable(formData.get('diagnostic_report_profile')),
      observation_profile: toNullable(formData.get('observation_profile')),
      destination_identifier_system: toNullable(formData.get('destination_identifier_system')),
      destination_identifier_value: toNullable(formData.get('destination_identifier_value')),
      composition_type_system: toNullable(formData.get('composition_type_system')),
      composition_type_code: toNullable(formData.get('composition_type_code')),
      composition_type_display: toNullable(formData.get('composition_type_display')),
      composition_profile: toNullable(formData.get('composition_profile')),
      document_type_system: toNullable(formData.get('document_type_system')),
      document_type_code: toNullable(formData.get('document_type_code')),
      document_type_display: toNullable(formData.get('document_type_display')),
      document_title: toNullable(formData.get('document_title')),
      document_profile: toNullable(formData.get('document_profile')),
      include_variant_observations: templateForm.elements.include_variant_observations.checked,
      include_document_reference: templateForm.elements.include_document_reference.checked,
      include_composition: templateForm.elements.include_composition.checked
    };
    if (!payload.name) {
      alert('Angiv et navn for skabelonen.');
      templateForm.elements.name?.focus();
      return;
    }
    const idValue = formData.get('id');
    let nextSelectedId = null;
    if (idValue) {
      const id = Number(idValue);
      const before = {...findById('fhir_templates', id)};
      const updated = {...before, ...payload, id};
      await updateRecord('fhir_templates', updated, before);
      setStatus('Skabelon opdateret.');
      nextSelectedId = id;
    } else {
      const createdId = await addRecord('fhir_templates', payload);
      setStatus('Skabelon oprettet.');
      nextSelectedId = createdId;
    }
    await loadStore('fhir_templates');
    templateData = getSortedTemplates();
    selectedTemplateId = nextSelectedId != null && Number.isFinite(Number(nextSelectedId)) ? Number(nextSelectedId) : null;
    if (selectedTemplateId == null && templateData.length) {
      const fallbackId = templateData[0]?.id;
      selectedTemplateId = Number.isFinite(Number(fallbackId)) ? Number(fallbackId) : null;
    }
    renderTemplateRows();
    const activeTemplate = templateData.find(t => Number(t.id) === selectedTemplateId);
    loadTemplateIntoForm(activeTemplate || null);
    refreshTemplateConsumers();
  });
  templateDeleteBtn?.addEventListener('click', async () => {
    const id = Number(templateForm?.elements.id?.value);
    if (!id) {
      alert('Vælg en skabelon der skal slettes.');
      return;
    }
    if (!ensureWrite('fhir_templates')) return;
    if (!confirm('Slet skabelonen? Handling kan ikke fortrydes.')) return;
    await deleteRecord('fhir_templates', id);
    await loadStore('fhir_templates');
    templateData = getSortedTemplates();
    const firstTemplateId = templateData[0]?.id;
    selectedTemplateId = Number.isFinite(Number(firstTemplateId)) ? Number(firstTemplateId) : null;
    const nextTemplate = templateData.find(t => Number(t.id) === selectedTemplateId) || null;
    loadTemplateIntoForm(nextTemplate);
    renderTemplateRows();
    refreshTemplateConsumers();
  });

  const presetLists = {
    metric: section.querySelector('[data-qc-preset-list="metric"]'),
    unit: section.querySelector('[data-qc-preset-list="unit"]')
  };
  const presetInputs = {
    metric: section.querySelector('[data-qc-preset-input="metric"]'),
    unit: section.querySelector('[data-qc-preset-input="unit"]')
  };
  const presetAddButtons = {
    metric: section.querySelector('[data-qc-preset-add="metric"]'),
    unit: section.querySelector('[data-qc-preset-add="unit"]')
  };

  const getPresetRecords = kind => sortQcPresets((getCached('qc_presets') || []).filter(item => item && item.kind === kind));
  const refreshPresetConsumers = () => {
    ['case_create','qc'].forEach(id => {
      const target = document.querySelector(`section[data-tab="${id}"]`);
      if (target && target.classList.contains('active')) {
        renderTab(id);
      }
    });
  };
  const hasDuplicatePreset = (kind, value, excludeId = null) => {
    const normalised = value.trim().toLowerCase();
    return (getCached('qc_presets') || []).some(item => {
      if (!item || item.kind !== kind) return false;
      if (excludeId != null && Number(item.id) === Number(excludeId)) return false;
      return String(item.value ?? '').trim().toLowerCase() === normalised;
    });
  };
  const renderPresetList = kind => {
    const container = presetLists[kind];
    if (!container) return;
    container.innerHTML = '';
    const presets = getPresetRecords(kind);
    if (!presets.length) {
      const empty = document.createElement('p');
      empty.className = 'form-hint';
      empty.textContent = 'Ingen forvalg endnu.';
      container.appendChild(empty);
      return;
    }
    presets.forEach(preset => {
      const row = document.createElement('div');
      row.className = 'inline-group qc-preset-row';
      row.dataset.id = preset.id;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = String(preset.value ?? '');
      input.placeholder = kind === 'metric' ? 'Måling' : 'Enhed';
      input.addEventListener('change', async () => {
        const trimmed = input.value.trim();
        if (!trimmed) {
          alert('Værdien må ikke være tom.');
          input.value = String(preset.value ?? '');
          input.focus();
          return;
        }
        if (!ensureWrite('qc_presets')) {
          input.value = String(preset.value ?? '');
          return;
        }
        if (hasDuplicatePreset(kind, trimmed, preset.id)) {
          alert('Værdien findes allerede i listen.');
          input.value = String(preset.value ?? '');
          input.select();
          return;
        }
        const before = {...preset};
        const updated = {...preset, value: trimmed};
        try {
          await updateRecord('qc_presets', updated, before);
          setStatus(`${kind === 'metric' ? 'Måling' : 'Enhed'} opdateret.`);
          renderPresetList(kind);
          refreshPresetConsumers();
        } catch (err) {
          console.error(err);
          alert('Kunne ikke opdatere værdien: ' + err.message);
          input.value = String(before.value ?? '');
        }
      });
      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.className = 'secondary';
      deleteBtn.textContent = 'Fjern';
      deleteBtn.addEventListener('click', async () => {
        if (!ensureWrite('qc_presets')) return;
        if (!confirm('Fjern denne forvalgsværdi?')) return;
        await deleteRecord('qc_presets', Number(preset.id));
        setStatus(`${kind === 'metric' ? 'Måling' : 'Enhed'} fjernet fra forvalgene.`);
        renderPresetList(kind);
        refreshPresetConsumers();
      });
      row.appendChild(input);
      row.appendChild(deleteBtn);
      container.appendChild(row);
    });
  };
  const addPreset = async kind => {
    const input = presetInputs[kind];
    if (!input) return;
    const trimmed = input.value.trim();
    if (!trimmed) {
      alert(kind === 'metric' ? 'Angiv en måling der skal tilføjes.' : 'Angiv en enhed der skal tilføjes.');
      input.focus();
      return;
    }
    if (!ensureWrite('qc_presets')) return;
    if (hasDuplicatePreset(kind, trimmed)) {
      alert('Værdien findes allerede i listen.');
      input.select();
      return;
    }
    const presets = getPresetRecords(kind);
    const last = presets[presets.length - 1];
    const nextOrder = last && Number.isFinite(Number(last.sort_order)) ? Number(last.sort_order) + 1 : presets.length;
    await addRecord('qc_presets', {kind, value: trimmed, sort_order: nextOrder});
    input.value = '';
    setStatus(`${kind === 'metric' ? 'Måling' : 'Enhed'} tilføjet til forvalgene.`);
    renderPresetList(kind);
    refreshPresetConsumers();
  };
  ['metric','unit'].forEach(kind => {
    renderPresetList(kind);
    const button = presetAddButtons[kind];
    const input = presetInputs[kind];
    button?.addEventListener('click', () => addPreset(kind));
    input?.addEventListener('keydown', evt => {
      if (evt.key === 'Enter') {
        evt.preventDefault();
        addPreset(kind);
      }
    });
  });
  const restoreBtn = section.querySelector('#qcPresetsRestore');
  restoreBtn?.addEventListener('click', async () => {
    if (!ensureWrite('qc_presets')) return;
    if (!confirm('Gendan standardværdier for QC-målinger og enheder?')) return;
    try {
      if (state.db) {
        const tx = state.db.transaction('qc_presets', 'readwrite');
        tx.objectStore('qc_presets').clear();
        await tx.done?.catch(() => {});
      }
      state.cache.set('qc_presets', []);
      await ensureDefaultQcPresets();
      setStatus('Standardværdier for kvalitetskontrol gendannet.');
      ['metric','unit'].forEach(renderPresetList);
      refreshPresetConsumers();
    } catch (err) {
      console.error(err);
      alert('Kunne ikke gendanne standardværdier: ' + err.message);
    }
  });
}
async function runTests() {
  if (!ensureWrite('patients')) return;
  let section = document.querySelector('section[data-tab="admin"]');
  if (!section) {
    activateTab('admin');
    return setTimeout(runTests, 200);
  }
  setStatus('Kører selvtest...');
  const snapshot = await exportData();
  const results = [];
  try {
    const patientId = await addRecord('patients', {mrn:'TEST1', name:'Testpatient', gender:'other', birth_date:'1980-01-01', notes:''});
    const patient = findById('patients', patientId);
    results.push(['Oprettelse/udlæsning patient', patient?.name === 'Testpatient', `Navn: ${patient?.name}`]);
    const sampleId = await addRecord('samples', {patient_id:patientId, pmb_number:`PMB-SELFTST-${Date.now()}`, sample_type:'Blod', status:'Modtaget', collected_at:new Date().toISOString(), notes:''});
    const orderId = await addRecord('orders', {patient_id:patientId, sample_id:sampleId, panel_id:null, clinician:'Testperson', status:'Analyse', acute:false, urgent:false, ordered_at:new Date().toISOString(), family_type:'singleton'});
    await addRecord('variants', {
      order_id: orderId,
      gene: 'BRCA1',
      transcript: '',
      hgvs_c: 'c.5266dupC',
      hgvs_p: 'p.(Gln1756Profs*74)',
      classification: '5',
      criteria: 'PVS1',
      af: '',
      interpretation: ''
    });
    const variantCount = getCached('variants').filter(v => v.order_id === orderId).length;
    results.push(['Tilføj testvariant', variantCount > 0, `Varianter: ${variantCount}`]);
    results.push(['Oprettelse ordination med FK', !!findById('orders', orderId), `Ordination ${orderId}`]);
    const variantDetails = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
    const reportHtml = buildReportHtml(orderId, {status:'draft', issued_at:new Date().toISOString(), summary:'Test', variant_details: variantDetails});
    results.push(['Generering af rapport HTML', reportHtml.includes('Diagnostisk rapport'), 'HTML længde ' + reportHtml.length]);
    const bundle = buildFhirBundle(orderId);
    const hasResources = ['MessageHeader','Patient','DiagnosticReport','Observation'].every(type => (bundle.entry||[]).some(e => e.resource.resourceType === type));
    results.push(['Udgående FHIR-bundle indhold', hasResources, `Ressourcer: ${(bundle.entry||[]).length}`]);
    const files = await buildZipFiles();
    const zip = createZip(files);
    const view = new DataView(zip.buffer);
    const centralDirOffset = view.getUint32(zip.length - 6, true);
    results.push(['ZIP-bytes genereret', centralDirOffset > 0, `Centraldir-offset: ${centralDirOffset}`]);
    const sql = await generateSqlDump();
    results.push(['SQL-dump indeholder variants.criteria', sql.includes('`criteria`'), 'Længde ' + sql.length]);
    results.push(['Filbinding API', 'showOpenFilePicker' in window || 'showSaveFilePicker' in window, 'Filadgang ' + (('showOpenFilePicker' in window) ? 'tilgængelig' : 'ukendt')]);
  } catch (err) {
    console.error(err);
    results.push(['Testfejl', false, err.message]);
  } finally {
    state.testResults = results;
    await replaceAllData(snapshot, {markSynced: true});
    renderAll();
    section = document.querySelector('section[data-tab="admin"]');
    if (section) renderAdmin(section);
    setStatus('Selvtest gennemført. Data gendannet til udgangspunktet.');
  }
}
async function buildZipFiles() {
  const backup = JSON.stringify(await exportData(), null, 2);
  const html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
  const readme = 'GlimR - lokalt enkeltfil-LIMS\n\nÅbn GlimR.html i en moderne browser.\n';
  return [
    {name:'GlimR.html', data:utf8Encode(html)},
    {name:'glimr-backup.json', data:utf8Encode(backup)},
    {name:'README.txt', data:utf8Encode(readme)}
  ];
}
function base64EncodeUtf8(str) {
  const bytes = utf8Encode(str);
  let binary = '';
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  return btoa(binary);
}
function utf8Encode(str) {
  return new TextEncoder().encode(str);
}
function crc32(buf) {
  let crc = -1;
  for (let i=0; i<buf.length; i++) {
    crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ buf[i]) & 0xff];
  }
  return (crc ^ -1) >>> 0;
}
const CRC_TABLE = (() => {
  const table = new Uint32Array(256);
  for (let n=0; n<256; n++) {
    let c = n;
    for (let k=0; k<8; k++) {
      c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[n] = c >>> 0;
  }
  return table;
})();
function createZip(files) {
  let total = 0;
  files.forEach(f => total += 30 + f.name.length + f.data.length);
  total += files.length * 46;
  total += 22;
  const buffer = new Uint8Array(total + 1024);
  let offset = 0;
  const central = [];
  const now = new Date();
  const dostime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() / 2)) & 0xffff;
  const dosdate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth()+1) << 5) | now.getDate()) & 0xffff;
  for (const file of files) {
    const nameBytes = utf8Encode(file.name);
    const crc = crc32(file.data);
    const localHeader = new DataView(buffer.buffer, offset, 30);
    localHeader.setUint32(0, 0x04034b50, true);
    localHeader.setUint16(4, 20, true);
    localHeader.setUint16(6, 0, true);
    localHeader.setUint16(8, 0, true);
    localHeader.setUint16(10, dostime, true);
    localHeader.setUint16(12, dosdate, true);
    localHeader.setUint32(14, crc, true);
    localHeader.setUint32(18, file.data.length, true);
    localHeader.setUint32(22, file.data.length, true);
    localHeader.setUint16(26, nameBytes.length, true);
    localHeader.setUint16(28, 0, true);
    offset += 30;
    buffer.set(nameBytes, offset);
    offset += nameBytes.length;
    buffer.set(file.data, offset);
    offset += file.data.length;
    central.push({nameBytes, crc, size:file.data.length, offset: offset - file.data.length - nameBytes.length - 30});
  }
  const centralStart = offset;
  for (const entry of central) {
    const view = new DataView(buffer.buffer, offset, 46);
    view.setUint32(0, 0x02014b50, true);
    view.setUint16(4, 0x031E, true);
    view.setUint16(6, 20, true);
    view.setUint16(8, 0, true);
    view.setUint16(10, 0, true);
    view.setUint16(12, dostime, true);
    view.setUint16(14, dosdate, true);
    view.setUint32(16, entry.crc, true);
    view.setUint32(20, entry.size, true);
    view.setUint32(24, entry.size, true);
    view.setUint16(28, entry.nameBytes.length, true);
    view.setUint16(30, 0, true);
    view.setUint16(32, 0, true);
    view.setUint16(34, 0, true);
    view.setUint16(36, 0, true);
    view.setUint32(38, 0, true);
    view.setUint32(42, entry.offset, true);
    offset += 46;
    buffer.set(entry.nameBytes, offset);
    offset += entry.nameBytes.length;
  }
  const centralSize = offset - centralStart;
  const view = new DataView(buffer.buffer, offset, 22);
  view.setUint32(0, 0x06054b50, true);
  view.setUint16(4, 0, true);
  view.setUint16(6, 0, true);
  view.setUint16(8, central.length, true);
  view.setUint16(10, central.length, true);
  view.setUint32(12, centralSize, true);
  view.setUint32(16, centralStart, true);
  view.setUint16(20, 0, true);
  offset += 22;
  return buffer.slice(0, offset);
}
async function generateSqlDump() {
  const createStatements = `SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS=0;
CREATE TABLE IF NOT EXISTS \`patients\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`mrn\` VARCHAR(64),
  \`extra_id\` VARCHAR(64),
  \`family_number\` VARCHAR(64),
  \`name\` VARCHAR(255),
  \`gender\` VARCHAR(32),
  \`birth_date\` DATE,
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`users\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`name\` VARCHAR(255),
  \`email\` VARCHAR(255),
  \`role\` VARCHAR(128),
  \`pin\` VARCHAR(128),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`panels\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`name\` VARCHAR(255),
  \`description\` TEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`samples\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`pmb_number\` VARCHAR(64),
  \`patient_id\` INT,
  \`sample_type\` VARCHAR(128),
  \`collected_at\` DATETIME,
  \`status\` VARCHAR(64),
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_samples_patient FOREIGN KEY (patient_id) REFERENCES patients(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  CREATE TABLE IF NOT EXISTS \`orders\` (
    \`id\` INT AUTO_INCREMENT PRIMARY KEY,
    \`patient_id\` INT,
    \`sample_id\` INT,
    \`panel_id\` INT NULL,
    \`analysis_responsible_id\` INT NULL,
    \`interpreter_id\` INT NULL,
    \`approver_id\` INT NULL,
    \`patient_group_id\` INT NULL,
    \`family_type\` VARCHAR(32),
    \`clinician\` VARCHAR(255),
    \`status\` VARCHAR(64),
    \`urgent\` TINYINT(1) DEFAULT 0,
    \`ordered_at\` DATETIME,
    \`created_by\` VARCHAR(255),
    \`created_at\` DATETIME,
    \`updated_at\` DATETIME,
    CONSTRAINT fk_orders_patient FOREIGN KEY (patient_id) REFERENCES patients(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_orders_sample FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_orders_panel FOREIGN KEY (panel_id) REFERENCES panels(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_analysis_responsible FOREIGN KEY (analysis_responsible_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_interpreter FOREIGN KEY (interpreter_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_approver FOREIGN KEY (approver_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_orders_patient_group FOREIGN KEY (patient_group_id) REFERENCES patient_groups(id) ON DELETE SET NULL ON UPDATE CASCADE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  CREATE TABLE IF NOT EXISTS \`patient_groups\` (
    \`id\` INT AUTO_INCREMENT PRIMARY KEY,
    \`name\` VARCHAR(255),
    \`created_by\` VARCHAR(255),
    \`created_at\` DATETIME,
    \`updated_at\` DATETIME
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  CREATE TABLE IF NOT EXISTS \`reports\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`order_id\` INT,
  \`findings\` TEXT,
  \`variant_ids\` TEXT,
  \`variant_details\` LONGTEXT,
  \`summary\` TEXT,
  \`status\` VARCHAR(32),
  \`issued_at\` DATETIME,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_reports_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`qc_metrics\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`sample_id\` INT,
  \`metric\` VARCHAR(128),
  \`value\` DECIMAL(18,6),
  \`unit\` VARCHAR(64),
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_qc_sample FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`qc_presets\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`kind\` VARCHAR(32),
  \`value\` VARCHAR(255),
  \`sort_order\` INT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`variants\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`order_id\` INT,
  \`gene\` VARCHAR(128),
  \`transcript\` VARCHAR(128),
  \`hgvs_c\` VARCHAR(255),
  \`hgvs_p\` VARCHAR(255),
  \`genomic_position\` VARCHAR(128),
  \`zygosity\` VARCHAR(64),
  \`classification\` VARCHAR(8),
  \`criteria\` VARCHAR(255),
  \`af\` DECIMAL(18,6),
  \`interpretation\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_variants_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`variant_library\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`gene\` VARCHAR(128),
  \`transcript\` VARCHAR(128),
  \`hgvs_c\` VARCHAR(255),
  \`hgvs_p\` VARCHAR(255),
  \`genomic_position\` VARCHAR(128),
  \`classification\` VARCHAR(8),
  \`criteria\` VARCHAR(255),
  \`evidence\` TEXT,
  \`condition\` VARCHAR(255),
  \`inheritance\` VARCHAR(128),
  \`curated_by\` VARCHAR(255),
  \`last_review\` DATE,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`conclusion_library\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`title\` VARCHAR(255),
  \`body\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`responses\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`ts\` DATETIME,
  \`sender\` VARCHAR(255),
  \`patient\` VARCHAR(255),
  \`diagnostic_report_id\` VARCHAR(255),
  \`variant_count\` INT,
  \`variants\` TEXT,
  \`raw\` LONGTEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`fhir_templates\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`name\` VARCHAR(255),
  \`target_system\` VARCHAR(255),
  \`description\` TEXT,
  \`bundle_profile\` VARCHAR(512),
  \`message_profile\` VARCHAR(512),
  \`message_event_system\` VARCHAR(512),
  \`message_event_code\` VARCHAR(255),
  \`message_event_display\` VARCHAR(255),
  \`destination_name\` VARCHAR(255),
  \`destination_endpoint\` VARCHAR(512),
  \`destination_identifier_system\` VARCHAR(255),
  \`destination_identifier_value\` VARCHAR(255),
  \`diagnostic_report_profile\` VARCHAR(512),
  \`observation_profile\` VARCHAR(512),
  \`include_document_reference\` TINYINT(1),
  \`include_composition\` TINYINT(1),
  \`include_variant_observations\` TINYINT(1),
  \`composition_title\` VARCHAR(255),
  \`composition_type_system\` VARCHAR(255),
  \`composition_type_code\` VARCHAR(64),
  \`composition_type_display\` VARCHAR(255),
  \`composition_profile\` VARCHAR(512),
  \`document_type_system\` VARCHAR(255),
  \`document_type_code\` VARCHAR(64),
  \`document_type_display\` VARCHAR(255),
  \`document_title\` VARCHAR(255),
  \`document_profile\` VARCHAR(512),
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`audit_log\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`ts\` DATETIME,
  \`user\` VARCHAR(128),
  \`action\` VARCHAR(64),
  \`entity\` VARCHAR(64),
  \`entity_id\` INT,
  \`before\` LONGTEXT,
  \`after\` LONGTEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;`;
  const rows = await exportData();
  const inserts = [];
  const mapTable = {
    patients: 'patients',
    patient_groups: 'patient_groups',
    users: 'users',
    samples: 'samples',
    panels: 'panels',
    orders: 'orders',
    reports: 'reports',
    qc: 'qc_metrics',
    qc_presets: 'qc_presets',
    variants: 'variants',
    variant_library: 'variant_library',
    conclusion_library: 'conclusion_library',
    responses: 'responses',
    fhir_templates: 'fhir_templates',
    audit: 'audit_log'
  };
  for (const [store, table] of Object.entries(mapTable)) {
    const data = rows[store] || [];
    if (!data.length) continue;
    const fields = schemaFields[store];
    const fieldList = fields.map(f => `\`${f}\``).join(',');
    const values = data
      .map(row => `(${fields.map(field => sqlValue(row[field])).join(',')})`)
      .join(',\n');
    inserts.push(
      `INSERT INTO \`${table}\` (${fieldList}) VALUES\n${values};`
    );
  }
  return createStatements + inserts.join('\n\n') + '\n';
}


function sqlValue(val) {
  if (val === null || val === undefined || val === '') return 'NULL';
  if (typeof val === 'number') return String(val);
  const str = String(val).replace(/'/g, "''");
  return `'${str}'`;
}
async function loadDemoData() {
  if (!ensureWrite('patients')) return;
  if (!confirm('Indlæse demo-data? Dette overskriver ikke eksisterende poster men tilføjer hvis tomt.')) return;
  const groups = getCached('patient_groups');
  const firstGroupId = groups[0]?.id || null;
  const secondGroupId = groups[1]?.id || firstGroupId;
  if (!getCached('patients').length) {
    const p1 = await addRecord('patients', {mrn:'MRN001', extra_id:'ALT-001', family_number:'FAM-001', name:'Anna Jensen', gender:'female', birth_date:'1985-03-12', notes:'Familiehistorik positiv'});
    const p2 = await addRecord('patients', {mrn:'MRN002', extra_id:'ALT-002', family_number:'FAM-002', name:'Lars Petersen', gender:'male', birth_date:'1978-11-03', notes:''});
    const s1 = await addRecord('samples', {patient_id:p1, pmb_number:'PMB-0001', sample_type:'Blod', status:'QC', collected_at:new Date().toISOString(), notes:''});
    const s2 = await addRecord('samples', {patient_id:p2, pmb_number:'PMB-0002', sample_type:'Kindskrab', status:'Analyse', collected_at:new Date().toISOString(), notes:''});
    const panel = await addRecord('panels', {name:'Onko-panel', description:'50 gener'});
    const o1 = await addRecord('orders', {patient_id:p1, sample_id:s1, panel_id:panel, analysis_responsible_id:null, interpreter_id:null, approver_id:null, clinician:'Dr. Holm', indication:'Mistanke om arvelig brystkræft', patient_group_id:firstGroupId, family_type:'singleton', hpo_terms:normalizeHpoTerms('HP:0003002; HP:0006770'), status:'Analyse', acute:false, urgent:false, ordered_at:new Date().toISOString()});
    const o2 = await addRecord('orders', {patient_id:p2, sample_id:s2, panel_id:panel, analysis_responsible_id:null, interpreter_id:null, approver_id:null, clinician:'Dr. Holm', indication:'Kolorektal cancer – postoperativ opfølgning', patient_group_id:secondGroupId, family_type:'trio', hpo_terms:normalizeHpoTerms('HP:0100242'), status:'Rapport', acute:false, urgent:false, ordered_at:new Date().toISOString()});
    await addRecord('variants', {order_id:o1, gene:'BRCA1', transcript:'NM_007294.3', hgvs_c:'c.5266dupC', hgvs_p:'p.Gln1756Profs', genomic_position:'chr17-43071077', zygosity:'heterozygot', classification:'5', criteria:'PVS1,PS3,PM2,PP3', af:0.0001, interpretation:'Patogen variant med høj risiko'});
    await addRecord('qc', {sample_id:s1, metric:'Dækning', value:98.5, unit:'%', notes:''});
    await addRecord('reports', {order_id:o2, variant_ids:'[]', variant_details:[], summary:'Negativ rapport', status:'final', issued_at:new Date().toISOString()});
    await addRecord('users', {name:'Admin', email:'admin@example.com', role:'Administrator', pin:'admin'});
  } else {
    alert('Demo-data allerede til stede.');
  }
  await loadAllStores();
  renderAll();
  refreshLoginOptions();
  updateAuthUi();
}
function hookUi() {
  const loginForm = document.getElementById('loginForm');
  if (loginForm) loginForm.addEventListener('submit', handleLogin);
  const logoutBtn = document.getElementById('logoutBtn');
  if (logoutBtn) {
    logoutBtn.addEventListener('click', logoutUser);
    setTooltip(logoutBtn, tooltipCatalog.buttons.logoutBtn);
  }
  const themeBtn = document.getElementById('themeToggle');
  if (themeBtn) {
    themeBtn.addEventListener('click', toggleTheme);
    setTooltip(themeBtn, tooltipCatalog.buttons.themeToggle);
  }
  const logoImg = document.getElementById('glimrLogo');
  if (logoImg) {
    const brand = logoImg.closest('.brand');
    const brandMark = brand ? brand.querySelector('.brand-mark') : null;
    const showBrandMark = (show) => {
      if (!brandMark) return;
      brandMark.setAttribute('aria-hidden', show ? 'false' : 'true');
    };
    const markMissing = () => {
      if (brand) {
        brand.classList.add('logo-missing');
      }
      showBrandMark(true);
      if (logoImg.parentElement) {
        logoImg.remove();
      }
    };
    const markLoaded = () => {
      if (brand) {
        brand.classList.remove('logo-missing');
      }
      showBrandMark(false);
    };
    logoImg.addEventListener('error', markMissing, { once: true });
    logoImg.addEventListener('load', markLoaded);
    if (logoImg.complete) {
      if (logoImg.naturalWidth === 0) {
        markMissing();
      } else {
        markLoaded();
      }
    } else {
      markLoaded();
    }
  }
  applyTheme();
  refreshLoginOptions();
  updateAuthUi();
  applyControlTooltips(document.body);
}
async function init() {
  initTabs();
  try {
    setStatus('Åbner database...');
    state.db = await openDb();
    setStatus(state.usingMemoryDb ? 'Database åben (midlertidig hukommelse)' : 'Database åben');
    await loadAllStores();
    await ensureDefaultPatientGroups();
    await ensureDefaultQcPresets();
    await ensureDefaultFhirTemplates();
    await ensureCreationMetadata();
    await captureSyncedSnapshot();
    await restoreBoundHandle();
    hookUi();
    restoreUserSession();
    if (state.boundHandle) {
      await reloadBoundFileData({silent: true, refreshUi: false});
    }
    renderAll();
    if (state.autosave && state.boundHandle) {
      scheduleAutosave();
    }
    activateTab('dashboard');
  } catch (err) {
    console.error(err);
    setStatus('Kunne ikke åbne database: ' + err.message);
  }
}
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
})();
</script>
</body>
</html>
