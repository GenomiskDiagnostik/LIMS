<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<title>GlimR – Genetic LIMS Reporter</title>
<style>
:root {
  font-family: "Segoe UI", Arial, sans-serif;
  color-scheme: light dark;
  --bg: #f5f7fb;
  --text: #162941;
  --muted-text: #41516b;
  --panel-bg: #ffffff;
  --panel-border: #c7d2e3;
  --shadow: 0 4px 14px rgba(18, 76, 135, 0.08);
  --accent: #186faf;
  --accent-strong: #124c87;
  --danger: #c0392b;
  --nav-bg: #ffffff;
  --nav-border: #c7d2e3;
  --nav-button-bg: #e3ecf8;
  --nav-button-color: #124c87;
  --nav-button-active-bg: #124c87;
  --nav-button-active-color: #ffffff;
  --table-header-bg: #f0f4fb;
  --table-row-border: #dde4f1;
  --badge-bg: #dce6f7;
  --badge-color: #0f4173;
  --input-bg: #ffffff;
  --input-border: #c3cde0;
  --input-placeholder: #6b7d97;
  --input-focus: rgba(24, 111, 175, 0.35);
  --header-bg: linear-gradient(135deg, #124c87, #186faf);
  --header-text: #ffffff;
  --code-bg: #101927;
  --code-text: #e8f1ff;
}
[data-theme="dark"] {
  --bg: #0f172a;
  --text: #e2e8f0;
  --muted-text: #94a3b8;
  --panel-bg: #1e293b;
  --panel-border: #334155;
  --shadow: 0 6px 18px rgba(8, 47, 73, 0.55);
  --accent: #38bdf8;
  --accent-strong: #0ea5e9;
  --danger: #ef4444;
  --nav-bg: #111c30;
  --nav-border: #1f2a3c;
  --nav-button-bg: #1f2a3c;
  --nav-button-color: #cbd5f5;
  --nav-button-active-bg: #0ea5e9;
  --nav-button-active-color: #0b1120;
  --table-header-bg: #233049;
  --table-row-border: #2f3e58;
  --badge-bg: #1d4ed8;
  --badge-color: #bfdbfe;
  --input-bg: #0f172a;
  --input-border: #334155;
  --input-placeholder: #64748b;
  --input-focus: rgba(56, 189, 248, 0.45);
  --header-bg: linear-gradient(135deg, #0b2a4a, #14395d);
  --header-text: #e2e8f0;
  --code-bg: #0b1120;
  --code-text: #e2e8f0;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  transition: background 0.2s ease, color 0.2s ease;
}
header {
  background: var(--header-bg);
  color: var(--header-text);
  padding: 1rem 2rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 1rem;
}
.brand {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex: 1 1 260px;
  min-width: 200px;
}
.brand img {
  width: 64px;
  height: 64px;
  object-fit: contain;
}
.brand.logo-missing::after {
  content: 'Logo mangler – placer logo.png ved siden af GlimR.html.';
  display: block;
  font-size: 0.75rem;
  color: var(--muted-text);
}
header h1 {
  margin: 0;
  font-size: 1.8rem;
}
#statusBar {
  font-size: 0.9rem;
  margin-top: 0.3rem;
  color: var(--header-text);
}
.header-actions {
  display: flex;
  gap: 1rem;
  align-items: stretch;
  flex-wrap: wrap;
  justify-content: flex-end;
}
.auth-block {
  background: rgba(255, 255, 255, 0.12);
  border-radius: 0.75rem;
  padding: 0.6rem 0.8rem;
  display: flex;
  align-items: center;
  gap: 0.6rem;
}
[data-theme="dark"] .auth-block {
  background: rgba(15, 23, 42, 0.45);
}
.auth-block form {
  display: flex;
  gap: 0.4rem;
  flex-wrap: wrap;
  align-items: center;
}
.auth-block select,
.auth-block input {
  min-width: 160px;
}
.auth-block .user-info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.auth-block .user-info span {
  font-weight: 600;
}
.quick-actions {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  flex-wrap: wrap;
  justify-content: flex-end;
}
nav {
  background: var(--nav-bg);
  border-bottom: 1px solid var(--nav-border);
  display: flex;
  flex-wrap: wrap;
  padding: 0.5rem 1rem;
  gap: 0.5rem;
}
nav button {
  border: none;
  background: var(--nav-button-bg);
  color: var(--nav-button-color);
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-size: 0.95rem;
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease;
}
nav button.active {
  background: var(--nav-button-active-bg);
  color: var(--nav-button-active-color);
}
main {
  padding: 1.5rem;
}
section[data-tab] {
  display: none;
}
section[data-tab].active {
  display: block;
}
.panel {
  background: var(--panel-bg);
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  padding: 1rem 1.2rem;
  margin-bottom: 1.2rem;
  border: 1px solid var(--panel-border);
}
.tool-panel {
  padding: 0;
  overflow: hidden;
}
.tool-panel summary {
  margin: 0;
  padding: 1rem 1.2rem;
  list-style: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
  background: transparent;
  color: inherit;
  transition: background 0.2s ease, color 0.2s ease;
}
.tool-panel summary:hover {
  background: rgba(24, 111, 175, 0.08);
}
.tool-panel[open] summary {
  color: var(--accent-strong);
  background: rgba(24, 111, 175, 0.08);
}
[data-theme="dark"] .tool-panel summary:hover {
  background: rgba(56, 189, 248, 0.12);
}
[data-theme="dark"] .tool-panel[open] summary {
  background: rgba(56, 189, 248, 0.12);
  color: var(--accent);
}
.tool-panel summary:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
.tool-panel summary::-webkit-details-marker {
  display: none;
}
.tool-panel summary::marker {
  display: none;
}
.tool-panel summary::after {
  content: '\25B6';
  font-size: 0.95rem;
  color: var(--muted-text);
  transition: transform 0.2s ease;
}
.tool-panel[open] summary::after {
  transform: rotate(90deg);
  color: var(--accent-strong);
}
.tool-summary-text {
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
}
.tool-summary-text .tool-title {
  font-size: 1.05rem;
  font-weight: 600;
}
.tool-summary-text .tool-subtitle {
  font-size: 0.9rem;
  color: var(--muted-text);
}
.tool-panel .tool-body {
  padding: 0 1.2rem 1.2rem;
  border-top: 1px solid var(--panel-border);
}
.tool-panel .tool-body > h3 {
  margin-top: 1rem;
  margin-bottom: 0.5rem;
  font-size: 1.2rem;
}
.tool-panel .tool-body > p:first-of-type {
  margin-top: 0;
}
[data-theme="dark"] .tool-panel summary::after {
  color: var(--muted-text);
}
[data-theme="dark"] .tool-panel[open] summary::after {
  color: var(--accent);
}
.tool-panel[open] {
  padding-bottom: 0;
}
.tool-columns {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 0.75rem;
  margin-top: 0.75rem;
}
.tool-criteria-list {
  display: grid;
  gap: 0.4rem;
  justify-items: stretch;
}
.tool-criteria {
  display: grid;
  grid-template-columns: auto 1fr;
  align-items: flex-start;
  gap: 0.55rem;
  padding: 0.45rem 0.6rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.55rem;
  background: rgba(24, 111, 175, 0.08);
  text-align: left;
}
[data-theme="dark"] .tool-criteria {
  background: rgba(14, 165, 233, 0.12);
}
.tool-criteria input[type="checkbox"] {
  margin-top: 0.25rem;
}
.tool-criteria span {
  display: block;
  line-height: 1.35;
}
.tool-result {
  margin-top: 0.9rem;
  padding: 0.7rem 0.9rem;
  border-radius: 0.55rem;
  background: rgba(24, 111, 175, 0.08);
  border: 1px solid var(--panel-border);
}
[data-theme="dark"] .tool-result {
  background: rgba(14, 165, 233, 0.15);
}
.tool-inline {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 0.75rem;
  align-items: end;
  margin-top: 0.75rem;
}
.tool-inline label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.tool-note {
  color: var(--muted-text);
  font-size: 0.85rem;
  margin-top: 0.5rem;
}
.placeholder-guide {
  margin-top: 1rem;
  padding: 1rem 1.25rem;
  border-radius: 0.75rem;
  border: 1px solid var(--panel-border);
  background: rgba(24, 111, 175, 0.08);
}
[data-theme="dark"] .placeholder-guide {
  background: rgba(14, 165, 233, 0.12);
}
.placeholder-guide h3 {
  margin-top: 0;
  margin-bottom: 0.5rem;
}
.placeholder-guide h4 {
  margin: 0.75rem 0 0.35rem;
  font-size: 0.95rem;
}
.placeholder-guide p {
  margin: 0 0 0.5rem;
}
.placeholder-guide-columns {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 1rem;
}
.placeholder-guide ul {
  margin: 0;
  padding-left: 1.1rem;
  font-size: 0.92rem;
  color: var(--muted-text);
}
.placeholder-guide li + li {
  margin-top: 0.35rem;
}
.placeholder-guide code {
  font-family: 'Fira Code', 'Fira Mono', 'Consolas', monospace;
  background: rgba(24, 111, 175, 0.15);
  color: var(--accent-strong);
  border-radius: 0.45rem;
  padding: 0.05rem 0.35rem;
  font-size: 0.85rem;
}
[data-theme="dark"] .placeholder-guide code {
  background: rgba(14, 165, 233, 0.2);
  color: var(--code-text);
}
.placeholder-guide-footnote {
  margin-top: 0.75rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.variant-picker-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.45);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 1.5rem;
}
[data-theme="dark"] .variant-picker-overlay {
  background: rgba(8, 13, 23, 0.75);
}
.variant-picker {
  background: var(--panel-bg);
  color: var(--text);
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  border: 1px solid var(--panel-border);
  max-width: 960px;
  width: 100%;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
}
.variant-picker header {
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--panel-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}
.variant-picker header h3 {
  margin: 0;
  font-size: 1.25rem;
}
.variant-picker .picker-body {
  padding: 1rem 1.25rem 1.25rem;
  overflow: auto;
}
.variant-picker .picker-actions {
  display: flex;
  justify-content: flex-end;
  padding: 0 1.25rem 1rem;
}
.variant-picker table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 0.75rem;
}
.variant-picker table th,
.variant-picker table td {
  padding: 0.5rem 0.75rem;
  border-bottom: 1px solid var(--table-row-border);
  text-align: left;
}
.variant-picker table tbody tr {
  cursor: pointer;
  transition: background 0.15s ease;
}
.variant-picker table tbody tr:hover,
.variant-picker table tbody tr:focus-within {
  background: var(--table-header-bg);
}
.variant-picker table tbody tr:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
}
.variant-picker-empty {
  text-align: center;
  padding: 1.5rem 0.5rem;
  color: var(--muted-text);
}
.panel h2 {
  margin-top: 0;
}
.flex {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}
.flex > * {
  flex: 1 1 280px;
}
table {
  width: 100%;
  border-collapse: collapse;
  background: var(--panel-bg);
  color: inherit;
}
th, td {
  padding: 0.45rem 0.6rem;
  border-bottom: 1px solid var(--table-row-border);
  text-align: left;
  font-size: 0.9rem;
}
th {
  background: var(--table-header-bg);
}
tbody tr[data-selected="true"] {
  background: rgba(24, 111, 175, 0.12);
}
[data-theme="dark"] tbody tr[data-selected="true"] {
  background: rgba(56, 189, 248, 0.18);
}
form label {
  display: block;
  font-size: 0.8rem;
  font-weight: 600;
  margin-top: 0.4rem;
  color: var(--muted-text);
}
form input,
form select,
form textarea {
  width: 100%;
  padding: 0.4rem;
  border-radius: 0.4rem;
  border: 1px solid var(--input-border);
  font-size: 0.95rem;
  background: var(--input-bg);
  color: var(--text);
  transition: border 0.2s ease, box-shadow 0.2s ease;
}
form input::placeholder,
form textarea::placeholder {
  color: var(--input-placeholder);
}
form input:focus,
form select:focus,
form textarea:focus {
  outline: 2px solid var(--input-focus);
  border-color: var(--accent);
}
form textarea {
  min-height: 80px;
  resize: vertical;
}
.btn-row {
  margin-top: 0.8rem;
  display: flex;
  gap: 0.6rem;
  flex-wrap: wrap;
}
.panel-hint {
  margin-top: 0.4rem;
  color: var(--muted-text);
  font-size: 0.85rem;
}
.case-form fieldset {
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 1rem;
  margin: 0 0 1rem 0;
}
.case-form legend {
  font-weight: 600;
  padding: 0 0.4rem;
  color: var(--text);
}
.case-form .inline-group {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 0.5rem;
}
.case-form .inline-group > label,
.case-form label.inline {
  flex: 1 1 220px;
}
.case-form label.inline {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.case-form .form-hint {
  margin: 0.2rem 0 0.6rem 0;
  color: var(--muted-text);
  font-size: 0.85rem;
}
.case-form .case-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  align-items: flex-end;
  margin-bottom: 0.75rem;
}
.case-form .case-row > label {
  flex: 1 1 180px;
}
.case-form .case-row > label.wide {
  flex: 1 1 100%;
}
.case-form .case-row textarea {
  min-height: 60px;
}
.case-form .case-row button {
  align-self: flex-start;
}
.case-form .toggle {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.6rem 0;
  font-weight: 600;
  color: var(--muted-text);
}
.case-form .toggle input[type="checkbox"] {
  width: auto;
  accent-color: var(--accent);
}
.case-form textarea.small {
  min-height: 48px;
}
.table-actions {
  margin-top: 0.8rem;
  display: flex;
  justify-content: flex-end;
}
.table-actions button {
  min-width: 220px;
}
button.primary {
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 0.5rem;
  padding: 0.5rem 0.9rem;
  cursor: pointer;
}
button.danger {
  background: var(--danger);
  color: #fff;
}
button.secondary {
  background: var(--nav-button-bg);
  color: var(--nav-button-color);
  border: 1px solid transparent;
}
button:disabled {
  opacity: 0.55;
  cursor: not-allowed;
}
.badge {
  display: inline-block;
  padding: 0.2rem 0.5rem;
  border-radius: 0.4rem;
  background: var(--badge-bg);
  color: var(--badge-color);
  font-size: 0.75rem;
}
input[type="search"] {
  border-radius: 1rem;
}
.filterable-select {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  margin-top: 0.3rem;
}
.filterable-select input[type="search"] {
  padding: 0.35rem 0.5rem;
}
.filterable-select select {
  max-height: 220px;
}
.report-variant-selector {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  align-items: flex-end;
  margin-top: 0.4rem;
}
.report-variant-selector .filterable-select {
  flex: 1 1 260px;
  margin-top: 0;
}
.conclusion-library-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  align-items: flex-end;
  margin-top: 0.4rem;
}
.conclusion-library-controls label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.conclusion-library-controls select {
  min-width: 220px;
}
.conclusion-library-buttons {
  display: flex;
  gap: 0.4rem;
  align-items: center;
}
.conclusion-library-buttons button {
  margin-top: 0.35rem;
}
.report-variant-list {
  margin-top: 0.6rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.report-variant-item {
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 0.65rem;
  padding: 0.6rem 0.75rem;
  box-shadow: inset 0 1px 0 rgba(15, 27, 45, 0.04);
}
[data-theme="dark"] .report-variant-item {
  background: rgba(15, 23, 42, 0.45);
}
.report-variant-item header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-weight: 600;
}
.report-variant-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem 0.8rem;
  margin-top: 0.35rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.report-variant-meta strong {
  font-weight: 600;
}
.report-variant-item p {
  margin: 0.35rem 0 0;
}
.report-variant-remove {
  background: none;
  border: none;
  color: var(--danger);
  cursor: pointer;
  padding: 0.15rem 0.35rem;
  border-radius: 0.4rem;
  font-size: 0.85rem;
}
.report-variant-remove:hover,
.report-variant-remove:focus {
  text-decoration: underline;
}
.report-variant-empty {
  color: var(--muted-text);
  font-style: italic;
  font-size: 0.9rem;
}
.report-variant-detail {
  margin-top: 0.75rem;
  padding: 0.6rem 0.8rem;
  border-left: 3px solid var(--accent);
  border-radius: 0.6rem;
  background: var(--panel-bg);
}
[data-theme="dark"] .report-variant-detail {
  background: rgba(15, 23, 42, 0.45);
}
.report-variant-detail h3 {
  margin: 0;
}
.report-variant-detail ul {
  margin: 0.4rem 0 0;
  padding-left: 1.2rem;
}
.report-variant-detail p {
  margin: 0.5rem 0 0;
}
.family-combo {
  display: flex;
  gap: 0.4rem;
  align-items: center;
  margin-top: 0.3rem;
}
.family-combo select {
  flex: 0 0 12rem;
}
.family-combo input {
  flex: 1 1 auto;
}
.advanced-filter {
  margin-top: 0.6rem;
  border: 1px solid var(--panel-border);
  border-radius: 0.75rem;
  padding: 0.35rem 0.75rem;
  background: var(--panel-bg);
  box-shadow: inset 0 1px 2px rgba(15, 27, 45, 0.08);
}
.advanced-filter summary {
  cursor: pointer;
  font-weight: 600;
  color: var(--accent-strong);
  outline: none;
}
.advanced-filter summary::-webkit-details-marker {
  display: none;
}
.advanced-filter summary::after {
  content: '▾';
  float: right;
  transform: rotate(0deg);
  transition: transform 0.2s ease;
}
.advanced-filter[open] summary::after {
  transform: rotate(-180deg);
}
.advanced-filter .filter-grid {
  margin-top: 0.6rem;
  display: grid;
  gap: 0.6rem;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}
.advanced-filter label {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  font-size: 0.85rem;
  color: var(--muted-text);
}
.advanced-filter input,
.advanced-filter select {
  font-size: 0.9rem;
}
.read-only-banner {
  background: rgba(192, 57, 43, 0.1);
  color: var(--danger);
  border: 1px dashed var(--danger);
  border-radius: 0.5rem;
  padding: 0.6rem 0.8rem;
  margin-bottom: 1rem;
  font-weight: 600;
}
pre {
  background: var(--code-bg);
  color: var(--code-text);
  padding: 0.8rem;
  border-radius: 0.6rem;
  overflow: auto;
}
@media (max-width: 900px) {
  header {
    flex-direction: column;
    align-items: stretch;
  }
  .header-actions {
    width: 100%;
    justify-content: space-between;
  }
  .auth-block,
  .quick-actions {
    width: 100%;
    justify-content: space-between;
  }
}
@media (max-width: 600px) {
  .auth-block form,
  .quick-actions {
    flex-direction: column;
    align-items: stretch;
  }
  .auth-block form > * {
    width: 100%;
  }
}
</style>
</head>
<body>
<header>
  <div class="brand">
    <img id="glimrLogo" src="logo.png" alt="G" loading="lazy">
    <div>
      <h1>GlimR – Genetic LIMS Reporter</h1>
      <div id="statusBar">Initialiserer...</div>
    </div>
  </div>
  <div class="header-actions">
    <div class="auth-block" id="authBlock">
      <form id="loginForm">
        <select id="loginUser" required></select>
        <input id="loginPass" type="password" placeholder="Adgangskode (valgfri)">
        <button type="submit" class="primary">Log ind</button>
      </form>
      <div class="user-info" id="userInfo" hidden>
        <span id="currentUserLabel"></span>
        <button type="button" class="secondary" id="logoutBtn">Log ud</button>
      </div>
    </div>
    <div class="quick-actions">
      <button class="secondary" id="themeToggle">Skift til mørkt tema</button>
    </div>
  </div>
</header>
<nav id="tabNav"></nav>
<main id="tabContent"></main>
<script>
(() => {
'use strict';
const DB_NAME = 'glims';
const DB_VER = 6;
const STORES = ['patients','samples','orders','panels','variants','qc','reports','users','audit','variant_library','responses','conclusion_library'];
const state = {
  db: null,
  cache: new Map(),
  creationLookup: new Map(),
  boundHandle: null,
  autosave: false,
  autosaveTimer: null,
  currentTab: 'dashboard',
  currentUser: null,
  theme: localStorage.getItem('glimr-theme') || 'light',
  testResults: [],
  lastStatus: ''
};
const CREATED_BY_STORES = new Set(['patients','samples','orders','variants','qc','reports','conclusion_library']);
const ROLE_OPTIONS = [
  {value: 'Observatør', description: 'Kun læseadgang til data', canWrite: false},
  {value: 'Bioinformatiker', description: 'Kan registrere analyser og varianter', canWrite: true},
  {value: 'Skriver', description: 'Kan oprette og redigere alle laboratoriedata', canWrite: true},
  {value: 'Administrator', description: 'Fuld systemadgang inkl. brugeradministration', canWrite: true}
];
const WRITE_ROLE_KEYS = new Set(ROLE_OPTIONS.filter(opt => opt.canWrite).map(opt => opt.value.toLowerCase()));
function normaliseRoleValue(role) {
  return (role || '').toString().trim();
}
function findRoleOption(role) {
  const normalised = normaliseRoleValue(role).toLowerCase();
  return ROLE_OPTIONS.find(opt => opt.value.toLowerCase() === normalised) || null;
}
function roleLabel(role) {
  if (!role) return '';
  const match = findRoleOption(role);
  return match ? match.value : normaliseRoleValue(role);
}
function roleWithDescription(role) {
  if (!role) return '';
  const match = findRoleOption(role);
  if (!match) return normaliseRoleValue(role);
  return `${match.value} – ${match.description}`;
}
const classificationMap = {
  '1': {code:'LA6576-8', display:'Godartet'},
  '2': {code:'LA6577-6', display:'Sandsynligvis godartet'},
  '3': {code:'LA4489-6', display:'Variant af ukendt betydning (VUS)'},
  '4': {code:'LA6668-3', display:'Sandsynligvis patogen'},
  '5': {code:'LA6708-8', display:'Patogen'}
};
const tabs = [
  {id:'dashboard', label:'Overblik'},
  {id:'case_create', label:'Opret'},
  {id:'patients', label:'Patienter'},
  {id:'samples', label:'Prøver'},
  {id:'orders', label:'Ordinationer'},
  {id:'panels', label:'Analyser/Panels'},
  {id:'variants', label:'Varianter'},
  {id:'variant_library', label:'Variantbibliotek'},
  {id:'conclusion_library', label:'Standardtekster'},
  {id:'reports', label:'Rapporter'},
  {id:'qc', label:'Kvalitetskontrol'},
  {id:'responses', label:'Svar (MedCom)'},
  {id:'tools', label:'Værktøjskasse'},
  {id:'users', label:'Brugere'},
  {id:'audit', label:'Revision'},
  {id:'db', label:'Database & Backup'},
  {id:'admin', label:'Administration'},
  {id:'tests', label:'Selvtest'}
];
const SAMPLE_TYPES = ['Blod','Kindskrab','Biopsi','Kontrol'];
const SAMPLE_STATUSES = ['Modtaget','Afventer','QC','Analyse','Tolkning','Rapport','Svaret','Biobank','Annulleret'];
const schemaFields = {
  patients: ['id','mrn','family_number','name','gender','birth_date','notes','created_by','created_at','updated_at'],
  samples: ['id','pmb_number','patient_id','sample_type','collected_at','status','notes','created_by','created_at','updated_at'],
  panels: ['id','name','description','created_at','updated_at'],
  orders: ['id','patient_id','sample_id','panel_id','analysis_responsible_id','interpreter_id','approver_id','clinician','status','ordered_at','created_by','created_at','updated_at'],
  variants: ['id','order_id','gene','transcript','hgvs_c','hgvs_p','zygosity','classification','criteria','af','annotations','interpretation','created_by','created_at','updated_at'],
  qc: ['id','sample_id','metric','value','unit','notes','created_by','created_at','updated_at'],
  reports: ['id','order_id','findings','variant_ids','variant_details','summary','status','issued_at','created_by','created_at','updated_at'],
  users: ['id','name','email','role','pin','created_at','updated_at'],
  audit: ['id','ts','user','action','entity','entity_id','before','after','created_at','updated_at'],
  variant_library: ['id','gene','transcript','hgvs_c','hgvs_p','classification','criteria','evidence','condition','inheritance','curated_by','last_review','created_at','updated_at'],
  responses: ['id','ts','sender','patient','diagnostic_report_id','variant_count','variants','raw','created_at','updated_at'],
  conclusion_library: ['id','title','body','created_by','created_at','updated_at']
};
const tooltipCatalog = {
  tabs: {
    dashboard: 'Viser nøgletal, seneste ordinationer og seneste revisionshændelser.',
    case_create: 'Opret patient, prøve, ordination, QC og varianter i ét samlet flow.',
    patients: 'Administrer patientoplysninger og søg i patientlisten.',
    samples: 'Registrer og vedligehold prøver knyttet til patienter.',
    orders: 'Administrer analyseordinationer og deres status.',
    panels: 'Vedligehold assays og analysepaneler.',
    variants: 'Registrer genetiske varianter for ordinationer.',
    variant_library: 'Se og vedligehold det kuraterede variantbibliotek.',
    conclusion_library: 'Administrer standardtekster til rapportkonklusioner.',
    reports: 'Opret og redigér laboratoriesvar og rapporter.',
    qc: 'Registrer kvalitetskontrolmålinger for prøver.',
    responses: 'Importer og gennemse MedCom/FHIR-svar.',
    tools: 'Åbn værktøjskassen med beregnere og hjælpeværktøjer til variantfortolkning.',
    users: 'Administrer GlimR-brugere og roller.',
    audit: 'Gennemgå revisionsloggen for alle ændringer.',
    db: 'Håndter lokal databasefil, backup og autogem.',
    admin: 'Tilgå administrative værktøjer, SQL og ZIP-eksport.',
    tests: 'Kør indbyggede selvtests og se resultater.'
  },
  metrics: {
    'Patienter': 'Antal registrerede patienter i databasen.',
    'Prøver': 'Antal registrerede laboratorieprøver.',
    'Ordinationer': 'Samlet antal aktive og historiske ordinationer.',
    'Modtaget': 'Prøver registreret som modtaget i laboratoriet.',
    'Aktive': 'Prøver i aktiv behandling (QC, Analyse, Tolkning eller Rapport).',
    'Analyse': 'Prøver markeret som i analysefasen.',
    'Tolkning': 'Prøver under tolkning af resultater.',
    'Rapport': 'Prøver i rapporteringsfasen.',
    'Varianter': 'Antal registrerede genetiske varianter.',
    'Biobank': 'Prøver arkiveret i biobanken.'
  },
  headers: {
    'ID': 'Intern databaseidentifikator for posten.',
    'MRN': 'Medicinsk journalnummer eller CPR-reference.',
    'Familienummer': 'Eksternt familienummer brugt til at gruppere beslægtede patienter.',
    'Navn': 'Navnet på patient, panel eller bruger.',
    'Køn': 'Patientens registrerede køn.',
    'Født': 'Patientens fødselsdato.',
    'Patient': 'Tilknyttet patient til posten.',
    'Prøve': 'Prøve-ID eller beskrivelse.',
    'Prøvetype': 'Type af biologisk materiale.',
    'Panel': 'Navn på det analyserede panel.',
    'Analyseansvarlig': 'Bruger der har det overordnede ansvar for analysen.',
    'Tolker': 'Bruger der tolker de genetiske fund.',
    'Godkender': 'Bruger der godkender ordinationen eller rapporten.',
    'Status': 'Aktuel status for posten.',
    'Opdateret': 'Seneste ændringstidspunkt.',
    'Bestilt': 'Tidspunkt for oprettelse af ordinationen.',
    'Opsamlet': 'Dato og tidspunkt for prøveindsamling.',
    'Ordination': 'Reference til ordinationen.',
    'Gen': 'Genet hvor varianten er fundet.',
    'Transkript': 'Reference-transkript for varianten.',
    'HGVS c.': 'HGVS-beskrivelse på cDNA-niveau.',
    'HGVS p.': 'HGVS-beskrivelse på protein-niveau.',
    'Klasse': 'ACMG-klassifikation 1–5.',
    'Kriterier': 'Anvendte ACMG-kriterier.',
    'HGVS': 'HGVS-beskrivelse for varianten.',
    'Evidens': 'Kurateret evidens for varianten.',
    'Kurateret af': 'Navn på ansvarlig kurator.',
    'Sidst gennemgået': 'Dato for seneste kuratoriske gennemgang.',
    'Tilstand': 'Associeret sygdom eller klinisk tilstand.',
    'Nedarvning': 'Beskriver variantens nedarvningsmønster.',
    'Oprettet': 'Tidspunkt for hvornår posten blev oprettet.',
    'Opdateret': 'Tidspunkt for den seneste ændring.',
    'Beskrivelse': 'Uddybende beskrivelse.',
    'Måling': 'Navn på kvalitetskontrolmålingen.',
    'Værdi': 'Målt værdi.',
    'Enhed': 'Måleenhed for værdien.',
    'Tid': 'Tidsstempel for hændelsen.',
    'Handling': 'Registreret handlingstype.',
    'Entitet': 'Tabellen som blev ændret.',
    'Før': 'Data før ændringen.',
    'Efter': 'Data efter ændringen.',
    'Sender': 'Afsendende organisation eller system.',
    'Rapport': 'DiagnosticReport-identifikator.',
    'Varianter': 'Antal varianter i posten.',
    'Udstedt': 'Tidspunkt hvor rapporten blev udsendt.',
    'Test': 'Navn på selvtesten.',
    'Detaljer': 'Supplerende oplysninger til testen.'
  },
  search: {
    patientSearch: 'Filtrer patientlisten efter navn, MRN, familienummer eller køn.',
    sampleSearch: 'Filtrer prøver efter ID, PMB-nummer, status eller type.',
    panelSearch: 'Find paneler efter navn.',
    orderSearch: 'Søg efter ordination ud fra status eller ID.',
    variantSearch: 'Søg efter varianter baseret på gen eller HGVS.',
    libSearch: 'Filtrer variantbiblioteket efter gen eller HGVS.',
    reportSearch: 'Find rapporter ved at søge på status.',
    qcSearch: 'Søg efter kvalitetsmålinger.',
    userSearch: 'Søg brugere på navn, e-mail eller rolle.'
  },
  forms: {
    patientForm: {
      mrn: 'Patientens MRN/CPR til entydig identifikation.',
      family_number: 'Familienummer anvendt til at gruppere beslægtede patienter.',
      name: 'Patientens fulde navn som angivet i journalen.',
      gender: 'Registreret køn for patienten.',
      birth_date: 'Patientens fødselsdato (ÅÅÅÅ-MM-DD).',
      notes: 'Evt. kliniske noter om patienten.'
    },
    sampleForm: {
      patient_id: 'Vælg hvilken patient prøven tilhører.',
      pmb_number: 'Unikt PMB-nummer anvendt i andre systemer.',
      sample_type: 'Vælg prøvetype fra listen.',
      status: 'Prøvens aktuelle laboratoriestatus.',
      collected_at: 'Dato og tidspunkt for prøveindsamling.',
      notes: 'Evt. bemærkninger til prøven.'
    },
    panelForm: {
      name: 'Navn på analysepanelet eller assay.',
      description: 'Beskriv kort panelets indhold og formål.'
    },
    orderForm: {
      patient_id: 'Vælg patienten ordinationen vedrører.',
      sample_id: 'Vælg den prøve der analyseres.',
      panel_id: 'Vælg panel for analysen (valgfrit).',
      analysis_responsible_id: 'Vælg hvem der er analyseansvarlig.',
      interpreter_id: 'Vælg den bruger der tolker resultaterne.',
      approver_id: 'Vælg den bruger der godkender ordinationen.',
      clinician: 'Navn på rekvirerende kliniker eller afdeling.',
      status: 'Ordinationens arbejdsgangstatus.',
      ordered_at: 'Tidspunkt for oprettelse af ordinationen.'
    },
    variantForm: {
      order_id: 'Ordination som varianten er registreret på.',
      gene: 'Gen-symbol for den påviste variant.',
      transcript: 'Reference-transkript (fx NM_).',
      hgvs_c: 'HGVS-beskrivelse på cDNA-niveau.',
      hgvs_p: 'HGVS-beskrivelse på protein-niveau.',
      zygosity: 'Zygositetsstatus (fx heterozygot).',
      classification: 'ACMG-klassifikation 1 (godartet) – 5 (patogen).',
      criteria: 'Anfør anvendte ACMG-kriterier, adskilt af komma.',
      af: 'Allelfrekvens eller observationsfrekvens.',
      annotations: 'Supplerende annoteringer fra eksterne værktøjer såsom VarSeq.',
      interpretation: 'Klinisk tolkning og evidens for varianten.'
    },
    variantLibraryForm: {
      gene: 'Gen-symbol for varianten i biblioteket.',
      transcript: 'Reference-transkript brugt til kurateringen.',
      hgvs_c: 'HGVS cDNA-beskrivelse som varianten er registreret med.',
      hgvs_p: 'HGVS protein-beskrivelse for varianten.',
      classification: 'Kurateret ACMG-klassifikation eller tilsvarende vurdering.',
      criteria: 'De kriterier der understøtter klassifikationen.',
      evidence: 'Sammendrag af litteratur, observationer eller noter.',
      condition: 'Associeret sygdom eller klinisk tilstand.',
      inheritance: 'Beskriv nedarvningsmønstret, fx autosomal dominant.',
      curated_by: 'Navn på kurator eller team der har ansvaret.',
      last_review: 'Dato for seneste gennemgang (ÅÅÅÅ-MM-DD).'
    },
    conclusionLibraryForm: {
      title: 'Sigende titel, fx formål eller patientgruppe.',
      body: 'Standardtekst der kan indsættes som rapportkonklusion.'
    },
    reportForm: {
      order_id: 'Ordinationen som rapporten beskriver.',
      status: 'Rapportstatus (udkast, endelig eller ændret).',
      issued_at: 'Dato og tidspunkt for rapportens udsendelse.',
      variant_ids: 'Tilføj de registrerede varianter, der skal indgå i rapporten.',
      summary: 'Kort konklusion til modtageren.'
    },
    qcForm: {
      sample_id: 'Vælg den prøve QC-målingen relaterer til.',
      metric: 'Navn på kvalitetskontrolparameteren.',
      value: 'Målt værdi for QC-parameteren.',
      unit: 'Måleenhed (fx %, ng/µl).',
      notes: 'Supplerende noter om målingen.'
    },
    createCaseForm: {
      patient_mrn: 'Patientens MRN eller CPR til entydig identifikation.',
      patient_family: 'Evt. familienummer der kobler patienten til andre sager.',
      patient_name: 'Patientens fulde navn.',
      patient_gender: 'Patientens registrerede køn.',
      patient_birth: 'Patientens fødselsdato.',
      patient_notes: 'Evt. kliniske noter om patienten.',
      sample_pmb: 'Unikt PMB-nummer for den primære prøve.',
      sample_type: 'Vælg prøvetype for hovedprøven.',
      sample_status: 'Status for prøven og den tilknyttede ordination.',
      sample_collected: 'Dato og tidspunkt for prøveindsamlingen.',
      sample_notes: 'Noter om hovedprøven.',
      control_pmb: 'PMB-nummer for kontrolprøven.',
      control_type: 'Prøvetype for kontrolprøven.',
      control_status: 'Status for kontrolprøven.',
      control_collected: 'Dato og tidspunkt for kontrolprøven.',
      control_notes: 'Noter om kontrolprøven.',
      order_panel_id: 'Vælg hvilket panel ordinationen omfatter.',
      order_analysis_responsible: 'Vælg analyseansvarlig bruger.',
      order_interpreter: 'Vælg den bruger der tolker fundene.',
      order_approver: 'Vælg den bruger der godkender ordinationen.',
      order_clinician: 'Rekvirerende kliniker eller afdeling.',
      order_ordered_at: 'Tidspunkt hvor ordinationen registreres.'
    },
    userForm: {
      name: 'Brugerens fulde navn.',
      email: 'Brugerens arbejds-e-mailadresse.',
      role: 'Vælg brugerrolle for at fastlægge læse- eller skriveadgang.',
      pin: 'Valgfri adgangskode, der kræves ved login for brugeren.'
    }
  },
  buttons: {
    demoDataBtn: 'Indlæser et demodatasæt til hurtig afprøvning (kræver skriveadgang).',
    runTestsBtn: 'Kører den indbyggede selvtest og viser resultater.',
    resetDataBtn: 'Downloader en fuld backup og rydder alle data undtagen brugerlisten.',
    patientClear: 'Ryd formularen for at registrere en ny patient.',
    patientDelete: 'Slet den valgte patient permanent.',
    sampleClear: 'Ryd formularen for at registrere en ny prøve.',
    sampleDelete: 'Slet den valgte prøve.',
    panelClear: 'Ryd formularen for at oprette et nyt panel.',
    panelDelete: 'Slet det valgte panel.',
    panelsExport: 'Eksportér den filtrerede panelliste som tekstfil.',
    orderClear: 'Ryd formularen for at oprette en ny ordination.',
    orderDelete: 'Slet den valgte ordination.',
    variantClear: 'Ryd formularen for at registrere en ny variant.',
    variantSaveNew: 'Gem varianten som en ny registrering uden at overskrive den valgte.',
    variantDelete: 'Slet den valgte variant.',
    variantToLibrary: 'Tilføj varianten til det kuraterede bibliotek.',
    variantFromLibrary: 'Hent variantoplysninger fra biblioteket.',
    variantLibraryClear: 'Ryd formularen for at oprette en ny bibliotekspost.',
    variantLibraryDelete: 'Slet den valgte bibliotekspost.',
    variantLibrarySaveNew: 'Gem biblioteksposten som en ny registrering.',
    variantLibrarySave: 'Gem ændringerne til den valgte bibliotekspost.',
    libraryExportCsv: 'Eksportér de viste biblioteksposter til en CSV-fil.',
    libraryImportCsv: 'Importer biblioteksposter fra en CSV-fil.',
    conclusionLibraryClear: 'Ryd formularen for at oprette en ny standardtekst.',
    conclusionLibraryDelete: 'Slet den valgte standardtekst.',
    conclusionLibraryInsert: 'Erstat konklusionsfeltet med den valgte standardtekst.',
    conclusionLibraryAppend: 'Tilføj den valgte tekst til eksisterende konklusion.',
    reportClear: 'Ryd formularen for at skrive en ny rapport.',
    reportDelete: 'Slet den valgte rapport.',
    reportPreview: 'Åbn rapporten i en ny fane til forhåndsvisning.',
    reportAddVariant: 'Tilføj den valgte variant til rapporten.',
    qcClear: 'Ryd formularen for at registrere en ny QC-måling.',
    qcDelete: 'Slet den valgte QC-måling.',
    userClear: 'Ryd formularen for at oprette en ny bruger.',
    userDelete: 'Slet den valgte bruger.',
    acmgReset: 'Ryd alle valgte ACMG-kriterier.',
    distanceSwap: 'Byt start- og slutposition for beregningen.',
    gcUpper: 'Fjern mellemrum og konverter sekvensen til store bogstaver.',
    gcReverse: 'Beregn og indsæt den omvendt komplementære sekvens.',
    patientsExport: 'Eksportér den aktuelt filtrerede patientliste til en JSON-fil.',
    samplesExport: 'Eksportér de filtrerede prøver til JSON til deling eller videre analyse.',
    ordersExport: 'Eksportér ordinationerne der matcher filtrene.',
    variantsExport: 'Eksportér filtrerede varianter inklusive ACMG-data.',
    reportsExport: 'Eksportér rapportlisten med de valgte filtre.',
    themeToggle: 'Skifter mellem lyst og mørkt layout for GlimR.',
    logoutBtn: 'Log brugeren ud og lås GlimR for redigering.',
    generateFhir: 'Generér og download et FHIR-svar for ordinationen.',
    previewFhir: 'Vis FHIR-bundlen som JSON uden download.',
    downloadSql: 'Download komplet MySQL-dump af GlimR-data.',
    showSchema: 'Vis MySQL-skemaet direkte på siden.',
    downloadZip: 'Download ZIP med GlimR og aktuelle data.',
    bindFile: 'Vælg eller opret en lokal databasefil til autogem.',
    saveNow: 'Gem straks til den tilknyttede databasefil.',
    downloadBackup: 'Eksportér alle data som JSON-backup.',
    submit: 'Gemmer formularens indhold i databasen.',
    addQcRow: 'Tilføj en ekstra QC-måling til prøven.',
    addVariantRow: 'Tilføj endnu en variant til ordinationen.',
    caseImportVarSeq: 'Importer varianter fra en VarSeq-CSV direkte i oprettelsesflowet.',
    variantBatchAdd: 'Tilføj en tom række til masseoprettelse af varianter.',
    variantBatchImport: 'Importer en VarSeq-CSV og udfyld rækkerne automatisk.',
    variantBatchSave: 'Gem alle udfyldte rækker på den valgte ordination.',
    variantBatchClear: 'Ryd alle midlertidige rækker uden at gemme dem.',
    createCaseSubmit: 'Opretter patient, prøve, ordination, QC og varianter i ét trin.',
    createCaseReset: 'Ryd alle felter i oprettelsesformularen.',
    'Vælg fra bibliotek': 'Hent variantoplysninger fra biblioteket.'
  },
  controls: {
    autosaveToggle: 'Aktiver eller deaktiver automatisk gemning til fil.',
    fhirOrderSelect: 'Vælg hvilken ordination der skal bruges til FHIR-svar.',
    fhirImportLabel: 'Importer en modtaget FHIR JSON-fil.',
    fhirPreview: 'JSON-visning af den genererede FHIR-bundle.',
    reportVariantSelect: 'Vælg blandt ordinationens registrerede varianter.',
    reportVariantList: 'Varianter der er føjet til rapportens fund.',
    restoreLabel: 'Gendan databasen fra en tidligere JSON-backup.',
    schemaText: 'Viser MySQL-skema og INSERT-statements til reference.',
    patientsFilterPanel: 'Åbn avancerede filtre for at søge præcist i patientlisten.',
    samplesFilterPanel: 'Finfiltrér prøver efter patient, status og indsamlingstid.',
    ordersFilterPanel: 'Filtrer ordinationer på patient, panel, status og dato.',
    variantsFilterPanel: 'Indsnævr variantoversigten efter gen, ordination og ACMG-klasse.',
    reportsFilterPanel: 'Begræns rapportlisten efter status, ordination og udstedelsesdato.',
    loginUser: 'Vælg hvilken GlimR-bruger der skal logges ind.',
    loginPass: 'Indtast brugerens adgangskode hvis der er opsat en PIN.',
    includeControlSample: 'Aktiver for at registrere en ekstra kontrolprøve på samme patient.',
    orderStatusPreview: 'Viser hvilken status den nye ordination får. Status følger prøvens valg.',
    caseVariantHint: 'Information om tilknyttede varianter i den nye sag.',
    variantLibraryImportInput: 'Vælg en CSV-fil der indeholder biblioteksposter til import.',
    caseImportVarSeqInput: 'Vælg en VarSeq CSV-fil med fund, som skal tilføjes til sagen.',
    variantBatchOrder: 'Vælg den ordination som de importerede varianter skal knyttes til.',
    variantBatchMessage: 'Status og advarsler for masseoprettelse af varianter.',
    variantBatchFile: 'Vælg en VarSeq CSV-fil til masseimport.',
    acmgTool: 'Vælg de kriterier der er opfyldt, for at få et ACMG-forslag.',
    distanceTool: 'Indtast to koordinater for at udregne den genomiske afstand.',
    distanceStart: 'Genomisk startposition, fx 123456 eller chr7:123456.',
    distanceEnd: 'Genomisk slutposition. Bogstaver ignoreres automatisk.',
    distanceResult: 'Viser antal baser mellem positionerne (inkl./ekskl.).',
    gcSequence: 'Indsæt DNA/RNA-sekvens for at beregne længde og GC%.',
    acmgResult: 'Opsummering af den foreslåede klassifikation baseret på kriterierne.',
    gcResult: 'Opsummerer længde, GC% og basefordeling for sekvensen.'
  }
};
function setTooltip(el, text) {
  if (!el || !text) return;
  el.title = text;
  el.dataset.tip = text;
  el.setAttribute('aria-label', text);
}
function annotateHeaders(root) {
  if (!root) return;
  root.querySelectorAll('th').forEach(th => {
    const key = th.textContent.trim();
    const tip = tooltipCatalog.headers[key] || `Kolonne: ${key}`;
    setTooltip(th, tip);
  });
}
function annotateTableCells(root) {
  if (!root) return;
  root.querySelectorAll('tbody td').forEach(td => {
    const text = td.textContent.trim();
    if (text) setTooltip(td, text);
  });
}
function annotateSearchInputs(root) {
  if (!root) return;
  root.querySelectorAll('input[type="search"]').forEach(input => {
    const tip = tooltipCatalog.search[input.id] || 'Filtrer tabellen ved at indtaste søgetekst.';
    setTooltip(input, tip);
  });
}
function applyMetricTooltips(root) {
  if (!root) return;
  root.querySelectorAll('.badge').forEach(badge => {
    const key = badge.textContent.trim();
    const tip = tooltipCatalog.metrics[key];
    if (tip) {
      setTooltip(badge, tip);
      const container = badge.parentElement;
      if (container) {
        setTooltip(container, tip);
        const value = container.querySelector('h3');
        if (value) setTooltip(value, tip);
      }
    }
  });
}
function applyFormTooltips(form) {
  if (!form) return;
  const map = tooltipCatalog.forms[form.id];
  if (map) {
    Object.entries(map).forEach(([name, tip]) => {
      const field = form.elements[name];
      if (!field) return;
      const isRadioList = typeof RadioNodeList !== 'undefined' && field instanceof RadioNodeList;
      const el = isRadioList ? field[0] : field;
      if (!el) return;
      setTooltip(el, tip);
      const label = el.closest('label');
      if (label) setTooltip(label, tip);
    });
  }
  const submit = form.querySelector('button[type="submit"]');
  if (submit) setTooltip(submit, tooltipCatalog.buttons.submit);
}
function applyButtonTooltips(root) {
  if (!root) return;
  root.querySelectorAll('button').forEach(btn => {
    const tip = tooltipCatalog.buttons[btn.id] || tooltipCatalog.buttons[btn.textContent.trim()];
    if (tip) setTooltip(btn, tip);
  });
}
function applyControlTooltips(root) {
  if (!root) return;
  Object.entries(tooltipCatalog.controls).forEach(([id, tip]) => {
    const el = root.querySelector(`#${id}`);
    if (el) {
      setTooltip(el, tip);
      if (el.tagName === 'INPUT' && el.type === 'checkbox' && el.parentElement) {
        setTooltip(el.parentElement, tip);
      }
    }
  });
}
function applySelectFilters(root) {
  if (!root) return;
  root.querySelectorAll('.filterable-select').forEach(wrapper => {
    const input = wrapper.querySelector('input[data-select-filter]');
    const select = wrapper.querySelector('select');
    if (!input || !select || wrapper.dataset.filterInit) return;
    const options = Array.from(select.options).map(option => ({
      option,
      text: option.textContent.toLowerCase()
    }));
    input.addEventListener('input', () => {
      const term = input.value.trim().toLowerCase();
      options.forEach(({option, text}) => {
        const matches = !term || text.includes(term) || option.selected;
        option.hidden = !matches;
      });
      if (term) {
        const firstMatch = options.find(({option}) => !option.hidden);
        if (firstMatch && !firstMatch.option.selected) {
          select.value = firstMatch.option.value;
        }
      }
    });
    input.addEventListener('keydown', evt => {
      if (evt.key === 'Escape') {
        input.value = '';
        input.dispatchEvent(new Event('input'));
      }
    });
    wrapper.dataset.filterInit = 'true';
  });
}

function openVariantLibraryPicker(onSelect) {
  const library = (getCached('variant_library') || []).slice();
  if (!library.length) {
    alert('Variantbiblioteket er tomt.');
    return;
  }
  const existing = document.querySelector('.variant-picker-overlay');
  if (existing) existing.remove();
  const sorted = library.sort((a, b) => {
    const geneCompare = (a.gene || '').localeCompare(b.gene || '');
    if (geneCompare) return geneCompare;
    const hgvsCompare = (a.hgvs_c || '').localeCompare(b.hgvs_c || '');
    if (hgvsCompare) return hgvsCompare;
    return (a.id || 0) - (b.id || 0);
  });
  const overlay = document.createElement('div');
  overlay.className = 'variant-picker-overlay';
  overlay.innerHTML = `
    <div class="variant-picker" role="dialog" aria-modal="true" aria-label="Vælg variant fra bibliotek">
      <header>
        <h3>Vælg variant fra bibliotek</h3>
        <button type="button" class="secondary" data-action="close">Luk</button>
      </header>
      <div class="picker-body">
        <label class="inline">Søg
          <input type="search" placeholder="Filtrer på gen, HGVS eller kriterier">
        </label>
        <p class="form-hint">Klik på en variant for at kopiere oplysningerne til formularen.</p>
        <table>
          <thead>
            <tr><th>ID</th><th>Gen</th><th>Transkript</th><th>HGVS c.</th><th>HGVS p.</th><th>Klasse</th><th>Kriterier</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>`;
  const previousOverflow = document.body.style.overflow;
  document.body.style.overflow = 'hidden';
  document.body.appendChild(overlay);
  const dialog = overlay.querySelector('.variant-picker');
  const searchInput = overlay.querySelector('input[type="search"]');
  const tbody = overlay.querySelector('tbody');
  const closeBtn = overlay.querySelector('[data-action="close"]');
  const cleanup = () => {
    document.body.style.overflow = previousOverflow;
    overlay.remove();
    document.removeEventListener('keydown', onKeyDown, true);
  };
  const onKeyDown = evt => {
    if (evt.key === 'Escape') {
      evt.preventDefault();
      cleanup();
    }
  };
  document.addEventListener('keydown', onKeyDown, true);
  const handleSelect = id => {
    const variant = sorted.find(item => item.id === id);
    if (!variant) return;
    if (onSelect) onSelect({...variant});
    cleanup();
  };
  const renderRows = () => {
    const term = (searchInput?.value || '').trim().toLowerCase();
    const filtered = sorted.filter(item => {
      if (!term) return true;
      return [item.gene, item.transcript, item.hgvs_c, item.hgvs_p, item.criteria, item.evidence]
        .some(value => (value || '').toLowerCase().includes(term));
    });
    if (!filtered.length) {
      tbody.innerHTML = '<tr><td colspan="7"><div class="variant-picker-empty">Ingen varianter matcher søgningen.</div></td></tr>';
      return;
    }
    tbody.innerHTML = filtered.map(item => `
      <tr tabindex="0" data-id="${item.id}">
        <td>${esc(item.id)}</td>
        <td>${esc(item.gene)}</td>
        <td>${esc(item.transcript || '')}</td>
        <td>${esc(item.hgvs_c || '')}</td>
        <td>${esc(item.hgvs_p || '')}</td>
        <td>${esc(item.classification || '')}</td>
        <td>${esc(item.criteria || '')}</td>
      </tr>`).join('');
    annotateTableCells(dialog);
  };
  renderRows();
  annotateHeaders(dialog);
  applyButtonTooltips(dialog);
  overlay.addEventListener('click', evt => {
    if (evt.target === overlay) cleanup();
  });
  closeBtn?.addEventListener('click', cleanup);
  searchInput?.addEventListener('input', renderRows);
  tbody.addEventListener('click', evt => {
    const tr = evt.target.closest('tr[data-id]');
    if (!tr) return;
    handleSelect(Number(tr.dataset.id));
  });
  tbody.addEventListener('keydown', evt => {
    if (evt.key === 'Enter' || evt.key === ' ') {
      evt.preventDefault();
      const tr = evt.target.closest('tr[data-id]');
      if (tr) handleSelect(Number(tr.dataset.id));
    }
  });
  setTimeout(() => searchInput?.focus(), 50);
}
function initFamilyCombos(root) {
  if (!root) return;
  root.querySelectorAll('.family-combo').forEach(combo => {
    if (combo.dataset.familyInit) return;
    const select = combo.querySelector('[data-family-select]');
    const input = combo.querySelector('[data-family-input]');
    if (!select || !input) return;
    const syncSelect = () => {
      const value = input.value.trim();
      if (!value) {
        select.value = '';
        return;
      }
      const match = Array.from(select.options).find(opt => opt.value === value);
      select.value = match ? value : '__custom__';
    };
    select.addEventListener('change', () => {
      if (!select.value) {
        input.value = '';
      } else if (select.value !== '__custom__') {
        input.value = select.value;
      }
      if (select.value === '__custom__') {
        input.focus();
      } else {
        input.dispatchEvent(new Event('input', {bubbles: false}));
      }
    });
    input.addEventListener('input', () => syncSelect());
    combo.dataset.familyInit = 'true';
    const form = combo.closest('form');
    if (form && !form.dataset.familyResetInit) {
      form.addEventListener('reset', () => {
        setTimeout(() => {
          form.querySelectorAll('[data-family-input]').forEach(field => {
            field.dispatchEvent(new Event('input', {bubbles: false}));
          });
        }, 0);
      });
      form.dataset.familyResetInit = 'true';
    }
    syncSelect();
  });
}
function hasWriteRole(user) {
  if (!user) return false;
  const role = normaliseRoleValue(user.role).toLowerCase();
  if (WRITE_ROLE_KEYS.has(role)) return true;
  return ['admin', 'skriver', 'redakt', 'editor', 'bio', 'write', 'leder'].some(key => role.includes(key));
}
function currentCanWrite() {
  if (state.currentUser?.internal) return true;
  return hasWriteRole(state.currentUser);
}
function ensureWrite(storeName) {
  if (state.currentUser?.internal) return true;
  if (storeName === 'users') {
    const existing = state.cache.get('users');
    if (!existing || existing.length === 0) {
      return true;
    }
  }
  if (currentCanWrite()) return true;
  alert('Handling kræver skriveadgang. Log ind med en bruger der har rollen "Administrator" eller "Skriver".');
  return false;
}
function updateWriteBanner() {
  const hasWrite = currentCanWrite();
  let banner = document.getElementById('writeLockBanner');
  if (!hasWrite) {
    if (!banner) {
      banner = document.createElement('div');
      banner.id = 'writeLockBanner';
      banner.className = 'read-only-banner';
      banner.textContent = 'Skriveadgang er låst. Log ind med skrivetilladelse for at redigere eller oprette data.';
      const main = document.getElementById('tabContent');
      if (main) {
        main.prepend(banner);
      }
    }
  } else if (banner) {
    banner.remove();
  }
}
function refreshLoginOptions() {
  const select = document.getElementById('loginUser');
  if (!select) return;
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const currentId = state.currentUser?.id ? String(state.currentUser.id) : '';
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = users.length ? 'Vælg bruger' : 'Opret en bruger for at logge ind';
  placeholder.disabled = true;
  select.appendChild(placeholder);
  users.forEach(user => {
    const opt = document.createElement('option');
    opt.value = String(user.id);
    opt.textContent = `${user.name} (${roleWithDescription(user.role) || 'rolle ukendt'})`;
    select.appendChild(opt);
  });
  if (currentId) {
    select.value = currentId;
    placeholder.selected = false;
  } else {
    placeholder.selected = true;
  }
}
function updateAuthUi() {
  const form = document.getElementById('loginForm');
  const info = document.getElementById('userInfo');
  const label = document.getElementById('currentUserLabel');
  const select = document.getElementById('loginUser');
  if (!form || !info || !label || !select) return;
  const user = state.currentUser;
  if (user) {
    form.style.display = 'none';
    info.hidden = false;
    label.textContent = `${user.name} – ${roleWithDescription(user.role) || 'rolle ukendt'}`;
  } else {
    info.hidden = true;
    form.style.display = '';
    form.reset();
    refreshLoginOptions();
  }
  updateWriteBanner();
}
function applyTheme() {
  if (!['light', 'dark'].includes(state.theme)) {
    state.theme = 'light';
  }
  document.documentElement.dataset.theme = state.theme;
  localStorage.setItem('glimr-theme', state.theme);
  const btn = document.getElementById('themeToggle');
  if (btn) {
    const toDark = state.theme !== 'dark';
    btn.textContent = toDark ? 'Skift til mørkt tema' : 'Skift til lyst tema';
    setTooltip(btn, tooltipCatalog.buttons.themeToggle);
  }
}
function toggleTheme() {
  state.theme = state.theme === 'dark' ? 'light' : 'dark';
  applyTheme();
}
function restoreUserSession() {
  const storedId = localStorage.getItem('glimr-user-id');
  if (storedId) {
    const user = findById('users', Number(storedId));
    if (user) {
      state.currentUser = {...user};
    } else {
      state.currentUser = null;
      localStorage.removeItem('glimr-user-id');
    }
  } else if (!state.currentUser || !state.currentUser.internal) {
    state.currentUser = null;
  }
  refreshLoginOptions();
  updateAuthUi();
}
function logoutUser() {
  state.currentUser = null;
  localStorage.removeItem('glimr-user-id');
  updateAuthUi();
  setStatus('Logget ud. Systemet er skrivebeskyttet.');
}
function handleLogin(event) {
  event.preventDefault();
  const select = document.getElementById('loginUser');
  const pass = document.getElementById('loginPass');
  if (!select || !pass) return;
  const id = Number(select.value);
  if (!id) {
    alert('Vælg en bruger for at logge ind.');
    return;
  }
  const user = findById('users', id);
  if (!user) {
    alert('Brugeren findes ikke længere.');
    refreshLoginOptions();
    return;
  }
  const pin = pass.value.trim();
  if (user.pin && user.pin !== pin) {
    alert('Forkert adgangskode.');
    return;
  }
  state.currentUser = {...user};
  localStorage.setItem('glimr-user-id', String(user.id));
  pass.value = '';
  updateAuthUi();
  setStatus(`Logget ind som ${user.name}.`);
}
function esc(str) {
  return String(str ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}
function setStatus(msg) {
  state.lastStatus = msg;
  document.getElementById('statusBar').textContent = msg;
  setTooltip(document.getElementById('statusBar'), msg);
}
function currentUserName() {
  return state.currentUser?.name || 'System';
}
function initTabs() {
  const nav = document.getElementById('tabNav');
  const main = document.getElementById('tabContent');
  nav.innerHTML = '';
  main.innerHTML = '';
  tabs.forEach(tab => {
    const btn = document.createElement('button');
    btn.textContent = tab.label;
    btn.dataset.tab = tab.id;
    setTooltip(btn, tooltipCatalog.tabs[tab.id]);
    btn.addEventListener('click', () => activateTab(tab.id));
    nav.appendChild(btn);
    const section = document.createElement('section');
    section.dataset.tab = tab.id;
    main.appendChild(section);
  });
}
function activateTab(id) {
  state.currentTab = id;
  document.querySelectorAll('nav button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === id);
  });
  document.querySelectorAll('section[data-tab]').forEach(sec => {
    sec.classList.toggle('active', sec.dataset.tab === id);
  });
  renderTab(id);
}
function openDb() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = event => {
      const db = event.target.result;
      const ensureStore = (name, options) => {
        if (!db.objectStoreNames.contains(name)) {
          const store = db.createObjectStore(name, options);
          return store;
        }
        return event.target.transaction.objectStore(name);
      };
      const withTimestamps = store => {
        ['created_at','updated_at'].forEach(field => {
          if (!store.indexNames.contains(field)) {
            try { store.createIndex(field, field); } catch (e) {}
          }
        });
        return store;
      };
      withTimestamps(ensureStore('patients', {keyPath:'id', autoIncrement:true}));
      const samplesStore = withTimestamps(ensureStore('samples',{keyPath:'id',autoIncrement:true}));
      if (!samplesStore.indexNames.contains('pmb_number')) {
        try { samplesStore.createIndex('pmb_number','pmb_number',{unique:true}); } catch (e) {}
      }
      if (!samplesStore.indexNames.contains('patient_id')) samplesStore.createIndex('patient_id','patient_id');
      const ordersStore = withTimestamps(ensureStore('orders',{keyPath:'id',autoIncrement:true}));
      ['patient_id','sample_id','panel_id','analysis_responsible_id','interpreter_id','approver_id'].forEach(idx => {
        if (!ordersStore.indexNames.contains(idx)) ordersStore.createIndex(idx, idx);
      });
      withTimestamps(ensureStore('panels',{keyPath:'id',autoIncrement:true}));
      const variantsStore = withTimestamps(ensureStore('variants',{keyPath:'id',autoIncrement:true}));
      if (!variantsStore.indexNames.contains('order_id')) variantsStore.createIndex('order_id','order_id');
      const qcStore = withTimestamps(ensureStore('qc',{keyPath:'id',autoIncrement:true}));
      if (!qcStore.indexNames.contains('sample_id')) qcStore.createIndex('sample_id','sample_id');
      const reportsStore = withTimestamps(ensureStore('reports',{keyPath:'id',autoIncrement:true}));
      if (!reportsStore.indexNames.contains('order_id')) reportsStore.createIndex('order_id','order_id');
      withTimestamps(ensureStore('users',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('audit',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('variant_library',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('responses',{keyPath:'id',autoIncrement:true}));
      withTimestamps(ensureStore('conclusion_library',{keyPath:'id',autoIncrement:true}));
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
function requestToPromise(req) {
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function loadStore(name) {
  const tx = state.db.transaction(name, 'readonly');
  const store = tx.objectStore(name);
  const req = store.getAll();
  const rows = await requestToPromise(req);
  state.cache.set(name, rows);
  if (name === 'audit') {
    rebuildCreationLookup();
  }
  return rows;
}
async function loadAllStores() {
  for (const name of STORES) {
    await loadStore(name);
  }
  rebuildCreationLookup();
}
function getCached(name) {
  return state.cache.get(name) ?? [];
}
function findById(store, id) {
  return getCached(store).find(item => item.id === id);
}
async function addRecord(store, record) {
  const now = new Date().toISOString();
  if (CREATED_BY_STORES.has(store) && !record.created_by) {
    record.created_by = currentUserName();
  }
  record.created_at = now;
  record.updated_at = now;
  const tx = state.db.transaction(store, 'readwrite');
  const req = tx.objectStore(store).add(record);
  const id = await requestToPromise(req);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('CREATE', store, id, null, record);
  scheduleAutosave();
  return id;
}
async function updateRecord(store, record, before) {
  record.updated_at = new Date().toISOString();
  const tx = state.db.transaction(store, 'readwrite');
  tx.objectStore(store).put(record);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('UPDATE', store, record.id, before, record);
  scheduleAutosave();
}
async function deleteRecord(store, id) {
  const existing = findById(store, id);
  if (!existing) return;
  const tx = state.db.transaction(store, 'readwrite');
  tx.objectStore(store).delete(id);
  await tx.done?.catch(() => {});
  await loadStore(store);
  await logAudit('DELETE', store, id, existing, null);
  scheduleAutosave();
}
async function logAudit(action, entity, entityId, before, after) {
  const entry = {
    ts: new Date().toISOString(),
    user: currentUserName(),
    action,
    entity,
    entity_id: entityId ?? null,
    before: before ? JSON.stringify(before) : null,
    after: after ? JSON.stringify(after) : null
  };
  const tx = state.db.transaction('audit','readwrite');
  tx.objectStore('audit').add({...entry, created_at:new Date().toISOString(), updated_at:new Date().toISOString()});
  await tx.done?.catch(() => {});
  await loadStore('audit');
}
function scheduleAutosave() {
  if (!state.autosave || !state.boundHandle) return;
  if (state.autosaveTimer) clearTimeout(state.autosaveTimer);
  state.autosaveTimer = setTimeout(() => {
    saveBoundFile().catch(err => console.error(err));
  }, 1200);
}
async function exportData() {
  const data = {};
  for (const store of STORES) {
    data[store] = cloneWithCreatedBy(store, getCached(store));
  }
  return data;
}
async function saveBoundFile() {
  if (!state.boundHandle) {
    setStatus('Ingen fil tilknyttet.');
    return;
  }
  const writable = await state.boundHandle.createWritable();
  const data = await exportData();
  await writable.write(JSON.stringify(data, null, 2));
  await writable.close();
  setStatus('Autogemt kl. ' + new Date().toLocaleTimeString());
}
async function manualSave() {
  try {
    await saveBoundFile();
  } catch (err) {
    console.error(err);
    alert('Kunne ikke gemme: ' + err.message);
  }
}
async function bindDbFile() {
  try {
    const [handle] = await window.showOpenFilePicker({multiple:false, types:[{description:'GlimR-data', accept:{'application/json':['.json']}}]});
    state.boundHandle = handle;
    setStatus('Fil tilknyttet: ' + handle.name);
    const file = await handle.getFile();
    if (file.size > 0) {
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        await importData(data, true);
      } catch (err) {
        console.error(err);
        alert('Kunne ikke læse filen: ' + err.message);
      }
    }
  } catch (err) {
    if (err && err.name !== 'AbortError') {
      console.error(err);
      alert('Filtilknytning fejlede: ' + err.message);
    }
  }
  renderDbTab();
}
async function replaceAllData(data) {
  const timestamp = new Date().toISOString();
  for (const store of STORES) {
    const tx = state.db.transaction(store, 'readwrite');
    const objectStore = tx.objectStore(store);
    const clearReq = objectStore.clear();
    await requestToPromise(clearReq);
    const rows = data[store] ?? [];
    for (const row of rows) {
      if (!row.created_at) row.created_at = timestamp;
      if (!row.updated_at) row.updated_at = timestamp;
      objectStore.add(row);
    }
    await tx.done?.catch(() => {});
  }
  await loadAllStores();
}
async function importData(data, skipConfirm=false) {
  if (!currentCanWrite()) {
    alert('Import kræver login med skrivetilladelse.');
    return;
  }
  const proceed = skipConfirm || confirm('Dette vil overskrive eksisterende data. Fortsæt?');
  if (!proceed) return;
  await replaceAllData(data);
  setStatus('Data indlæst.');
  renderAll();
}
async function downloadBackup() {
  const data = await exportData();
  const filename = downloadJsonFile(data, 'glimr-backup.json');
  setStatus(`Fuld backup downloadet som ${filename}.`);
}
async function backupAndResetData() {
  if (!ensureWrite('patients')) return;
  const confirmReset = confirm('Dette vil hente en fuld backup og derefter slette alle data undtagen brugere. Fortsæt?');
  if (!confirmReset) return;
  const data = await exportData();
  const filename = downloadJsonFile(data, 'glimr-backup-pre-reset.json');
  const storesToClear = STORES.filter(store => store !== 'users');
  const preservedUsers = JSON.parse(JSON.stringify(getCached('users') || []));
  try {
    if (state.db) {
      state.db.close();
      state.db = null;
    }
    await new Promise((resolve, reject) => {
      const req = indexedDB.deleteDatabase(DB_NAME);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
      req.onblocked = () => {
        alert('Databasen kunne ikke nulstilles, fordi den er åben i en anden fane. Luk andre GlimR-vinduer og prøv igen.');
      };
    });
    state.cache.clear();
    state.db = await openDb();
    await loadAllStores();
    if (preservedUsers.length) {
      const tx = state.db.transaction('users', 'readwrite');
      const store = tx.objectStore('users');
      const now = new Date().toISOString();
      for (const user of preservedUsers) {
        if (!user.created_at) user.created_at = now;
        if (!user.updated_at) user.updated_at = now;
        store.put(user);
      }
      await tx.done?.catch(() => {});
    }
    await loadAllStores();
    await logAudit('RESET', 'system', null, null, {clearedStores: storesToClear});
    renderAll();
    restoreUserSession();
    scheduleAutosave();
    setStatus(`Data ryddet (undtagen brugere). Backup: ${filename}.`);
    alert(`Alle data undtagen brugere er nu ryddet. Backup er downloadet som ${filename}.`);
  } catch (err) {
    console.error(err);
    setStatus('Kunne ikke nulstille databasen: ' + err.message);
    alert('Kunne ikke nulstille databasen: ' + err.message);
    if (!state.db) {
      try {
        state.db = await openDb();
        await loadAllStores();
        restoreUserSession();
      } catch (reopenErr) {
        console.error(reopenErr);
      }
    }
  }
}
function exportFilteredJson(filename, rows, meta = {}) {
  const filters = meta.filters ? Object.fromEntries(Object.entries(meta.filters).filter(([, value]) => value !== '' && value != null)) : undefined;
  const payload = {
    titel: meta.title || 'GlimR filtreret eksport',
    entitet: meta.entity || 'ukendt',
    antal: rows.length,
    genereret: new Date().toISOString(),
    poster: rows
  };
  if (filters && Object.keys(filters).length) {
    payload.filtre = filters;
  }
  if (meta.tab) {
    payload.fane = meta.tab;
  }
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const stamped = withDateStamp(filename);
  triggerDownload(url, stamped);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  const plural = meta.plural || meta.entity || 'poster';
  setStatus(`Eksporterede ${rows.length} ${plural} til ${stamped}.`);
}
function triggerDownload(url, filename) {
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
function downloadJsonFile(data, baseName) {
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  return filename;
}
const WINDOWS_1252_EXTENDED = {
  0x20ac: 0x80,
  0x201a: 0x82,
  0x0192: 0x83,
  0x201e: 0x84,
  0x2026: 0x85,
  0x2020: 0x86,
  0x2021: 0x87,
  0x02c6: 0x88,
  0x2030: 0x89,
  0x0160: 0x8a,
  0x2039: 0x8b,
  0x0152: 0x8c,
  0x017d: 0x8e,
  0x2018: 0x91,
  0x2019: 0x92,
  0x201c: 0x93,
  0x201d: 0x94,
  0x2022: 0x95,
  0x2013: 0x96,
  0x2014: 0x97,
  0x02dc: 0x98,
  0x2122: 0x99,
  0x0161: 0x9a,
  0x203a: 0x9b,
  0x0153: 0x9c,
  0x017e: 0x9e,
  0x0178: 0x9f
};
function encodeWindows1252(str) {
  const bytes = [];
  for (let i = 0; i < str.length; i++) {
    let codePoint = str.codePointAt(i);
    if (codePoint > 0xffff) {
      i++;
    }
    if (codePoint <= 0xff) {
      bytes.push(codePoint);
      continue;
    }
    const mapped = WINDOWS_1252_EXTENDED[codePoint];
    if (mapped != null) {
      bytes.push(mapped);
    } else {
      bytes.push(0x3f);
    }
  }
  return new Uint8Array(bytes);
}
function downloadCsvFile(rows, columns, baseName, delimiter = ';') {
  if (!Array.isArray(rows)) rows = [];
  const cols = columns.map(col => typeof col === 'string' ? {key: col, label: col} : col);
  const header = cols.map(col => escapeCsvValue(col.label ?? col.key, delimiter)).join(delimiter);
  const lines = rows.map(row => cols.map(col => {
    const raw = typeof col.value === 'function' ? col.value(row) : row?.[col.key];
    return escapeCsvValue(raw, delimiter);
  }).join(delimiter));
  const csv = [header, ...lines].join('\r\n');
  const encoded = encodeWindows1252(csv);
  const blob = new Blob([encoded], {type: 'text/csv;charset=windows-1252;'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  return filename;
}
function downloadTextFile(text, baseName) {
  if (typeof text !== 'string') text = '';
  const normalised = text.replace(/\r?\n|\r/g, '\r\n');
  const encoded = encodeWindows1252(normalised);
  const blob = new Blob([encoded], {type: 'text/plain;charset=windows-1252;'});
  const url = URL.createObjectURL(blob);
  const filename = withDateStamp(baseName);
  triggerDownload(url, filename);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  return filename;
}
function escapeCsvValue(value, delimiter) {
  if (value == null) value = '';
  if (value instanceof Date) value = value.toISOString();
  let str = String(value);
  if (!str) return '';
  str = str.replace(/\r?\n|\r/g, ' ');
  const needsQuotes = str.includes(delimiter) || str.includes('"') || /[\t]/.test(str) || /^\s|\s$/.test(str);
  let escaped = str.replace(/"/g, '""');
  if (needsQuotes) {
    escaped = `"${escaped}"`;
  }
  return escaped;
}
function withDateStamp(filename) {
  const stamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0].replace('T', '-');
  const dot = filename.lastIndexOf('.');
  if (dot === -1) return `${filename}-${stamp}`;
  return `${filename.slice(0, dot)}-${stamp}${filename.slice(dot)}`;
}
function detectCsvDelimiter(text) {
  const sample = (text || '').slice(0, 1024);
  const counts = {',': 0, ';': 0, '\t': 0};
  let inQuotes = false;
  for (let i = 0; i < sample.length; i++) {
    const char = sample[i];
    if (char === '"') {
      if (inQuotes && sample[i + 1] === '"') {
        i++;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }
    if (!inQuotes && (char === ',' || char === ';' || char === '\t')) {
      counts[char]++;
    }
    if (char === '\n' && !inQuotes) {
      break;
    }
  }
  if (counts[';'] >= counts[','] && counts[';'] >= counts['\t'] && counts[';'] > 0) return ';';
  if (counts[','] >= counts['\t'] && counts[','] > 0) return ',';
  if (counts['\t'] > 0) return '\t';
  return ';';
}
function parseCsv(text) {
  if (!text) return {headers: [], rows: [], delimiter: ';'};
  const cleaned = text.replace(/^\ufeff/, '');
  const delimiter = detectCsvDelimiter(cleaned);
  const rows = [];
  let field = '';
  let row = [];
  let inQuotes = false;
  for (let i = 0; i < cleaned.length; i++) {
    const char = cleaned[i];
    if (inQuotes) {
      if (char === '"') {
        if (cleaned[i + 1] === '"') {
          field += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        field += char;
      }
      continue;
    }
    if (char === '"') {
      inQuotes = true;
      continue;
    }
    if (char === '\r') {
      continue;
    }
    if (char === '\n') {
      row.push(field);
      rows.push(row);
      row = [];
      field = '';
      continue;
    }
    if (char === delimiter) {
      row.push(field);
      field = '';
      continue;
    }
    field += char;
  }
  if (inQuotes) {
    row.push(field);
  } else if (field !== '' || row.length) {
    row.push(field);
  }
  if (row.length) {
    rows.push(row);
  }
  while (rows.length && rows[rows.length - 1].every(cell => cell.trim() === '')) {
    rows.pop();
  }
  const headers = rows.shift() || [];
  return {headers: headers.map(h => h.trim()), rows, delimiter};
}
function normaliseHeader(header) {
  if (header == null) return '';
  let value = String(header).trim().toLowerCase();
  if (typeof value.normalize === 'function') {
    value = value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }
  return value.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
}
function mapVarSeqClassification(value) {
  if (value == null) return '';
  const raw = String(value).trim();
  if (!raw) return '';
  if (/^[1-5]$/.test(raw)) return raw;
  const digit = raw.match(/[1-5]/);
  if (digit) return digit[0];
  const lower = raw.toLowerCase();
  if (lower.includes('pathogenic')) {
    return lower.includes('likely') ? '4' : '5';
  }
  if (lower.includes('benign')) {
    return lower.includes('likely') ? '2' : '1';
  }
  if (lower.includes('vus') || lower.includes('uncertain') || lower.includes('ukendt')) {
    return '3';
  }
  if (lower.includes('risk')) return '3';
  return '';
}
function parseVarSeqVariants(text) {
  const {headers, rows} = parseCsv(text);
  if (!headers.length) throw new Error('CSV-filen mangler kolonneoverskrifter.');
  const headerMap = {
    gene: 'gene',
    gen: 'gene',
    gene_name: 'gene',
    gene_symbol: 'gene',
    transcript: 'transcript',
    transcript_id: 'transcript',
    transcript_accession: 'transcript',
    refseq_transcript: 'transcript',
    refseq: 'transcript',
    ensembl_transcript: 'transcript',
    cdna_change: 'hgvs_c',
    cdna_change_hgvs: 'hgvs_c',
    cdna: 'hgvs_c',
    c_hgvs: 'hgvs_c',
    hgvs_c: 'hgvs_c',
    coding_hgvs: 'hgvs_c',
    coding_dna_change: 'hgvs_c',
    protein_change: 'hgvs_p',
    protein_change_hgvs: 'hgvs_p',
    protein: 'hgvs_p',
    hgvs_p: 'hgvs_p',
    amino_acid_change: 'hgvs_p',
    effect: 'hgvs_p',
    protein_effect: 'hgvs_p',
    zygosity: 'zygosity',
    genotype: 'zygosity',
    sample_zygosity: 'zygosity',
    classification: 'classification',
    classification_short: 'classification',
    acmg_classification: 'classification',
    acmg_class: 'classification',
    acmg_score: 'classification',
    acmg: 'criteria',
    acmg_evidence: 'criteria',
    acmg_criteria: 'criteria',
    acmg_codes: 'criteria',
    acmg_rule: 'criteria',
    allele_fraction: 'af',
    allele_frequency: 'af',
    allele_balance: 'af',
    allele_ratio: 'af',
    af: 'af',
    af_percent: 'af',
    variant_af: 'af',
    allel_frekvens: 'af',
    allelfrekvens: 'af'
  };
  const columnKeys = headers.map(header => headerMap[normaliseHeader(header)] || null);
  if (!columnKeys.some(key => key === 'gene' || key === 'hgvs_c' || key === 'hgvs_p')) {
    throw new Error('CSV-filen skal indeholde mindst én kolonne for gen eller HGVS.');
  }
  const variants = [];
  let skipped = 0;
  const warnings = [];
  const seenAnnotations = new Set();
  const toNumber = value => {
    if (value == null) return null;
    const trimmed = String(value).trim();
    if (!trimmed) return null;
    const hasPercent = /%/.test(trimmed);
    const normalised = trimmed.replace(/%/g, '').replace(/\s+/g, '').replace(',', '.');
    const parsed = Number(normalised);
    if (!Number.isFinite(parsed)) return null;
    const result = hasPercent ? parsed / 100 : parsed;
    return result;
  };
  rows.forEach((rowValues, index) => {
    if (!rowValues || rowValues.every(cell => !cell || !cell.trim())) {
      skipped++;
      return;
    }
    const entry = {};
    const annotations = [];
    columnKeys.forEach((key, idx) => {
      const rawValue = rowValues[idx];
      if (rawValue == null) return;
      const value = String(rawValue).trim();
      if (!value) return;
      if (!key) {
        const header = headers[idx] ?? `Kolonne ${idx + 1}`;
        const label = String(header).trim() || `Kolonne ${idx + 1}`;
        annotations.push(`${label}: ${value}`);
        seenAnnotations.add(label);
        return;
      }
      switch (key) {
        case 'gene':
          entry.gene = value;
          break;
        case 'transcript':
          entry.transcript = value;
          break;
        case 'hgvs_c':
          entry.hgvs_c = value;
          break;
        case 'hgvs_p':
          entry.hgvs_p = value;
          break;
        case 'zygosity':
          entry.zygosity = value;
          break;
        case 'classification':
          entry.classification = mapVarSeqClassification(value);
          if (!entry.classification && value) {
            warnings.push(`Række ${index + 2}: Ukendt klassifikation "${value}".`);
          }
          break;
        case 'criteria':
          entry.criteria = entry.criteria ? `${entry.criteria}; ${value}` : value;
          break;
        case 'af':
          const afValue = toNumber(value);
          if (afValue != null) {
            entry.af = afValue;
          } else {
            warnings.push(`Række ${index + 2}: Kunne ikke tolke allelfrekvens "${value}".`);
          }
          break;
        default:
          break;
      }
    });
    if (!entry.gene && !entry.hgvs_c && !entry.hgvs_p) {
      skipped++;
      return;
    }
    if (annotations.length) {
      entry.annotations = annotations.join(' | ');
    }
    variants.push(entry);
  });
  return {
    variants,
    warnings,
    summary: {
      total: rows.length,
      imported: variants.length,
      skipped,
      annotationColumns: Array.from(seenAnnotations)
    }
  };
}
async function parseVarSeqFile(file) {
  if (!file) throw new Error('Ingen fil valgt.');
  const text = await file.text();
  return parseVarSeqVariants(text);
}
async function restoreFromFile(file) {
  const text = await file.text();
  const data = JSON.parse(text);
  await importData(data);
}
function renderAll() {
  tabs.forEach(tab => renderTab(tab.id));
}
function renderTab(id) {
  const section = document.querySelector(`section[data-tab="${id}"]`);
  if (!section) return;
  switch(id) {
    case 'dashboard': return renderDashboard(section);
    case 'case_create': return renderCreateCase(section);
    case 'patients': return renderPatients(section);
    case 'samples': return renderSamples(section);
    case 'orders': return renderOrders(section);
    case 'panels': return renderPanels(section);
    case 'variants': return renderVariants(section);
    case 'variant_library': return renderVariantLibrary(section);
    case 'conclusion_library': return renderConclusionLibrary(section);
    case 'reports': return renderReports(section);
    case 'qc': return renderQC(section);
    case 'responses': return renderResponses(section);
    case 'tools': return renderTools(section);
    case 'users': return renderUsers(section);
    case 'audit': return renderAudit(section);
    case 'db': return renderDbTab(section);
    case 'admin': return renderAdmin(section);
    case 'tests': return renderTestsTab(section);
    default:
      section.innerHTML = '<p>Ingen data.</p>';
  }
}
function renderDashboard(section) {
  const patients = getCached('patients').length;
  const samples = getCached('samples');
  const sampleCount = samples.length;
  const orders = getCached('orders');
  const variants = getCached('variants');
  const statusCounts = samples.reduce((acc, sample) => {
    const status = (sample.status || '').toLowerCase();
    if (status === 'modtaget') acc.received += 1;
    else if (status === 'qc') acc.qc += 1;
    else if (status === 'analyse') acc.analysis += 1;
    else if (status === 'tolkning') acc.interpretation += 1;
    else if (status === 'rapport') acc.report += 1;
    else if (status === 'biobank') acc.biobank += 1;
    return acc;
  }, {received: 0, qc: 0, analysis: 0, interpretation: 0, report: 0, biobank: 0});
  const activeCount = statusCounts.qc + statusCounts.analysis + statusCounts.interpretation + statusCounts.report;
  const recentOrders = orders.slice().sort((a,b)=> (b.updated_at||'').localeCompare(a.updated_at||'' )).slice(0,5);
  const audit = getCached('audit').slice(-5).reverse();
  const recentOrdersHtml = recentOrders.map(o => {
    const sample = findById('samples', Number(o.sample_id));
    const statusDisplay = sample?.status || o.status || '';
    return `<tr><td>${o.id}</td><td>${esc(getName('patients', o.patient_id))}</td><td>${esc(o.sample_id || '')}</td><td>${getName('panels', o.panel_id)}</td><td>${esc(statusDisplay)}</td><td>${esc(o.updated_at||'')}</td></tr>`;
  }).join('') || '<tr><td colspan="6">Ingen</td></tr>';
  section.innerHTML = `
  <div class="panel">
    <h2>KPI'er</h2>
    <div class="flex">
      <div><div class="badge">Patienter</div><h3>${patients}</h3></div>
      <div><div class="badge">Prøver</div><h3>${sampleCount}</h3></div>
      <div><div class="badge">Ordinationer</div><h3>${orders.length}</h3></div>
      <div><div class="badge">Modtaget</div><h3>${statusCounts.received}</h3></div>
      <div><div class="badge">Aktive</div><h3>${activeCount}</h3></div>
      <div><div class="badge">Analyse</div><h3>${statusCounts.analysis}</h3></div>
      <div><div class="badge">Tolkning</div><h3>${statusCounts.interpretation}</h3></div>
      <div><div class="badge">Rapport</div><h3>${statusCounts.report}</h3></div>
      <div><div class="badge">Varianter</div><h3>${variants.length}</h3></div>
      <div><div class="badge">Biobank</div><h3>${statusCounts.biobank}</h3></div>
    </div>
  </div>
  <div class="panel">
    <h2>Seneste ordrer</h2>
    <table>
      <thead><tr><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Status</th><th>Opdateret</th></tr></thead>
      <tbody>
        ${recentOrdersHtml}
      </tbody>
    </table>
  </div>
  <div class="panel">
    <h2>Revision</h2>
    <table>
      <thead><tr><th>Tid</th><th>Bruger</th><th>Handling</th><th>Entitet</th><th>ID</th></tr></thead>
      <tbody>
        ${audit.map(a => `<tr><td>${esc(a.ts)}</td><td>${esc(a.user)}</td><td>${esc(a.action)}</td><td>${esc(a.entity)}</td><td>${esc(a.entity_id??'')}</td></tr>`).join('') || '<tr><td colspan="5">Ingen</td></tr>'}
      </tbody>
    </table>
  </div>`;
  applyMetricTooltips(section);
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
}

function renderCreateCase(section) {
  const panels = getCached('panels').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const families = Array.from(new Set(getCached('patients').map(p => (p.family_number || '').trim()).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const familySelectOptions = ['<option value="">Vælg familienummer</option>']
    .concat(families.map(num => `<option value="${esc(num)}">${esc(num)}</option>`))
    .concat('<option value="__custom__">Tilføj nyt familienummer…</option>')
    .join('');
  const panelOptions = panels.length
    ? panels.map(p => `<option value="${p.id}">${esc(p.name || `Panel #${p.id}`)}</option>`).join('')
    : '<option value="" disabled>Ingen paneler tilgængelige</option>';
  const userOptions = users.map(u => `<option value="${u.id}">${esc(u.name || `Bruger #${u.id}`)}</option>`).join('');
  const typeOptions = SAMPLE_TYPES.map(type => `<option value="${type}">${type}</option>`).join('');
  const controlTypeOptions = SAMPLE_TYPES.map(type => {
    const selected = type.toLowerCase() === 'kontrol' ? ' selected' : '';
    return `<option value="${type}"${selected}>${type}</option>`;
  }).join('');
  const statusOptions = SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <h2>Opret komplet sag</h2>
    <form id="createCaseForm" class="case-form">
      <fieldset>
        <legend>Patient</legend>
        <div class="inline-group">
          <label class="inline">MRN<input name="patient_mrn" required placeholder="Fx 010170-1234"></label>
          <label class="inline">Navn<input name="patient_name" required placeholder="Patientnavn"></label>
          <label class="inline">Familienummer
            <div class="family-combo">
              <select data-family-select>
                ${familySelectOptions}
              </select>
              <input name="patient_family" data-family-input placeholder="Fx FAM-001">
            </div>
          </label>
        </div>
        <div class="inline-group">
          <label class="inline">Køn<select name="patient_gender"><option value="">-</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
          <label class="inline">Fødselsdato<input type="date" name="patient_birth"></label>
        </div>
        <label class="inline">Noter<textarea name="patient_notes" class="small" placeholder="Valgfrit"></textarea></label>
      </fieldset>
      <fieldset>
        <legend>Prøve</legend>
        <div class="inline-group">
          <label class="inline">PMB-nummer<input name="sample_pmb" required placeholder="PMB-12345"></label>
          <label class="inline">Prøvetype<select name="sample_type" required><option value="" selected>Vælg type</option>${typeOptions}</select></label>
        </div>
        <div class="inline-group">
          <label class="inline">Status<select name="sample_status" required><option value="" selected>Vælg status</option>${statusOptions}</select></label>
          <label class="inline">Opsamlet<input type="datetime-local" name="sample_collected"></label>
        </div>
        <label class="inline">Noter<textarea name="sample_notes" class="small" placeholder="Valgfrit"></textarea></label>
        <label class="toggle"><input type="checkbox" id="includeControlSample"> Tilføj kontrolprøve</label>
        <div id="controlSampleFields" hidden>
          <div class="inline-group">
            <label class="inline">PMB-nummer<input name="control_pmb" placeholder="PMB-KONTROL"></label>
            <label class="inline">Prøvetype<select name="control_type">${controlTypeOptions}</select></label>
          </div>
          <div class="inline-group">
            <label class="inline">Status<select name="control_status"><option value="" selected>Vælg status</option>${statusOptions}</select></label>
            <label class="inline">Opsamlet<input type="datetime-local" name="control_collected"></label>
          </div>
          <label class="inline">Noter<textarea name="control_notes" class="small" placeholder="Valgfrit"></textarea></label>
        </div>
      </fieldset>
      <fieldset>
        <legend>Ordination</legend>
        <div class="inline-group">
          <label class="inline">Panel
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer paneler">
              <select name="order_panel_id" ${panels.length ? 'required' : ''}>
                <option value="" selected>Vælg panel</option>
                ${panelOptions}
              </select>
            </div>
          </label>
          <label class="inline">Rekvirent<input name="order_clinician" placeholder="Afdeling/Læge"></label>
        </div>
        <div class="inline-group">
          <label class="inline">Analyseansvarlig
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="order_analysis_responsible">
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
          <label class="inline">Tolker
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="order_interpreter">
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
        </div>
        <div class="inline-group">
          <label class="inline">Godkender
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="order_approver">
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
          <label class="inline">Bestilt<input type="datetime-local" name="order_ordered_at"></label>
        </div>
        <p class="form-hint" id="orderStatusPreview">Ordinationsstatus følger prøven: <strong id="orderStatusValue">–</strong></p>
      </fieldset>
      <fieldset>
        <legend>Kvalitetskontrol</legend>
        <p class="form-hint">Tilføj QC-målinger for prøven (valgfrit).</p>
        <div id="qcList" class="repeater"></div>
        <button type="button" class="secondary" id="addQcRow">Tilføj måling</button>
      </fieldset>
      <fieldset>
        <legend>Varianter</legend>
        <p class="form-hint" id="caseVariantHint">Registrer varianter fundet ved analysen. Tomme rækker ignoreres.</p>
        <div id="variantList" class="repeater"></div>
        <div class="btn-row">
          <button type="button" class="secondary" id="addVariantRow">Tilføj variant</button>
          <button type="button" class="secondary" id="caseImportVarSeq">Importér VarSeq CSV</button>
          <input type="file" id="caseImportVarSeqInput" accept=".csv,text/csv" hidden>
        </div>
      </fieldset>
      <div class="btn-row">
        <button type="submit" class="primary" id="createCaseSubmit">Opret sag</button>
        <button type="reset" class="secondary" id="createCaseReset">Ryd formular</button>
      </div>
    </form>
    <div id="createCaseMessage" class="form-hint" role="status" aria-live="polite"></div>
  </div>`;
  const form = section.querySelector('#createCaseForm');
  const message = section.querySelector('#createCaseMessage');
  if (!form) return;
  const controlToggle = form.querySelector('#includeControlSample');
  const controlFields = form.querySelector('#controlSampleFields');
  const controlTypeSelect = form.elements.control_type;
  const controlStatusSelect = form.elements.control_status;
  const sampleStatusSelect = form.elements.sample_status;
  const orderedAtInput = form.elements.order_ordered_at;
  const addQcBtn = section.querySelector('#addQcRow');
  const qcList = section.querySelector('#qcList');
  const addVariantBtn = section.querySelector('#addVariantRow');
  const importVariantBtn = section.querySelector('#caseImportVarSeq');
  const importVariantInput = section.querySelector('#caseImportVarSeqInput');
  const variantList = section.querySelector('#variantList');
  const submitBtn = section.querySelector('#createCaseSubmit');
  const resetBtn = section.querySelector('#createCaseReset');
  const statusPreviewValue = section.querySelector('#orderStatusValue');
  const setMessage = (text, tone = 'info') => {
    if (!message) return;
    message.textContent = text;
    const color = tone === 'success' ? 'var(--accent-strong)' : tone === 'error' ? 'var(--danger)' : 'var(--muted-text)';
    message.style.color = color;
  };
  const toLocalDateTimeValue = (date = new Date()) => {
    const pad = value => String(value).padStart(2, '0');
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
  };
  const disableButtons = disabled => {
    if (submitBtn) submitBtn.disabled = disabled;
    if (resetBtn) resetBtn.disabled = disabled;
  };
  const updateControlVisibility = () => {
    if (!controlFields) return;
    const enabled = Boolean(controlToggle?.checked);
    controlFields.hidden = !enabled;
    controlFields.querySelectorAll('input, select, textarea').forEach(el => {
      el.disabled = !enabled;
    });
    if (enabled) {
      if (controlTypeSelect && !controlTypeSelect.value) {
        const defaultType = SAMPLE_TYPES.find(type => type.toLowerCase() === 'kontrol') || SAMPLE_TYPES[0] || '';
        if (defaultType) controlTypeSelect.value = defaultType;
      }
      if (controlStatusSelect && !controlStatusSelect.value && sampleStatusSelect) {
        controlStatusSelect.value = sampleStatusSelect.value;
      }
    }
  };
  const updateStatusPreview = () => {
    const value = sampleStatusSelect?.value || '';
    if (statusPreviewValue) statusPreviewValue.textContent = value || '–';
    if (controlStatusSelect && controlToggle?.checked && !controlStatusSelect.value) {
      controlStatusSelect.value = value;
    }
  };
  controlToggle?.addEventListener('change', updateControlVisibility);
  sampleStatusSelect?.addEventListener('change', updateStatusPreview);
  const addQcRow = (values = {}) => {
    if (!qcList) return;
    const row = document.createElement('div');
    row.className = 'case-row qc-row';
    row.innerHTML = `
      <label class="inline">Måling<input type="text" data-field="metric" placeholder="DNA-koncentration"></label>
      <label class="inline">Værdi<input type="number" step="0.0001" data-field="value" placeholder="42.0"></label>
      <label class="inline">Enhed<input type="text" data-field="unit" placeholder="ng/µl"></label>
      <label class="inline wide">Noter<input type="text" data-field="notes" placeholder="Valgfrit"></label>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const metricInput = row.querySelector('[data-field="metric"]');
    const valueInput = row.querySelector('[data-field="value"]');
    const unitInput = row.querySelector('[data-field="unit"]');
    const notesInput = row.querySelector('[data-field="notes"]');
    if (metricInput) metricInput.value = values.metric || '';
    if (valueInput) valueInput.value = values.value != null ? values.value : '';
    if (unitInput) unitInput.value = values.unit || '';
    if (notesInput) notesInput.value = values.notes || '';
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern denne måling');
    qcList.appendChild(row);
    applyButtonTooltips(row);
  };
  const addVariantRow = (values = {}) => {
    if (!variantList) return;
    const defaultClass = values.classification != null ? String(values.classification) : '3';
    const classificationOptions = ['1','2','3','4','5'].map(v => `<option value="${v}"${defaultClass === String(v) ? ' selected' : ''}>${v}</option>`).join('');
    const row = document.createElement('div');
    row.className = 'case-row variant-row';
    row.innerHTML = `
      <label class="inline">Gen<input type="text" data-field="gene" placeholder="BRCA1"></label>
      <label class="inline">Transkript<input type="text" data-field="transcript" placeholder="NM_007294.3"></label>
      <label class="inline">HGVS c.<input type="text" data-field="hgvs_c" placeholder="c.5266dupC"></label>
      <label class="inline">HGVS p.<input type="text" data-field="hgvs_p" placeholder="p.(Gln1756Profs*74)"></label>
      <label class="inline">Zygositet<input type="text" data-field="zygosity" placeholder="Heterozygot"></label>
      <label class="inline">ACMG<select data-field="classification">${classificationOptions}</select></label>
      <label class="inline">Kriterier<input type="text" data-field="criteria" placeholder="PM1,PP3"></label>
      <label class="inline">Allelfrekvens<input type="number" step="0.0001" data-field="af" placeholder="0.125"></label>
      <label class="inline wide">Annoteringer<textarea class="small" data-field="annotations" placeholder="VarSeq-annoteringer og noter"></textarea></label>
      <label class="inline wide">Tolkning<textarea class="small" data-field="interpretation" placeholder="Kort tolkning"></textarea></label>
      <button type="button" class="secondary case-choose-library">Vælg fra bibliotek</button>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const setValue = (selector, value) => {
      const el = row.querySelector(selector);
      if (el) el.value = value || '';
    };
    setValue('[data-field="gene"]', values.gene);
    setValue('[data-field="transcript"]', values.transcript);
    setValue('[data-field="hgvs_c"]', values.hgvs_c);
    setValue('[data-field="hgvs_p"]', values.hgvs_p);
    setValue('[data-field="zygosity"]', values.zygosity);
    setValue('[data-field="criteria"]', values.criteria);
    const afField = row.querySelector('[data-field="af"]');
    if (afField) {
      if (values.af !== undefined && values.af !== null && values.af !== '') {
        afField.value = values.af;
      } else {
        afField.value = '';
      }
    }
    const interpretationField = row.querySelector('[data-field="interpretation"]');
    if (interpretationField) interpretationField.value = values.interpretation || '';
    const annotationsField = row.querySelector('[data-field="annotations"]');
    if (annotationsField) annotationsField.value = values.annotations || '';
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern varianten fra oprettelsen.');
    const libraryBtn = row.querySelector('.case-choose-library');
    libraryBtn?.addEventListener('click', () => {
      openVariantLibraryPicker(variant => {
        setValue('[data-field="gene"]', variant.gene);
        setValue('[data-field="transcript"]', variant.transcript);
        setValue('[data-field="hgvs_c"]', variant.hgvs_c);
        setValue('[data-field="hgvs_p"]', variant.hgvs_p);
        setValue('[data-field="criteria"]', variant.criteria);
        const classField = row.querySelector('[data-field="classification"]');
        if (classField && variant.classification != null && variant.classification !== '') {
          classField.value = String(variant.classification);
        }
        const interpretationField = row.querySelector('[data-field="interpretation"]');
        if (interpretationField) interpretationField.value = variant.evidence || variant.interpretation || '';
        const annotationsField = row.querySelector('[data-field="annotations"]');
        if (annotationsField) annotationsField.value = variant.annotations || variant.annotation_summary || '';
      });
    });
    if (libraryBtn) setTooltip(libraryBtn, 'Vælg en variant fra biblioteket.');
    variantList.appendChild(row);
    applyButtonTooltips(row);
  };
  const isVariantRowEmpty = row => {
    if (!row) return true;
    const get = field => {
      const el = row.querySelector(`[data-field="${field}"]`);
      if (!el) return '';
      if (el.type === 'number') return el.value.trim();
      return (el.value || '').trim();
    };
    const gene = get('gene');
    const transcript = get('transcript');
    const hgvsC = get('hgvs_c');
    const hgvsP = get('hgvs_p');
    const zygosity = get('zygosity');
    const criteria = get('criteria');
    const af = get('af');
    const interpretation = get('interpretation');
    const annotations = get('annotations');
    return !gene && !transcript && !hgvsC && !hgvsP && !zygosity && !criteria && !af && !interpretation && !annotations;
  };
  const removeEmptyVariantRows = () => {
    if (!variantList) return;
    const rows = Array.from(variantList.querySelectorAll('.variant-row'));
    if (!rows.length) return;
    const filled = rows.filter(row => !isVariantRowEmpty(row));
    if (!filled.length) {
      variantList.innerHTML = '';
      return;
    }
    rows.forEach(row => {
      if (isVariantRowEmpty(row)) row.remove();
    });
  };
  addQcBtn?.addEventListener('click', () => addQcRow());
  addVariantBtn?.addEventListener('click', () => addVariantRow());
  importVariantBtn?.addEventListener('click', () => importVariantInput?.click());
  importVariantInput?.addEventListener('change', async () => {
    const file = importVariantInput?.files?.[0];
    if (!file) return;
    try {
      const {variants: importedVariants, warnings, summary} = await parseVarSeqFile(file);
      if (!importedVariants.length) {
        setMessage('Ingen varianter blev fundet i filen.', 'error');
        return;
      }
      removeEmptyVariantRows();
      importedVariants.forEach(variant => addVariantRow(variant));
      const parts = [`Tilføjede ${importedVariants.length} varianter fra ${file.name}.`];
      if (summary.skipped) parts.push(`${summary.skipped} rækker blev ignoreret.`);
      if (warnings.length) parts.push(`${warnings.length} advarsler blev logget i konsollen.`);
      const messageText = parts.join(' ');
      setMessage(messageText, 'success');
      setStatus(`VarSeq import til oprettelse: ${importedVariants.length} varianter klar.`);
      if (warnings.length) console.warn('VarSeq import advarsler', warnings);
    } catch (err) {
      console.error(err);
      setMessage('Kunne ikke importere VarSeq CSV: ' + (err?.message || err), 'error');
    } finally {
      if (importVariantInput) importVariantInput.value = '';
    }
  });
  addQcRow();
  addVariantRow();
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  initFamilyCombos(form);
  applySelectFilters(section);
  updateControlVisibility();
  updateStatusPreview();
  if (orderedAtInput && !orderedAtInput.value) {
    orderedAtInput.value = toLocalDateTimeValue();
  }
  form.addEventListener('reset', () => {
    setTimeout(() => {
      setMessage('');
      updateControlVisibility();
      updateStatusPreview();
      if (qcList) {
        qcList.innerHTML = '';
        addQcRow();
      }
      if (variantList) {
        variantList.innerHTML = '';
        addVariantRow();
      }
      if (orderedAtInput) orderedAtInput.value = toLocalDateTimeValue();
    }, 0);
  });
  let submitting = false;
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (submitting) return;
    submitting = true;
    disableButtons(true);
    setMessage('');
    const patientMrn = form.elements.patient_mrn.value.trim();
    if (!patientMrn) {
      setMessage('Angiv patientens MRN.', 'error');
      form.elements.patient_mrn.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const patientName = form.elements.patient_name.value.trim();
    if (!patientName) {
      setMessage('Angiv patientens navn.', 'error');
      form.elements.patient_name.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const patient = {
      mrn: patientMrn,
      family_number: form.elements.patient_family?.value.trim() || '',
      name: patientName,
      gender: form.elements.patient_gender.value || '',
      birth_date: form.elements.patient_birth.value || '',
      notes: form.elements.patient_notes.value.trim()
    };
    const samplePmb = form.elements.sample_pmb.value.trim();
    if (!samplePmb) {
      setMessage('Angiv et PMB-nummer for prøven.', 'error');
      form.elements.sample_pmb.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sampleTypeValue = form.elements.sample_type.value.trim();
    if (!sampleTypeValue) {
      setMessage('Vælg prøvetype.', 'error');
      form.elements.sample_type.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sampleStatusValue = form.elements.sample_status.value.trim();
    if (!sampleStatusValue) {
      setMessage('Vælg prøvens status.', 'error');
      form.elements.sample_status.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    const sample = {
      pmb_number: samplePmb,
      sample_type: sampleTypeValue,
      status: sampleStatusValue,
      collected_at: form.elements.sample_collected.value || '',
      notes: form.elements.sample_notes.value.trim()
    };
    let controlSample = null;
    if (controlToggle?.checked) {
      const controlPmb = form.elements.control_pmb.value.trim();
      if (!controlPmb) {
        setMessage('Angiv PMB-nummer for kontrolprøven.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
      const controlTypeValue = (form.elements.control_type?.value || '').trim();
      const controlStatusValue = (form.elements.control_status?.value || '').trim();
      controlSample = {
        pmb_number: controlPmb,
        sample_type: controlTypeValue || (SAMPLE_TYPES.find(type => type.toLowerCase() === 'kontrol') || sample.sample_type),
        status: controlStatusValue || sample.status,
        collected_at: form.elements.control_collected.value || '',
        notes: form.elements.control_notes.value.trim()
      };
    }
    const panelIdValue = form.elements.order_panel_id.value;
    if (!panelIdValue) {
      setMessage('Vælg panel til ordinationen.', 'error');
      form.elements.order_panel_id.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    let orderedAt = form.elements.order_ordered_at.value;
    if (!orderedAt) orderedAt = toLocalDateTimeValue();
    const order = {
      panel_id: Number(panelIdValue),
      analysis_responsible_id: form.elements.order_analysis_responsible.value ? Number(form.elements.order_analysis_responsible.value) : null,
      interpreter_id: form.elements.order_interpreter.value ? Number(form.elements.order_interpreter.value) : null,
      approver_id: form.elements.order_approver.value ? Number(form.elements.order_approver.value) : null,
      clinician: form.elements.order_clinician.value.trim(),
      status: sample.status,
      ordered_at: orderedAt
    };
    const qcEntries = [];
    if (qcList) {
      for (const row of qcList.querySelectorAll('.qc-row')) {
        const metric = row.querySelector('[data-field="metric"]')?.value.trim() || '';
        const value = row.querySelector('[data-field="value"]')?.value.trim() || '';
        const unit = row.querySelector('[data-field="unit"]')?.value.trim() || '';
        const notes = row.querySelector('[data-field="notes"]')?.value.trim() || '';
        if (!metric && !value && !unit && !notes) continue;
        if (!metric || !value) {
          setMessage('Angiv både måling og værdi for QC-poster.', 'error');
          row.querySelector('[data-field="metric"]')?.focus();
          disableButtons(false);
          submitting = false;
          return;
        }
        qcEntries.push({metric, value, unit, notes});
      }
    }
    const variantEntries = [];
    if (variantList) {
      for (const row of variantList.querySelectorAll('.variant-row')) {
        const gene = row.querySelector('[data-field="gene"]')?.value.trim() || '';
        const transcript = row.querySelector('[data-field="transcript"]')?.value.trim() || '';
        const hgvsC = row.querySelector('[data-field="hgvs_c"]')?.value.trim() || '';
        const hgvsP = row.querySelector('[data-field="hgvs_p"]')?.value.trim() || '';
        const zygosity = row.querySelector('[data-field="zygosity"]')?.value.trim() || '';
        const classification = row.querySelector('[data-field="classification"]')?.value || '3';
        const criteria = row.querySelector('[data-field="criteria"]')?.value.trim() || '';
        const afRaw = row.querySelector('[data-field="af"]')?.value.trim() || '';
        const interpretation = row.querySelector('[data-field="interpretation"]')?.value.trim() || '';
        const annotations = row.querySelector('[data-field="annotations"]')?.value.trim() || '';
        const isEmpty = !gene && !transcript && !hgvsC && !hgvsP && !zygosity && !criteria && !afRaw && !interpretation && !annotations;
        if (isEmpty) continue;
        if (!gene) {
          setMessage('Angiv gen for hver registreret variant.', 'error');
          row.querySelector('[data-field="gene"]')?.focus();
          disableButtons(false);
          submitting = false;
          return;
        }
        const variant = {
          gene,
          transcript,
          hgvs_c: hgvsC,
          hgvs_p: hgvsP,
          zygosity,
          classification: String(classification || '3'),
          criteria,
          interpretation
        };
        if (afRaw) {
          const afNumber = Number(afRaw);
          if (!Number.isFinite(afNumber)) {
            setMessage('Allelfrekvens skal være et tal.', 'error');
            row.querySelector('[data-field="af"]')?.focus();
            disableButtons(false);
            submitting = false;
            return;
          }
          variant.af = afNumber;
        }
        if (annotations) {
          variant.annotations = annotations;
        }
        variantEntries.push(variant);
      }
    }
    const requiredStores = new Set(['patients','samples','orders']);
    if (qcEntries.length) requiredStores.add('qc');
    if (variantEntries.length) requiredStores.add('variants');
    for (const store of requiredStores) {
      if (!ensureWrite(store)) {
        setMessage('Handling kræver skriveadgang. Kontakt en administrator.', 'error');
        disableButtons(false);
        submitting = false;
        return;
      }
    }
    const existingSamples = getCached('samples');
    const primaryPmbLower = sample.pmb_number.toLowerCase();
    if (existingSamples.some(s => (s.pmb_number || '').toLowerCase() === primaryPmbLower)) {
      setMessage('PMB-nummeret for hovedprøven er allerede i brug.', 'error');
      form.elements.sample_pmb.focus();
      disableButtons(false);
      submitting = false;
      return;
    }
    if (controlSample) {
      const controlPmbLower = controlSample.pmb_number.toLowerCase();
      if (controlPmbLower === primaryPmbLower) {
        setMessage('Kontrolprøven skal have et andet PMB-nummer end hovedprøven.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
      if (existingSamples.some(s => (s.pmb_number || '').toLowerCase() === controlPmbLower)) {
        setMessage('Kontrolprøvens PMB-nummer er allerede i brug.', 'error');
        form.elements.control_pmb.focus();
        disableButtons(false);
        submitting = false;
        return;
      }
    }
    try {
      setMessage('Opretter sag...', 'info');
      const patientId = await addRecord('patients', patient);
      const sampleId = await addRecord('samples', {...sample, patient_id: patientId});
      if (controlSample) {
        await addRecord('samples', {...controlSample, patient_id: patientId});
      }
      const orderId = await addRecord('orders', {...order, patient_id: patientId, sample_id: sampleId});
      for (const qc of qcEntries) {
        await addRecord('qc', {...qc, sample_id: sampleId});
      }
      for (const variant of variantEntries) {
        await addRecord('variants', {...variant, order_id: orderId});
      }
      form.reset();
      setMessage(`Sag ${orderId} oprettet for ${patient.name} med PMB ${sample.pmb_number}.`, 'success');
      setStatus(`Sag ${orderId} oprettet for ${patient.name}.`);
      const dashboardSection = document.querySelector('section[data-tab="dashboard"]');
      if (dashboardSection) renderDashboard(dashboardSection);
      ['patients','samples','orders','qc','variants'].forEach(id => {
        const target = document.querySelector(`section[data-tab="${id}"]`);
        if (target && target.classList.contains('active')) {
          renderTab(id);
        }
      });
    } catch (err) {
      console.error(err);
      setMessage('Kunne ikke oprette sag: ' + (err?.message || err), 'error');
      setStatus('Fejl under oprettelse: ' + (err?.message || err));
    } finally {
      disableButtons(false);
      submitting = false;
    }
  });
  if (!panels.length) {
    setMessage('Opret først et panel under "Analyser/Panels" for at kunne oprette en sag.', 'error');
    disableButtons(true);
  } else {
    setMessage('');
    disableButtons(false);
  }
}
function getName(store, id) {
  if (!id) return '';
  const row = findById(store, typeof id === 'string' ? Number(id) : id);
  if (!row) return '';
  if (store === 'patients') {
    const name = row.name || '';
    const details = [row.mrn, row.family_number].filter(Boolean).join(' • ');
    if (name && details) return `${name} (${details})`;
    if (name) return name;
    if (details) return details;
  }
  return row.pmb_number || row.name || row.mrn || `#${id}`;
}
function creationKey(entity, id) {
  if (!entity || id === undefined || id === null) return null;
  return `${entity}:${id}`;
}
function rebuildCreationLookup() {
  const auditEntries = getCached('audit') || [];
  const map = new Map();
  for (const entry of auditEntries) {
    if (!entry || entry.action !== 'CREATE') continue;
    const key = creationKey(entry.entity, entry.entity_id);
    if (!key || map.has(key)) continue;
    let creator = entry.user || '';
    if ((!creator || creator === 'System') && entry.after) {
      try {
        const after = JSON.parse(entry.after);
        if (after?.created_by) creator = after.created_by;
      } catch (err) {
        /* ignore parse errors */
      }
    }
    if (creator) {
      map.set(key, creator);
    }
  }
  state.creationLookup = map;
}
function determineCreatedBy(store, record) {
  if (!record) return 'Ukendt';
  if (record.created_by) return record.created_by;
  const key = creationKey(store, record.id);
  if (key && state.creationLookup?.has(key)) {
    return state.creationLookup.get(key) || 'Ukendt';
  }
  return 'Ukendt';
}
function cloneWithCreatedBy(store, rows) {
  if (!Array.isArray(rows)) return [];
  if (!CREATED_BY_STORES.has(store)) {
    return rows.map(row => ({...row}));
  }
  return rows.map(row => {
    const clone = {...row};
    const creator = determineCreatedBy(store, row);
    if (creator && creator !== clone.created_by) {
      clone.created_by = creator;
    }
    return clone;
  });
}
async function ensureCreationMetadata() {
  if (!state.db) return;
  const stores = Array.from(CREATED_BY_STORES);
  const toReload = [];
  for (const store of stores) {
    const list = getCached(store) || [];
    const pending = [];
    for (const row of list) {
      if (!row) continue;
      const creator = determineCreatedBy(store, row);
      if (creator && creator !== 'Ukendt' && creator !== row.created_by) {
        pending.push({...row, created_by: creator});
      }
    }
    if (!pending.length) continue;
    const tx = state.db.transaction(store, 'readwrite');
    const objectStore = tx.objectStore(store);
    for (const record of pending) {
      objectStore.put(record);
    }
    await tx.done?.catch(() => {});
    toReload.push(store);
  }
  if (toReload.length) {
    for (const store of toReload) {
      await loadStore(store);
    }
  }
}
function fillForm(form, record) {
  if (!form || !record) return;
  Array.from(form.elements).forEach(el => {
    if (!el.name) return;
    if (!(el.name in record)) {
      return;
    }
    const value = record[el.name];
    if (el.type === 'checkbox') {
      el.checked = Boolean(value);
      return;
    }
    if (el.type === 'password') {
      el.value = '';
      return;
    }
    if (el.tagName === 'SELECT') {
      const asString = value == null ? '' : String(value);
      if (el.name === 'role' && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
        const opt = document.createElement('option');
        opt.value = asString;
        opt.textContent = roleWithDescription(asString);
        opt.dataset.legacy = 'true';
        el.appendChild(opt);
      }
      if (el.dataset.allowLegacyOption !== undefined && asString && !Array.from(el.options).some(opt => opt.value === asString)) {
        const opt = document.createElement('option');
        opt.value = asString;
        opt.textContent = asString;
        opt.dataset.legacy = 'true';
        el.appendChild(opt);
      }
      el.value = asString;
      return;
    }
    el.value = value ?? '';
    if (el.dataset.familyInput !== undefined) {
      el.dispatchEvent(new Event('input', {bubbles: false}));
    }
  });
}
function renderPatients(section) {
  const list = getCached('patients');
  const existingFamilyNumbers = Array.from(new Set(list.map(p => (p.family_number || '').trim()).filter(Boolean))).sort((a, b) => a.localeCompare(b, 'da'));
  const familySelectOptions = ['<option value="">Vælg familienummer</option>']
    .concat(existingFamilyNumbers.map(num => `<option value="${esc(num)}">${esc(num)}</option>`))
    .concat('<option value="__custom__">Tilføj nyt familienummer…</option>')
    .join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="patientSearch">Søg</label>
        <input id="patientSearch" type="search" placeholder="Navn/MRN/familie...">
        <details class="advanced-filter" id="patientsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-patients="id" placeholder="Fx 152"></label>
            <label>MRN<input type="search" data-filter-patients="mrn" placeholder="MRN eller CPR"></label>
            <label>Familienummer<input type="search" data-filter-patients="family" placeholder="Fx FAM-001"></label>
            <label>Navn<input type="search" data-filter-patients="name" placeholder="Patientnavn"></label>
            <label>Køn<select data-filter-patients="gender"><option value="">Alle</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
            <label>Fødselsår<input type="search" data-filter-patients="birth" placeholder="ÅÅÅÅ"></label>
          </div>
        </details>
        <table id="patientsTable"><thead><tr><th>ID</th><th>MRN</th><th>Familienummer</th><th>Navn</th><th>Køn</th><th>Født</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="patientsExport">Eksportér filtrerede patienter</button>
        </div>
      </div>
      <div>
        <h2>Patient</h2>
        <form id="patientForm">
          <input type="hidden" name="id">
          <label>MRN<input name="mrn" required></label>
          <label>Familienummer
            <div class="family-combo">
              <select data-family-select>
                ${familySelectOptions}
              </select>
              <input name="family_number" data-family-input placeholder="Fx FAM-001">
            </div>
          </label>
          <label>Navn<input name="name" required></label>
          <label>Køn<select name="gender"><option value="">-</option><option value="male">Mand</option><option value="female">Kvinde</option><option value="other">Andet</option></select></label>
          <label>Fødselsdato<input type="date" name="birth_date"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button type="submit" class="primary">Gem</button>
            <button type="button" id="patientClear" class="secondary">Ny</button>
            <button type="button" id="patientDelete" class="danger">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('#patientsTable tbody');
  const form = section.querySelector('#patientForm');
  const searchInput = section.querySelector('#patientSearch');
  const deleteBtn = section.querySelector('#patientDelete');
  const clearBtn = section.querySelector('#patientClear');
  const filterInputs = {
    id: section.querySelector('[data-filter-patients="id"]'),
    mrn: section.querySelector('[data-filter-patients="mrn"]'),
    family: section.querySelector('[data-filter-patients="family"]'),
    name: section.querySelector('[data-filter-patients="name"]'),
    gender: section.querySelector('[data-filter-patients="gender"]'),
    birth: section.querySelector('[data-filter-patients="birth"]')
  };
  let filteredPatients = list.slice();
  let activeFilters = {};
  let selectedPatientId = null;
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  initFamilyCombos(form);
  const genderMap = {male:'Mand', female:'Kvinde', other:'Andet'};
  const renderRows = () => {
    const term = searchInput.value.trim().toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      mrn: filterInputs.mrn?.value.trim().toLowerCase() || '',
      family: filterInputs.family?.value.trim().toLowerCase() || '',
      name: filterInputs.name?.value.trim().toLowerCase() || '',
      gender: filterInputs.gender?.value || '',
      birth: filterInputs.birth?.value.trim().toLowerCase() || ''
    };
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredPatients = list.filter(p => {
      if (!term) return true;
      const displayGender = genderMap[p.gender];
      const creator = determineCreatedBy('patients', p);
      return [p.name, p.mrn, p.family_number, p.gender, displayGender, creator].some(v => (v||'').toLowerCase().includes(term));
    }).filter(p => {
      if (filters.id && !String(p.id).includes(filters.id)) return false;
      if (filters.mrn && !(p.mrn||'').toLowerCase().includes(filters.mrn)) return false;
      if (filters.family && !(p.family_number||'').toLowerCase().includes(filters.family)) return false;
      if (filters.name && !(p.name||'').toLowerCase().includes(filters.name)) return false;
      if (filters.gender && (p.gender||'') !== filters.gender) return false;
      if (filters.birth && !(p.birth_date||'').toLowerCase().startsWith(filters.birth)) return false;
      return true;
    });
    if (selectedPatientId != null && !filteredPatients.some(p => p.id === selectedPatientId)) {
      selectedPatientId = null;
    }
    tbody.innerHTML = filteredPatients.map(p => {
      const gender = genderMap[p.gender] || p.gender || '';
      const createdBy = determineCreatedBy('patients', p);
      const selectedAttr = p.id === selectedPatientId ? ' data-selected="true"' : '';
      return `<tr data-id="${p.id}"${selectedAttr}><td>${p.id}</td><td>${esc(p.mrn)}</td><td>${esc(p.family_number||'')}</td><td>${esc(p.name)}</td><td>${esc(gender)}</td><td>${esc(p.birth_date||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  searchInput.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  section.querySelector('#patientsExport').addEventListener('click', () => {
    exportFilteredJson('glimr-patienter-filtreret.json', cloneWithCreatedBy('patients', filteredPatients), {
      entity: 'patienter',
      plural: 'patienter',
      tab: 'Patienter',
      filters: activeFilters
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const patient = list.find(p => p.id === id);
    if (!patient) return;
    selectedPatientId = id;
    fillForm(form, patient);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('patients')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('patients', id)};
      const updated = {...before, ...data, id};
      await updateRecord('patients', updated, before);
    } else {
      delete data.id;
      await addRecord('patients', data);
    }
    await loadStore('patients');
    renderTab('patients');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
  });
  deleteBtn.addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg en patient');
    if (!ensureWrite('patients')) return;
    if (confirm('Slet patient?')) {
      await deleteRecord('patients', id);
      form.reset();
      renderTab('patients');
      renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    }
  });
  form.addEventListener('reset', () => {
    selectedPatientId = null;
    renderRows();
  });
  clearBtn.addEventListener('click', () => form.reset());
}
function renderSamples(section) {
  const list = getCached('samples');
  const patients = getCached('patients');
  const patientMap = new Map(patients.map(p => [p.id, p]));
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="sampleSearch">Søg</label>
        <input id="sampleSearch" type="search" placeholder="ID/PMB/status...">
        <details class="advanced-filter" id="samplesFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-samples="id" placeholder="Sample-ID"></label>
            <label>PMB-nummer<input type="search" data-filter-samples="pmb" placeholder="PMB"></label>
            <label>Patient<input type="search" data-filter-samples="patient" placeholder="Patientnavn/MRN/familie"></label>
            <label>Prøvetype<input type="search" data-filter-samples="type" placeholder="Type"></label>
            <label>Status<input type="search" data-filter-samples="status" placeholder="Status"></label>
            <label>Opsamlet fra<input type="date" data-filter-samples="collected_from"></label>
            <label>Opsamlet til<input type="date" data-filter-samples="collected_to"></label>
          </div>
        </details>
        <table><thead><tr><th>ID</th><th>PMB-nummer</th><th>Patient</th><th>Prøvetype</th><th>Status</th><th>Opsamlet</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="samplesExport">Eksportér filtrerede prøver</button>
        </div>
      </div>
      <div>
        <h2>Prøve</h2>
        <form id="sampleForm">
          <input type="hidden" name="id">
          <label>Patient
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer patienter">
              <select name="patient_id" required>
                <option value="" selected>Vælg patient</option>
                ${patients.map(p => {
                  const details = [p.mrn, p.family_number].filter(Boolean).map(esc).join(' • ');
                  return `<option value="${p.id}">${esc(p.name)}${details ? ` (${details})` : ''}</option>`;
                }).join('')}
              </select>
            </div>
          </label>
          <label>PMB-nummer<input name="pmb_number" required></label>
          <label>Prøvetype
            <select name="sample_type" required data-allow-legacy-option>
              <option value="">Vælg prøvetype</option>
              ${SAMPLE_TYPES.map(type => `<option value="${type}">${type}</option>`).join('')}
            </select>
          </label>
          <label>Status
            <select name="status" data-allow-legacy-option>
              <option value="">Vælg status</option>
              ${SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('')}
            </select>
          </label>
          <label>Opsamlet<input type="datetime-local" name="collected_at"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button class="primary" type="submit">Gem</button>
            <button class="secondary" type="button" id="sampleClear">Ny</button>
            <button class="danger" type="button" id="sampleDelete">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#sampleSearch');
  const form = section.querySelector('#sampleForm');
  const filterInputs = {
    id: section.querySelector('[data-filter-samples="id"]'),
    pmb: section.querySelector('[data-filter-samples="pmb"]'),
    patient: section.querySelector('[data-filter-samples="patient"]'),
    type: section.querySelector('[data-filter-samples="type"]'),
    status: section.querySelector('[data-filter-samples="status"]'),
    collected_from: section.querySelector('[data-filter-samples="collected_from"]'),
    collected_to: section.querySelector('[data-filter-samples="collected_to"]')
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  let filteredSamples = list.slice();
  let activeFilters = {};
  let selectedSampleId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      pmb: filterInputs.pmb?.value.trim().toLowerCase() || '',
      patient: filterInputs.patient?.value.trim().toLowerCase() || '',
      type: filterInputs.type?.value.trim().toLowerCase() || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      collected_from: filterInputs.collected_from?.value || '',
      collected_to: filterInputs.collected_to?.value || ''
    };
    const fromDate = filters.collected_from ? new Date(filters.collected_from) : null;
    const toDate = filters.collected_to ? new Date(filters.collected_to) : null;
    if (toDate) {
      toDate.setHours(23, 59, 59, 999);
    }
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredSamples = list.filter(s => {
      if (!term) return true;
      const creator = determineCreatedBy('samples', s);
      return [s.id, s.pmb_number, s.status, s.sample_type, creator].some(v => (v ?? '').toString().toLowerCase().includes(term));
    }).filter(s => {
      const patient = patientMap.get(Number(s.patient_id));
      const patientString = [patient?.name, patient?.mrn, patient?.family_number].filter(Boolean).join(' ').toLowerCase();
      if (filters.id && !String(s.id).includes(filters.id)) return false;
      if (filters.pmb && !(s.pmb_number || '').toLowerCase().includes(filters.pmb)) return false;
      if (filters.patient && !patientString.includes(filters.patient)) return false;
      if (filters.type && !(s.sample_type || '').toLowerCase().includes(filters.type)) return false;
      if (filters.status && !(s.status || '').toLowerCase().includes(filters.status)) return false;
      if (fromDate || toDate) {
        if (!s.collected_at) return false;
        const collectedAt = new Date(s.collected_at);
        if (Number.isNaN(collectedAt.getTime())) return false;
        if (fromDate && collectedAt < fromDate) return false;
        if (toDate && collectedAt > toDate) return false;
      }
      return true;
    });
    if (selectedSampleId != null && !filteredSamples.some(s => s.id === selectedSampleId)) {
      selectedSampleId = null;
    }
    tbody.innerHTML = filteredSamples.map(s => {
      const createdBy = determineCreatedBy('samples', s);
      const selectedAttr = s.id === selectedSampleId ? ' data-selected="true"' : '';
      return `<tr data-id="${s.id}"${selectedAttr}><td>${s.id}</td><td>${esc(s.pmb_number||'')}</td><td>${esc(getName('patients', Number(s.patient_id)))}</td><td>${esc(s.sample_type)}</td><td>${esc(s.status||'')}</td><td>${esc(s.collected_at||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  section.querySelector('#samplesExport').addEventListener('click', () => {
    exportFilteredJson('glimr-proever-filtreret.json', cloneWithCreatedBy('samples', filteredSamples), {
      entity: 'prøver',
      plural: 'prøver',
      tab: 'Prøver',
      filters: activeFilters
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const sample = list.find(s => s.id === Number(tr.dataset.id));
    if (!sample) return;
    selectedSampleId = sample.id;
    fillForm(form, sample);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('samples')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    const currentId = data.id ? Number(data.id) : null;
    data.patient_id = Number(data.patient_id);
    data.pmb_number = (data.pmb_number || '').trim();
    if (!data.pmb_number) {
      alert('Angiv et PMB-nummer.');
      return;
    }
    const existingSamples = getCached('samples');
    const conflict = existingSamples.find(s => (s.pmb_number || '').toLowerCase() === data.pmb_number.toLowerCase() && s.id !== currentId);
    if (conflict) {
      alert('PMB-nummeret er allerede i brug.');
      return;
    }
    if (data.sample_type) data.sample_type = data.sample_type.trim();
    if (data.status) data.status = data.status.trim();
    if (data.notes) data.notes = data.notes.trim();
    let sampleId;
    if (currentId) {
      const id = currentId;
      const before = {...findById('samples', id)};
      const updated = {...before, ...data, id};
      await updateRecord('samples', updated, before);
      sampleId = id;
    } else {
      delete data.id;
      sampleId = await addRecord('samples', data);
    }
    const sampleStatus = data.status || '';
    if (sampleId) {
      const relatedOrders = getCached('orders').filter(o => Number(o.sample_id) === sampleId);
      let ordersUpdated = false;
      for (const order of relatedOrders) {
        if ((order.status || '') !== sampleStatus) {
          const beforeOrder = {...order};
          const updatedOrder = {...order, status: sampleStatus};
          await updateRecord('orders', updatedOrder, beforeOrder);
          ordersUpdated = true;
        }
      }
      if (ordersUpdated && state.currentTab === 'orders') {
        renderTab('orders');
      }
    }
    await loadStore('samples');
    renderTab('samples');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
  });
  section.querySelector('#sampleDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg sample');
    if (!ensureWrite('samples')) return;
    if (confirm('Slet sample?')) {
      await deleteRecord('samples', id);
      renderTab('samples');
    }
  });
  form.addEventListener('reset', () => {
    selectedSampleId = null;
    renderRows();
  });
  section.querySelector('#sampleClear').addEventListener('click', () => form.reset());
}
function renderPanels(section) {
  const list = getCached('panels');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="panelSearch">Søg</label>
        <input id="panelSearch" type="search" placeholder="Navn...">
        <table><thead><tr><th>ID</th><th>Navn</th><th>Beskrivelse</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="panelsExport">Eksportér filtrerede paneler</button>
        </div>
      </div>
      <div>
        <h2>Panel</h2>
        <form id="panelForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <label>Beskrivelse<textarea name="description"></textarea></label>
          <div class="btn-row">
            <button class="primary" type="submit">Gem</button>
            <button class="secondary" type="button" id="panelClear">Ny</button>
            <button class="danger" type="button" id="panelDelete">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#panelSearch');
  const form = section.querySelector('#panelForm');
  const exportButton = section.querySelector('#panelsExport');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  let selectedPanelId = null;
  let filteredPanels = list.slice();
  const renderRows = () => {
    const term = search.value.trim().toLowerCase();
    filteredPanels = list.filter(p => !term || (p.name || '').toLowerCase().includes(term));
    if (selectedPanelId != null && !filteredPanels.some(p => p.id === selectedPanelId)) {
      selectedPanelId = null;
    }
    tbody.innerHTML = filteredPanels.map(p => {
      const selectedAttr = p.id === selectedPanelId ? ' data-selected="true"' : '';
      return `<tr data-id="${p.id}"${selectedAttr}><td>${p.id}</td><td>${esc(p.name)}</td><td>${esc(p.description||'')}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  exportButton?.addEventListener('click', () => {
    if (!filteredPanels.length) {
      alert('Ingen paneler matcher filtreringen.');
      return;
    }
    const lines = filteredPanels.map(p => {
      const name = (p.name ?? '').toString().trim() || '(uden navn)';
      const desc = (p.description ?? '').toString().replace(/\r?\n|\r/g, ' ').trim();
      return `${name}: ${desc}`;
    });
    const text = lines.join('\r\n');
    const filename = downloadTextFile(text, 'glimr-paneler.txt');
    setStatus(`Eksporterede ${filteredPanels.length} paneler til ${filename}.`);
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const panel = list.find(p => p.id === Number(tr.dataset.id));
    if (!panel) return;
    selectedPanelId = panel.id;
    fillForm(form, panel);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('panels')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('panels', id)};
      const updated = {...before, ...data, id};
      await updateRecord('panels', updated, before);
    } else {
      delete data.id;
      await addRecord('panels', data);
    }
    await loadStore('panels');
    renderTab('panels');
  });
  section.querySelector('#panelDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg panel');
    if (!ensureWrite('panels')) return;
    if (confirm('Slet panel?')) {
      await deleteRecord('panels', id);
      renderTab('panels');
    }
  });
  form.addEventListener('reset', () => {
    selectedPanelId = null;
    renderRows();
  });
  section.querySelector('#panelClear').addEventListener('click', () => form.reset());
}
function renderOrders(section) {
  const list = getCached('orders');
  const patients = getCached('patients');
  const samples = getCached('samples');
  const panels = getCached('panels');
  const users = getCached('users').slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  const patientMap = new Map(patients.map(p => [p.id, p]));
  const sampleMap = new Map(samples.map(s => [s.id, s]));
  const panelMap = new Map(panels.map(p => [p.id, p]));
  const userMap = new Map(users.map(u => [u.id, u]));
  const userOptions = users.map(u => `<option value="${u.id}">${esc(u.name || `Bruger #${u.id}`)}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="orderSearch">Søg</label>
        <input id="orderSearch" type="search" placeholder="Status/ID/PMB...">
        <details class="advanced-filter" id="ordersFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-orders="id" placeholder="Ordination-ID"></label>
            <label>Patient<input type="search" data-filter-orders="patient" placeholder="Patientnavn/MRN/familie"></label>
            <label>Prøve<input type="search" data-filter-orders="sample" placeholder="Prøve-ID eller PMB"></label>
            <label>Panel<input type="search" data-filter-orders="panel" placeholder="Panelnavn"></label>
            <label>Analyseansvarlig
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="analysis_responsible">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Tolker
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="interpreter">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Godkender
              <div class="filterable-select">
                <input type="search" data-select-filter placeholder="Filtrer brugere">
                <select data-filter-orders="approver">
                  <option value="" selected>Alle</option>
                  ${userOptions}
                </select>
              </div>
            </label>
            <label>Status<input type="search" data-filter-orders="status" placeholder="Status"></label>
            <label>Bestilt fra<input type="date" data-filter-orders="ordered_from"></label>
            <label>Bestilt til<input type="date" data-filter-orders="ordered_to"></label>
          </div>
        </details>
        <table><thead><tr><th>ID</th><th>Patient</th><th>Prøve</th><th>Panel</th><th>Analyseansvarlig</th><th>Tolker</th><th>Godkender</th><th>Status</th><th>Oprettet af</th><th>Bestilt</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="ordersExport">Eksportér filtrerede ordinationer</button>
        </div>
      </div>
      <div>
        <h2>Ordination</h2>
        <form id="orderForm">
          <input type="hidden" name="id">
          <label>Patient
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer patienter">
              <select name="patient_id" required>
                <option value="" selected>Vælg patient</option>
                ${patients.map(p => {
                  const details = [p.mrn, p.family_number].filter(Boolean).map(esc).join(' • ');
                  return `<option value="${p.id}">${esc(p.name)}${details ? ` (${details})` : ''}</option>`;
                }).join('')}
              </select>
            </div>
          </label>
          <label>Prøve
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer prøver">
              <select name="sample_id" required>
                <option value="" selected>Vælg prøve</option>
                ${samples.map(s => `<option value="${s.id}">${s.id} (${esc(s.pmb_number||'–')}) – ${esc(getName('patients', s.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Panel
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer paneler">
              <select name="panel_id"><option value="">-</option>${panels.map(p => `<option value="${p.id}">${esc(p.name)}</option>`).join('')}</select>
            </div>
          </label>
          <label>Analyseansvarlig
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="analysis_responsible_id" data-allow-legacy-option>
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
          <label>Tolker
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="interpreter_id" data-allow-legacy-option>
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
          <label>Godkender
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer brugere">
              <select name="approver_id" data-allow-legacy-option>
                <option value="" selected>Vælg bruger</option>
                ${userOptions}
              </select>
            </div>
          </label>
          <label>Rekvirent<input name="clinician"></label>
          <label>Status
            <select name="status" required data-allow-legacy-option>
              <option value="" selected>Vælg status</option>
              ${SAMPLE_STATUSES.map(status => `<option value="${status}">${status}</option>`).join('')}
            </select>
          </label>
          <label>Bestillingstidspunkt<input type="datetime-local" name="ordered_at"></label>
          <div class="btn-row">
            <button class="primary" type="submit">Gem</button>
            <button class="secondary" type="button" id="orderClear">Ny</button>
            <button class="danger" type="button" id="orderDelete">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#orderSearch');
  const form = section.querySelector('#orderForm');
  const filterInputs = {
    id: section.querySelector('[data-filter-orders="id"]'),
    patient: section.querySelector('[data-filter-orders="patient"]'),
    sample: section.querySelector('[data-filter-orders="sample"]'),
    panel: section.querySelector('[data-filter-orders="panel"]'),
    analysis_responsible: section.querySelector('[data-filter-orders="analysis_responsible"]'),
    interpreter: section.querySelector('[data-filter-orders="interpreter"]'),
    approver: section.querySelector('[data-filter-orders="approver"]'),
    status: section.querySelector('[data-filter-orders="status"]'),
    ordered_from: section.querySelector('[data-filter-orders="ordered_from"]'),
    ordered_to: section.querySelector('[data-filter-orders="ordered_to"]')
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  const statusSelect = form?.elements?.status;
  const sampleSelect = form?.elements?.sample_id;
  const ensureStatusOption = value => {
    if (!statusSelect || !value) return;
    if (!Array.from(statusSelect.options).some(opt => opt.value === value)) {
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = value;
      statusSelect.appendChild(opt);
    }
  };
  const syncStatusFromSample = sampleId => {
    if (!statusSelect) return;
    if (!sampleId) {
      statusSelect.value = '';
      return;
    }
    const sample = sampleMap.get(Number(sampleId));
    if (sample?.status) {
      ensureStatusOption(sample.status);
      statusSelect.value = sample.status;
    }
  };
  sampleSelect?.addEventListener('change', () => {
    const sampleId = Number(sampleSelect.value);
    if (sampleId) {
      syncStatusFromSample(sampleId);
    } else if (statusSelect) {
      statusSelect.value = '';
    }
  });
  let filteredOrders = list.slice();
  let activeFilters = {};
  let selectedOrderId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      patient: filterInputs.patient?.value.trim().toLowerCase() || '',
      sample: filterInputs.sample?.value.trim().toLowerCase() || '',
      panel: filterInputs.panel?.value.trim().toLowerCase() || '',
      analysis_responsible: filterInputs.analysis_responsible?.value || '',
      interpreter: filterInputs.interpreter?.value || '',
      approver: filterInputs.approver?.value || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      ordered_from: filterInputs.ordered_from?.value || '',
      ordered_to: filterInputs.ordered_to?.value || ''
    };
    const fromDate = filters.ordered_from ? new Date(filters.ordered_from) : null;
    const toDate = filters.ordered_to ? new Date(filters.ordered_to) : null;
    if (toDate) toDate.setHours(23, 59, 59, 999);
    const filterSummary = {...filters};
    if (filters.analysis_responsible) filterSummary.analysis_responsible = getName('users', Number(filters.analysis_responsible));
    if (filters.interpreter) filterSummary.interpreter = getName('users', Number(filters.interpreter));
    if (filters.approver) filterSummary.approver = getName('users', Number(filters.approver));
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredOrders = list.filter(o => {
      if (!term) return true;
      const sample = sampleMap.get(Number(o.sample_id));
      const analysisUser = userMap.get(Number(o.analysis_responsible_id));
      const interpreterUser = userMap.get(Number(o.interpreter_id));
      const approverUser = userMap.get(Number(o.approver_id));
      const creator = determineCreatedBy('orders', o);
      return [
        o.status,
        o.id,
        o.patient_id,
        o.sample_id,
        o.panel_id,
        sample?.pmb_number,
        sample?.status,
        analysisUser?.name,
        interpreterUser?.name,
        approverUser?.name,
        creator
      ].some(v => (v ?? '').toString().toLowerCase().includes(term));
    }).filter(o => {
      const patient = patientMap.get(Number(o.patient_id));
      const sample = sampleMap.get(Number(o.sample_id));
      const panel = panelMap.get(Number(o.panel_id));
      const patientString = [patient?.name, patient?.mrn, patient?.family_number].filter(Boolean).join(' ').toLowerCase();
      const sampleString = [o.sample_id, sample?.pmb_number, sample?.sample_type, getName('patients', sample?.patient_id)].filter(Boolean).join(' ').toLowerCase();
      if (filters.id && !String(o.id).includes(filters.id)) return false;
      if (filters.patient && !patientString.includes(filters.patient)) return false;
      if (filters.sample && !sampleString.includes(filters.sample)) return false;
      if (filters.panel) {
        const panelString = (panel?.name || String(o.panel_id || '')).toLowerCase();
        if (!panelString.includes(filters.panel)) return false;
      }
      if (filters.analysis_responsible && String(o.analysis_responsible_id || '') !== filters.analysis_responsible) return false;
      if (filters.interpreter && String(o.interpreter_id || '') !== filters.interpreter) return false;
      if (filters.approver && String(o.approver_id || '') !== filters.approver) return false;
      const statusValue = (sample?.status || o.status || '').toLowerCase();
      if (filters.status && !statusValue.includes(filters.status)) return false;
      if (fromDate || toDate) {
        if (!o.ordered_at) return false;
        const ordered = new Date(o.ordered_at);
        if (Number.isNaN(ordered.getTime())) return false;
        if (fromDate && ordered < fromDate) return false;
        if (toDate && ordered > toDate) return false;
      }
      return true;
    });
    const userName = id => userMap.get(Number(id))?.name || '';
    if (selectedOrderId != null && !filteredOrders.some(o => o.id === selectedOrderId)) {
      selectedOrderId = null;
    }
    tbody.innerHTML = filteredOrders.map(o => {
      const sample = sampleMap.get(Number(o.sample_id));
      const statusDisplay = sample?.status || o.status || '';
      const createdBy = determineCreatedBy('orders', o);
      const selectedAttr = o.id === selectedOrderId ? ' data-selected="true"' : '';
      return `<tr data-id="${o.id}"${selectedAttr}><td>${o.id}</td><td>${esc(getName('patients', Number(o.patient_id)))}</td><td>${esc(getName('samples', Number(o.sample_id)))}</td><td>${esc(getName('panels', Number(o.panel_id)))}</td><td>${esc(userName(o.analysis_responsible_id))}</td><td>${esc(userName(o.interpreter_id))}</td><td>${esc(userName(o.approver_id))}</td><td>${esc(statusDisplay)}</td><td>${esc(createdBy)}</td><td>${esc(o.ordered_at||'')}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => {
    if (!input) return;
    const eventName = input.tagName === 'SELECT' ? 'change' : 'input';
    input.addEventListener(eventName, renderRows);
    if (eventName === 'change') {
      input.addEventListener('input', renderRows);
    }
  });
  section.querySelector('#ordersExport').addEventListener('click', () => {
    exportFilteredJson('glimr-ordinationer-filtreret.json', cloneWithCreatedBy('orders', filteredOrders), {
      entity: 'ordinationer',
      plural: 'ordinationer',
      tab: 'Ordinationer',
      filters: activeFilters
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const order = list.find(o => o.id === Number(tr.dataset.id));
    if (!order) return;
    selectedOrderId = order.id;
    fillForm(form, order);
    syncStatusFromSample(order.sample_id);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('orders')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.patient_id = Number(data.patient_id);
    data.sample_id = Number(data.sample_id);
    data.panel_id = data.panel_id ? Number(data.panel_id) : null;
    data.analysis_responsible_id = data.analysis_responsible_id ? Number(data.analysis_responsible_id) : null;
    data.interpreter_id = data.interpreter_id ? Number(data.interpreter_id) : null;
    data.approver_id = data.approver_id ? Number(data.approver_id) : null;
    if (data.clinician) data.clinician = data.clinician.trim();
    if (data.status) data.status = data.status.trim();
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('orders', id)};
      const updated = {...before, ...data, id};
      await updateRecord('orders', updated, before);
    } else {
      delete data.id;
      await addRecord('orders', data);
    }
    const sampleBefore = findById('samples', data.sample_id);
    if (sampleBefore && (sampleBefore.status || '') !== (data.status || '')) {
      const updatedSample = {...sampleBefore, status: data.status || ''};
      await updateRecord('samples', updatedSample, sampleBefore);
      if (state.currentTab === 'samples') {
        renderTab('samples');
      }
    }
    await loadStore('orders');
    renderTab('orders');
    renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
  });
  section.querySelector('#orderDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg ordre');
    if (!ensureWrite('orders')) return;
    if (confirm('Slet ordre?')) {
      await deleteRecord('orders', id);
      renderTab('orders');
      renderDashboard(document.querySelector('section[data-tab="dashboard"]'));
    }
  });
  form.addEventListener('reset', () => {
    selectedOrderId = null;
    renderRows();
  });
  section.querySelector('#orderClear').addEventListener('click', () => form.reset());
}
function renderVariants(section) {
  let list = getCached('variants');
  const orders = getCached('orders');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="variantSearch">Søg</label>
        <input id="variantSearch" type="search" placeholder="Gen/HGVS...">
        <details class="advanced-filter" id="variantsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-variants="id" placeholder="Variant-ID"></label>
            <label>Ordination<input type="search" data-filter-variants="order" placeholder="Ordinations-ID"></label>
            <label>Gen<input type="search" data-filter-variants="gene" placeholder="Gen"></label>
            <label>Transkript<input type="search" data-filter-variants="transcript" placeholder="RefSeq/ENST"></label>
            <label>ACMG<input type="search" data-filter-variants="classification" placeholder="1-5"></label>
            <label>Kriterier<input type="search" data-filter-variants="criteria" placeholder="PM1,PP3..."></label>
          </div>
        </details>
        <table><thead><tr><th>ID</th><th>Ordination</th><th>Gen</th><th>HGVS c.</th><th>Klasse</th><th>Kriterier</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="variantsExport">Eksportér filtrerede varianter</button>
        </div>
      </div>
      <div>
        <h2>Variant</h2>
        <form id="variantForm">
          <input type="hidden" name="id">
          <label>Ordination
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer ordinationer">
              <select name="order_id" required>
                <option value="" selected>Vælg ordination</option>
                ${orders.map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Gen<input name="gene" required></label>
          <label>Transkript<input name="transcript"></label>
          <label>HGVS c.<input name="hgvs_c"></label>
          <label>HGVS p.<input name="hgvs_p"></label>
          <label>Zygositet<input name="zygosity"></label>
          <label>ACMG-klasse<select name="classification" required><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option></select></label>
          <label>Kriterier<input name="criteria" placeholder="PM1,PP3..."></label>
          <label>Allelfrekvens<input name="af" type="number" step="0.0001"></label>
          <label>Annoteringer<textarea name="annotations" placeholder="Importerede annoteringer fra VarSeq og andre værktøjer."></textarea></label>
          <label>Tolkning<textarea name="interpretation"></textarea></label>
          <div class="btn-row">
            <button class="primary" type="submit" id="variantSave" data-action="save">Gem</button>
            <button class="secondary" type="submit" id="variantSaveNew" data-action="create" hidden>Gem som ny</button>
            <button class="secondary" type="button" id="variantClear">Ny</button>
            <button class="danger" type="button" id="variantDelete">Slet</button>
            <button class="secondary" type="button" id="variantFromLibrary">Fra bibliotek</button>
            <button class="secondary" type="button" id="variantToLibrary">Til bibliotek</button>
          </div>
        </form>
      </div>
    </div>
  </div>
  <div class="panel">
    <h2>Massetilføj varianter</h2>
    <p class="panel-hint">Tilføj flere varianter til en eksisterende ordination via import eller manuel indtastning.</p>
    <label>Ordination
      <div class="filterable-select">
        <input type="search" data-select-filter placeholder="Filtrer ordinationer">
        <select id="variantBatchOrder">
          <option value="" selected>Vælg ordination</option>
          ${orders.map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}
        </select>
      </div>
    </label>
    <div id="variantBatchList" class="repeater"></div>
    <div class="btn-row">
      <button type="button" class="secondary" id="variantBatchAdd">Tilføj variant</button>
      <button type="button" class="secondary" id="variantBatchImport">Importér VarSeq CSV</button>
      <input type="file" id="variantBatchFile" accept=".csv,text/csv" hidden>
      <button type="button" class="primary" id="variantBatchSave">Gem varianter</button>
      <button type="button" class="secondary" id="variantBatchClear">Ryd rækker</button>
    </div>
    <div class="form-hint" id="variantBatchMessage" role="status" aria-live="polite"></div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#variantSearch');
  const form = section.querySelector('#variantForm');
  const saveButton = form.querySelector('#variantSave');
  const saveNewButton = form.querySelector('#variantSaveNew');
  const defaultSaveLabel = saveButton?.textContent || 'Gem';
  const batchList = section.querySelector('#variantBatchList');
  const batchAddBtn = section.querySelector('#variantBatchAdd');
  const batchImportBtn = section.querySelector('#variantBatchImport');
  const batchFileInput = section.querySelector('#variantBatchFile');
  const batchSaveBtn = section.querySelector('#variantBatchSave');
  const batchClearBtn = section.querySelector('#variantBatchClear');
  const batchMessage = section.querySelector('#variantBatchMessage');
  const batchOrderSelect = section.querySelector('#variantBatchOrder');
  const setBatchMessage = (text, tone = 'info') => {
    if (!batchMessage) return;
    batchMessage.textContent = text ?? '';
    const color = tone === 'success' ? 'var(--accent-strong)' : tone === 'error' ? 'var(--danger)' : 'var(--muted-text)';
    batchMessage.style.color = color;
  };
  const addBatchVariantRow = (values = {}) => {
    if (!batchList) return;
    const defaultClass = values.classification != null ? String(values.classification) : '3';
    const classificationOptions = ['1','2','3','4','5'].map(v => `<option value="${v}"${defaultClass === String(v) ? ' selected' : ''}>${v}</option>`).join('');
    const row = document.createElement('div');
    row.className = 'case-row variant-row';
    row.innerHTML = `
      <label class="inline">Gen<input type="text" data-field="gene" placeholder="BRCA1"></label>
      <label class="inline">Transkript<input type="text" data-field="transcript" placeholder="NM_007294.3"></label>
      <label class="inline">HGVS c.<input type="text" data-field="hgvs_c" placeholder="c.5266dupC"></label>
      <label class="inline">HGVS p.<input type="text" data-field="hgvs_p" placeholder="p.(Gln1756Profs*74)"></label>
      <label class="inline">Zygositet<input type="text" data-field="zygosity" placeholder="Heterozygot"></label>
      <label class="inline">ACMG<select data-field="classification">${classificationOptions}</select></label>
      <label class="inline">Kriterier<input type="text" data-field="criteria" placeholder="PM1,PP3"></label>
      <label class="inline">Allelfrekvens<input type="number" step="0.0001" data-field="af" placeholder="0.125"></label>
      <label class="inline wide">Annoteringer<textarea class="small" data-field="annotations" placeholder="VarSeq-annoteringer og noter"></textarea></label>
      <label class="inline wide">Tolkning<textarea class="small" data-field="interpretation" placeholder="Valgfrit"></textarea></label>
      <button type="button" class="secondary case-choose-library">Vælg fra bibliotek</button>
      <button type="button" class="secondary case-remove-row">Fjern</button>`;
    const setValue = (selector, value) => {
      const el = row.querySelector(selector);
      if (el) el.value = value || '';
    };
    setValue('[data-field="gene"]', values.gene);
    setValue('[data-field="transcript"]', values.transcript);
    setValue('[data-field="hgvs_c"]', values.hgvs_c);
    setValue('[data-field="hgvs_p"]', values.hgvs_p);
    setValue('[data-field="zygosity"]', values.zygosity);
    setValue('[data-field="criteria"]', values.criteria);
    const afField = row.querySelector('[data-field="af"]');
    if (afField) {
      if (values.af !== undefined && values.af !== null && values.af !== '') {
        afField.value = values.af;
      } else {
        afField.value = '';
      }
    }
    const interpretationField = row.querySelector('[data-field="interpretation"]');
    if (interpretationField) interpretationField.value = values.interpretation || '';
    const annotationsField = row.querySelector('[data-field="annotations"]');
    if (annotationsField) annotationsField.value = values.annotations || '';
    const removeBtn = row.querySelector('.case-remove-row');
    removeBtn?.addEventListener('click', () => row.remove());
    if (removeBtn) setTooltip(removeBtn, 'Fjern varianten fra batch-listen.');
    const libraryBtn = row.querySelector('.case-choose-library');
    libraryBtn?.addEventListener('click', () => {
      openVariantLibraryPicker(variant => {
        setValue('[data-field="gene"]', variant.gene);
        setValue('[data-field="transcript"]', variant.transcript);
        setValue('[data-field="hgvs_c"]', variant.hgvs_c);
        setValue('[data-field="hgvs_p"]', variant.hgvs_p);
        setValue('[data-field="criteria"]', variant.criteria);
        const classField = row.querySelector('[data-field="classification"]');
        if (classField && variant.classification != null && variant.classification !== '') {
          classField.value = String(variant.classification);
        }
        const interpretationField = row.querySelector('[data-field="interpretation"]');
        if (interpretationField) interpretationField.value = variant.evidence || variant.interpretation || '';
        const annotationsField = row.querySelector('[data-field="annotations"]');
        if (annotationsField) annotationsField.value = variant.annotations || variant.annotation_summary || '';
      });
    });
    if (libraryBtn) setTooltip(libraryBtn, 'Vælg en variant fra biblioteket.');
    batchList.appendChild(row);
    applyButtonTooltips(row);
  };
  const getBatchValue = (row, field) => {
    const el = row?.querySelector(`[data-field="${field}"]`);
    if (!el) return '';
    return (el.value || '').trim();
  };
  const isBatchVariantRowEmpty = row => {
    if (!row) return true;
    const gene = getBatchValue(row, 'gene');
    const transcript = getBatchValue(row, 'transcript');
    const hgvsC = getBatchValue(row, 'hgvs_c');
    const hgvsP = getBatchValue(row, 'hgvs_p');
    const zygosity = getBatchValue(row, 'zygosity');
    const criteria = getBatchValue(row, 'criteria');
    const af = getBatchValue(row, 'af');
    const interpretation = getBatchValue(row, 'interpretation');
    const annotations = getBatchValue(row, 'annotations');
    return !gene && !transcript && !hgvsC && !hgvsP && !zygosity && !criteria && !af && !interpretation && !annotations;
  };
  const collectBatchVariants = () => {
    if (!batchList) return [];
    const rows = Array.from(batchList.querySelectorAll('.variant-row'));
    const variants = [];
    rows.forEach((row, idx) => {
      const gene = getBatchValue(row, 'gene');
      const transcript = getBatchValue(row, 'transcript');
      const hgvsC = getBatchValue(row, 'hgvs_c');
      const hgvsP = getBatchValue(row, 'hgvs_p');
      const zygosity = getBatchValue(row, 'zygosity');
      const criteria = getBatchValue(row, 'criteria');
      const afRaw = getBatchValue(row, 'af');
      const interpretation = getBatchValue(row, 'interpretation');
      const annotations = getBatchValue(row, 'annotations');
      const classification = row.querySelector('[data-field="classification"]')?.value || '3';
      const isEmpty = !gene && !transcript && !hgvsC && !hgvsP && !zygosity && !criteria && !afRaw && !interpretation && !annotations;
      if (isEmpty) return;
      if (!gene) {
        const err = new Error(`Angiv gen for række ${idx + 1}.`);
        err.focus = row.querySelector('[data-field="gene"]');
        throw err;
      }
      const variant = {
        gene,
        transcript,
        hgvs_c: hgvsC,
        hgvs_p: hgvsP,
        zygosity,
        classification: String(classification || '3'),
        criteria,
        interpretation
      };
      if (afRaw) {
        const afNumber = Number(afRaw);
        if (!Number.isFinite(afNumber)) {
          const err = new Error(`Allelfrekvens skal være et tal i række ${idx + 1}.`);
          err.focus = row.querySelector('[data-field="af"]');
          throw err;
        }
        variant.af = afNumber;
      }
      if (annotations) {
        variant.annotations = annotations;
      }
      variants.push(variant);
    });
    return variants;
  };
  const removeEmptyBatchRows = () => {
    if (!batchList) return;
    const rows = Array.from(batchList.querySelectorAll('.variant-row'));
    if (!rows.length) return;
    const filled = rows.filter(row => !isBatchVariantRowEmpty(row));
    if (!filled.length) {
      batchList.innerHTML = '';
      return;
    }
    rows.forEach(row => {
      if (isBatchVariantRowEmpty(row)) row.remove();
    });
  };
  const enterEditMode = id => {
    if (!form) return;
    form.dataset.mode = 'edit';
    form.dataset.editingId = id != null ? String(id) : '';
    if (saveButton) saveButton.textContent = 'Opdater variant';
    if (saveNewButton) saveNewButton.hidden = false;
  };
  const exitEditMode = () => {
    if (!form) return;
    form.dataset.mode = 'create';
    form.dataset.editingId = '';
    if (form.elements.id) form.elements.id.value = '';
    if (saveButton) saveButton.textContent = defaultSaveLabel;
    if (saveNewButton) saveNewButton.hidden = true;
  };
  exitEditMode();
  const filterInputs = {
    id: section.querySelector('[data-filter-variants="id"]'),
    order: section.querySelector('[data-filter-variants="order"]'),
    gene: section.querySelector('[data-filter-variants="gene"]'),
    transcript: section.querySelector('[data-filter-variants="transcript"]'),
    classification: section.querySelector('[data-filter-variants="classification"]'),
    criteria: section.querySelector('[data-filter-variants="criteria"]')
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  let filteredVariants = list.slice();
  let activeFilters = {};
  let selectedVariantId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      order: filterInputs.order?.value.trim().toLowerCase() || '',
      gene: filterInputs.gene?.value.trim().toLowerCase() || '',
      transcript: filterInputs.transcript?.value.trim().toLowerCase() || '',
      classification: filterInputs.classification?.value.trim().toLowerCase() || '',
      criteria: filterInputs.criteria?.value.trim().toLowerCase() || ''
    };
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredVariants = list.filter(v => {
      if (!term) return true;
      const creator = determineCreatedBy('variants', v);
      return [v.gene, v.hgvs_c, v.hgvs_p, creator].some(val => (val || '').toLowerCase().includes(term));
    }).filter(v => {
      if (filters.id && !String(v.id).includes(filters.id)) return false;
      if (filters.order && !(String(v.order_id || '')).toLowerCase().includes(filters.order)) return false;
      if (filters.gene && !(v.gene || '').toLowerCase().includes(filters.gene)) return false;
      if (filters.transcript && !(v.transcript || '').toLowerCase().includes(filters.transcript)) return false;
      if (filters.classification && !(String(v.classification || '')).toLowerCase().includes(filters.classification)) return false;
      if (filters.criteria && !(v.criteria || '').toLowerCase().includes(filters.criteria)) return false;
      return true;
    });
    if (selectedVariantId != null && !filteredVariants.some(v => v.id === selectedVariantId)) {
      selectedVariantId = null;
    }
    tbody.innerHTML = filteredVariants.map(v => {
      const createdBy = determineCreatedBy('variants', v);
      const selectedAttr = v.id === selectedVariantId ? ' data-selected="true"' : '';
      return `<tr data-id="${v.id}"${selectedAttr}><td>${v.id}</td><td>${v.order_id}</td><td>${esc(v.gene)}</td><td>${esc(v.hgvs_c||'')}</td><td>${esc(v.classification||'')}</td><td>${esc(v.criteria||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  section.querySelector('#variantsExport').addEventListener('click', () => {
    exportFilteredJson('glimr-varianter-filtreret.json', cloneWithCreatedBy('variants', filteredVariants), {
      entity: 'varianter',
      plural: 'varianter',
      tab: 'Varianter',
      filters: activeFilters
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const variant = list.find(v => v.id === Number(tr.dataset.id));
    if (!variant) return;
    selectedVariantId = variant.id;
    fillForm(form, variant);
    enterEditMode(variant.id);
    if (batchOrderSelect && variant.order_id) {
      batchOrderSelect.value = String(variant.order_id);
    }
    renderRows();
  });
  batchAddBtn?.addEventListener('click', () => addBatchVariantRow());
  batchClearBtn?.addEventListener('click', () => {
    if (batchList) {
      batchList.innerHTML = '';
      addBatchVariantRow();
    }
    setBatchMessage('Batch-liste ryddet.', 'info');
  });
  batchImportBtn?.addEventListener('click', () => batchFileInput?.click());
  batchFileInput?.addEventListener('change', async () => {
    const file = batchFileInput?.files?.[0];
    if (!file) return;
    try {
      const {variants: importedVariants, warnings, summary} = await parseVarSeqFile(file);
      if (!importedVariants.length) {
        setBatchMessage('Ingen varianter blev fundet i filen.', 'error');
        return;
      }
      removeEmptyBatchRows();
      importedVariants.forEach(variant => addBatchVariantRow(variant));
      const parts = [`Tilføjede ${importedVariants.length} varianter fra ${file.name}.`];
      if (summary.skipped) parts.push(`${summary.skipped} rækker ignoreret.`);
      if (warnings.length) parts.push(`${warnings.length} advarsler logget i konsollen.`);
      setBatchMessage(parts.join(' '), 'success');
      setStatus(`VarSeq import til masseoprettelse: ${importedVariants.length} varianter klar.`);
      if (warnings.length) console.warn('VarSeq import advarsler', warnings);
    } catch (err) {
      console.error(err);
      setBatchMessage('Kunne ikke importere VarSeq CSV: ' + (err?.message || err), 'error');
    } finally {
      if (batchFileInput) batchFileInput.value = '';
    }
  });
  batchSaveBtn?.addEventListener('click', async () => {
    if (!ensureWrite('variants')) {
      setBatchMessage('Handling kræver skriveadgang. Log ind med en bruger der kan redigere varianter.', 'error');
      return;
    }
    const orderId = Number(batchOrderSelect?.value || 0);
    if (!orderId) {
      setBatchMessage('Vælg en ordination for at gemme varianterne.', 'error');
      batchOrderSelect?.focus();
      return;
    }
    let variants;
    try {
      variants = collectBatchVariants();
    } catch (err) {
      setBatchMessage(err.message || 'Kunne ikke fortolke batch-rækkerne.', 'error');
      if (err.focus) err.focus.focus();
      return;
    }
    if (!variants.length) {
      setBatchMessage('Udfyld mindst én variant før du gemmer.', 'error');
      return;
    }
    batchSaveBtn.disabled = true;
    if (batchAddBtn) batchAddBtn.disabled = true;
    if (batchImportBtn) batchImportBtn.disabled = true;
    if (batchClearBtn) batchClearBtn.disabled = true;
    try {
      setBatchMessage('Gemmer varianter...', 'info');
      const createdIds = [];
      for (const variant of variants) {
        const id = await addRecord('variants', {...variant, order_id: orderId});
        createdIds.push(id);
      }
      list = getCached('variants');
      filteredVariants = list.slice();
      renderRows();
      if (batchList) {
        batchList.innerHTML = '';
        addBatchVariantRow();
      }
      setBatchMessage(`Tilføjede ${createdIds.length} varianter til ordination ${orderId}.`, 'success');
      setStatus(`Tilføjede ${createdIds.length} varianter til ordination ${orderId}.`);
    } catch (err) {
      console.error(err);
      setBatchMessage('Kunne ikke gemme varianter: ' + (err?.message || err), 'error');
    } finally {
      batchSaveBtn.disabled = false;
      if (batchAddBtn) batchAddBtn.disabled = false;
      if (batchImportBtn) batchImportBtn.disabled = false;
      if (batchClearBtn) batchClearBtn.disabled = false;
    }
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('variants')) return;
    const action = e.submitter?.dataset.action || 'save';
    const data = Object.fromEntries(new FormData(form).entries());
    data.order_id = Number(data.order_id);
    data.classification = String(data.classification);
    if (data.af) data.af = Number(data.af);
    const editingId = Number(form.dataset.editingId || data.id || 0);
    const creatingNew = action === 'create' || !editingId;
    if (!creatingNew) {
      const id = editingId;
      const before = {...findById('variants', id)};
      const updated = {...before, ...data, id};
      await updateRecord('variants', updated, before);
    } else {
      delete data.id;
      await addRecord('variants', data);
    }
    await loadStore('variants');
    renderTab('variants');
  });
  section.querySelector('#variantDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg variant');
    if (!ensureWrite('variants')) return;
    if (confirm('Slet variant?')) {
      await deleteRecord('variants', id);
      renderTab('variants');
    }
  });
  section.querySelector('#variantFromLibrary').addEventListener('click', () => {
    openVariantLibraryPicker(variant => {
      if (!form) return;
      if (form.elements.gene) form.elements.gene.value = variant.gene || '';
      if (form.elements.transcript) form.elements.transcript.value = variant.transcript || '';
      if (form.elements.hgvs_c) form.elements.hgvs_c.value = variant.hgvs_c || '';
      if (form.elements.hgvs_p) form.elements.hgvs_p.value = variant.hgvs_p || '';
      if (form.elements.criteria) form.elements.criteria.value = variant.criteria || '';
      if (form.elements.annotations) form.elements.annotations.value = variant.annotations || variant.annotation_summary || '';
      if (form.elements.interpretation) form.elements.interpretation.value = variant.evidence || variant.interpretation || '';
      if (form.elements.classification && variant.classification != null && variant.classification !== '') {
        form.elements.classification.value = String(variant.classification);
      }
    });
  });
  if (batchList && !batchList.children.length) {
    addBatchVariantRow();
    setBatchMessage('Importer eller udfyld varianter for at gemme dem på den valgte ordination.', 'info');
  }
  form.addEventListener('reset', () => {
    selectedVariantId = null;
    exitEditMode();
    renderRows();
  });
  section.querySelector('#variantClear').addEventListener('click', () => {
    const orderValue = form.elements.order_id.value;
    const classificationValue = form.elements.classification.value;
    form.reset();
    if (orderValue) form.elements.order_id.value = orderValue;
    if (classificationValue) form.elements.classification.value = classificationValue;
    exitEditMode();
  });
  section.querySelector('#variantToLibrary').addEventListener('click', async () => {
    if (!ensureWrite('variant_library')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    if (!data.gene) return alert('Vælg variant først');
    const evidenceParts = [];
    if (data.interpretation) evidenceParts.push(data.interpretation);
    if (data.annotations) evidenceParts.push(data.annotations);
    const libraryEntry = {
      gene: data.gene,
      transcript: data.transcript,
      hgvs_c: data.hgvs_c,
      hgvs_p: data.hgvs_p,
      classification: String(data.classification || ''),
      criteria: data.criteria,
      evidence: evidenceParts.join('\n').trim(),
      condition: '',
      inheritance: '',
      curated_by: currentUserName(),
      last_review: new Date().toISOString().split('T')[0]
    };
    await addRecord('variant_library', libraryEntry);
    await loadStore('variant_library');
    renderTab('variant_library');
    alert('Variant tilføjet til biblioteket');
  });
}
function renderVariantLibrary(section) {
  const list = getCached('variant_library').slice().sort((a, b) => {
    const geneCompare = (a.gene || '').localeCompare(b.gene || '', 'da');
    if (geneCompare) return geneCompare;
    const hgvsCompare = (a.hgvs_c || '').localeCompare(b.hgvs_c || '', 'da');
    if (hgvsCompare) return hgvsCompare;
    return (a.id || 0) - (b.id || 0);
  });
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="libSearch">Søg</label>
        <input id="libSearch" type="search" placeholder="Gen/HGVS...">
        <details class="advanced-filter" id="variantLibraryFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>Gen<input type="search" data-filter-library="gene" placeholder="Gen"></label>
            <label>Transkript<input type="search" data-filter-library="transcript" placeholder="RefSeq/ENST"></label>
            <label>HGVS c.<input type="search" data-filter-library="hgvs_c" placeholder="c."></label>
            <label>HGVS p.<input type="search" data-filter-library="hgvs_p" placeholder="p."></label>
            <label>Klasse<input type="search" data-filter-library="classification" placeholder="1-5/VUS"></label>
            <label>Kriterier<input type="search" data-filter-library="criteria" placeholder="PM1,PP3..."></label>
            <label>Tilstand<input type="search" data-filter-library="condition" placeholder="Tilstand"></label>
            <label>Nedarvning<input type="search" data-filter-library="inheritance" placeholder="Arvegang"></label>
            <label>Kurateret af<input type="search" data-filter-library="curated_by" placeholder="Kurator"></label>
            <label>Sidst gennemgået fra<input type="date" data-filter-library="last_review_from"></label>
            <label>Sidst gennemgået til<input type="date" data-filter-library="last_review_to"></label>
          </div>
        </details>
        <table>
          <thead>
            <tr><th>ID</th><th>Gen</th><th>Transkript</th><th>HGVS c.</th><th>HGVS p.</th><th>Klasse</th><th>Kriterier</th><th>Tilstand</th><th>Nedarvning</th><th>Kurateret af</th><th>Sidst gennemgået</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="table-actions">
          <button type="button" class="secondary" id="libraryExportCsv">Eksportér CSV</button>
          <button type="button" class="secondary" id="libraryImportCsv">Importér CSV</button>
          <input type="file" id="variantLibraryImportInput" accept=".csv,text/csv" hidden>
        </div>
      </div>
      <div>
        <h2>Bibliotekspost</h2>
        <form id="variantLibraryForm">
          <input type="hidden" name="id">
          <label>Gen<input name="gene" required></label>
          <label>Transkript<input name="transcript"></label>
          <label>HGVS c.<input name="hgvs_c"></label>
          <label>HGVS p.<input name="hgvs_p"></label>
          <label>Klasse<input name="classification" placeholder="1-5/VUS"></label>
          <label>Kriterier<input name="criteria"></label>
          <label>Tilstand<input name="condition"></label>
          <label>Nedarvning<input name="inheritance"></label>
          <label>Evidens<textarea name="evidence" rows="4"></textarea></label>
          <label>Kurateret af<input name="curated_by"></label>
          <label>Sidst gennemgået<input type="date" name="last_review"></label>
          <div class="btn-row">
            <button class="primary" type="submit" data-action="save" id="variantLibrarySave">Gem</button>
            <button class="secondary" type="submit" data-action="create" id="variantLibrarySaveNew" hidden>Gem som ny</button>
            <button class="secondary" type="button" id="variantLibraryClear">Ny</button>
            <button class="danger" type="button" id="variantLibraryDelete">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#libSearch');
  const form = section.querySelector('#variantLibraryForm');
  const saveButton = section.querySelector('#variantLibrarySave');
  const saveNewButton = section.querySelector('#variantLibrarySaveNew');
  const clearButton = section.querySelector('#variantLibraryClear');
  const deleteButton = section.querySelector('#variantLibraryDelete');
  const exportButton = section.querySelector('#libraryExportCsv');
  const importButton = section.querySelector('#libraryImportCsv');
  const importInput = section.querySelector('#variantLibraryImportInput');
  const defaultSaveLabel = saveButton?.textContent || 'Gem';
  const csvColumns = [
    {key: 'id', label: 'ID'},
    {key: 'gene', label: 'Gen'},
    {key: 'transcript', label: 'Transkript'},
    {key: 'hgvs_c', label: 'HGVS c.'},
    {key: 'hgvs_p', label: 'HGVS p.'},
    {key: 'classification', label: 'Klasse'},
    {key: 'criteria', label: 'Kriterier'},
    {key: 'condition', label: 'Tilstand'},
    {key: 'inheritance', label: 'Nedarvning'},
    {key: 'evidence', label: 'Evidens'},
    {key: 'curated_by', label: 'Kurateret af'},
    {key: 'last_review', label: 'Sidst gennemgået'},
    {key: 'created_at', label: 'Oprettet'},
    {key: 'updated_at', label: 'Opdateret'}
  ];
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  let filteredLibrary = list.slice();
  let selectedId = null;
  const filterInputs = {
    gene: section.querySelector('[data-filter-library="gene"]'),
    transcript: section.querySelector('[data-filter-library="transcript"]'),
    hgvs_c: section.querySelector('[data-filter-library="hgvs_c"]'),
    hgvs_p: section.querySelector('[data-filter-library="hgvs_p"]'),
    classification: section.querySelector('[data-filter-library="classification"]'),
    criteria: section.querySelector('[data-filter-library="criteria"]'),
    condition: section.querySelector('[data-filter-library="condition"]'),
    inheritance: section.querySelector('[data-filter-library="inheritance"]'),
    curated_by: section.querySelector('[data-filter-library="curated_by"]'),
    last_review_from: section.querySelector('[data-filter-library="last_review_from"]'),
    last_review_to: section.querySelector('[data-filter-library="last_review_to"]')
  };
  const enterEditMode = id => {
    if (!form) return;
    form.dataset.mode = 'edit';
    form.dataset.editingId = id != null ? String(id) : '';
    if (saveButton) saveButton.textContent = 'Opdater bibliotekspost';
    if (saveNewButton) saveNewButton.hidden = false;
  };
  const exitEditMode = () => {
    if (!form) return;
    form.dataset.mode = 'create';
    form.dataset.editingId = '';
    if (form.elements.id) form.elements.id.value = '';
    if (saveButton) saveButton.textContent = defaultSaveLabel;
    if (saveNewButton) saveNewButton.hidden = true;
  };
  exitEditMode();
  const renderRows = () => {
    const term = (search?.value || '').trim().toLowerCase();
    const filters = {
      gene: filterInputs.gene?.value.trim().toLowerCase() || '',
      transcript: filterInputs.transcript?.value.trim().toLowerCase() || '',
      hgvs_c: filterInputs.hgvs_c?.value.trim().toLowerCase() || '',
      hgvs_p: filterInputs.hgvs_p?.value.trim().toLowerCase() || '',
      classification: filterInputs.classification?.value.trim().toLowerCase() || '',
      criteria: filterInputs.criteria?.value.trim().toLowerCase() || '',
      condition: filterInputs.condition?.value.trim().toLowerCase() || '',
      inheritance: filterInputs.inheritance?.value.trim().toLowerCase() || '',
      curated_by: filterInputs.curated_by?.value.trim().toLowerCase() || '',
      last_review_from: filterInputs.last_review_from?.value || '',
      last_review_to: filterInputs.last_review_to?.value || ''
    };
    const fromDate = filters.last_review_from ? new Date(filters.last_review_from) : null;
    const toDate = filters.last_review_to ? new Date(filters.last_review_to) : null;
    const validFrom = fromDate && !Number.isNaN(fromDate.getTime()) ? fromDate : null;
    const validTo = toDate && !Number.isNaN(toDate.getTime()) ? toDate : null;
    filteredLibrary = list.filter(v => {
      if (!term) return true;
      return [v.gene, v.transcript, v.hgvs_c, v.hgvs_p, v.classification, v.criteria, v.condition, v.inheritance, v.evidence, v.curated_by]
        .some(val => (val || '').toLowerCase().includes(term));
    }).filter(v => {
      if (filters.gene && !(v.gene || '').toLowerCase().includes(filters.gene)) return false;
      if (filters.transcript && !(v.transcript || '').toLowerCase().includes(filters.transcript)) return false;
      if (filters.hgvs_c && !(v.hgvs_c || '').toLowerCase().includes(filters.hgvs_c)) return false;
      if (filters.hgvs_p && !(v.hgvs_p || '').toLowerCase().includes(filters.hgvs_p)) return false;
      if (filters.classification && !(String(v.classification || '')).toLowerCase().includes(filters.classification)) return false;
      if (filters.criteria && !(v.criteria || '').toLowerCase().includes(filters.criteria)) return false;
      if (filters.condition && !(v.condition || '').toLowerCase().includes(filters.condition)) return false;
      if (filters.inheritance && !(v.inheritance || '').toLowerCase().includes(filters.inheritance)) return false;
      if (filters.curated_by && !(v.curated_by || '').toLowerCase().includes(filters.curated_by)) return false;
      if ((validFrom || validTo) && v.last_review) {
        const reviewDate = new Date(v.last_review);
        if (!Number.isNaN(reviewDate.getTime())) {
          if (validFrom && reviewDate < validFrom) return false;
          if (validTo && reviewDate > validTo) return false;
        } else if (validFrom || validTo) {
          return false;
        }
      } else if ((validFrom || validTo) && !v.last_review) {
        return false;
      }
      return true;
    });
    if (selectedId && !filteredLibrary.some(v => v.id === selectedId)) {
      selectedId = null;
    }
    if (!filteredLibrary.length) {
      tbody.innerHTML = `<tr><td colspan="11">Ingen poster matcher filtreringen.</td></tr>`;
      annotateTableCells(section);
      return;
    }
    tbody.innerHTML = filteredLibrary.map(v => {
      const selectedAttr = v.id === selectedId ? ' data-selected="true"' : '';
      return `<tr data-id="${v.id}"${selectedAttr}><td>${v.id}</td><td>${esc(v.gene)}</td><td>${esc(v.transcript || '')}</td><td>${esc(v.hgvs_c || '')}</td><td>${esc(v.hgvs_p || '')}</td><td>${esc(v.classification || '')}</td><td>${esc(v.criteria || '')}</td><td>${esc(v.condition || '')}</td><td>${esc(v.inheritance || '')}</td><td>${esc(v.curated_by || '')}</td><td>${esc(v.last_review || '')}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search?.addEventListener('input', renderRows);
  Object.entries(filterInputs).forEach(([, input]) => {
    if (!input) return;
    const eventName = input.type === 'date' ? 'change' : 'input';
    input.addEventListener(eventName, renderRows);
    if (eventName === 'change') {
      input.addEventListener('input', renderRows);
    }
  });
  tbody?.addEventListener('click', e => {
    const tr = e.target.closest('tr[data-id]');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const entry = list.find(v => v.id === id);
    if (!entry) return;
    selectedId = id;
    fillForm(form, entry);
    enterEditMode(id);
    renderRows();
  });
  const clearForm = () => {
    if (!form) return;
    form.reset();
    exitEditMode();
    selectedId = null;
    renderRows();
  };
  clearButton?.addEventListener('click', clearForm);
  form?.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('variant_library')) return;
    const submitterAction = e.submitter?.dataset.action || 'save';
    const data = Object.fromEntries(new FormData(form).entries());
    Object.keys(data).forEach(key => {
      if (typeof data[key] === 'string') {
        data[key] = data[key].trim();
      }
    });
    const editingId = Number(form.dataset.editingId || data.id || 0);
    const creatingNew = submitterAction === 'create' || !editingId;
    const payload = {
      gene: data.gene || '',
      transcript: data.transcript || '',
      hgvs_c: data.hgvs_c || '',
      hgvs_p: data.hgvs_p || '',
      classification: data.classification || '',
      criteria: data.criteria || '',
      condition: data.condition || '',
      inheritance: data.inheritance || '',
      evidence: data.evidence || '',
      curated_by: data.curated_by || '',
      last_review: data.last_review || ''
    };
    if (payload.last_review && !/^\d{4}-\d{2}-\d{2}$/.test(payload.last_review)) {
      const date = new Date(payload.last_review);
      if (!Number.isNaN(date.getTime())) {
        payload.last_review = date.toISOString().split('T')[0];
      }
    }
    if (!creatingNew) {
      const id = editingId;
      const beforeRecord = findById('variant_library', id);
      if (!beforeRecord) {
        alert('Kunne ikke finde biblioteksposten.');
        return;
      }
      const before = {...beforeRecord};
      const updated = {...before, ...payload, id};
      await updateRecord('variant_library', updated, before);
      setStatus(`Bibliotekspost ${id} opdateret.`);
    } else {
      if (!payload.curated_by) payload.curated_by = currentUserName() || '';
      if (!payload.last_review) payload.last_review = new Date().toISOString().split('T')[0];
      const record = {...payload};
      await addRecord('variant_library', record);
      setStatus('Bibliotekspost oprettet.');
    }
    renderTab('variant_library');
  });
  deleteButton?.addEventListener('click', async () => {
    const id = Number(form?.elements?.id?.value || 0);
    if (!id) {
      alert('Vælg en bibliotekspost der skal slettes.');
      return;
    }
    if (!ensureWrite('variant_library')) return;
    if (!confirm('Slet bibliotekspost?')) return;
    await deleteRecord('variant_library', id);
    setStatus(`Bibliotekspost ${id} slettet.`);
    renderTab('variant_library');
  });
  exportButton?.addEventListener('click', () => {
    const filename = downloadCsvFile(filteredLibrary, csvColumns, 'glimr-variantbibliotek.csv');
    setStatus(`Eksporterede ${filteredLibrary.length} biblioteksposter til ${filename}.`);
  });
  importButton?.addEventListener('click', () => importInput?.click());
  importInput?.addEventListener('change', async () => {
    const file = importInput.files?.[0];
    if (!file) return;
    if (!ensureWrite('variant_library')) {
      importInput.value = '';
      return;
    }
    try {
      const text = await file.text();
      const {headers, rows} = parseCsv(text);
      if (!headers.length) throw new Error('CSV-filen mangler kolonneoverskrifter.');
      const headerMap = {
        id: 'id',
        gene: 'gene',
        gen: 'gene',
        transcript: 'transcript',
        transkript: 'transcript',
        hgvs_c: 'hgvs_c',
        hgvs_c_: 'hgvs_c',
        hgvs: 'hgvs_c',
        hgvs_p: 'hgvs_p',
        klassifikation: 'classification',
        classification: 'classification',
        class: 'classification',
        klasse: 'classification',
        criteria: 'criteria',
        kriterier: 'criteria',
        acmg: 'criteria',
        evidence: 'evidence',
        evidens: 'evidence',
        notes: 'evidence',
        condition: 'condition',
        tilstand: 'condition',
        phenotype: 'condition',
        inheritance: 'inheritance',
        nedarvning: 'inheritance',
        curated_by: 'curated_by',
        kurator: 'curated_by',
        kurateret_af: 'curated_by',
        last_review: 'last_review',
        sidst_gennemgaaet: 'last_review',
        lastreview: 'last_review'
      };
      const columnKeys = headers.map(header => headerMap[normaliseHeader(header)] || null);
      if (!columnKeys.some(key => key === 'gene' || key === 'hgvs_c' || key === 'hgvs_p')) {
        throw new Error('CSV-filen skal mindst indeholde kolonnen "Gene/Gen" eller HGVS.');
      }
      const summary = {created: 0, updated: 0, skipped: 0};
      const existingCache = new Map(getCached('variant_library').map(entry => [entry.id, {...entry}]));
      for (const rowValues of rows) {
        if (!rowValues || rowValues.every(cell => !cell || !cell.trim())) {
          summary.skipped++;
          continue;
        }
        const entry = {};
        columnKeys.forEach((key, idx) => {
          if (!key) return;
          entry[key] = (rowValues[idx] || '').trim();
        });
        let id = null;
        if (entry.id) {
          const parsedId = Number(entry.id);
          if (Number.isFinite(parsedId) && parsedId > 0) {
            id = parsedId;
            entry.id = parsedId;
          } else {
            delete entry.id;
          }
        }
        const ensureIsoDate = value => {
          if (!value) return '';
          if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
          const parsed = new Date(value);
          if (!Number.isNaN(parsed.getTime())) {
            return parsed.toISOString().split('T')[0];
          }
          return value;
        };
        entry.last_review = ensureIsoDate(entry.last_review || '');
        if (!entry.gene && !entry.hgvs_c && !entry.hgvs_p) {
          summary.skipped++;
          continue;
        }
        if (id && existingCache.has(id)) {
          const before = existingCache.get(id);
          const updated = {...before, ...entry, id};
          await updateRecord('variant_library', updated, before);
          existingCache.set(id, updated);
          summary.updated++;
        } else {
          const record = {...entry};
          delete record.id;
          if (!record.curated_by) record.curated_by = currentUserName() || '';
          if (!record.last_review) record.last_review = new Date().toISOString().split('T')[0];
          await addRecord('variant_library', record);
          summary.created++;
        }
      }
      const summaryParts = [];
      if (summary.updated) summaryParts.push(`${summary.updated} opdateret`);
      if (summary.created) summaryParts.push(`${summary.created} tilføjet`);
      if (summary.skipped) summaryParts.push(`${summary.skipped} uændret`);
      const message = summaryParts.length ? summaryParts.join(', ') : 'Ingen poster ændret';
      setStatus(`Import fuldført: ${message}.`);
      alert(`Import fuldført: ${message}.`);
      renderTab('variant_library');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke importere CSV: ' + err.message);
      setStatus('Fejl under import: ' + err.message);
    } finally {
      importInput.value = '';
    }
  });
}
function snapshotVariant(variant) {
  if (!variant) {
    return {id: null, order_id: null, gene: '', transcript: '', hgvs_c: '', hgvs_p: '', zygosity: '', classification: '', criteria: '', af: '', annotations: '', interpretation: ''};
  }
  return {
    id: variant.id ?? null,
    order_id: variant.order_id ?? null,
    gene: variant.gene || '',
    transcript: variant.transcript || '',
    hgvs_c: variant.hgvs_c || '',
    hgvs_p: variant.hgvs_p || '',
    zygosity: variant.zygosity || '',
    classification: variant.classification || '',
    criteria: variant.criteria || '',
    af: variant.af ?? '',
    annotations: variant.annotations || variant.annotation_summary || '',
    interpretation: variant.interpretation || ''
  };
}
function parseReportVariantIds(value) {
  if (Array.isArray(value)) {
    return value.map(Number).filter(id => Number.isFinite(id));
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return [];
    try {
      const parsed = JSON.parse(trimmed);
      return parseReportVariantIds(parsed);
    } catch (err) {
      return trimmed.split(/[^0-9]+/).map(Number).filter(id => Number.isFinite(id));
    }
  }
  return [];
}
function getReportVariantSnapshots(report, orderId) {
  if (!report) return [];
  const detailsRaw = report.variant_details;
  if (Array.isArray(detailsRaw) && detailsRaw.length) {
    return detailsRaw.map(snapshotVariant);
  }
  if (typeof detailsRaw === 'string' && detailsRaw.trim()) {
    try {
      const parsed = JSON.parse(detailsRaw);
      if (Array.isArray(parsed) && parsed.length) {
        return parsed.map(snapshotVariant);
      }
    } catch (err) {
      console.warn('Kunne ikke parse variant_details', err);
    }
  }
  const ids = parseReportVariantIds(report.variant_ids);
  if (!ids.length) return [];
  const orderVariants = getCached('variants').filter(v => !orderId || v.order_id === orderId);
  return ids.map(id => {
    const found = orderVariants.find(v => v.id === id) || getCached('variants').find(v => v.id === id);
    if (!found) return null;
    return snapshotVariant(found);
  }).filter(Boolean);
}
function describeVariantNarrative(variant) {
  if (!variant) return '';
  const nameParts = [variant.gene, variant.hgvs_c, variant.hgvs_p].filter(Boolean);
  const summaryParts = [];
  if (variant.classification) summaryParts.push(`Klasse ${variant.classification}`);
  if (variant.criteria) summaryParts.push(`ACMG: ${variant.criteria}`);
  if (variant.af !== undefined && variant.af !== null && variant.af !== '') summaryParts.push(`AF: ${variant.af}`);
  if (variant.zygosity) summaryParts.push(`Zygositet: ${variant.zygosity}`);
  if (variant.interpretation) summaryParts.push(variant.interpretation);
  const title = nameParts.join(' · ');
  return [title, summaryParts.join(' – ')].filter(Boolean).join(' – ');
}
function buildConclusionPlaceholderGuide(context = 'report') {
  const intro = context === 'library'
    ? 'Indsæt pladsholdere i standardteksten for at få felter udfyldt automatisk, når teksten bruges i en rapport.'
    : 'Når du indsætter en standardtekst i rapporten, erstattes pladsholdere automatisk med data fra den valgte ordination.';
  return `
    <div class="placeholder-guide">
      <h3>Pladsholdere til konklusioner</h3>
      <p>${intro} Skriv pladsholderen i firkantede parenteser, fx <code>[Patient]</code>.</p>
      <div class="placeholder-guide-columns">
        <div>
          <h4>Patient &amp; ordination</h4>
          <ul>
            <li><code>[Patient]</code> – patientens navn</li>
            <li><code>[PatientMRN]</code> – patientens MRN/CPR</li>
            <li><code>[PatientFamilienummer]</code> – familienummer</li>
            <li><code>[PatientFødselsdato]</code> – fødselsdato (dd-mm-åååå)</li>
            <li><code>[OrdinationID]</code> – ordinationens ID</li>
            <li><code>[OrdinationStatus]</code> – ordinationens status</li>
            <li><code>[OrdinationDato]</code> – bestillingsdato</li>
            <li><code>[OrdinationRekvirent]</code> – rekvirerende afdeling/læge</li>
            <li><code>[OrdinationPanel]</code> – valgt panel</li>
            <li><code>[OrdinationAnalyseansvarlig]</code> – analyseansvarlig</li>
            <li><code>[OrdinationTolker]</code> – tolk/fortolker</li>
            <li><code>[OrdinationGodkender]</code> – godkender</li>
          </ul>
        </div>
        <div>
          <h4>Prøve</h4>
          <ul>
            <li><code>[SampleID]</code> – prøve-ID</li>
            <li><code>[SamplePMB]</code> – PMB-nummer</li>
            <li><code>[SampleType]</code> – prøvetype</li>
            <li><code>[SampleStatus]</code> – prøvens status</li>
            <li><code>[SampleDato]</code> – prøvetagningsdato</li>
          </ul>
        </div>
        <div>
          <h4>Varianter</h4>
          <ul>
            <li><code>[VariantAntal]</code> – antal valgte varianter</li>
            <li><code>[Gen]</code>, <code>[Transkript]</code>, <code>[HGVS_c]</code>, <code>[HGVS_p]</code> – lister over værdier på tværs af varianter</li>
            <li><code>[Zygositet]</code>, <code>[ACMG-klasse]</code>, <code>[Kriterier]</code> – kombinerede klassifikationer</li>
            <li><code>[Annoteringer]</code> – samlede annoteringer (inkl. VarSeq-noter)</li>
            <li><code>[Tolkning]</code> – samlede tolkninger</li>
            <li><code>[VariantListe]</code> – nummereret oversigt med detaljer for hver variant</li>
            <li><code>[Variant]</code> / <code>[Variant1]</code> – detaljer for den første variant</li>
          </ul>
        </div>
      </div>
      <p class="placeholder-guide-footnote">Tilgå enkelte varianter med nummererede pladsholdere, fx <code>[Variant1Gene]</code>, <code>[Variant2Tolkning]</code> eller <code>[Variant3.HGVS_c]</code>. Manglende oplysninger giver tom tekst, og pladsholdere er uafhængige af store/små bogstaver. Punktum kan bruges som adskillelse, fx <code>[Patient.MRN]</code>.</p>
    </div>
  `;
}

function renderConclusionLibrary(section) {
  const list = getCached('conclusion_library').slice().sort((a, b) => {
    const titleCompare = (a.title || '').localeCompare(b.title || '', 'da');
    if (titleCompare) return titleCompare;
    return (a.id || 0) - (b.id || 0);
  });
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="conclusionLibrarySearch">Søg</label>
        <input id="conclusionLibrarySearch" type="search" placeholder="Titel eller tekst...">
        <table>
          <thead>
            <tr><th>ID</th><th>Titel</th><th>Uddrag</th><th>Opdateret</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h2>Standardtekst</h2>
        <form id="conclusionLibraryForm">
          <input type="hidden" name="id">
          <label>Titel<input name="title" required></label>
          <label>Standardtekst<textarea name="body" rows="8" required></textarea></label>
          <div class="btn-row">
            <button class="primary" type="submit">Gem</button>
            <button class="secondary" type="button" id="conclusionLibraryClear">Ny</button>
            <button class="danger" type="button" id="conclusionLibraryDelete">Slet</button>
          </div>
        </form>
        <div data-placeholder-guide="library"></div>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#conclusionLibrarySearch');
  const form = section.querySelector('#conclusionLibraryForm');
  const clearBtn = section.querySelector('#conclusionLibraryClear');
  const deleteBtn = section.querySelector('#conclusionLibraryDelete');
  const placeholderGuideHost = section.querySelector('[data-placeholder-guide="library"]');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  if (placeholderGuideHost) {
    placeholderGuideHost.innerHTML = buildConclusionPlaceholderGuide('library');
  }
  let selectedId = null;
  let filtered = list.slice();
  const renderRows = () => {
    const term = (search?.value || '').toLowerCase().trim();
    filtered = list.filter(entry => {
      if (!term) return true;
      const haystack = `${entry.title || ''} ${(entry.body || '').replace(/\s+/g, ' ')}`.toLowerCase();
      return haystack.includes(term);
    });
    if (selectedId && !filtered.some(entry => entry.id === selectedId)) {
      selectedId = null;
    }
    if (!filtered.length) {
      tbody.innerHTML = '<tr><td colspan="4">Ingen standardtekster matcher søgningen.</td></tr>';
      annotateTableCells(section);
      return;
    }
    tbody.innerHTML = filtered.map(entry => {
      const snippetSource = (entry.body || '').replace(/\s+/g, ' ').trim();
      const snippet = snippetSource.length > 120 ? `${snippetSource.slice(0, 117)}…` : snippetSource;
      const updatedAt = entry.updated_at ? new Date(entry.updated_at).toLocaleString('da-DK') : '';
      const selectedAttr = entry.id === selectedId ? ' data-selected="true"' : '';
      return `<tr data-id="${entry.id}"${selectedAttr}><td>${entry.id}</td><td>${esc(entry.title || '')}</td><td>${esc(snippet)}</td><td>${esc(updatedAt)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search?.addEventListener('input', renderRows);
  tbody?.addEventListener('click', e => {
    const tr = e.target.closest('tr[data-id]');
    if (!tr) return;
    const id = Number(tr.dataset.id);
    const entry = list.find(item => item.id === id);
    if (!entry) return;
    selectedId = id;
    fillForm(form, entry);
    renderRows();
  });
  const clearForm = () => {
    if (!form) return;
    form.reset();
    selectedId = null;
    renderRows();
  };
  clearBtn?.addEventListener('click', clearForm);
  deleteBtn?.addEventListener('click', async () => {
    if (!ensureWrite('conclusion_library')) return;
    const id = Number(form?.elements.id.value);
    if (!id) {
      alert('Vælg en standardtekst der skal slettes.');
      return;
    }
    if (!confirm('Slet den valgte standardtekst?')) return;
    await deleteRecord('conclusion_library', id);
    setStatus(`Standardtekst ${id} slettet.`);
    renderTab('conclusion_library');
  });
  form?.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('conclusion_library')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    const payload = {
      title: (data.title || '').trim(),
      body: (data.body || '').trim()
    };
    if (!payload.title || !payload.body) {
      alert('Udfyld både titel og tekst.');
      return;
    }
    const id = Number(data.id || 0);
    if (id) {
      const before = findById('conclusion_library', id);
      if (!before) {
        alert('Kunne ikke finde standardteksten.');
        return;
      }
      const updated = {...before, ...payload, id};
      await updateRecord('conclusion_library', updated, before);
      setStatus(`Standardtekst ${id} opdateret.`);
    } else {
      await addRecord('conclusion_library', payload);
      setStatus('Standardtekst oprettet.');
    }
    renderTab('conclusion_library');
  });
  form?.addEventListener('reset', () => {
    selectedId = null;
    renderRows();
  });
}

function renderReports(section) {
  const list = getCached('reports');
  const orders = getCached('orders');
  const conclusionLibrary = getCached('conclusion_library').slice().sort((a, b) => (a.title || '').localeCompare(b.title || '', 'da'));
  const conclusionOptions = conclusionLibrary.map(entry => `<option value="${entry.id}">${esc(entry.title || `Tekst #${entry.id}`)}</option>`).join('');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="reportSearch">Søg</label>
        <input id="reportSearch" type="search" placeholder="Status...">
        <details class="advanced-filter" id="reportsFilterPanel">
          <summary>Avanceret filter</summary>
          <div class="filter-grid">
            <label>ID<input type="search" data-filter-reports="id" placeholder="Rapport-ID"></label>
            <label>Ordination<input type="search" data-filter-reports="order" placeholder="Ordinations-ID"></label>
            <label>Status<input type="search" data-filter-reports="status" placeholder="Status"></label>
            <label>Udstedt fra<input type="date" data-filter-reports="issued_from"></label>
            <label>Udstedt til<input type="date" data-filter-reports="issued_to"></label>
          </div>
        </details>
        <table><thead><tr><th>ID</th><th>Ordination</th><th>Status</th><th>Oprettet af</th><th>Udstedt</th></tr></thead><tbody></tbody></table>
        <div class="table-actions">
          <button type="button" class="secondary" id="reportsExport">Eksportér filtrerede rapporter</button>
        </div>
      </div>
      <div>
        <h2>Rapport</h2>
        <form id="reportForm">
          <input type="hidden" name="id">
          <label>Ordination
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer ordinationer">
              <select name="order_id" required>
                <option value="" selected>Vælg ordination</option>
                ${orders.map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Status<select name="status"><option value="draft">Udkast</option><option value="final">Endelig</option><option value="amended">Ændret</option></select></label>
          <label>Udstedt<input type="datetime-local" name="issued_at"></label>
          <label>Fund
            <div class="report-variant-selector">
              <div class="filterable-select">
                <input type="search" placeholder="Filtrer varianter" data-report-variant-filter>
                <select id="reportVariantSelect" disabled>
                  <option value="" selected>Vælg variant</option>
                </select>
              </div>
              <button class="secondary" type="button" id="reportAddVariant" disabled>Tilføj</button>
            </div>
          </label>
          <div class="report-variant-list" id="reportVariantList">
            <p class="report-variant-empty">Ingen varianter valgt.</p>
          </div>
          <input type="hidden" name="variant_ids" value="[]">
          <label>Konklusion<textarea name="summary"></textarea></label>
          <div class="conclusion-library-controls">
            <label>Standardtekst
              <select id="conclusionLibrarySelect">
                <option value="" selected>Vælg standardtekst</option>
                ${conclusionOptions}
              </select>
            </label>
            <div class="conclusion-library-buttons">
              <button class="secondary" type="button" id="conclusionLibraryInsert">Erstat konklusion</button>
              <button class="secondary" type="button" id="conclusionLibraryAppend">Tilføj til konklusion</button>
            </div>
          </div>
          <div data-placeholder-guide="report"></div>
          <div class="btn-row">
            <button class="primary" type="submit">Gem</button>
            <button class="secondary" type="button" id="reportClear">Ny</button>
            <button class="danger" type="button" id="reportDelete">Slet</button>
            <button class="secondary" type="button" id="reportPreview">Udskriv/forhåndsvis</button>
            <button class="secondary" type="button" id="reportDownloadPdf">Hent PDF</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#reportSearch');
  const form = section.querySelector('#reportForm');
  const orderSelect = form?.elements.order_id;
  const variantSelect = form?.querySelector('#reportVariantSelect');
  const variantFilterInput = form?.querySelector('[data-report-variant-filter]');
  const variantAddButton = form?.querySelector('#reportAddVariant');
  const variantList = form?.querySelector('#reportVariantList');
  const variantIdsInput = form?.elements.variant_ids;
  const conclusionSelect = form?.querySelector('#conclusionLibrarySelect');
  const conclusionInsertBtn = form?.querySelector('#conclusionLibraryInsert');
  const conclusionAppendBtn = form?.querySelector('#conclusionLibraryAppend');
  const summaryField = form?.elements.summary;
  const conclusionMap = new Map(conclusionLibrary.map(entry => [String(entry.id), entry]));
  const placeholderGuideHost = section.querySelector('[data-placeholder-guide="report"]');
  let selectedReportVariants = [];
  let currentReportOrderId = null;
  let variantOptionState = [];
  if (placeholderGuideHost) {
    placeholderGuideHost.innerHTML = buildConclusionPlaceholderGuide('report');
  }
  const updateAddButtonState = () => {
    if (!variantAddButton || !variantSelect) return;
    const id = Number(variantSelect.value);
    const exists = selectedReportVariants.some(v => v.id === id);
    variantAddButton.disabled = variantSelect.disabled || !variantSelect.value || exists;
  };
  const syncVariantIdsInput = () => {
    if (!variantIdsInput) return;
    const ids = selectedReportVariants.map(v => v.id).filter(id => id != null);
    variantIdsInput.value = JSON.stringify(ids);
  };
  const renderSelectedReportVariants = () => {
    if (!variantList) return;
    if (!selectedReportVariants.length) {
      variantList.innerHTML = '<p class="report-variant-empty">Ingen varianter valgt.</p>';
      return;
    }
    const items = selectedReportVariants.map(variant => {
      const titleParts = [variant.gene, variant.hgvs_c, variant.hgvs_p].filter(Boolean);
      const title = titleParts.length ? titleParts.join(' · ') : `Variant ${variant.id ?? ''}`.trim();
      const metaParts = [];
      if (variant.id != null) metaParts.push(`<span><strong>ID:</strong> ${esc(variant.id)}</span>`);
      if (variant.transcript) metaParts.push(`<span><strong>Transkript:</strong> ${esc(variant.transcript)}</span>`);
      if (variant.classification) metaParts.push(`<span><strong>Klasse:</strong> ${esc(variant.classification)}</span>`);
      if (variant.criteria) metaParts.push(`<span><strong>ACMG:</strong> ${esc(variant.criteria)}</span>`);
      if (variant.af !== undefined && variant.af !== null && variant.af !== '') metaParts.push(`<span><strong>AF:</strong> ${esc(variant.af)}</span>`);
      if (variant.zygosity) metaParts.push(`<span><strong>Zygositet:</strong> ${esc(variant.zygosity)}</span>`);
      const metaHtml = metaParts.length ? `<div class="report-variant-meta">${metaParts.join('')}</div>` : '';
      const interpretationHtml = variant.interpretation ? `<p>${esc(variant.interpretation)}</p>` : '';
      return `<div class="report-variant-item" data-variant-id="${variant.id}"><header><span>${esc(title)}</span><button type="button" class="report-variant-remove" data-action="remove" data-variant-id="${variant.id}">Fjern</button></header>${metaHtml}${interpretationHtml}</div>`;
    }).join('');
    variantList.innerHTML = items;
  };
  const setSelectedReportVariants = variants => {
    selectedReportVariants = (variants || []).map(v => ({...v}));
    syncVariantIdsInput();
    renderSelectedReportVariants();
    updateAddButtonState();
  };
  const buildVariantOptionLabel = variant => {
    const parts = [variant.gene, variant.hgvs_c, variant.hgvs_p].filter(Boolean);
    if (parts.length) return parts.join(' · ');
    return `Variant ${variant.id}`;
  };
  const applyVariantFilter = () => {
    if (!variantFilterInput) return;
    const term = variantFilterInput.value.trim().toLowerCase();
    variantOptionState.forEach(({option, text}) => {
      const matches = !term || text.includes(term) || option.selected;
      option.hidden = !matches;
    });
    if (term && variantSelect) {
      const firstVisible = variantOptionState.find(({option}) => !option.hidden);
      if (firstVisible && !firstVisible.option.selected) {
        variantSelect.value = firstVisible.option.value;
      }
    }
    updateAddButtonState();
  };
  const refreshVariantOptions = () => {
    if (!variantSelect) return;
    const orderId = Number(orderSelect?.value || '');
    currentReportOrderId = Number.isFinite(orderId) && orderId ? orderId : null;
    variantOptionState = [];
    variantSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Vælg variant';
    variantSelect.appendChild(placeholder);
    if (!currentReportOrderId) {
      variantSelect.disabled = true;
      if (variantFilterInput) {
        variantFilterInput.value = '';
        variantFilterInput.disabled = true;
      }
      updateAddButtonState();
      return;
    }
    const variantsForOrder = getCached('variants').filter(v => v.order_id === currentReportOrderId);
    variantsForOrder.forEach(variant => {
      const option = document.createElement('option');
      option.value = variant.id;
      option.textContent = buildVariantOptionLabel(variant);
      variantSelect.appendChild(option);
      variantOptionState.push({option, text: option.textContent.toLowerCase()});
    });
    variantSelect.disabled = variantsForOrder.length === 0;
    if (variantFilterInput) {
      variantFilterInput.value = '';
      variantFilterInput.disabled = variantsForOrder.length === 0;
    }
    variantSelect.value = '';
    applyVariantFilter();
  };
  const filterInputs = {
    id: section.querySelector('[data-filter-reports="id"]'),
    order: section.querySelector('[data-filter-reports="order"]'),
    status: section.querySelector('[data-filter-reports="status"]'),
    issued_from: section.querySelector('[data-filter-reports="issued_from"]'),
    issued_to: section.querySelector('[data-filter-reports="issued_to"]')
  };
  const updateConclusionButtons = () => {
    const hasSelection = !!conclusionSelect?.value;
    if (conclusionInsertBtn) conclusionInsertBtn.disabled = !hasSelection;
    if (conclusionAppendBtn) conclusionAppendBtn.disabled = !hasSelection;
  };
  const normalizePlaceholderKey = key => {
    if (!key) return '';
    return key
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/[^a-z0-9_.æøå-]/g, '')
      .replace(/-+/g, '')
      .replace(/^[.]+|[.]+$/g, '');
  };
  const joinUnique = (values, separator = ', ') => {
    const seen = new Set();
    const result = [];
    for (const value of values || []) {
      const text = value == null ? '' : String(value).trim();
      if (!text || seen.has(text)) continue;
      seen.add(text);
      result.push(text);
    }
    return result.join(separator);
  };
  const joinUniqueParagraphs = values => {
    const seen = new Set();
    const result = [];
    for (const value of values || []) {
      const text = value == null ? '' : String(value).trim();
      if (!text || seen.has(text)) continue;
      seen.add(text);
      result.push(text);
    }
    return result.join('\n\n');
  };
  const describeVariantBlock = variant => {
    if (!variant) return '';
    const lines = [];
    const header = [variant.gene, variant.hgvs_c, variant.hgvs_p].filter(Boolean).join(' · ');
    if (header) lines.push(header);
    const details = [];
    if (variant.transcript) details.push(`Transkript: ${variant.transcript}`);
    if (variant.zygosity) details.push(`Zygositet: ${variant.zygosity}`);
    if (variant.classification) details.push(`ACMG-klasse: ${variant.classification}`);
    if (variant.criteria) details.push(`Kriterier: ${variant.criteria}`);
    if (variant.af !== undefined && variant.af !== null && variant.af !== '') details.push(`AF: ${variant.af}`);
    if (details.length) lines.push(details.join(' – '));
    if (variant.annotations) lines.push(`Annoteringer: ${variant.annotations}`);
    if (variant.interpretation) lines.push(`Tolkning: ${variant.interpretation}`);
    return lines.join('\n');
  };
  const buildConclusionPlaceholderMap = () => {
    const map = new Map();
    const add = (keys, value) => {
      if (!Array.isArray(keys)) keys = [keys];
      const text = value == null ? '' : String(value);
      for (const key of keys) {
        const normalized = normalizePlaceholderKey(key);
        if (!normalized) continue;
        map.set(normalized, text);
      }
    };
    const orderId = Number(form?.elements.order_id?.value || '') || null;
    const order = orderId ? findById('orders', orderId) : null;
    const patient = order?.patient_id ? findById('patients', Number(order.patient_id)) : null;
    const sample = order?.sample_id ? findById('samples', Number(order.sample_id)) : null;
    const panel = order?.panel_id ? findById('panels', Number(order.panel_id)) : null;
    const analysisUser = order?.analysis_responsible_id ? findById('users', Number(order.analysis_responsible_id)) : null;
    const interpreterUser = order?.interpreter_id ? findById('users', Number(order.interpreter_id)) : null;
    const approverUser = order?.approver_id ? findById('users', Number(order.approver_id)) : null;
    const variants = selectedReportVariants.slice();
    const variantCount = variants.length;
    const firstVariant = variants[0] || null;
    add(['Patient', 'PatientNavn', 'Patient.Name'], patient?.name || '');
    add(['PatientMRN', 'MRN', 'Patient.MRN'], patient?.mrn || '');
    add(['PatientFamilienummer', 'Familienummer', 'Patient.Familienummer'], patient?.family_number || '');
    add(['PatientFodselsdato', 'PatientFødselsdato', 'Patient.BirthDate'], patient?.birth_date ? formatDanishDate(patient.birth_date) : '');
    add(['OrdinationID', 'Ordination.Id', 'OrderID'], orderId ? String(orderId) : '');
    add(['OrdinationStatus', 'Ordination.Status'], order?.status || '');
    add(['OrdinationDato', 'OrdinationBestilt', 'Ordination.Ordered'], order?.ordered_at ? formatDanishDate(order.ordered_at) : '');
    add(['OrdinationRekvirent', 'Ordination.Clinician', 'Clinician'], order?.clinician || '');
    add(['OrdinationPanel', 'PanelNavn', 'Panel'], panel?.name || '');
    add(['OrdinationAnalyseansvarlig', 'Analyseansvarlig'], analysisUser?.name || '');
    add(['OrdinationTolker', 'Tolker'], interpreterUser?.name || '');
    add(['OrdinationGodkender', 'Godkender'], approverUser?.name || '');
    add(['SampleID', 'ProeveID', 'PrøveID'], sample?.id ? String(sample.id) : '');
    add(['SamplePMB', 'PMB'], sample?.pmb_number || '');
    add(['SampleType', 'ProeveType', 'PrøveType'], sample?.sample_type || '');
    add(['SampleStatus', 'ProeveStatus', 'PrøveStatus'], sample?.status || '');
    add(['SampleDato', 'Sample.Collected', 'PrøveDato'], sample?.collected_at ? formatDanishDate(sample.collected_at) : '');
    add(['VariantAntal', 'AntalVarianter'], variantCount ? String(variantCount) : '');
    const geneList = joinUnique(variants.map(v => v.gene));
    const transcriptList = joinUnique(variants.map(v => v.transcript));
    const hgvscList = joinUnique(variants.map(v => v.hgvs_c));
    const hgvsPList = joinUnique(variants.map(v => v.hgvs_p));
    const zygosityList = joinUnique(variants.map(v => v.zygosity));
    const classificationList = joinUnique(variants.map(v => v.classification));
    const criteriaList = joinUnique(variants.map(v => v.criteria));
    const annotationsText = joinUniqueParagraphs(variants.map(v => v.annotations));
    const interpretationText = joinUniqueParagraphs(variants.map(v => v.interpretation));
    const variantSummaryBlocks = variants.map((variant, index) => {
      const block = describeVariantBlock(variant);
      if (!block) return '';
      const indented = block.replace(/\n/g, '\n   ');
      return `${index + 1}. ${indented}`;
    }).filter(Boolean);
    const variantSummary = variantSummaryBlocks.join('\n\n');
    add(['Gen', 'Gene', 'Gener'], geneList);
    add(['Transkript', 'Transcript'], transcriptList);
    add(['HGVS_c', 'HGVS c', 'HGVSc'], hgvscList);
    add(['HGVS_p', 'HGVS p', 'HGVSp'], hgvsPList);
    add(['Zygositet', 'Zygosity'], zygosityList);
    add(['ACMG-klasse', 'ACMGklasse', 'ACMG'], classificationList);
    add(['Kriterier', 'Criteria'], criteriaList);
    add(['Annoteringer', 'Annotationer', 'Annotations', 'VarSeq'], annotationsText);
    add(['Tolkning', 'Tolkninger', 'Interpretation', 'Interpretations'], interpretationText);
    add(['VariantListe', 'VariantList', 'Varianter'], variantSummary);
    if (firstVariant) {
      add(['Variant', 'VariantNavn', 'Variant1'], describeVariantBlock(firstVariant));
      add(['VariantGene', 'VariantGen', 'Variant1Gene', 'Variant1.Gen'], firstVariant.gene || '');
      add(['VariantTranskript', 'Variant1Transkript'], firstVariant.transcript || '');
      add(['VariantHGVS_c', 'Variant1HGVS_c', 'Variant1.HGVS_c'], firstVariant.hgvs_c || '');
      add(['VariantHGVS_p', 'Variant1HGVS_p', 'Variant1.HGVS_p'], firstVariant.hgvs_p || '');
      add(['VariantZygositet', 'Variant1Zygositet'], firstVariant.zygosity || '');
      add(['VariantACMG', 'Variant1ACMG'], firstVariant.classification || '');
      add(['VariantKriterier', 'Variant1Kriterier'], firstVariant.criteria || '');
      add(['VariantAnnoteringer', 'Variant1Annoteringer'], firstVariant.annotations || '');
      add(['VariantTolkning', 'Variant1Tolkning'], firstVariant.interpretation || '');
    }
    variants.forEach((variant, index) => {
      const idx = index + 1;
      const prefix = `Variant${idx}`;
      add([`${prefix}`, `${prefix}Navn`, `${prefix}.Navn`], describeVariantBlock(variant));
      add([`${prefix}Gene`, `${prefix}.Gene`, `${prefix}Gen`, `${prefix}.Gen`], variant.gene || '');
      add([`${prefix}Transkript`, `${prefix}.Transkript`], variant.transcript || '');
      add([`${prefix}HGVS_c`, `${prefix}.HGVS_c`], variant.hgvs_c || '');
      add([`${prefix}HGVS_p`, `${prefix}.HGVS_p`], variant.hgvs_p || '');
      add([`${prefix}Zygositet`, `${prefix}.Zygositet`], variant.zygosity || '');
      add([`${prefix}ACMG`, `${prefix}.ACMG`], variant.classification || '');
      add([`${prefix}Kriterier`, `${prefix}.Kriterier`], variant.criteria || '');
      add([`${prefix}Annoteringer`, `${prefix}.Annoteringer`], variant.annotations || '');
      add([`${prefix}Tolkning`, `${prefix}.Tolkning`], variant.interpretation || '');
    });
    return map;
  };
  const resolveConclusionTemplate = template => {
    if (!template) return '';
    const replacements = buildConclusionPlaceholderMap();
    return String(template).replace(/\[([^\]]+)\]/g, (match, rawKey) => {
      const normalized = normalizePlaceholderKey(rawKey);
      if (!normalized) return match;
      return replacements.has(normalized) ? replacements.get(normalized) : match;
    });
  };
  const applyConclusionText = mode => {
    if (!summaryField || !conclusionSelect) return;
    const entry = conclusionMap.get(conclusionSelect.value);
    if (!entry) return;
    const text = resolveConclusionTemplate(entry.body || '');
    if (mode === 'replace') {
      summaryField.value = text;
    } else if (mode === 'append') {
      const existing = summaryField.value || '';
      const trimmed = existing.replace(/\s+$/, '');
      summaryField.value = trimmed ? `${trimmed}\n\n${text}` : text;
    }
    summaryField.dispatchEvent(new Event('input', {bubbles: false}));
    summaryField.focus();
  };
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  updateConclusionButtons();
  setSelectedReportVariants([]);
  refreshVariantOptions();
  if (variantFilterInput) {
    variantFilterInput.addEventListener('input', applyVariantFilter);
    variantFilterInput.addEventListener('keydown', evt => {
      if (evt.key === 'Escape') {
        variantFilterInput.value = '';
        applyVariantFilter();
      }
    });
  }
  if (variantSelect) {
    variantSelect.addEventListener('change', updateAddButtonState);
  }
  conclusionSelect?.addEventListener('change', updateConclusionButtons);
  conclusionInsertBtn?.addEventListener('click', () => applyConclusionText('replace'));
  conclusionAppendBtn?.addEventListener('click', () => applyConclusionText('append'));
  if (variantAddButton) {
    variantAddButton.addEventListener('click', () => {
      if (!variantSelect) return;
      const id = Number(variantSelect.value);
      if (!id || selectedReportVariants.some(v => v.id === id)) {
        updateAddButtonState();
        return;
      }
      const storeVariant = getCached('variants').find(v => v.id === id);
      const snapshot = snapshotVariant(storeVariant || {id, order_id: currentReportOrderId || Number(orderSelect?.value) || null});
      if (!snapshot.order_id) snapshot.order_id = currentReportOrderId || Number(orderSelect?.value) || null;
      setSelectedReportVariants(selectedReportVariants.concat(snapshot));
      variantSelect.value = '';
      applyVariantFilter();
    });
  }
  if (variantList) {
    variantList.addEventListener('click', evt => {
      const btn = evt.target.closest('[data-action="remove"]');
      if (!btn) return;
      const id = Number(btn.dataset.variantId);
      if (!id) return;
      setSelectedReportVariants(selectedReportVariants.filter(v => v.id !== id));
      updateAddButtonState();
    });
  }
  if (orderSelect) {
    orderSelect.addEventListener('change', () => {
      refreshVariantOptions();
      const orderId = Number(orderSelect.value);
      if (!orderId) {
        setSelectedReportVariants([]);
        return;
      }
      const filtered = selectedReportVariants.filter(v => Number(v.order_id) === orderId);
      if (filtered.length !== selectedReportVariants.length) {
        setSelectedReportVariants(filtered);
      } else {
        syncVariantIdsInput();
        renderSelectedReportVariants();
        updateAddButtonState();
      }
    });
  }
  const statusMap = {draft:'Udkast', final:'Endelig', amended:'Ændret'};
  let filteredReports = list.slice();
  let activeFilters = {};
  let selectedReportId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filters = {
      id: filterInputs.id?.value.trim() || '',
      order: filterInputs.order?.value.trim().toLowerCase() || '',
      status: filterInputs.status?.value.trim().toLowerCase() || '',
      issued_from: filterInputs.issued_from?.value || '',
      issued_to: filterInputs.issued_to?.value || ''
    };
    const fromDate = filters.issued_from ? new Date(filters.issued_from) : null;
    const toDate = filters.issued_to ? new Date(filters.issued_to) : null;
    if (toDate) toDate.setHours(23, 59, 59, 999);
    const filterSummary = {...filters};
    if (term) filterSummary.fritekst = term;
    activeFilters = filterSummary;
    filteredReports = list.filter(r => {
      if (!term) return true;
      const raw = (r.status || '').toLowerCase();
      const display = (statusMap[r.status] || r.status || '').toLowerCase();
      const creator = determineCreatedBy('reports', r).toLowerCase();
      return [raw, display, creator].some(value => value.includes(term));
    }).filter(r => {
      if (filters.id && !String(r.id).includes(filters.id)) return false;
      if (filters.order && !(String(r.order_id || '')).toLowerCase().includes(filters.order)) return false;
      const statusStrings = [(r.status || '').toLowerCase(), (statusMap[r.status] || '').toLowerCase()];
      if (filters.status && !statusStrings.some(v => v.includes(filters.status))) return false;
      if (fromDate || toDate) {
        if (!r.issued_at) return false;
        const issued = new Date(r.issued_at);
        if (Number.isNaN(issued.getTime())) return false;
        if (fromDate && issued < fromDate) return false;
        if (toDate && issued > toDate) return false;
      }
      return true;
    });
    if (selectedReportId != null && !filteredReports.some(r => r.id === selectedReportId)) {
      selectedReportId = null;
    }
    tbody.innerHTML = filteredReports.map(r => {
      const displayStatus = statusMap[r.status] || r.status || '';
      const createdBy = determineCreatedBy('reports', r);
      const selectedAttr = r.id === selectedReportId ? ' data-selected="true"' : '';
      return `<tr data-id="${r.id}"${selectedAttr}><td>${r.id}</td><td>${r.order_id}</td><td>${esc(displayStatus)}</td><td>${esc(createdBy)}</td><td>${esc(r.issued_at||'')}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  Object.values(filterInputs).forEach(input => input?.addEventListener('input', renderRows));
  section.querySelector('#reportsExport').addEventListener('click', () => {
    exportFilteredJson('glimr-rapporter-filtreret.json', cloneWithCreatedBy('reports', filteredReports), {
      entity: 'rapporter',
      plural: 'rapporter',
      tab: 'Rapporter',
      filters: activeFilters
    });
  });
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const report = list.find(r => r.id === Number(tr.dataset.id));
    if (!report) return;
    selectedReportId = report.id;
    fillForm(form, report);
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
    refreshVariantOptions();
    const variants = getReportVariantSnapshots(report, Number(report.order_id));
    setSelectedReportVariants(variants);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('reports')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.order_id = Number(data.order_id);
    const orderId = data.order_id;
    const variantStore = getCached('variants');
    const variantSnapshots = selectedReportVariants.map(item => {
      const source = variantStore.find(v => v.id === item.id) || item;
      const snapshot = snapshotVariant(source);
      if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
      return snapshot;
    });
    data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
    data.variant_details = variantSnapshots;
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('reports', id)};
      const updated = {...before, ...data, id};
      await updateRecord('reports', updated, before);
    } else {
      delete data.id;
      await addRecord('reports', data);
    }
    await loadStore('reports');
    renderTab('reports');
  });
  section.querySelector('#reportDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg rapport');
    if (!ensureWrite('reports')) return;
    if (confirm('Slet rapport?')) {
      await deleteRecord('reports', id);
      renderTab('reports');
    }
  });
  form.addEventListener('reset', () => {
    selectedReportId = null;
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
    renderRows();
  });
  section.querySelector('#reportClear').addEventListener('click', () => {
    form.reset();
    setSelectedReportVariants([]);
    refreshVariantOptions();
    if (conclusionSelect) {
      conclusionSelect.value = '';
      updateConclusionButtons();
    }
  });
  section.querySelector('#reportPreview').addEventListener('click', () => {
    const data = Object.fromEntries(new FormData(form).entries());
    if (!data.order_id) return alert('Vælg ordre');
    const orderId = Number(data.order_id);
    data.order_id = orderId;
    const variantStore = getCached('variants');
    const variantSnapshots = selectedReportVariants.map(item => {
      const source = variantStore.find(v => v.id === item.id) || item;
      const snapshot = snapshotVariant(source);
      if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
      return snapshot;
    });
    data.variant_details = variantSnapshots;
    data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
    const html = buildReportHtml(orderId, data);
    const win = window.open('', '_blank');
    if (win) {
      win.document.write('<!DOCTYPE html><html><head><title>Rapport</title><style>body{font-family:Segoe UI,Arial;margin:2rem;}table{width:100%;border-collapse:collapse;}th,td{border:1px solid #ccc;padding:0.4rem;}th{background:#f0f0f0;}</style></head><body>' + html + '</body></html>');
      win.document.close();
    }
  });
  const downloadPdfButton = section.querySelector('#reportDownloadPdf');
  if (downloadPdfButton) {
    downloadPdfButton.addEventListener('click', async () => {
      const data = Object.fromEntries(new FormData(form).entries());
      if (!data.order_id) {
        alert('Vælg ordre');
        return;
      }
      const orderId = Number(data.order_id);
      data.order_id = orderId;
      const variantStore = getCached('variants');
      const variantSnapshots = selectedReportVariants.map(item => {
        const source = variantStore.find(v => v.id === item.id) || item;
        const snapshot = snapshotVariant(source);
        if (!snapshot.order_id) snapshot.order_id = orderId || item.order_id || currentReportOrderId || null;
        return snapshot;
      });
      data.variant_details = variantSnapshots;
      data.variant_ids = JSON.stringify(variantSnapshots.map(v => v.id).filter(id => id != null));
      const exportedAt = new Date();
      const blob = await createReportPdfBlob(orderId, data, exportedAt);
      if (!blob) {
        alert('Kunne ikke generere PDF for rapporten.');
        return;
      }
      const filename = buildReportPdfFilename(orderId, data, exportedAt);
      const url = URL.createObjectURL(blob);
      triggerDownload(url, filename);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      setStatus(`Rapport PDF hentet som ${filename}.`);
    });
  }
}
function buildReportHtml(orderId, reportData) {
  const order = findById('orders', orderId);
  const patient = order ? findById('patients', Number(order.patient_id)) : null;
  const sample = order ? findById('samples', Number(order.sample_id)) : null;
  let variants = getReportVariantSnapshots(reportData, orderId);
  if (!variants.length) {
    variants = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
  }
  const sampleIdentifierParts = [];
  if (sample?.pmb_number) sampleIdentifierParts.push(sample.pmb_number);
  if (sample?.id != null) sampleIdentifierParts.push(`ID ${sample.id}`);
  const sampleIdentifier = sampleIdentifierParts.join(' / ');
  const rows = variants.map(v => `<tr><td>${esc(v.gene)}</td><td>${esc(v.hgvs_c||'')}</td><td>${esc(v.hgvs_p||'')}</td><td>${esc(v.classification||'')}</td><td>${esc(v.criteria||'')}</td><td>${esc(v.af??'')}</td><td>${esc(v.interpretation||'')}</td></tr>`).join('') || '<tr><td colspan="7">Ingen fund</td></tr>';
  const detailSections = variants.length ? variants.map(variant => {
    const headingParts = [variant.gene, variant.hgvs_c, variant.hgvs_p].filter(Boolean);
    const heading = headingParts.length ? headingParts.join(' · ') : `Variant ${variant.id ?? ''}`.trim();
    const meta = [];
    if (variant.transcript) meta.push(`<li><strong>Transkript:</strong> ${esc(variant.transcript)}</li>`);
    if (variant.zygosity) meta.push(`<li><strong>Zygositet:</strong> ${esc(variant.zygosity)}</li>`);
    if (variant.classification) meta.push(`<li><strong>Klasse:</strong> ${esc(variant.classification)}</li>`);
    if (variant.criteria) meta.push(`<li><strong>ACMG:</strong> ${esc(variant.criteria)}</li>`);
    if (variant.af !== undefined && variant.af !== null && variant.af !== '') meta.push(`<li><strong>AF:</strong> ${esc(variant.af)}</li>`);
    const interpretation = variant.interpretation ? `<p>${esc(variant.interpretation)}</p>` : '';
    const metaList = meta.length ? `<ul>${meta.join('')}</ul>` : '';
    return `<div class="report-variant-detail"><h3>${esc(heading)}</h3>${metaList}${interpretation}</div>`;
  }).join('') : '<p>Ingen variantdetaljer registreret.</p>';
  return `
  <h1>Diagnostisk rapport</h1>
  <p><strong>Ordination:</strong> ${orderId}</p>
  <p><strong>Patient:</strong> ${esc(patient?.name||'')} (${esc(patient?.mrn||'')})</p>
  <p><strong>Prøve:</strong> ${esc(sample?.sample_type||'')}${sampleIdentifier ? ` (${esc(sampleIdentifier)})` : ''}</p>
  <p><strong>Status:</strong> ${esc(reportData.status||'')}</p>
  <p><strong>Udstedt:</strong> ${esc(reportData.issued_at||'')}</p>
  <h2>Konklusion</h2>
  <p>${esc(reportData.summary||'')}</p>
  <h2>Fund</h2>
  <table><thead><tr><th>Gen</th><th>HGVS c.</th><th>HGVS p.</th><th>Klasse</th><th>ACMG</th><th>AF</th><th>Tolkning</th></tr></thead><tbody>${rows}</tbody></table>
  <h2>Detaljer</h2>
  ${detailSections}`;
}
function escapePdfText(text) {
  return String(text || '').replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)').replace(/\r/g, '').replace(/\n/g, '\\n');
}
function stringToPdfBytes(str) {
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    bytes[i] = code <= 0xFF ? code : 0x3F;
  }
  return bytes;
}
const PDF_PAGE_WIDTH = 595;
const PDF_PAGE_HEIGHT = 842;
const PDF_MARGIN = 48;
const PDF_GUTTER = 28;
const PDF_BODY_FONT_SIZE = 11;
const PDF_HEADING_FONT_SIZE = 13;
const PDF_TITLE_FONT_SIZE = 20;
const PDF_BODY_LEADING = 16;
const PDF_HEADING_LEADING = 20;
const PDF_HEADING_GAP = 6;
const PDF_SECTION_SPACING = 16;
const PDF_ROW_SPACING = 6;
const PDF_SIGNATURE_BLOCK_HEIGHT = 110;
const PDF_TITLE_LEADING = 28;
const PDF_SECTION_CARD_PADDING_X = 14;
const PDF_SECTION_CARD_PADDING_TOP = 14;
const PDF_SECTION_CARD_PADDING_BOTTOM = 16;
const PDF_SECTION_CARD_INSET = 6;
const PDF_HEADER_BAND_HEIGHT = 132;
const PDF_HEADER_TITLE_BASELINE_OFFSET = 26;
const PDF_TEXT_COLOR = '#1b2c45';
const PDF_MUTED_TEXT_COLOR = '#4a6080';
const PDF_HEADING_TEXT_COLOR = '#124c87';
const PDF_ACCENT_COLOR = '#124c87';
const PDF_HEADER_BAND_COLOR = '#e5effb';
const PDF_CARD_BACKGROUND_COLOR = '#f9fbff';
const PDF_CARD_BORDER_COLOR = '#c5d7ed';
const PDF_CARD_HEADING_COLOR = '#cfe0f6';
const PDF_SIGNATURE_BAND_COLOR = '#ecf2fb';
const PDF_SIGNATURE_LINE_COLOR = '#8ea8c7';
const PDF_HEADING_TEXT_OFFSET = 2;
const PDF_HEADING_BAR_OFFSET = 3;
const PT_TO_PX = 96 / 72;

function pdfColorToRgb(color) {
  if (!color) return null;
  if (Array.isArray(color) && color.length >= 3) {
    return color.slice(0, 3).map(component => Math.max(0, Math.min(1, Number(component) || 0))).join(' ');
  }
  if (typeof color === 'string') {
    let hex = color.trim();
    if (hex.startsWith('#')) hex = hex.slice(1);
    if (hex.length === 3) {
      hex = hex.split('').map(ch => ch + ch).join('');
    }
    if (hex.length === 6) {
      const r = parseInt(hex.slice(0, 2), 16) / 255;
      const g = parseInt(hex.slice(2, 4), 16) / 255;
      const b = parseInt(hex.slice(4, 6), 16) / 255;
      return [r, g, b].map(v => v.toFixed(4).replace(/0+$/, '').replace(/\.$/, '')).join(' ');
    }
  }
  return null;
}

let pdfMeasureCtx = null;

function getPdfMeasureContext(fontSize) {
  if (!pdfMeasureCtx) {
    const canvas = document.createElement('canvas');
    pdfMeasureCtx = canvas.getContext('2d');
  }
  if (pdfMeasureCtx) {
    pdfMeasureCtx.font = `${(fontSize * PT_TO_PX).toFixed(2)}px "Arial", "Helvetica", sans-serif`;
  }
  return pdfMeasureCtx;
}

function wrapPdfText(text, maxWidth, fontSize) {
  const ctx = getPdfMeasureContext(fontSize);
  if (!ctx) return [String(text ?? '')];
  const maxWidthPx = maxWidth * PT_TO_PX;
  const paragraphs = String(text ?? '').replace(/\r/g, '').split('\n');
  const lines = [];
  for (let p = 0; p < paragraphs.length; p++) {
    const paragraph = paragraphs[p];
    const words = paragraph.trim() ? paragraph.split(/\s+/) : [];
    if (!words.length) {
      if (p < paragraphs.length - 1) lines.push('');
      continue;
    }
    let current = '';
    const flush = () => {
      if (current) {
        lines.push(current);
        current = '';
      }
    };
    for (const word of words) {
      const candidate = current ? `${current} ${word}` : word;
      if (ctx.measureText(candidate).width <= maxWidthPx) {
        current = candidate;
        continue;
      }
      flush();
      if (ctx.measureText(word).width <= maxWidthPx) {
        current = word;
        continue;
      }
      let segment = '';
      for (const char of word) {
        const attempt = segment + char;
        if (ctx.measureText(attempt).width > maxWidthPx && segment) {
          lines.push(segment);
          segment = char;
        } else {
          segment = attempt;
        }
      }
      current = segment;
    }
    flush();
    if (p < paragraphs.length - 1) lines.push('');
  }
  if (!lines.length) lines.push('');
  return lines;
}

function indentWrappedLines(lines, indentText) {
  if (!indentText) return lines;
  return lines.map((line, index) => (index === 0 ? `${indentText}${line}` : `${indentText}${line}`));
}

function formatDanishDate(value) {
  if (!value) return '';
  if (value instanceof Date && !Number.isNaN(value.getTime())) {
    const day = String(value.getDate()).padStart(2, '0');
    const month = String(value.getMonth() + 1).padStart(2, '0');
    return `${day}-${month}-${value.getFullYear()}`;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return '';
    const isoDateMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (isoDateMatch) {
      const [, year, month, day] = isoDateMatch;
      return `${day}-${month}-${year}`;
    }
    const parsed = new Date(trimmed);
    if (!Number.isNaN(parsed.getTime())) {
      return formatDanishDate(parsed);
    }
    return trimmed;
  }
  if (typeof value === 'number') {
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) {
      return formatDanishDate(parsed);
    }
  }
  return '';
}

function translateGender(value) {
  if (value === null || value === undefined) return '';
  const text = String(value).trim();
  if (!text) return '';
  const normalized = text.toLowerCase();
  if (['male', 'mand', 'm'].includes(normalized)) return 'Mand';
  if (['female', 'kvinde', 'f'].includes(normalized)) return 'Kvinde';
  if (['other', 'andet'].includes(normalized)) return 'Andet';
  if (['unknown', 'ukendt'].includes(normalized)) return 'Uoplyst';
  return text;
}

class SimplePdfBuilder {
  constructor() {
    this.width = PDF_PAGE_WIDTH;
    this.height = PDF_PAGE_HEIGHT;
    this.margin = PDF_MARGIN;
    this.pages = [];
    this.images = [];
    this.currentPage = null;
  }
  startPage() {
    const page = {ops: [], imageNames: new Set()};
    this.pages.push(page);
    this.currentPage = page;
    return page;
  }
  ensurePage() {
    if (!this.currentPage) this.startPage();
  }
  addText(text, x, y, fontSize = PDF_BODY_FONT_SIZE, color = null) {
    this.ensurePage();
    const fill = pdfColorToRgb(color || PDF_TEXT_COLOR);
    const colorPart = fill ? `${fill} rg\n` : '';
    this.currentPage.ops.push(`BT\n${colorPart}/F1 ${fontSize.toFixed(2)} Tf\n1 0 0 1 ${x.toFixed(2)} ${y.toFixed(2)} Tm (${escapePdfText(text)}) Tj\nET`);
  }
  addLine(x1, y1, x2, y2, width = 1, color = null) {
    this.ensurePage();
    const stroke = pdfColorToRgb(color || PDF_ACCENT_COLOR);
    const colorPart = stroke ? `${stroke} RG ` : '';
    this.currentPage.ops.push(`q ${colorPart}${width.toFixed(2)} w ${x1.toFixed(2)} ${y1.toFixed(2)} m ${x2.toFixed(2)} ${y2.toFixed(2)} l S Q`);
  }
  fillRect(x, y, width, height, color = null) {
    this.ensurePage();
    const fill = pdfColorToRgb(color);
    const colorPart = fill ? `${fill} rg ` : '';
    this.currentPage.ops.push(`q ${colorPart}${x.toFixed(2)} ${y.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)} re f Q`);
  }
  strokeRect(x, y, width, height, lineWidth = 1, color = null) {
    this.ensurePage();
    const stroke = pdfColorToRgb(color || PDF_CARD_BORDER_COLOR);
    const colorPart = stroke ? `${stroke} RG ` : '';
    this.currentPage.ops.push(`q ${colorPart}${lineWidth.toFixed(2)} w ${x.toFixed(2)} ${y.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)} re S Q`);
  }
  registerImage(image) {
    const name = `Im${this.images.length + 1}`;
    this.images.push({...image, name});
    return name;
  }
  drawImage(name, x, y, width, height) {
    this.ensurePage();
    this.currentPage.imageNames.add(name);
    this.currentPage.ops.push(`q ${width.toFixed(2)} 0 0 ${height.toFixed(2)} ${x.toFixed(2)} ${y.toFixed(2)} cm /${name} Do Q`);
  }
  build() {
    if (!this.pages.length) this.startPage();
    const pageCount = this.pages.length;
    let pdf = '%PDF-1.4\n';
    const offsets = [0];
    const addObject = str => {
      offsets.push(pdf.length);
      pdf += str;
    };
    const kids = this.pages.map((_, idx) => `${3 + idx} 0 R`).join(' ');
    addObject('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
    addObject(`2 0 obj\n<< /Type /Pages /Count ${pageCount} /Kids [${kids}] >>\nendobj\n`);
    const fontObjNumber = 3 + pageCount * 2;
    const imageStart = fontObjNumber + 1;
    this.images.forEach((image, index) => {
      image.objectNumber = imageStart + index;
    });
    const contentObjects = [];
    this.pages.forEach((page, idx) => {
      const pageObjNumber = 3 + idx;
      const contentObjNumber = 3 + pageCount + idx;
      const resourceParts = [`/Font << /F1 ${fontObjNumber} 0 R >>`];
      if (page.imageNames.size) {
        const entries = [];
        page.imageNames.forEach(name => {
          const image = this.images.find(img => img.name === name);
          if (image) entries.push(`/${name} ${image.objectNumber} 0 R`);
        });
        if (entries.length) resourceParts.push(`/XObject << ${entries.join(' ')} >>`);
      }
      addObject(`${pageObjNumber} 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${this.width} ${this.height}] /Contents ${contentObjNumber} 0 R /Resources << ${resourceParts.join(' ')} >> >>\nendobj\n`);
      const content = page.ops.join('\n');
      contentObjects.push({number: contentObjNumber, content});
    });
    contentObjects.forEach(obj => {
      addObject(`${obj.number} 0 obj\n<< /Length ${obj.content.length} >>\nstream\n${obj.content}\nendstream\nendobj\n`);
    });
    addObject(`${fontObjNumber} 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica /Encoding /WinAnsiEncoding >>\nendobj\n`);
    this.images.forEach(image => {
      const filter = image.filter || '/DCTDecode';
      const colorSpace = image.colorSpace || '/DeviceRGB';
      addObject(`${image.objectNumber} 0 obj\n<< /Type /XObject /Subtype /Image /Width ${image.width} /Height ${image.height} /ColorSpace ${colorSpace} /BitsPerComponent ${image.bitsPerComponent || 8} /Filter ${filter} /Length ${image.dataString.length} >>\nstream\n${image.dataString}\nendstream\nendobj\n`);
    });
    const totalObjects = fontObjNumber + this.images.length;
    const xrefOffset = pdf.length;
    pdf += `xref\n0 ${totalObjects + 1}\n0000000000 65535 f \n`;
    for (let i = 1; i <= totalObjects; i++) {
      const offset = offsets[i] || 0;
      pdf += `${String(offset).padStart(10, '0')} 00000 n \n`;
    }
    pdf += `trailer\n<< /Size ${totalObjects + 1} /Root 1 0 R >>\nstartxref\n${xrefOffset}\n%%EOF`;
    return stringToPdfBytes(pdf);
  }
}

function bytesToBinaryString(bytes) {
  let result = '';
  for (let i = 0; i < bytes.length; i++) {
    result += String.fromCharCode(bytes[i]);
  }
  return result;
}

function base64ToUint8Array(base64) {
  const binary = atob(base64);
  const length = binary.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}

async function loadReportLogoImage() {
  if (loadReportLogoImage.cache !== undefined) {
    return loadReportLogoImage.cache;
  }
  try {
    const img = await new Promise((resolve, reject) => {
      const element = new Image();
      element.onload = () => resolve(element);
      element.onerror = reject;
      element.src = `logo.png?ts=${Date.now()}`;
    });
    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
    const base64 = dataUrl.split(',')[1];
    const bytes = base64ToUint8Array(base64);
    loadReportLogoImage.cache = {
      width: img.naturalWidth,
      height: img.naturalHeight,
      data: bytes,
      dataString: bytesToBinaryString(bytes),
      bitsPerComponent: 8,
      filter: '/DCTDecode',
      colorSpace: '/DeviceRGB'
    };
  } catch (err) {
    console.warn('Kunne ikke indlæse logo til PDF', err);
    loadReportLogoImage.cache = null;
  }
  return loadReportLogoImage.cache;
}

function drawReportHeader(builder, logo, exportedAt) {
  const margin = builder.margin;
  const pageHeight = builder.height;
  const headerBottom = pageHeight - margin - PDF_HEADER_BAND_HEIGHT;
  const titleBaseline = headerBottom + PDF_HEADER_TITLE_BASELINE_OFFSET;
  builder.fillRect(0, headerBottom, builder.width, PDF_HEADER_BAND_HEIGHT, PDF_HEADER_BAND_COLOR);
  let imageWidth = 0;
  let imageHeight = 0;
  if (logo) {
    if (!logo.objectName) {
      logo.objectName = builder.registerImage({
        width: logo.width,
        height: logo.height,
        dataString: logo.dataString,
        bitsPerComponent: logo.bitsPerComponent,
        filter: logo.filter,
        colorSpace: logo.colorSpace
      });
    }
    const maxHeaderImageHeight = PDF_HEADER_BAND_HEIGHT - 48;
    const targetHeight = Math.max(48, Math.min(68, maxHeaderImageHeight));
    const aspect = logo.width && logo.height ? logo.width / logo.height : 1;
    imageHeight = Math.min(targetHeight, Math.max(0, maxHeaderImageHeight));
    imageWidth = imageHeight * aspect;
    const imageY = headerBottom + PDF_HEADER_BAND_HEIGHT - imageHeight - 12;
    builder.drawImage(logo.objectName, margin, imageY, imageWidth, imageHeight);
  }
  const titleX = imageWidth ? margin + imageWidth + 28 : margin + PDF_SECTION_CARD_PADDING_X;
  builder.addText('Diagnostisk Rapport', titleX, titleBaseline, PDF_TITLE_FONT_SIZE, PDF_ACCENT_COLOR);
  const dateFormatter = drawReportHeader.dateFormatter || new Intl.DateTimeFormat('da-DK');
  drawReportHeader.dateFormatter = dateFormatter;
  const dateLabel = dateFormatter.format(exportedAt || new Date());
  const dateWidth = measurePdfTextWidth(dateLabel, 12);
  const dateX = builder.width - margin - dateWidth;
  builder.addText(dateLabel, dateX, titleBaseline, 12, PDF_MUTED_TEXT_COLOR);
  builder.addLine(margin, headerBottom + 8, builder.width - margin, headerBottom + 8, 1.1, PDF_ACCENT_COLOR);
  const contentStart = Math.min(titleBaseline - PDF_TITLE_LEADING, headerBottom - 12, pageHeight - margin - imageHeight - 42);
  return {contentTop: contentStart};
}

function measurePdfTextWidth(text, fontSize) {
  const ctx = getPdfMeasureContext(fontSize);
  if (!ctx) return String(text || '').length * fontSize * 0.5;
  return ctx.measureText(String(text || '')).width * (72 / 96);
}

function buildSectionLayout(heading, rows, width) {
  const contentWidth = Math.max(10, width - PDF_SECTION_CARD_PADDING_X * 2);
  const layout = {
    heading,
    width,
    contentWidth,
    blocks: [],
    height: PDF_SECTION_CARD_PADDING_TOP + PDF_HEADING_TEXT_OFFSET + PDF_HEADING_LEADING + PDF_HEADING_GAP + PDF_SECTION_CARD_PADDING_BOTTOM + PDF_SECTION_SPACING
  };
  rows.forEach((row, index) => {
    switch (row.type) {
      case 'kv': {
        const value = row.value !== undefined && row.value !== null && row.value !== '' ? String(row.value) : row.fallback || '-';
        const text = `${row.label}: ${value}`;
        const lines = wrapPdfText(text, contentWidth, PDF_BODY_FONT_SIZE);
        layout.blocks.push({lines});
        layout.height += lines.length * PDF_BODY_LEADING;
        if (index < rows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'paragraph': {
        const label = row.label ? `${row.label}:` : '';
        if (label) {
          const labelLines = wrapPdfText(label, contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines: labelLines});
          layout.height += labelLines.length * PDF_BODY_LEADING;
        }
        const bodyText = row.value ? String(row.value) : (row.emptyText || 'Ingen oplysninger.');
        const bodyLines = wrapPdfText(bodyText, contentWidth, PDF_BODY_FONT_SIZE);
        const indented = row.indent ? indentWrappedLines(bodyLines, row.indent) : bodyLines;
        layout.blocks.push({lines: indented});
        layout.height += indented.length * PDF_BODY_LEADING;
        if (index < rows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'text': {
        const lines = wrapPdfText(row.text || '', contentWidth, PDF_BODY_FONT_SIZE);
        layout.blocks.push({lines});
        layout.height += lines.length * PDF_BODY_LEADING;
        if (index < rows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      case 'list': {
        const items = Array.isArray(row.items) ? row.items : [];
        if (!items.length) {
          const emptyLines = wrapPdfText(row.emptyText || 'Ingen poster.', contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines: emptyLines});
          layout.height += emptyLines.length * PDF_BODY_LEADING;
          if (index < rows.length - 1) layout.height += PDF_ROW_SPACING;
          break;
        }
        items.forEach((item, idx) => {
          const lines = wrapPdfText(item, contentWidth, PDF_BODY_FONT_SIZE);
          layout.blocks.push({lines});
          layout.height += lines.length * PDF_BODY_LEADING;
          if (idx < items.length - 1) layout.height += PDF_ROW_SPACING / 2;
        });
        if (index < rows.length - 1) layout.height += PDF_ROW_SPACING;
        break;
      }
      default:
        break;
    }
  });
  return layout;
}

function renderSection(builder, column, section) {
  const startCursor = column.cursor;
  const bodyHeight = section.height - PDF_SECTION_SPACING;
  const cardBottom = startCursor - bodyHeight;
  const cardX = column.x - PDF_SECTION_CARD_INSET;
  const cardWidth = column.width + PDF_SECTION_CARD_INSET * 2;
  builder.fillRect(cardX, cardBottom, cardWidth, bodyHeight, PDF_CARD_BACKGROUND_COLOR);
  builder.strokeRect(cardX, cardBottom, cardWidth, bodyHeight, 0.8, PDF_CARD_BORDER_COLOR);
  const headingBaseline = startCursor - PDF_SECTION_CARD_PADDING_TOP;
  const baseHeadingBarBottom = Math.max(cardBottom, headingBaseline - (PDF_HEADING_FONT_SIZE + 2));
  const baseHeadingBarTop = Math.min(startCursor - 2, headingBaseline + PDF_SECTION_CARD_PADDING_TOP - 2);
  const headingBarBottom = baseHeadingBarBottom + PDF_HEADING_BAR_OFFSET;
  const headingBarTop = baseHeadingBarTop + PDF_HEADING_BAR_OFFSET;
  const headingFillHeight = headingBarTop - headingBarBottom;
  if (headingFillHeight > 0.1) {
    builder.fillRect(cardX, headingBarBottom, cardWidth, headingFillHeight, PDF_CARD_HEADING_COLOR);
  }
  let cursor = headingBaseline - PDF_HEADING_TEXT_OFFSET;
  const textX = column.x + PDF_SECTION_CARD_PADDING_X;
  builder.addText(section.heading, textX, cursor, PDF_HEADING_FONT_SIZE, PDF_HEADING_TEXT_COLOR);
  cursor -= (PDF_HEADING_LEADING + PDF_HEADING_GAP);
  section.blocks.forEach((block, idx) => {
    const lines = block.lines || [];
    lines.forEach(line => {
      builder.addText(line, textX, cursor, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
      cursor -= PDF_BODY_LEADING;
    });
    if (idx < section.blocks.length - 1) cursor -= PDF_ROW_SPACING;
  });
  cursor -= PDF_SECTION_CARD_PADDING_BOTTOM;
  cursor -= PDF_SECTION_SPACING;
  column.cursor = cursor;
}

function ensureSingleColumnSpace(builder, column, neededHeight, reserveBottom) {
  const bottomLimit = builder.margin + (reserveBottom || 0);
  if (column.cursor - neededHeight < bottomLimit) {
    const {logo, exportedAt} = ensureSingleColumnSpace;
    const header = startNewReportPage(builder, logo, exportedAt);
    column.cursor = header.contentTop;
  }
}

function startNewReportPage(builder, logo, exportedAt) {
  builder.startPage();
  return drawReportHeader(builder, logo, exportedAt);
}

async function createReportPdfBlob(orderId, reportData, exportedAt = new Date()) {
  try {
    const order = findById('orders', orderId);
    if (!order) return null;
    const patient = findById('patients', Number(order.patient_id));
    const sample = findById('samples', Number(order.sample_id));
    const panel = order?.panel_id ? findById('panels', Number(order.panel_id)) : null;
    const interpreterName = order?.interpreter_id ? getName('users', order.interpreter_id) : '';
    const approverName = order?.approver_id ? getName('users', order.approver_id) : '';
    const analysisResponsible = order?.analysis_responsible_id ? getName('users', order.analysis_responsible_id) : '';
    const clinician = order?.clinician || '';
    const qcEntries = sample ? getCached('qc').filter(q => Number(q.sample_id) === Number(sample.id)) : [];
    let variants = getReportVariantSnapshots(reportData, orderId);
    if (!variants.length) {
      variants = getCached('variants').filter(v => Number(v.order_id) === Number(order.id)).map(snapshotVariant);
    }
    const builder = new SimplePdfBuilder();
    const logo = await loadReportLogoImage();
    const initialHeader = startNewReportPage(builder, logo, exportedAt);
    ensureSingleColumnSpace.logo = logo;
    ensureSingleColumnSpace.exportedAt = exportedAt;
    const columnWidth = (builder.width - builder.margin * 2 - PDF_GUTTER) / 2;
    const leftColumn = {x: builder.margin, width: columnWidth, cursor: initialHeader.contentTop};
    const rightColumn = {x: builder.margin + columnWidth + PDF_GUTTER, width: columnWidth, cursor: initialHeader.contentTop};
    const patientBirthDate = formatDanishDate(patient?.birth_date) || (patient?.birth_date || '');
    const patientRows = [
      {type: 'kv', label: 'Navn', value: patient?.name},
      {type: 'kv', label: 'MRN', value: patient?.mrn},
      {type: 'kv', label: 'Familienummer', value: patient?.family_number},
      {type: 'kv', label: 'Køn', value: translateGender(patient?.gender)},
      {type: 'kv', label: 'Fødselsdato', value: patientBirthDate}
    ];
    const sampleRows = [
      {type: 'kv', label: 'PMB-nummer', value: sample?.pmb_number},
      {type: 'kv', label: 'Prøvetype', value: sample?.sample_type},
      {type: 'kv', label: 'Status', value: sample?.status},
      {type: 'kv', label: 'Opsamlet', value: sample?.collected_at},
      {type: 'paragraph', label: 'Noter', value: sample?.notes, emptyText: 'Ingen noter.', indent: '  '}
    ];
    const analysisRows = [
      {type: 'kv', label: 'Panel', value: panel?.name},
      {type: 'kv', label: 'Analyseansvarlig', value: analysisResponsible},
      {type: 'kv', label: 'Rekvirent', value: clinician},
      {type: 'kv', label: 'Ordinationsstatus', value: order?.status},
      {type: 'kv', label: 'Bestilt', value: order?.ordered_at}
    ];
    const qcRows = [];
    if (qcEntries.length) {
      qcEntries.forEach((qc, index) => {
        const label = `${index + 1}. ${qc.metric}`;
        const unit = qc.unit ? ` ${qc.unit}` : '';
        const value = `${qc.value}${unit}`;
        const parts = [value];
        if (qc.notes) parts.push(`Noter: ${qc.notes}`);
        qcRows.push({type: 'paragraph', label, value: parts.join('\n'), indent: '  '});
      });
    } else {
      qcRows.push({type: 'text', text: 'Ingen registrerede kvalitetsmålinger.'});
    }
    const patientSection = buildSectionLayout('Patientoplysninger', patientRows, columnWidth);
    const analysisSection = buildSectionLayout('Analyse', analysisRows, columnWidth);
    const sampleSection = buildSectionLayout('Prøvedata', sampleRows, columnWidth);
    const qcSection = buildSectionLayout('Kvalitetsmålinger', qcRows, columnWidth);
    renderSection(builder, leftColumn, patientSection);
    renderSection(builder, rightColumn, sampleSection);
    renderSection(builder, leftColumn, analysisSection);
    renderSection(builder, rightColumn, qcSection);
    const singleColumn = {
      x: builder.margin,
      width: builder.width - builder.margin * 2,
      cursor: Math.min(leftColumn.cursor, rightColumn.cursor) - PDF_SECTION_SPACING
    };
    if (singleColumn.cursor < builder.margin + PDF_SIGNATURE_BLOCK_HEIGHT + 40) {
      const header = startNewReportPage(builder, logo, exportedAt);
      singleColumn.cursor = header.contentTop;
    }
    const fundRows = [];
    if (variants.length) {
      variants.forEach((variant, index) => {
        const headingParts = [variant.gene, variant.hgvs_c, variant.hgvs_p].filter(Boolean);
        const heading = headingParts.length ? headingParts.join(' · ') : `Variant ${variant.id ?? index + 1}`;
        const meta = [];
        if (variant.transcript) meta.push(`Transkript: ${variant.transcript}`);
        if (variant.zygosity) meta.push(`Zygositet: ${variant.zygosity}`);
        if (variant.classification) meta.push(`Klasse: ${variant.classification}`);
        if (variant.criteria) meta.push(`ACMG: ${variant.criteria}`);
        if (variant.af !== undefined && variant.af !== null && variant.af !== '') meta.push(`AF: ${variant.af}`);
        const bodyParts = [];
        if (meta.length) bodyParts.push(meta.join(' · '));
        if (variant.interpretation) bodyParts.push(variant.interpretation);
        fundRows.push({
          type: 'paragraph',
          label: `${index + 1}. ${heading}`,
          value: bodyParts.join('\n\n'),
          emptyText: 'Ingen detaljer angivet.',
          indent: '  '
        });
      });
    } else {
      fundRows.push({type: 'text', text: 'Ingen registrerede varianter.'});
    }
    const fundSection = buildSectionLayout('Fund', fundRows, singleColumn.width);
    const conclusionText = reportData.summary || '';
    const conclusionRows = [
      conclusionText ? {type: 'text', text: conclusionText} : {type: 'text', text: 'Ingen konklusion angivet.'}
    ];
    const conclusionSection = buildSectionLayout('Konklusion', conclusionRows, singleColumn.width);
    const singleSections = [fundSection, conclusionSection];
    singleSections.forEach((section, index) => {
      const remaining = singleSections.slice(index + 1).reduce((sum, item) => sum + item.height, 0);
      const reserve = remaining + PDF_SIGNATURE_BLOCK_HEIGHT + 20;
      ensureSingleColumnSpace(builder, singleColumn, section.height, reserve);
      renderSection(builder, singleColumn, section);
    });
    ensureSingleColumnSpace(builder, singleColumn, PDF_SIGNATURE_BLOCK_HEIGHT, 0);
    const signatureBottom = builder.margin;
    const signatureHeight = PDF_SIGNATURE_BLOCK_HEIGHT;
    const signatureX = builder.margin - PDF_SECTION_CARD_INSET;
    const signatureWidth = builder.width - 2 * builder.margin + PDF_SECTION_CARD_INSET * 2;
    builder.fillRect(signatureX, signatureBottom, signatureWidth, signatureHeight, PDF_SIGNATURE_BAND_COLOR);
    builder.strokeRect(signatureX, signatureBottom, signatureWidth, signatureHeight, 0.8, PDF_CARD_BORDER_COLOR);
    const signatureHeadingY = signatureBottom + signatureHeight - 18;
    const signatureTextX = singleColumn.x + PDF_SECTION_CARD_PADDING_X;
    builder.addText('Signering', signatureTextX, signatureHeadingY, PDF_HEADING_FONT_SIZE, PDF_HEADING_TEXT_COLOR);
    const signatureInnerWidth = singleColumn.width - PDF_SECTION_CARD_PADDING_X * 2;
    const signatureLineY = signatureBottom + 40;
    const firstLineStart = signatureTextX;
    const midPoint = signatureTextX + signatureInnerWidth / 2;
    const gap = 24;
    let firstLineEnd = midPoint - gap;
    if (firstLineEnd - firstLineStart < 80) firstLineEnd = firstLineStart + 80;
    firstLineEnd = Math.min(firstLineEnd, midPoint - 6);
    let secondLineStart = midPoint + gap;
    if (secondLineStart < firstLineEnd + 24) {
      secondLineStart = firstLineEnd + 24;
    }
    let secondLineEnd = signatureTextX + signatureInnerWidth;
    if (secondLineEnd - secondLineStart < 80) {
      secondLineStart = Math.max(secondLineEnd - 80, secondLineStart);
    }
    builder.addLine(firstLineStart, signatureLineY, firstLineEnd, signatureLineY, 1, PDF_SIGNATURE_LINE_COLOR);
    builder.addText(`Tolker: ${interpreterName || 'Ikke angivet'}`, firstLineStart, signatureLineY + 24, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
    builder.addLine(secondLineStart, signatureLineY, secondLineEnd, signatureLineY, 1, PDF_SIGNATURE_LINE_COLOR);
    builder.addText(`Godkender: ${approverName || 'Ikke angivet'}`, secondLineStart, signatureLineY + 24, PDF_BODY_FONT_SIZE, PDF_TEXT_COLOR);
    const bytes = builder.build();
    return new Blob([bytes], {type: 'application/pdf'});
  } catch (err) {
    console.error('Kunne ikke generere PDF for rapporten', err);
    return null;
  }
}

function sanitizeFilenameComponent(value) {
  if (!value) return 'ukendt';
  return String(value).trim().replace(/[^0-9A-Za-zÆØÅæøå_-]+/g, '_') || 'ukendt';
}

function buildReportPdfFilename(orderId, reportData, exportedAt = new Date()) {
  const order = findById('orders', Number(orderId));
  const patient = order ? findById('patients', Number(order?.patient_id)) : null;
  const mrnPart = sanitizeFilenameComponent(patient?.mrn || patient?.cpr || 'ukendt');
  const dateStamp = exportedAt.toISOString().slice(0, 10).replace(/-/g, '');
  return `${mrnPart}_Diagnostisk_Rapport_${dateStamp}.pdf`;
}
function renderQC(section) {
  const list = getCached('qc');
  const samples = getCached('samples');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="qcSearch">Søg</label>
        <input id="qcSearch" type="search" placeholder="Måling...">
        <table><thead><tr><th>ID</th><th>Prøve</th><th>Måling</th><th>Værdi</th><th>Enhed</th><th>Oprettet af</th></tr></thead><tbody></tbody></table>
      </div>
      <div>
        <h2>Kvalitetsmåling</h2>
        <form id="qcForm">
          <input type="hidden" name="id">
          <label>Prøve
            <div class="filterable-select">
              <input type="search" data-select-filter placeholder="Filtrer prøver">
              <select name="sample_id" required>
                <option value="" selected>Vælg prøve</option>
                ${samples.map(s => `<option value="${s.id}">${s.id} (${esc(s.pmb_number||'–')}) – ${esc(getName('patients', s.patient_id))}</option>`).join('')}
              </select>
            </div>
          </label>
          <label>Måling<input name="metric" required></label>
          <label>Værdi<input name="value" type="number" step="0.0001" required></label>
          <label>Enhed<input name="unit"></label>
          <label>Noter<textarea name="notes"></textarea></label>
          <div class="btn-row">
            <button class="primary" type="submit">Gem</button>
            <button class="secondary" type="button" id="qcClear">Ny</button>
            <button class="danger" type="button" id="qcDelete">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#qcSearch');
  const form = section.querySelector('#qcForm');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  applySelectFilters(section);
  let selectedQcId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filteredQc = list.filter(q => {
      if (!term) return true;
      const creator = determineCreatedBy('qc', q);
      return [q.metric, q.unit, creator].some(v => (v || '').toString().toLowerCase().includes(term));
    });
    if (selectedQcId != null && !filteredQc.some(q => q.id === selectedQcId)) {
      selectedQcId = null;
    }
    tbody.innerHTML = filteredQc.map(q => {
      const createdBy = determineCreatedBy('qc', q);
      const selectedAttr = q.id === selectedQcId ? ' data-selected="true"' : '';
      return `<tr data-id="${q.id}"${selectedAttr}><td>${q.id}</td><td>${esc(q.sample_id)}</td><td>${esc(q.metric)}</td><td>${esc(q.value)}</td><td>${esc(q.unit||'')}</td><td>${esc(createdBy)}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const qc = list.find(q => q.id === Number(tr.dataset.id));
    if (!qc) return;
    selectedQcId = qc.id;
    fillForm(form, qc);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('qc')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    data.sample_id = Number(data.sample_id);
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('qc', id)};
      const updated = {...before, ...data, id};
      await updateRecord('qc', updated, before);
    } else {
      delete data.id;
      await addRecord('qc', data);
    }
    await loadStore('qc');
    renderTab('qc');
  });
  section.querySelector('#qcDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg QC-post');
    if (!ensureWrite('qc')) return;
    if (confirm('Slet QC-post?')) {
      await deleteRecord('qc', id);
      renderTab('qc');
    }
  });
  form.addEventListener('reset', () => {
    selectedQcId = null;
    renderRows();
  });
  section.querySelector('#qcClear').addEventListener('click', () => form.reset());
}

function renderTools(section) {
  const pathogenicCriteria = [
    {code: 'PVS1', label: 'Loss-of-function variant i gen hvor loss-of-function er kendt sygdomsmekanisme.', weight: 8},
    {code: 'PS1', label: 'Samme aminosyreændring som kendt patogen variant uden ændret nukleotid.', weight: 4},
    {code: 'PS2', label: 'De novo (bekræftet) hos patient med sund(e) forælder(e).', weight: 4},
    {code: 'PS3', label: 'Funktionelle studier viser skadelig effekt.', weight: 4},
    {code: 'PS4', label: 'Signifikant øget forekomst i syge kontra kontroller.', weight: 4},
    {code: 'PM1', label: 'Hotspot/domæne uden godartede variationer.', weight: 2},
    {code: 'PM2', label: 'Fraværende eller ekstremt lav frekvens i kontroller.', weight: 2},
    {code: 'PM3', label: 'Påvist i trans med patogen variant i recessiv sygdom.', weight: 2},
    {code: 'PM4', label: 'Proteinaltering der påvirker læseramme eller stopper protein.', weight: 2},
    {code: 'PM5', label: 'Ny missense på samme aminosyre som anden patogen variant.', weight: 2},
    {code: 'PM6', label: 'De novo (uformelt) uden bekræftede forældre.', weight: 2},
    {code: 'PP1', label: 'Segregerer med sygdommen i familien.', weight: 1},
    {code: 'PP2', label: 'Missense i gen hvor missense er hyppig sygdomsmekanisme.', weight: 1},
    {code: 'PP3', label: 'In silico-støtte for skadelig effekt.', weight: 1},
    {code: 'PP4', label: 'Fænotype/specifik sygdom i tråd med genet.', weight: 1},
    {code: 'PP5', label: 'Anført som patogen af velrenommeret kilde.', weight: 1}
  ];
  const benignCriteria = [
    {code: 'BA1', label: 'Allelfrekvens >5 % i kontroller (stand-alone).', weight: 8, effect: 'benign'},
    {code: 'BS1', label: 'Allelfrekvens større end forventet for lidelsen.', weight: 4, effect: 'benign'},
    {code: 'BS2', label: 'Observeret hos sund homozygot/hemizygot.', weight: 4, effect: 'benign'},
    {code: 'BS3', label: 'Funktionelle studier viser ingen skadelig effekt.', weight: 4, effect: 'benign'},
    {code: 'BS4', label: 'Mangel på segregering med sygdommen.', weight: 4, effect: 'benign'},
    {code: 'BP1', label: 'Missense i gen hvor loss-of-function er dominerende mekanisme.', weight: 1, effect: 'benign'},
    {code: 'BP2', label: 'Observeret sammen med patogen variant for dominant sygdom.', weight: 1, effect: 'benign'},
    {code: 'BP3', label: 'In-frame indel i repetitiv region uden kendt funktion.', weight: 1, effect: 'benign'},
    {code: 'BP4', label: 'In silico understøtter benign effekt.', weight: 1, effect: 'benign'},
    {code: 'BP5', label: 'Variant forklarer alternativ diagnose.', weight: 1, effect: 'benign'},
    {code: 'BP6', label: 'Anført som godartet af velrenommeret kilde.', weight: 1, effect: 'benign'},
    {code: 'BP7', label: 'Synonym variant uden splice-påvirkning.', weight: 1, effect: 'benign'}
  ];
  const makeCriteriaList = list => list.map(item => {
    const code = esc(item.code);
    const label = esc(item.label);
    const effect = esc(item.effect || 'pathogenic');
    return `
    <label class="tool-criteria" title="${code} – ${label}">
      <input type="checkbox" value="${code}" data-weight="${item.weight}" data-effect="${effect}">
      <span><strong>${code}</strong> ${label}</span>
    </label>
  `;
  }).join('');
  section.innerHTML = `
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">ACMG klassifikationshjælper</span>
        <span class="tool-subtitle">Forenklet vægtning af ACMG/AMP 2015 med opdaterede pointværdier.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>ACMG klassifikationshjælper</h3>
      <p>Vælg de kriterier der er opfyldt for varianten. Resultatet bruger en forenklet vægtning af ACMG/AMP 2015 med opdaterede pointværdier.</p>
      <form id="acmgTool">
        <div class="tool-columns">
          <fieldset>
            <legend>Patogene kriterier</legend>
            <div class="tool-criteria-list">
              ${makeCriteriaList(pathogenicCriteria)}
            </div>
          </fieldset>
          <fieldset>
            <legend>Benigne kriterier</legend>
            <div class="tool-criteria-list">
              ${makeCriteriaList(benignCriteria)}
            </div>
          </fieldset>
        </div>
        <div class="btn-row">
          <button type="button" class="secondary" id="acmgReset">Nulstil kriterier</button>
        </div>
      </form>
      <div class="tool-result" id="acmgResult">Vælg kriterier for at se forslag til klassifikation.</div>
      <p class="tool-note">Vurderingen er vejledende og kræver altid manuel gennemgang og dokumentation.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">HGVS c. nomenklaturhjælper</span>
        <span class="tool-subtitle">Byg hurtigt cDNA-notation for substitutioner, deletioner m.m.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>HGVS c. nomenklaturhjælper</h3>
      <p>Udfyld felterne for at få foreslået et gyldigt HGVS c.-udtryk til simple varianter. Vælg varianttype og angiv de relevante positioner og sekvenser.</p>
      <form id="hgvsForm">
        <div class="tool-inline">
          <label for="hgvsTranscript" title="Angiv referencetranskript (RefSeq, LRG eller tilsvarende).">
            Referencetranskript
            <input id="hgvsTranscript" name="transcript" placeholder="fx NM_000546.5">
          </label>
          <label for="hgvsType" title="Vælg varianttypen for at vise de relevante felter.">
            Varianttype
            <select id="hgvsType" name="type">
              <option value="substitution">Basiskift (substitution)</option>
              <option value="deletion">Deletion</option>
              <option value="insertion">Insertion</option>
              <option value="duplication">Duplikation</option>
              <option value="delins">Delins (deletion+insertion)</option>
            </select>
          </label>
        </div>
        <div class="tool-inline">
          <label for="hgvsStart" data-hgvs-field="start" title="Startpositionen for ændringen. Brug intronnotation ved behov (fx 123+1).">
            Position (start)
            <input id="hgvsStart" name="start" placeholder="fx 215">
          </label>
          <label for="hgvsEnd" data-hgvs-field="end" title="Slutpositionen for ændringen. Udelades for enkeltbase-varianter.">
            Position (slut)
            <input id="hgvsEnd" name="end" placeholder="fx 217">
          </label>
        </div>
        <div class="tool-inline">
          <label for="hgvsRef" data-hgvs-field="ref" title="Referencebase(r) eller slettet sekvens, hvis kendt.">
            Reference/sekvens
            <input id="hgvsRef" name="ref" placeholder="fx C eller AGT">
          </label>
          <label for="hgvsAlt" data-hgvs-field="alt" title="Ændringen, indsatte baser eller erstatningssekvens.">
            Ændring/indsættelse
            <input id="hgvsAlt" name="alt" placeholder="fx G eller TTA">
          </label>
        </div>
        <p class="tool-note">Felter skjules automatisk for varianttyper, hvor de ikke anvendes. Positioner kan skrives med intronnotation (fx 123+1).</p>
        <div class="btn-row">
          <button type="button" class="secondary" id="hgvsCopy">Kopiér notation</button>
        </div>
      </form>
      <div class="tool-result" id="hgvsResult">Udfyld felterne for at få et HGVS-forslag.</div>
      <p class="tool-note">Kontroller altid notationen mod HGVS-retningslinjerne og kliniske SOP&apos;er før rapportering.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">Genomisk afstandsberegner</span>
        <span class="tool-subtitle">Beregn antal baser mellem to lokationer.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>Genomisk afstandsberegner</h3>
      <p>Beregn antal baser mellem to lokationer. Indtast fx <code>chr7:55191822</code> og <code>chr7:55277778</code>.</p>
      <form id="distanceTool">
        <div class="tool-inline">
          <label for="distanceStart">Startposition<input id="distanceStart" name="start" placeholder="fx chr7:55191822"></label>
          <label for="distanceEnd">Slutposition<input id="distanceEnd" name="end" placeholder="fx 55277778"></label>
        </div>
        <div class="btn-row">
          <button type="button" class="secondary" id="distanceSwap">Byt positioner</button>
        </div>
      </form>
      <div class="tool-result" id="distanceResult">Indtast positioner for at se resultatet.</div>
      <p class="tool-note">Resultatet viser både eksklusiv (end-start) og inklusiv (end-start+1) afstand.</p>
    </div>
  </details>
  <details class="panel tool-panel">
    <summary>
      <div class="tool-summary-text">
        <span class="tool-title">GC- og sekvensværktøj</span>
        <span class="tool-subtitle">Analyser sekvensen for GC-indhold og reverse komplement.</span>
      </div>
    </summary>
    <div class="tool-body">
      <h3>GC- og sekvensværktøj</h3>
      <p>Analyser en DNA/RNA-sekvens for længde, GC-indhold og generér reverse komplement.</p>
      <form id="gcTool">
        <label for="gcSequence">Sekvens
          <textarea id="gcSequence" name="sequence" rows="4" placeholder="Indsæt sekvens her"></textarea>
        </label>
        <div class="btn-row">
          <button type="button" class="secondary" id="gcUpper">Rens og formater</button>
          <button type="button" class="secondary" id="gcReverse">Reverse komplement</button>
        </div>
      </form>
      <div class="tool-result" id="gcResult">Indsæt en sekvens for at beregne GC%.</div>
      <p class="tool-note">Beregningen ignorerer mellemrum og tal. Ambigue baser (fx N, R, Y) medtages i længden.</p>
    </div>
  </details>`;

  applyButtonTooltips(section);
  applyControlTooltips(section);

  const acmgForm = section.querySelector('#acmgTool');
  const acmgResult = section.querySelector('#acmgResult');
  const acmgCheckboxes = Array.from(acmgForm.querySelectorAll('input[type="checkbox"]'));
  const acmgReset = section.querySelector('#acmgReset');
  const formatList = list => list.length ? list.join(', ') : 'Ingen';
  const updateAcmgResult = () => {
    let score = 0;
    const selectedPath = [];
    const selectedBenign = [];
    acmgCheckboxes.forEach(cb => {
      if (!cb.checked) return;
      const weight = Number(cb.dataset.weight || '0');
      const effect = cb.dataset.effect === 'benign' ? 'benign' : 'pathogenic';
      if (effect === 'benign') {
        score -= weight;
        selectedBenign.push(cb.value);
      } else {
        score += weight;
        selectedPath.push(cb.value);
      }
    });
    if (!selectedPath.length && !selectedBenign.length) {
      acmgResult.textContent = 'Vælg kriterier for at se forslag til klassifikation.';
      return;
    }
    let classification;
    if (score >= 10) classification = 'Patogen';
    else if (score >= 6) classification = 'Sandsynligvis patogen';
    else if (score <= -6) classification = 'Godartet';
    else if (score <= -2) classification = 'Sandsynligvis godartet';
    else classification = 'Variant af ukendt betydning (VUS)';
    acmgResult.innerHTML = `<strong>${classification}</strong><br>` +
      `Vægtet score: ${score}.<br>` +
      `Patogene kriterier: ${formatList(selectedPath)}.<br>` +
      `Benigne kriterier: ${formatList(selectedBenign)}.`;
  };
  acmgForm.addEventListener('change', updateAcmgResult);
  acmgReset?.addEventListener('click', () => {
    acmgCheckboxes.forEach(cb => { cb.checked = false; });
    updateAcmgResult();
  });
  updateAcmgResult();

  const hgvsForm = section.querySelector('#hgvsForm');
  const hgvsResult = section.querySelector('#hgvsResult');
  if (hgvsForm && hgvsResult) {
    const hgvsType = hgvsForm.querySelector('#hgvsType');
    if (hgvsType) {
      const hgvsCopy = section.querySelector('#hgvsCopy');
      const hgvsFields = {
        transcript: hgvsForm.querySelector('#hgvsTranscript'),
        start: hgvsForm.querySelector('#hgvsStart'),
        end: hgvsForm.querySelector('#hgvsEnd'),
        ref: hgvsForm.querySelector('#hgvsRef'),
        alt: hgvsForm.querySelector('#hgvsAlt')
      };
      const hgvsFieldVisibility = {
        substitution: {start: true, end: false, ref: true, alt: true},
        deletion: {start: true, end: true, ref: true, alt: false},
        insertion: {start: true, end: true, ref: false, alt: true},
        duplication: {start: true, end: true, ref: false, alt: false},
        delins: {start: true, end: true, ref: true, alt: true}
      };
      const hgvsRequiredFields = {
        substitution: ['start', 'ref', 'alt'],
        deletion: ['start'],
        insertion: ['start', 'end', 'alt'],
        duplication: ['start'],
        delins: ['start', 'alt']
      };
      const hgvsFieldLabels = {
        start: 'Position (start)',
        end: 'Position (slut)',
        ref: 'Reference/sekvens',
        alt: 'Ændring/indsættelse'
      };
      const hgvsFieldControls = Array.from(hgvsForm.querySelectorAll('[data-hgvs-field]'));
      const setHgvsVisibility = type => {
        const config = hgvsFieldVisibility[type] || hgvsFieldVisibility.substitution;
        hgvsFieldControls.forEach(label => {
          const field = label.getAttribute('data-hgvs-field');
          label.hidden = config[field] === false;
        });
      };
      const normaliseTranscript = value => value.trim();
      const normaliseSequenceField = value => value.replace(/\s+/g, '').toUpperCase();
      const buildCoordinate = (start, end) => {
        if (!end || end === start) return start;
        return `${start}_${end}`;
      };
      const updateHgvsResult = () => {
        const type = hgvsType.value;
        setHgvsVisibility(type);
        const config = hgvsFieldVisibility[type] || hgvsFieldVisibility.substitution;
        const transcript = normaliseTranscript(hgvsFields.transcript?.value || '');
        const start = (hgvsFields.start?.value || '').trim();
        const rawEnd = (hgvsFields.end?.value || '').trim();
        const end = config.end === false ? '' : rawEnd;
        const rawRef = hgvsFields.ref?.value || '';
        const rawAlt = hgvsFields.alt?.value || '';
        const ref = config.ref === false ? '' : normaliseSequenceField(rawRef);
        const alt = config.alt === false ? '' : normaliseSequenceField(rawAlt);
        const required = hgvsRequiredFields[type] || hgvsRequiredFields.substitution;
        const values = {start, end, ref, alt};
        const missing = required.filter(key => !values[key]);
        if (missing.length) {
          const names = missing.map(key => hgvsFieldLabels[key] || key).join(', ');
          hgvsResult.textContent = `Udfyld følgende felter: ${names}.`;
          hgvsResult.dataset.hgvsString = '';
          return;
        }
        let coordinate = start;
        if (end) {
          coordinate = buildCoordinate(start, end);
        }
        let variantPart = '';
        switch (type) {
          case 'deletion':
            variantPart = `${coordinate}del${ref}`;
            break;
          case 'insertion':
            variantPart = `${coordinate}ins${alt}`;
            break;
          case 'duplication':
            variantPart = `${coordinate}dup${ref || ''}`;
            break;
          case 'delins':
            variantPart = `${coordinate}delins${alt}`;
            break;
          default:
            variantPart = `${coordinate}${ref}>${alt}`;
        }
        let transcriptPart = '';
        if (transcript) {
          let cleaned = transcript.replace(/\s+/g, '');
          if (/^c\./i.test(cleaned)) {
            cleaned = cleaned.replace(/^c\./i, '');
            transcriptPart = '';
          } else {
            const lower = cleaned.toLowerCase();
            const colonIndex = lower.indexOf(':c.');
            if (colonIndex !== -1) {
              cleaned = cleaned.slice(0, colonIndex);
            } else {
              cleaned = cleaned.replace(/:$/,'').replace(/:c$/i, '');
            }
            if (cleaned) {
              transcriptPart = `${cleaned}:`;
            }
          }
        }
        const notation = `${transcriptPart}c.${variantPart}`;
        hgvsResult.innerHTML = `<strong>Forslag:</strong> <code>${esc(notation)}</code>`;
        hgvsResult.dataset.hgvsString = notation;
      };
      hgvsForm.addEventListener('input', updateHgvsResult);
      hgvsType.addEventListener('change', updateHgvsResult);
      updateHgvsResult();
      hgvsCopy?.addEventListener('click', async () => {
        const notation = hgvsResult.dataset.hgvsString;
        if (!notation) {
          alert('Der er ingen notation at kopiere endnu.');
          return;
        }
        try {
          await navigator.clipboard.writeText(notation);
          setStatus(`HGVS-notation kopieret: ${notation}`);
        } catch (err) {
          console.error(err);
          alert('Kunne ikke kopiere til udklipsholderen.');
        }
      });
    }
  }

  const distanceForm = section.querySelector('#distanceTool');
  const distanceResult = section.querySelector('#distanceResult');
  const distanceStart = distanceForm.querySelector('#distanceStart');
  const distanceEnd = distanceForm.querySelector('#distanceEnd');
  const parsePosition = value => {
    if (!value) return NaN;
    const cleaned = value.replace(/,/g, '');
    const matches = cleaned.match(/-?\d+/g);
    if (!matches) return NaN;
    return Number(matches[matches.length - 1]);
  };
  const updateDistance = () => {
    const startVal = parsePosition(distanceStart.value);
    const endVal = parsePosition(distanceEnd.value);
    if (!Number.isFinite(startVal) || !Number.isFinite(endVal)) {
      distanceResult.textContent = 'Indtast gyldige numeriske positioner for begge felter.';
      return;
    }
    const diff = Math.abs(endVal - startVal);
    const inclusive = diff + 1;
    const orientation = endVal === startVal ? 'samme position' : endVal > startVal ? 'stigende koordinater' : 'faldende koordinater';
    distanceResult.innerHTML = `<strong>Eksklusiv afstand:</strong> ${diff.toLocaleString('da-DK')} baser` +
      `<br><strong>Inklusiv afstand:</strong> ${inclusive.toLocaleString('da-DK')} baser` +
      `<br><span class="tool-note">Fortolkning: ${orientation}.</span>`;
  };
  distanceForm.addEventListener('input', updateDistance);
  section.querySelector('#distanceSwap')?.addEventListener('click', () => {
    const tmp = distanceStart.value;
    distanceStart.value = distanceEnd.value;
    distanceEnd.value = tmp;
    updateDistance();
  });
  updateDistance();

  const gcTextarea = section.querySelector('#gcSequence');
  const gcResult = section.querySelector('#gcResult');
  const gcUpper = section.querySelector('#gcUpper');
  const gcReverse = section.querySelector('#gcReverse');
  const normaliseSequence = value => value.replace(/[^A-Za-z]/g, '').toUpperCase();
  const updateGc = () => {
    const seq = normaliseSequence(gcTextarea.value);
    if (!seq.length) {
      gcResult.textContent = 'Indsæt en sekvens for at beregne GC%.';
      return;
    }
    const gcCount = (seq.match(/[GC]/g) || []).length;
    const atCount = (seq.match(/[ATU]/g) || []).length;
    const nCount = (seq.match(/[N]/g) || []).length;
    const otherCount = seq.length - (gcCount + atCount + nCount);
    const gcPct = (gcCount / seq.length) * 100;
    gcResult.innerHTML = `<strong>Længde:</strong> ${seq.length.toLocaleString('da-DK')} baser` +
      `<br><strong>GC-indhold:</strong> ${gcPct.toFixed(1)} % (${gcCount} G/C)` +
      `<br><strong>A/T/U:</strong> ${atCount}` +
      `<br><strong>N/andre:</strong> ${nCount + otherCount}`;
  };
  gcTextarea.addEventListener('input', updateGc);
  gcUpper?.addEventListener('click', () => {
    gcTextarea.value = normaliseSequence(gcTextarea.value);
    updateGc();
  });
  gcReverse?.addEventListener('click', () => {
    const seq = normaliseSequence(gcTextarea.value);
    if (!seq.length) {
      gcResult.textContent = 'Indsæt en sekvens for at beregne GC%.';
      return;
    }
    const complementMap = {A: 'T', T: 'A', U: 'A', G: 'C', C: 'G', Y: 'R', R: 'Y', S: 'S', W: 'W', K: 'M', M: 'K', B: 'V', V: 'B', D: 'H', H: 'D', N: 'N'};
    const reversed = seq.split('').reverse().map(base => complementMap[base] || base).join('');
    gcTextarea.value = reversed;
    updateGc();
  });
  updateGc();
}

function renderResponses(section) {
  const list = getCached('responses').slice().reverse();
  section.innerHTML = `
  <div class="panel">
    <div class="btn-row">
      <label class="secondary" id="fhirImportLabel" style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.4rem 0.8rem;border-radius:0.5rem;cursor:pointer;">Importér FHIR...
        <input type="file" id="fhirImport" accept="application/json" style="display:none;">
      </label>
    </div>
    <table><thead><tr><th>Tid</th><th>Sender</th><th>Patient</th><th>Rapport</th><th>Varianter</th></tr></thead><tbody>
      ${list.map(r => `<tr><td>${esc(r.ts)}</td><td>${esc(r.sender||'')}</td><td>${esc(r.patient||'')}</td><td>${esc(r.diagnostic_report_id||'')}</td><td>${esc(r.variant_count||0)}</td></tr>`).join('') || '<tr><td colspan="5">Ingen svar</td></tr>'}
    </tbody></table>
  </div>
  <div class="panel">
    <h2>Udgående MedCom-svar</h2>
    <label>Vælg ordre<select id="fhirOrderSelect"><option value="">Vælg...</option>${getCached('orders').map(o => `<option value="${o.id}">${o.id} – ${esc(getName('patients', o.patient_id))}</option>`).join('')}</select></label>
    <div class="btn-row">
      <button class="primary" id="generateFhir">Generér FHIR-bundle</button>
      <button class="secondary" id="previewFhir">Forhåndsvis</button>
    </div>
    <pre id="fhirPreview" style="display:none"></pre>
  </div>`;
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  const orderLabel = section.querySelector('#fhirOrderSelect')?.closest('label');
  if (orderLabel) setTooltip(orderLabel, tooltipCatalog.controls.fhirOrderSelect);
  section.querySelector('#fhirOrderSelect').addEventListener('change', () => section.querySelector('#fhirPreview').style.display='none');
  section.querySelector('#generateFhir').addEventListener('click', () => exportFhir(section, true));
  section.querySelector('#previewFhir').addEventListener('click', () => exportFhir(section, false));
  section.querySelector('#fhirImport').addEventListener('change', async e => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const json = JSON.parse(text);
      await handleInboundFhir(json, true);
      alert('FHIR bundle importeret.');
      await loadStore('responses');
      renderTab('responses');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke importere: ' + err.message);
    }
    e.target.value = '';
  });
}
async function exportFhir(section, download) {
  const select = section.querySelector('#fhirOrderSelect');
  const id = Number(select.value);
  if (!id) return alert('Vælg ordre');
  const bundle = buildFhirBundle(id);
  const json = JSON.stringify(bundle, null, 2);
  const preview = section.querySelector('#fhirPreview');
  preview.textContent = json;
  preview.style.display = 'block';
  if (download) {
    const blob = new Blob([json], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp(`glimr-ordre-${id}.json`);
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`FHIR-meddelelse for ordination ${id} downloadet som ${filename}.`);
  }
}
function buildFhirBundle(orderId) {
  const order = findById('orders', orderId);
  if (!order) throw new Error('Ordination ikke fundet');
  const patient = findById('patients', Number(order.patient_id));
  const sample = findById('samples', Number(order.sample_id));
  const panel = order.panel_id ? findById('panels', Number(order.panel_id)) : null;
  const report = getCached('reports').find(r => r.order_id === orderId) || {status:'final', summary:'', variant_ids:'[]', variant_details:[]};
  let variants = getReportVariantSnapshots(report, orderId);
  if (!variants.length) {
    variants = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
  }
  const timestamp = new Date().toISOString();
  const patientResource = {
    resourceType:'Patient',
    id:`patient-${patient?.id||order.patient_id}`,
    identifier: patient?.mrn ? [{system:'urn:oid:1.2.208.176.1.2', value:patient.mrn}] : undefined,
    name: patient?.name ? [{text:patient.name}] : undefined,
    gender: patient?.gender || undefined,
    birthDate: patient?.birth_date || undefined
  };
  const specimenResource = {
    resourceType:'Specimen',
    id:`specimen-${sample?.id||order.sample_id}`,
    status:'available',
    identifier: sample?.pmb_number ? [{system:'urn:glimr:pmb', value: sample.pmb_number}] : undefined,
    type: {text: sample?.sample_type || 'Genomic specimen'},
    receivedTime: sample?.collected_at || undefined,
    subject: {reference:`Patient/${patientResource.id}`}
  };
  const producerOrg = {
    resourceType:'Organization',
    id:'org-producer',
    name:'GenLab Producer'
  };
  const requesterOrg = {
    resourceType:'Organization',
    id:'org-requester',
    name: order.clinician || 'Requester'
  };
  const diagnosticReport = {
    resourceType:'DiagnosticReport',
    id:`dr-${orderId}`,
    status: report.status || 'final',
    category:[{coding:[{system:'http://terminology.hl7.org/CodeSystem/v2-0074', code:'LAB', display:'Laboratory'}]}],
    code:{coding:[{system:'http://loinc.org', code:'51969-4', display:'Genetic analysis report'}]},
    subject:{reference:`Patient/${patientResource.id}`},
    effectiveDateTime: report.issued_at || new Date().toISOString(),
    issued: report.issued_at || new Date().toISOString(),
    performer:[{reference:'Organization/org-producer'}],
    resultsInterpreter: requesterOrg.name ? [{reference:'Organization/org-requester'}] : undefined,
    conclusion: report.summary || undefined
  };
  const narrative = variants.map(describeVariantNarrative).filter(Boolean).join('\n');
  if (narrative) {
    diagnosticReport.presentedForm = [{contentType:'text/plain', data:base64EncodeUtf8(narrative)}];
  }
  const entries = [];
  const addEntry = resource => entries.push({fullUrl:`urn:uuid:${crypto.randomUUID?.() || Math.random().toString(36).slice(2)}`, resource});
  const messageHeader = {
    resourceType:'MessageHeader',
    id:`mh-${orderId}`,
    eventCoding:{system:'http://medcom.dk/fhir/medcom-messaging-communication-event', code:'medcom-lab-reporting', display:'MedCom Lab Report'},
    source:{name:'GlimR'},
    destination:[{name:'Recipient'}],
    sender:{reference:'Organization/org-producer'},
    focus:[{reference:`DiagnosticReport/${diagnosticReport.id}`}] 
  };
  addEntry(messageHeader);
  addEntry(patientResource);
  addEntry(producerOrg);
  addEntry(requesterOrg);
  addEntry(specimenResource);
  addEntry(diagnosticReport);
  variants.forEach((variant, idx) => {
    const obs = {
      resourceType:'Observation',
      id:`var-${orderId}-${idx+1}`,
      status:'final',
      category:[{coding:[{system:'http://terminology.hl7.org/CodeSystem/observation-category', code:'laboratory'}]}],
      code:{coding:[{system:'http://loinc.org', code:'69548-6', display:'Genomic sequence variation interpretation'}]},
      subject:{reference:`Patient/${patientResource.id}`},
      specimen:{reference:`Specimen/${specimenResource.id}`},
      valueCodeableConcept:{text:[variant.hgvs_c, variant.hgvs_p].filter(Boolean).join(' / ') || variant.gene},
      component:[{code:{text:'Gene'}, valueCodeableConcept:{text:variant.gene}}],
      interpretation: classificationMap[String(variant.classification)] ? [{coding:[{system:'http://loinc.org', code:classificationMap[String(variant.classification)].code, display:classificationMap[String(variant.classification)].display}]}] : undefined,
      note: variant.criteria ? [{text:`ACMG: ${variant.criteria}`}]: undefined
    };
    addEntry(obs);
    diagnosticReport.result = diagnosticReport.result || [];
    diagnosticReport.result.push({reference:`Observation/${obs.id}`});
  });
  const bundle = {
    resourceType:'Bundle',
    type:'message',
    timestamp,
    entry: entries
  };
  return bundle;
}
async function handleInboundFhir(bundle, offerLibrary=false) {
  if (!ensureWrite('responses')) return;
  if (!bundle || bundle.resourceType !== 'Bundle') throw new Error('Ikke en FHIR Bundle');
  const entries = bundle.entry || [];
  const findResource = type => entries.map(e => e.resource).find(r => r.resourceType === type);
  const diagnosticReport = findResource('DiagnosticReport');
  const patient = findResource('Patient');
  const observations = entries.map(e => e.resource).filter(r => r.resourceType === 'Observation');
  const response = {
    ts: new Date().toISOString(),
    sender: findResource('MessageHeader')?.sender?.reference || 'ukendt',
    patient: patient?.name?.[0]?.text || patient?.id || '',
    diagnostic_report_id: diagnosticReport?.id || '',
    variant_count: observations.length,
    variants: JSON.stringify(observations.map(o => ({gene:o.component?.[0]?.valueCodeableConcept?.text, note:o.note?.[0]?.text, value:o.valueCodeableConcept?.text}))),
    raw: JSON.stringify(bundle)
  };
  await addRecord('responses', response);
  if (offerLibrary && observations.length) {
    if (ensureWrite('variant_library') && confirm('Tilføj varianter til bibliotek?')) {
      for (const obs of observations) {
        const note = obs.note?.[0]?.text || '';
        await addRecord('variant_library', {
          gene: obs.component?.[0]?.valueCodeableConcept?.text || '',
          transcript: '',
          hgvs_c: obs.valueCodeableConcept?.text || '',
          hgvs_p: '',
          classification: note.includes('Pathogenic') ? '5' : '',
          criteria: note.replace('ACMG: ','') || '',
          evidence: note,
          condition: '',
          inheritance: '',
          curated_by: 'FHIR import',
          last_review: new Date().toISOString().split('T')[0]
        });
      }
      await loadStore('variant_library');
    }
  }
}
function renderUsers(section) {
  const list = getCached('users');
  section.innerHTML = `
  <div class="panel">
    <div class="flex">
      <div>
        <label for="userSearch">Søg</label>
        <input id="userSearch" type="search" placeholder="Navn/mail...">
        <table><thead><tr><th>ID</th><th>Navn</th><th>E-mail</th><th>Rolle</th></tr></thead><tbody></tbody></table>
      </div>
      <div>
        <h2>Bruger</h2>
        <form id="userForm">
          <input type="hidden" name="id">
          <label>Navn<input name="name" required></label>
          <label>E-mail<input type="email" name="email" required></label>
          <label>Rolle<select name="role" required>${ROLE_OPTIONS.map(opt => `<option value="${opt.value}">${opt.value} – ${opt.description}</option>`).join('')}</select></label>
          <label>Adgangskode (PIN)<input type="password" name="pin" placeholder="Valgfri kode"></label>
          <div class="btn-row">
            <button class="primary" type="submit">Gem</button>
            <button class="secondary" type="button" id="userClear">Ny</button>
            <button class="danger" type="button" id="userDelete">Slet</button>
          </div>
        </form>
      </div>
    </div>
  </div>`;
  const tbody = section.querySelector('tbody');
  const search = section.querySelector('#userSearch');
  const form = section.querySelector('#userForm');
  annotateHeaders(section);
  annotateSearchInputs(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  applyFormTooltips(form);
  let selectedUserId = null;
  const renderRows = () => {
    const term = search.value.toLowerCase();
    const filteredUsers = list.filter(u => !term || [u.name,u.email,u.role].some(v => (v||'').toLowerCase().includes(term)));
    if (selectedUserId != null && !filteredUsers.some(u => u.id === selectedUserId)) {
      selectedUserId = null;
    }
    tbody.innerHTML = filteredUsers.map(u => {
      const selectedAttr = u.id === selectedUserId ? ' data-selected="true"' : '';
      return `<tr data-id="${u.id}"${selectedAttr}><td>${u.id}</td><td>${esc(u.name)}</td><td>${esc(u.email)}</td><td>${esc(roleLabel(u.role))}</td></tr>`;
    }).join('');
    annotateTableCells(section);
  };
  renderRows();
  search.addEventListener('input', renderRows);
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const user = list.find(u => u.id === Number(tr.dataset.id));
    if (!user) return;
    selectedUserId = user.id;
    fillForm(form, user);
    renderRows();
  });
  form.addEventListener('submit', async e => {
    e.preventDefault();
    if (!ensureWrite('users')) return;
    const data = Object.fromEntries(new FormData(form).entries());
    if (data.id) {
      const id = Number(data.id);
      const before = {...findById('users', id)};
      if (!data.pin) data.pin = before?.pin || '';
      const updated = {...before, ...data, id};
      await updateRecord('users', updated, before);
    } else {
      if (!data.pin) data.pin = '';
      delete data.id;
      await addRecord('users', data);
    }
    await loadStore('users');
    refreshLoginOptions();
    restoreUserSession();
    renderTab('users');
  });
  section.querySelector('#userDelete').addEventListener('click', async () => {
    const id = Number(form.elements.id.value);
    if (!id) return alert('Vælg bruger');
    if (!ensureWrite('users')) return;
    if (confirm('Slet bruger?')) {
      await deleteRecord('users', id);
      refreshLoginOptions();
      const storedId = localStorage.getItem('glimr-user-id');
      if (storedId && Number(storedId) === id) {
        logoutUser();
      }
      renderTab('users');
    }
  });
  form.addEventListener('reset', () => {
    selectedUserId = null;
    renderRows();
  });
  section.querySelector('#userClear').addEventListener('click', () => form.reset());
}
function renderAudit(section) {
  const list = getCached('audit').slice().reverse();
  section.innerHTML = `
  <div class="panel">
    <table><thead><tr><th>Tid</th><th>Bruger</th><th>Handling</th><th>Entitet</th><th>ID</th><th>Før</th><th>Efter</th></tr></thead><tbody>
      ${list.map(a => `<tr><td>${esc(a.ts)}</td><td>${esc(a.user)}</td><td>${esc(a.action)}</td><td>${esc(a.entity)}</td><td>${esc(a.entity_id??'')}</td><td>${esc(a.before||'')}</td><td>${esc(a.after||'')}</td></tr>`).join('') || '<tr><td colspan="7">Ingen revisionsposter</td></tr>'}
    </tbody></table>
  </div>`;
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
}

function renderDbTab(section) {
  section = section || document.querySelector('section[data-tab="db"]');
  const status = state.boundHandle ? `Tilknyttet fil: ${state.boundHandle.name}` : 'Ingen fil tilknyttet';
  if (!section) return;
  section.innerHTML = `
  <div class="panel">
    <h2>Filbaseret database</h2>
    <p>${esc(status)}</p>
    <div class="btn-row">
      <button class="secondary" id="bindFile">Knyt/åbn DB-fil...</button>
      <button class="secondary" id="saveNow">Gem nu</button>
      <label style="display:flex;align-items:center;gap:0.5rem;">
        <input type="checkbox" id="autosaveToggle" ${state.autosave?'checked':''}> Autogem
      </label>
    </div>
  </div>
  <div class="panel">
    <h2>Backup</h2>
    <div class="btn-row">
      <button class="secondary" id="downloadBackup">Hent backup (JSON)</button>
      <label class="secondary" id="restoreLabel" style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.4rem 0.8rem;border-radius:0.5rem;cursor:pointer;">Gendan fra backup<input type="file" id="restoreFile" accept="application/json" style="display:none;"></label>
    </div>
    <div class="btn-row">
      <button class="danger" id="resetDataBtn">Backup &amp; ryd data (undtagen brugere)</button>
    </div>
    <p class="panel-hint">Downloader en fuld backup og nulstiller alle andre data. Kræver skriveadgang.</p>
  </div>`;
  applyButtonTooltips(section);
  applyControlTooltips(section);
  section.querySelector('#bindFile').addEventListener('click', bindDbFile);
  section.querySelector('#saveNow').addEventListener('click', manualSave);
  section.querySelector('#autosaveToggle').addEventListener('change', e => {
    state.autosave = e.target.checked;
    setStatus('Autogemning ' + (state.autosave ? 'aktiveret' : 'deaktiveret'));
  });
  section.querySelector('#downloadBackup').addEventListener('click', downloadBackup);
  section.querySelector('#restoreFile').addEventListener('change', async e => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      await restoreFromFile(file);
      alert('Backup gendannet.');
    } catch (err) {
      console.error(err);
      alert('Kunne ikke gendanne: ' + err.message);
    }
    e.target.value = '';
  });
  const resetBtn = section.querySelector('#resetDataBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', backupAndResetData);
  }
}
function renderAdmin(section) {
  section.innerHTML = `
  <div class="panel">
    <div class="btn-row">
      <button class="primary" id="demoDataBtn">Indlæs demo-data</button>
    </div>
    <div class="btn-row">
      <button class="primary" id="downloadSql">Hent glimr.sql</button>
      <button class="secondary" id="showSchema">Vis skema</button>
      <button class="secondary" id="downloadZip">Hent ZIP</button>
    </div>
    <textarea id="schemaText" style="width:100%;min-height:200px;margin-top:1rem;display:none;"></textarea>
  </div>`;
  applyButtonTooltips(section);
  applyControlTooltips(section);
  const demoBtn = section.querySelector('#demoDataBtn');
  if (demoBtn) {
    demoBtn.addEventListener('click', () => {
      if (!ensureWrite('patients')) return;
      loadDemoData();
    });
  }
  section.querySelector('#downloadSql').addEventListener('click', async () => {
    const sql = await generateSqlDump();
    const blob = new Blob([sql], {type:'text/sql'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp('glimr.sql');
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`MySQL-dump downloadet som ${filename}.`);
  });
  section.querySelector('#showSchema').addEventListener('click', async () => {
    const sql = await generateSqlDump();
    const textarea = section.querySelector('#schemaText');
    textarea.value = sql;
    textarea.style.display = 'block';
  });
  section.querySelector('#downloadZip').addEventListener('click', async () => {
    const files = await buildZipFiles();
    const zipBytes = createZip(files);
    const blob = new Blob([zipBytes], {type:'application/zip'});
    const url = URL.createObjectURL(blob);
    const filename = withDateStamp('glimr.zip');
    triggerDownload(url, filename);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus(`ZIP-arkiv downloadet som ${filename}.`);
  });
}
function renderTestsTab(section) {
  section.innerHTML = `
  <div class="panel">
    <h2>Selvtest</h2>
    <div class="btn-row">
      <button class="primary" id="runTestsBtn">Kør selvtest</button>
    </div>
    <table><thead><tr><th>Test</th><th>Status</th><th>Detaljer</th></tr></thead><tbody id="testsBody"></tbody></table>
  </div>`;
  const tbody = section.querySelector('#testsBody');
  if (tbody) {
    tbody.innerHTML = state.testResults.length
      ? state.testResults.map(([name, pass, detail]) => `<tr><td>${esc(name)}</td><td>${pass ? 'OK' : 'FEJL'}</td><td>${esc(detail||'')}</td></tr>`).join('')
      : '<tr><td colspan="3">Ingen tests kørt endnu.</td></tr>';
  }
  annotateHeaders(section);
  annotateTableCells(section);
  applyButtonTooltips(section);
  applyControlTooltips(section);
  const testsBtn = section.querySelector('#runTestsBtn');
  if (testsBtn) {
    testsBtn.addEventListener('click', () => {
      runTests();
    });
  }
}
async function runTests() {
  if (!ensureWrite('patients')) return;
  let section = document.querySelector('section[data-tab="tests"]');
  if (!section) {
    activateTab('tests');
    return setTimeout(runTests, 200);
  }
  setStatus('Kører selvtest...');
  const snapshot = await exportData();
  const results = [];
  try {
    const patientId = await addRecord('patients', {mrn:'TEST1', name:'Testpatient', gender:'other', birth_date:'1980-01-01', notes:''});
    const patient = findById('patients', patientId);
    results.push(['Oprettelse/udlæsning patient', patient?.name === 'Testpatient', `Navn: ${patient?.name}`]);
    const sampleId = await addRecord('samples', {patient_id:patientId, pmb_number:`PMB-SELFTST-${Date.now()}`, sample_type:'Blod', status:'Modtaget', collected_at:new Date().toISOString(), notes:''});
    const orderId = await addRecord('orders', {patient_id:patientId, sample_id:sampleId, panel_id:null, clinician:'Testperson', status:'Analyse', ordered_at:new Date().toISOString()});
    await addRecord('variants', {
      order_id: orderId,
      gene: 'BRCA1',
      transcript: '',
      hgvs_c: 'c.5266dupC',
      hgvs_p: 'p.(Gln1756Profs*74)',
      classification: '5',
      criteria: 'PVS1',
      af: '',
      interpretation: ''
    });
    const variantCount = getCached('variants').filter(v => v.order_id === orderId).length;
    results.push(['Tilføj testvariant', variantCount > 0, `Varianter: ${variantCount}`]);
    results.push(['Oprettelse ordination med FK', !!findById('orders', orderId), `Ordination ${orderId}`]);
    const variantDetails = getCached('variants').filter(v => v.order_id === orderId).map(snapshotVariant);
    const reportHtml = buildReportHtml(orderId, {status:'draft', issued_at:new Date().toISOString(), summary:'Test', variant_details: variantDetails});
    results.push(['Generering af rapport HTML', reportHtml.includes('Diagnostisk rapport'), 'HTML længde ' + reportHtml.length]);
    const bundle = buildFhirBundle(orderId);
    const hasResources = ['MessageHeader','Patient','DiagnosticReport','Observation'].every(type => (bundle.entry||[]).some(e => e.resource.resourceType === type));
    results.push(['Udgående FHIR-bundle indhold', hasResources, `Ressourcer: ${(bundle.entry||[]).length}`]);
    const files = await buildZipFiles();
    const zip = createZip(files);
    const view = new DataView(zip.buffer);
    const centralDirOffset = view.getUint32(zip.length - 6, true);
    results.push(['ZIP-bytes genereret', centralDirOffset > 0, `Centraldir-offset: ${centralDirOffset}`]);
    const sql = await generateSqlDump();
    results.push(['SQL-dump indeholder variants.criteria', sql.includes('`criteria`'), 'Længde ' + sql.length]);
    results.push(['Filbinding API', 'showOpenFilePicker' in window || 'showSaveFilePicker' in window, 'Filadgang ' + (('showOpenFilePicker' in window) ? 'tilgængelig' : 'ukendt')]);
  } catch (err) {
    console.error(err);
    results.push(['Testfejl', false, err.message]);
  } finally {
    state.testResults = results;
    await replaceAllData(snapshot);
    renderAll();
    section = document.querySelector('section[data-tab="tests"]');
    if (section) renderTestsTab(section);
    setStatus('Selvtest gennemført. Data gendannet til udgangspunktet.');
  }
}
async function buildZipFiles() {
  const backup = JSON.stringify(await exportData(), null, 2);
  const html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
  const readme = 'GlimR - lokalt enkeltfil-LIMS\n\nÅbn GlimR.html i en moderne browser.\n';
  return [
    {name:'GlimR.html', data:utf8Encode(html)},
    {name:'glimr-backup.json', data:utf8Encode(backup)},
    {name:'README.txt', data:utf8Encode(readme)}
  ];
}
function base64EncodeUtf8(str) {
  const bytes = utf8Encode(str);
  let binary = '';
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  return btoa(binary);
}
function utf8Encode(str) {
  return new TextEncoder().encode(str);
}
function crc32(buf) {
  let crc = -1;
  for (let i=0; i<buf.length; i++) {
    crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ buf[i]) & 0xff];
  }
  return (crc ^ -1) >>> 0;
}
const CRC_TABLE = (() => {
  const table = new Uint32Array(256);
  for (let n=0; n<256; n++) {
    let c = n;
    for (let k=0; k<8; k++) {
      c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[n] = c >>> 0;
  }
  return table;
})();
function createZip(files) {
  let total = 0;
  files.forEach(f => total += 30 + f.name.length + f.data.length);
  total += files.length * 46;
  total += 22;
  const buffer = new Uint8Array(total + 1024);
  let offset = 0;
  const central = [];
  const now = new Date();
  const dostime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() / 2)) & 0xffff;
  const dosdate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth()+1) << 5) | now.getDate()) & 0xffff;
  for (const file of files) {
    const nameBytes = utf8Encode(file.name);
    const crc = crc32(file.data);
    const localHeader = new DataView(buffer.buffer, offset, 30);
    localHeader.setUint32(0, 0x04034b50, true);
    localHeader.setUint16(4, 20, true);
    localHeader.setUint16(6, 0, true);
    localHeader.setUint16(8, 0, true);
    localHeader.setUint16(10, dostime, true);
    localHeader.setUint16(12, dosdate, true);
    localHeader.setUint32(14, crc, true);
    localHeader.setUint32(18, file.data.length, true);
    localHeader.setUint32(22, file.data.length, true);
    localHeader.setUint16(26, nameBytes.length, true);
    localHeader.setUint16(28, 0, true);
    offset += 30;
    buffer.set(nameBytes, offset);
    offset += nameBytes.length;
    buffer.set(file.data, offset);
    offset += file.data.length;
    central.push({nameBytes, crc, size:file.data.length, offset: offset - file.data.length - nameBytes.length - 30});
  }
  const centralStart = offset;
  for (const entry of central) {
    const view = new DataView(buffer.buffer, offset, 46);
    view.setUint32(0, 0x02014b50, true);
    view.setUint16(4, 0x031E, true);
    view.setUint16(6, 20, true);
    view.setUint16(8, 0, true);
    view.setUint16(10, 0, true);
    view.setUint16(12, dostime, true);
    view.setUint16(14, dosdate, true);
    view.setUint32(16, entry.crc, true);
    view.setUint32(20, entry.size, true);
    view.setUint32(24, entry.size, true);
    view.setUint16(28, entry.nameBytes.length, true);
    view.setUint16(30, 0, true);
    view.setUint16(32, 0, true);
    view.setUint16(34, 0, true);
    view.setUint16(36, 0, true);
    view.setUint32(38, 0, true);
    view.setUint32(42, entry.offset, true);
    offset += 46;
    buffer.set(entry.nameBytes, offset);
    offset += entry.nameBytes.length;
  }
  const centralSize = offset - centralStart;
  const view = new DataView(buffer.buffer, offset, 22);
  view.setUint32(0, 0x06054b50, true);
  view.setUint16(4, 0, true);
  view.setUint16(6, 0, true);
  view.setUint16(8, central.length, true);
  view.setUint16(10, central.length, true);
  view.setUint32(12, centralSize, true);
  view.setUint32(16, centralStart, true);
  view.setUint16(20, 0, true);
  offset += 22;
  return buffer.slice(0, offset);
}
async function generateSqlDump() {
  const createStatements = `SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS=0;
CREATE TABLE IF NOT EXISTS \`patients\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`mrn\` VARCHAR(64),
  \`family_number\` VARCHAR(64),
  \`name\` VARCHAR(255),
  \`gender\` VARCHAR(32),
  \`birth_date\` DATE,
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`users\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`name\` VARCHAR(255),
  \`email\` VARCHAR(255),
  \`role\` VARCHAR(128),
  \`pin\` VARCHAR(128),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`panels\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`name\` VARCHAR(255),
  \`description\` TEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`samples\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`pmb_number\` VARCHAR(64),
  \`patient_id\` INT,
  \`sample_type\` VARCHAR(128),
  \`collected_at\` DATETIME,
  \`status\` VARCHAR(64),
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_samples_patient FOREIGN KEY (patient_id) REFERENCES patients(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`orders\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`patient_id\` INT,
  \`sample_id\` INT,
  \`panel_id\` INT NULL,
  \`analysis_responsible_id\` INT NULL,
  \`interpreter_id\` INT NULL,
  \`approver_id\` INT NULL,
  \`clinician\` VARCHAR(255),
  \`status\` VARCHAR(64),
  \`ordered_at\` DATETIME,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_orders_patient FOREIGN KEY (patient_id) REFERENCES patients(id) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT fk_orders_sample FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT fk_orders_panel FOREIGN KEY (panel_id) REFERENCES panels(id) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT fk_orders_analysis_responsible FOREIGN KEY (analysis_responsible_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT fk_orders_interpreter FOREIGN KEY (interpreter_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT fk_orders_approver FOREIGN KEY (approver_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`reports\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`order_id\` INT,
  \`findings\` TEXT,
  \`variant_ids\` TEXT,
  \`variant_details\` LONGTEXT,
  \`summary\` TEXT,
  \`status\` VARCHAR(32),
  \`issued_at\` DATETIME,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_reports_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`qc_metrics\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`sample_id\` INT,
  \`metric\` VARCHAR(128),
  \`value\` DECIMAL(18,6),
  \`unit\` VARCHAR(64),
  \`notes\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_qc_sample FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`variants\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`order_id\` INT,
  \`gene\` VARCHAR(128),
  \`transcript\` VARCHAR(128),
  \`hgvs_c\` VARCHAR(255),
  \`hgvs_p\` VARCHAR(255),
  \`zygosity\` VARCHAR(64),
  \`classification\` VARCHAR(8),
  \`criteria\` VARCHAR(255),
  \`af\` DECIMAL(18,6),
  \`interpretation\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME,
  CONSTRAINT fk_variants_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`variant_library\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`gene\` VARCHAR(128),
  \`transcript\` VARCHAR(128),
  \`hgvs_c\` VARCHAR(255),
  \`hgvs_p\` VARCHAR(255),
  \`classification\` VARCHAR(8),
  \`criteria\` VARCHAR(255),
  \`evidence\` TEXT,
  \`condition\` VARCHAR(255),
  \`inheritance\` VARCHAR(128),
  \`curated_by\` VARCHAR(255),
  \`last_review\` DATE,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`conclusion_library\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`title\` VARCHAR(255),
  \`body\` TEXT,
  \`created_by\` VARCHAR(255),
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`responses\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`ts\` DATETIME,
  \`sender\` VARCHAR(255),
  \`patient\` VARCHAR(255),
  \`diagnostic_report_id\` VARCHAR(255),
  \`variant_count\` INT,
  \`variants\` TEXT,
  \`raw\` LONGTEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS \`audit_log\` (
  \`id\` INT AUTO_INCREMENT PRIMARY KEY,
  \`ts\` DATETIME,
  \`user\` VARCHAR(128),
  \`action\` VARCHAR(64),
  \`entity\` VARCHAR(64),
  \`entity_id\` INT,
  \`before\` LONGTEXT,
  \`after\` LONGTEXT,
  \`created_at\` DATETIME,
  \`updated_at\` DATETIME
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;`;
  const rows = await exportData();
  const inserts = [];
  const mapTable = {
    patients: 'patients',
    users: 'users',
    samples: 'samples',
    panels: 'panels',
    orders: 'orders',
    reports: 'reports',
    qc: 'qc_metrics',
    variants: 'variants',
    variant_library: 'variant_library',
    conclusion_library: 'conclusion_library',
    responses: 'responses',
    audit: 'audit_log'
  };
  for (const [store, table] of Object.entries(mapTable)) {
    const data = rows[store] || [];
    if (!data.length) continue;
    const fields = schemaFields[store];
    const fieldList = fields.map(f => `\`${f}\``).join(',');
    const values = data
      .map(row => `(${fields.map(field => sqlValue(row[field])).join(',')})`)
      .join(',\n');
    inserts.push(
      `INSERT INTO \`${table}\` (${fieldList}) VALUES\n${values};`
    );
  }
  return createStatements + inserts.join('\n\n') + '\n';
}


function sqlValue(val) {
  if (val === null || val === undefined || val === '') return 'NULL';
  if (typeof val === 'number') return String(val);
  const str = String(val).replace(/'/g, "''");
  return `'${str}'`;
}
async function loadDemoData() {
  if (!ensureWrite('patients')) return;
  if (!confirm('Indlæse demo-data? Dette overskriver ikke eksisterende poster men tilføjer hvis tomt.')) return;
  if (!getCached('patients').length) {
    const p1 = await addRecord('patients', {mrn:'MRN001', family_number:'FAM-001', name:'Anna Jensen', gender:'female', birth_date:'1985-03-12', notes:'Familiehistorik positiv'});
    const p2 = await addRecord('patients', {mrn:'MRN002', family_number:'FAM-002', name:'Lars Petersen', gender:'male', birth_date:'1978-11-03', notes:''});
    const s1 = await addRecord('samples', {patient_id:p1, pmb_number:'PMB-0001', sample_type:'Blod', status:'QC', collected_at:new Date().toISOString(), notes:''});
    const s2 = await addRecord('samples', {patient_id:p2, pmb_number:'PMB-0002', sample_type:'Kindskrab', status:'Analyse', collected_at:new Date().toISOString(), notes:''});
    const panel = await addRecord('panels', {name:'Onko-panel', description:'50 gener'});
    const o1 = await addRecord('orders', {patient_id:p1, sample_id:s1, panel_id:panel, analysis_responsible_id:null, interpreter_id:null, approver_id:null, clinician:'Dr. Holm', status:'Analyse', ordered_at:new Date().toISOString()});
    const o2 = await addRecord('orders', {patient_id:p2, sample_id:s2, panel_id:panel, analysis_responsible_id:null, interpreter_id:null, approver_id:null, clinician:'Dr. Holm', status:'Rapport', ordered_at:new Date().toISOString()});
    await addRecord('variants', {order_id:o1, gene:'BRCA1', transcript:'NM_007294.3', hgvs_c:'c.5266dupC', hgvs_p:'p.Gln1756Profs', zygosity:'heterozygot', classification:'5', criteria:'PVS1,PS3,PM2,PP3', af:0.0001, interpretation:'Patogen variant med høj risiko'});
    await addRecord('qc', {sample_id:s1, metric:'Dækning', value:98.5, unit:'%', notes:''});
    await addRecord('reports', {order_id:o2, variant_ids:'[]', variant_details:[], summary:'Negativ rapport', status:'final', issued_at:new Date().toISOString()});
    await addRecord('users', {name:'Admin', email:'admin@example.com', role:'Administrator', pin:'admin'});
  } else {
    alert('Demo-data allerede til stede.');
  }
  await loadAllStores();
  renderAll();
  refreshLoginOptions();
  updateAuthUi();
}
function hookUi() {
  const loginForm = document.getElementById('loginForm');
  if (loginForm) loginForm.addEventListener('submit', handleLogin);
  const logoutBtn = document.getElementById('logoutBtn');
  if (logoutBtn) {
    logoutBtn.addEventListener('click', logoutUser);
    setTooltip(logoutBtn, tooltipCatalog.buttons.logoutBtn);
  }
  const themeBtn = document.getElementById('themeToggle');
  if (themeBtn) {
    themeBtn.addEventListener('click', toggleTheme);
    setTooltip(themeBtn, tooltipCatalog.buttons.themeToggle);
  }
  const logoImg = document.getElementById('glimrLogo');
  if (logoImg) {
    const brand = logoImg.closest('.brand');
    const markMissing = () => {
      if (brand) {
        brand.classList.add('logo-missing');
      }
      if (logoImg.parentElement) {
        logoImg.remove();
      }
    };
    logoImg.addEventListener('error', markMissing, { once: true });
    if (brand && logoImg.complete && logoImg.naturalWidth === 0) {
      markMissing();
    }
  }
  applyTheme();
  refreshLoginOptions();
  updateAuthUi();
  applyControlTooltips(document.body);
}
async function init() {
  initTabs();
  try {
    state.db = await openDb();
    setStatus('Database åben');
    await loadAllStores();
    await ensureCreationMetadata();
    hookUi();
    restoreUserSession();
    renderAll();
    activateTab('dashboard');
  } catch (err) {
    console.error(err);
    setStatus('Kunne ikke åbne database: ' + err.message);
  }
}
document.addEventListener('DOMContentLoaded', init);
})();
</script>
</body>
</html>
